%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  fpsemi.msk                GAP documentation                Isabel Araujo
%%
%A  @(#)$Id: basic.msk,v 1.2 1999/05/14 20:20:35 andrews Exp $
%%
%Y  (C) 1999 School Math and Comp. Sci., University of St.  Andrews, Scotland
%%


\Chapter{Basics}

The normal interaction with {\GAP} happens in the so--called
*read--eval--print* loop.
This means that you type an input, {\GAP} first reads it,
evaluates it, and then shows the result.
In the following, whenever we want to express that {\GAP} places some
characters on the standard output, we will say that {\GAP} *shows*
something.
The exact sequence in the read eval print loop is as follows.

To signal that it is ready to accept your input,
{\GAP} shows the *prompt* `gap>'.
When you see this, you know that {\GAP} is waiting for your input.

Note that every statement must be terminated by a semicolon. You must
also enter <return> before {\GAP} starts to read and evaluate your input.
Because {\GAP} does not do anything until you enter <return>, you can
edit your input to fix typos and only when everything is correct enter
<return> and have {\GAP} take a look at it (see~"Line Editing"). It is
also possible to enter several statements as input on a single line. Of
course each statement must be terminated by a semicolon.
It is absolutely acceptable to enter a single statement on several lines.
When you have entered the beginning of a statement, but the statement is
not yet complete, and you enter <return>,
{\GAP} will show the *partial prompt* `>'.
When you see this, you know that {\GAP} is waiting for the rest
of the statement. This happens also when you forget
the semicolon `;' that terminates every {\GAP} statement.

If your input is syntactically correct, {\GAP} evaluates or executes it,
i.e., performs the required computations.
When {\GAP} is ready it will usually show the result of the computation,
i.e., the value computed. Note that not all statements produce a value,
for example, if you enter a `for' loop, nothing will be printed, because
the `for' loop does not produce a value that could be shown.

Also sometimes you do not want to see the result. For example if you
have computed a value and now want to assign the result to a variable,
you probably do not want to see the value again. You can terminate
statements by *two semicolons* to suppress showing the result.

When an error has occurred or when you interrupt {\GAP} (usually by
hitting <ctrl>-`C') {\GAP} enters a break loop, that is in most respects
like the main read eval print loop. That is, you can
enter statements, {\GAP} reads them, evaluates them, and shows the
result if any. However those evaluations happen within the context in
which the error occurred. So you can look at the arguments and local
variables of the functions that were active when the error happened and
even change them. The prompt is changed from `gap>' to `brk>' to
indicate that you are in a break loop.

\begintt
gap> 1/0;
Rational operations: divisor must not be zero
not in any function
Entering break read-eval-print loop, you can 'quit;' to quit to outer loop,
or you can return a new divisor to continue
brk> 
\endtt

If errors occur within a break loop {\GAP} enters another break loop at a
*deeper level*. This is indicated by a number appended to `brk':

\begintt
brk> 1/0;
Rational operations: divisor must not be zero
Entering break read-eval-print loop, you can 'quit;' to quit to outer loop,
or you can return a new divisor to continue
brk_02>
\endtt

There are two ways to leave a break loop.

\>`quit'{quit}

The first is to *quit* the break loop.
To do this you enter `quit;' or type the <eof> (*e*nd *o*f *f*ile) character,
which is usually <ctrl>-`D'.
Note that {\GAP} code between `quit;' and the end of the input line
is ignored.

\begintt
brk_02> quit;
brk>
\endtt

In this case control returns to the break loop one level above or
to the main loop, respectively.
So iterated break loops must be left iteratively.
Note also that if you type `quit;' from a `gap>' prompt, {\GAP} will exit
(see~"Leaving GAP").

*If you leave a break loop with `quit' without completing a command
it is possible (though not very likely) that data structures
will be corrupted or incomplete data has been stored in objects.
Therefore no guarantee can be given that calculations afterwards
will return correct results!*

\>`return [<obj>];'{return from break loop}

The other way is to *return* from a break loop. To do this you enter
`return;' or `return <expr>;'.
If the break loop was entered because you interrupted {\GAP},
then you can continue by entering `return;'.
If the break loop was entered due to an error,
you usually have to return a value to continue the computation.
For example, if the break loop was entered because a variable had no
assigned value, the value to be returned is the value that this variable
should have to continue the computation.

\begintt
brk> return 9;  # we had tried to enter the divisor 9 but typed 0 ...
1/9
gap>
\endtt

\Section{Leaving GAP}

\index{quit}
\index{QUIT}
\index{exit}
\index{at exit functions}
\index{saving on exit}
The normal way to terminate a {\GAP} session is to enter either
`quit;' (note the semicolon) or an end-of-file character (usually
ctrl-D) at the `gap>' prompt in the main read eval print loop.

An emergency way to leave {\GAP} is to enter
\begintt
brk>QUIT;
\endtt

\Section{Line Editing}

{\GAP} allows you to edit the current input line with a number of editing
commands. Those commands are accessible either as *control keys* or as
*escape keys*. You enter a control key by pressing the <ctrl> key, and,
while still holding the <ctrl> key down, hitting another key <key>. You
enter an escape key by hitting <esc> and then hitting another key <key>.
Below we denote control keys by <ctrl>-<key> and escape keys by
<esc>-<key>. The case of <key> does not matter, i.e., <ctrl>-`A' and
<ctrl>-`a' are equivalent.

Typing <ctrl>-<key> or <esc>-<key> for characters not mentioned below
always inserts <ctrl>-<key> resp.~<esc>-<key> at the current cursor position.

The first few commands allow you to move the cursor on the current line.

<ctrl>-`B' move the cursor backward one character.

<ctrl>-`F' move the cursor forward one character.

<ctrl>-`H' or <del> delete the character left of the cursor.

The <tab> character, which is in fact the control key <ctrl>-`I', looks at
the characters before the cursor, interprets them as the beginning of an
identifier and tries to complete this identifier. If there is more than
one possible completion, it completes to the longest common prefix of all
those completions. If the characters to the left of the cursor are
already the longest common prefix of all completions hitting <tab> a
second time will display all possible completions.

<tab>  complete the identifier before the cursor.

The next commands allow you to fetch previous lines, e.g., to correct
typos, etc. This history is limited to about 8000 characters.

<ctrl>-`P' redisplay the last input line, another <ctrl>-`P' will
  redisplay the line before that, etc. If the cursor is
  not in the first column only the lines starting with the
  string to the left of the cursor are taken.

<ctrl>-`N' Like <ctrl>-`P' but goes the other way round through the
  history.

The four arrow keys (cursor keys) can be used instead of <ctrl>-`B',
<ctrl>-`F', <ctrl>-`P', and <ctrl>-`N', respectively.



