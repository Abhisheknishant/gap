%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  lists.msk                GAP documentation                Isabel Araujo
%%
%A  @(#)$Id: prog.msk,v 1.3 1999/05/18 20:22:20 andrews Exp $
%%
%Y  (C) 1999 School Math and Comp. Sci., University of St.  Andrews, Scotland
%%


\Chapter{Basic Programming Constructs}

\Section{Lists}
Lists are the most important way to treat objects together.
A *list* arranges objects in a definite order.
So each list implies a partial mapping from the integers to the elements
of the list.
I.e., there is a first element of a list, a second, a third, and so on.

A list can be written by writing down the elements in order between
square brackets `[', `]', and separating them with commas `,'. An *empty
list*, i.e., a list with no elements, is written as `[]'.

\beginexample
gap> [ 1, 2, 3 ];
[ 1, 2, 3 ]  # a list with three elements
gap> [ [], [ 1 ], [ 1, 2 ] ];
[ [ ], [ 1 ], [ 1, 2 ] ]  # a list may contain other lists
\endexample

The basic operations for lists are element access,
assignment of elements to a list and fetching the length of a list.

\>`<list>[ <pos> ]'{list element!access}

The above construct evaluates to the <pos>-th element of the list <list>.
<pos> must be a positive integer. List indexing is done with origin 1,
i.e., the first element of the list is the element at position 1.
\beginexample
gap> l := [ 2, 3, 5, 7, 11, 13 ];;  l[1];  l[2];  l[6];
2
3
13
\endexample
If <list> is not a list, or <pos> does not evaluate to a
positive integer, or `<list>[<pos>]' is unbound an error is signalled.

\>`<list>[ <pos> ] := <object>;'{list element!assignment}

The list element assignment assigns the object <object>,
which can be of any type, to the list entry at the position <pos>,
which must be a positive integer.
That means that accessing the <pos>-th element of the list <list> will
return <object> after this assignment.

\beginexample
gap> l := [ 1, 2, 3 ];;
gap> l[1] := 3;; l;             # assign a new object
[ 3, 2, 3 ]
gap> l[2] := [ 4, 5, 6 ];; l;   # <object> may be of any type
[ 3, [ 4, 5, 6 ], 3 ]
\endexample

\Declaration{Add}
\beginexample
gap> l := [ 2, 3, 5 ];; Add( l, 7 ); l;
[ 2, 3, 5, 7 ]
\endexample

\>`<obj> in <list>'{element test}!{for lists}

tests whether there is a positive integer <index> such that
`<list>[ <index> ] = <obj>'.

\Declaration{Length}

\Section{Ranges}

A special type of list is a  *range*, which is a dense list of 
integers in arithmetic progression (or degression).  
This is a list of integers such that the difference between
consecutive elements is a nonzero constant.  Ranges can be abbreviated
with the syntactic construct `[ <first>, <second> .. <last> ]' or, if the
difference between consecutive elements is 1, as `[ <first> .. <last> ]'.

\beginexample
gap> r := [10..20];
[ 10 .. 20 ]
gap> Length( r );
11
gap> r[3];
12
gap> 17 in r;
true
gap> r[12] := 25;; r;
[ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 25 ]  # is no longer a range
gap> r := [1,3..17];
[ 1, 3 .. 17 ]
gap> Length( r );
9
gap> r[4];
7
gap> r := [0,-1..-9];
[ 0, -1 .. -9 ]
gap> r[5];
-4
gap> r := [ 1, 4 .. 32 ];
Range: <last>-<first> (31) must be divisible by <inc> (3)
\endexample

Most often ranges are used in connection with the `for'-loop.

\Section{Records}

\index{type!records}

*Records* are next to lists the most important way to collect objects
together. A record is a collection of *components*. Each component has
a unique *name*, which is an identifier that distinguishes this
component, and a *value*, which is an object of arbitrary type. We often
abbreviate *value of a component* to *element*. We also say that a
record *contains* its elements. You can access and change the elements
of a record using its name.

Record literals are written by writing down the components in order between
``{`rec('}'' and ``{`)'}'', and separating them by commas ``{`,'}''. Each
component consists of the name, the assignment operator `:=', and the value.
The *empty record*, i.e., the record with no components, is written as
`rec()'.

\beginexample
gap> rec( a := 1, b := "2" ); # a record with two components
rec(
 a := 1,
 b := "2" )
gap> rec( a := 1, b := rec( c := 2 ) ); # record may contain records
rec(
 a := 1,
 b := rec(
       c := 2 ) )
\endexample

Records usually contain elements of various types, i.e., they are usually
not homogeneous like lists.

\index{accessing!record elements}

\>`<rec>.<name>'{record!component access} O

The above construct evaluates to the value of the record component with
the name <name> in the record <rec>. Note that the <name> is not
evaluated, i.e. it is taken literal.

\beginexample
gap> r := rec( a := 1, b := 2 );;
gap> r.a;
1
gap> r.b;
2
\endexample


\index{assignment!to a record}

\>`<rec>.<name> := <obj>'{record!component assignement} O

The record assignment assigns the object <obj>, which may be an object of
arbitrary type, to the record component with the name <name>, which must
be an identifier, of the record <rec>. That means that accessing the
element with name <name> of the record <rec> will return <obj> after this
assignment. If the record <rec> has no component with the name <name>,
the record is automatically extended to make room for the new component.

\beginexample
gap> r := rec( a := 1, b := 2 );;
gap> r.a := 10;; r;
rec(
  a := 10,
  b := 2 )
gap> r.c := 3;; r;
rec(
  a := 10,
  b := 2,
  c := 3 )
\endexample

Note that assigning to a record changes the record.

The function `IsBound' can be used to test if a record
has a component with a certain name, the function `Unbind'
can be used to remove a component with a certain name again.

\beginexample
gap> IsBound(r.a);
true
gap> IsBound(r.d);
false
gap> Unbind(r.b);r;
rec(
  a := 10,
  c := 3 )
\endexample



\Section{If}

The if statement allows one to execute statements depending on the value 
of some boolean expression.  It has the form

'if' <expr1> 'then' <expr2> 'else' <stats3> 'fi'; 

The execution is done as follows: first the boolean expression <expr1> 
following the 'if' is evaluated. If it evaluates to 'true' the statement 
sequence <expr2> after the first 'then' is executed, and the execution 
of the 'if' statement is complete. 

\beginexample
gap> bignum := 948237498237489324972;;
gap> if bignum mod 3 = 0 then Print("yes\n"); else Print("no\n"); fi;
yes
\endexample

\Section{While}

\index{loop!while}

\>`while <bool-expr> do <statements> od;'{while loop}

The `while' loop executes the statement sequence <statements> while the
condition <bool-expr> evaluates to `true'.

\beginexample
gap> i := 0;; s := 0;;
gap> while s <= 200 do
>    i := i + 1; s := s + i^2;
>  od;
gap> s;
204    # sum of the first i squares larger than 200
\endexample

A `while' loop may be left prematurely using `break'.
\Section{For}

\index{loop!for}\index{do}\index{od}

\>`for <simple-var> in <list-expr> do <statements> od;'{for loop}

The `for' loop executes  the statement sequence <statements> for every
element of the list <list-expr>.  The list <list> is very often a range 
(see~"Ranges").

\>`for <variable> in [<from>..<to>] do <statements> od;'{loop over range}

corresponds to the more common

\){`for <variable> from <from> to <to> do <statements> od;'}

in other programming languages.

\beginexample
gap> s := 0;;
gap> for i in [1..100] do
>    s := s + i;
> od;
gap> s;
5050
\endexample

\Section{Break}

\index{loops!leaving}
\>`break;'{break statement}

The statement `break;' causes an immediate exit from the innermost
loop enclosing it. It is an error to use this statement other than
inside a loop.

\beginexample
gap> g := Group((1,2,3,4,5),(1,2)(3,4)(5,6));
Group([ (1,2,3,4,5), (1,2)(3,4)(5,6) ])
gap> for x in g do
> if Order(x) = 3 then
> break;
> fi; od;
gap> x;
(1,4,3)(2,6,5)
\endexample
\begintt
gap> break;
A break statement can only appear inside a loop
\endtt

\Section{Functions}

\index{function}\index{end}\index{local}
\index{recursion}\index{recursive functions}
\index{environment}\index{body}
\>`function ( [ <arg-ident> \{, <arg-ident>\} ] )'{function definition}
\){    [local  <loc-ident> \{, <loc-ident>\} ; ]}
\){    <statements>}
\){end}

A function is in fact a literal and not a statement. Such a function
literal can be assigned to a variable or to a list element or a record
component. 

The following is an example of a function definition.  It is a function
to compute values of the Fibonacci sequence.

\beginexample
gap> fib := function ( n )
>     local f1, f2, f3, i;
>     f1 := 1; f2 := 1;
>     for i in [3..n] do
>       f3 := f1 + f2;
>       f1 := f2;
>       f2 := f3;
>     od;
>     return f2;
>   end;;
gap> List( [1..10], fib );
[ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
\endexample

Because for each of the formal arguments <arg-ident> and for each of the
formal locals <loc-ident> a new variable is allocated when the function
is called, it is possible that a function calls
itself. This is usually called *recursion*. The following is a recursive
function that computes values of the Fibonacci sequence

\beginexample
gap> fib := function ( n )
>     if n < 3 then
>       return 1;
>     else
>       return fib(n-1) + fib(n-2);
>     fi;
>   end;;
gap> List( [1..10], fib );
[ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
\endexample

\>`<arg-ident> -> <expr>'{arrow notation for functions}

This is a shorthand for

\){function ( <arg-ident> ) return <expr>; end.}

<arg-ident> must be a single identifier, i.e., it is not possible to
write functions of several arguments this way. Also `arg' is not treated
specially, so it is also impossible to write functions that take a
variable number of arguments this way.

The following is an example of a typical use of such a function

\beginexample
gap> Sum( List( [1..100], x -> x^2 ) );
338350
\endexample

\Section{Creating new arithmetic elements}

It sometimes happens that the user may wish to create 
arithmetic elements which are not among {\GAP}'s native
types such as integers, permutations, transformations and mappings.

In this case, an easy way to create new arithmetic elements is 
by using the function

\Declaration{ArithmeticElementCreator}

Specification for the multiplicative/additive elements
defined as subsets of [1 .. 4]
where multiplication is intersection and addition is union
\beginexample
gap> # the whole set
gap> w := [1,2,3,4];
[ 1, 2, 3, 4 ]
gap> # The element specification
gap> PosetElementSpec :=
> rec(
>   # name of the new elements
>   ElementName := Concatenation("PosetOn",String(w)),
> 
>   # arithmetic operations
>   One := a -> w,
>   Zero := a -> [],
>   Multiplication := function(a, b) return Intersection(a, b); end,
>   # MultiplicativeInverse := function(a) end,
>   Addition := function(a, b) return Union(a, b); end,
>   AdditiveInverse := a -> Filtered(w, x->(not x in a)),
> 
>   # Information about the representation
>   # RepInfo := IsAttributeStoringRep,
> 
>   # Mathematical properties of the elements
>   MathInfo := IsCommutativeElement and IsAdditivelyCommutativeElement
> );;
gap> 
gap> mkposet := ArithmeticElementCreator(PosetElementSpec);
function( x ) ... end
gap> 
gap> a := mkposet([1,2,3]);
[ 1, 2, 3 ]
gap> b := mkposet([2,3,4]);
[ 2, 3, 4 ]
gap> a*b;
[ 2, 3 ]
gap> a+b;
[ 1, 2, 3, 4 ]
gap> One(a);
[ 1, 2, 3, 4 ]
gap> Zero(a);
[  ]
\endexample


In the next example we give a specification for multiplicative elements 
represented by sets where multiplication is union.
\beginexample
gap> # The element specification
gap> JoinSetElementSpec :=
> rec(
>   # name of the new elements
>   ElementName := "JoinSet",
> 
>   # arithmetic operations
>   Multiplication := function(a, b) return Union(a, b); end,
> 
>   # Mathematical properties of the elements
>   MathInfo := IsCommutativeElement
> );;
gap> 
gap> 
gap> mkjset := ArithmeticElementCreator(JoinSetElementSpec);
function( x ) ... end
gap> a := mkjset([1,2,3]);
[ 1, 2, 3 ]
gap> b := mkjset([2,3,4]);
[ 2, 3, 4 ]
gap> s := Semigroup([a,b]);
<semigroup with 2 generators>
gap> Size(s);
3
\endexample
