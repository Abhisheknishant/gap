##################################################################
##
##

Further ideas: check that the elementary idempotents actually
generate the semigroup.

##  On example.
##  Find a presentation for On
##  Show that On is RC
##  Find Rees Matrix representation of the top D-class
##
##################################################################

##################################################################
##
##  Part 1.  Create O5. It is well known that 
##  On is generated by the maps s_i which shift i+1->i leaving 
##  everything else fixed, i < n, and the maps t_i
##  and which shift i->i+1, leaving everything else fixed, i < n
## 

s1 := Transformation([1,1,3,4]);
s2 := Transformation([1,2,2,4]);
s3 := Transformation([1,2,3,3]);

t1 := Transformation([2,2,3,4]);
t2 := Transformation([1,3,3,4]);
t3 := Transformation([1,2,4,4]);

o4 := Semigroup([s1,s2,s3,t1,t2,t3]);

Size(o4);

bettergens := function(gens)
	local
		subsetsgens,
		x,
		n;

	gens := Set(gens);
	n := Size(Semigroup(gens));
	subsetsgens := Combinations(gens);

	RemoveSet(subsetsgens, gens);
	RemoveSet(subsetsgens, []);

	for x in subsetsgens do
		if Size(Semigroup(x)) = n then
			return x;
		fi;
	od;
	return fail;
end;


##
## A presentation for On
##
##

f4 := FreeSemigroup(["x1","x2","x3","y1","y2","y3"]);
x := GeneratorsOfSemigroup(f4){[1..3]};
y := GeneratorsOfSemigroup(f4){[4..6]};

# generators are idempotents
idrels := List([1 .. 3], i->[x[i]^2, x[i]]);
Append(idrels, List([1 .. 3], i->[y[i]^2, y[i]]));

# if generators are far enough apart, they commute
commrels := [];
for i in [1 ..3] do
	for j in [1 .. 3] do
		if AbsInt(i-j) > 1  then
			Append(commrels, [[x[i]*x[j], x[j]*x[i]]]);
			Append(commrels, [[y[i]*y[j], y[j]*y[i]]]);
			Append(commrels, [[x[i]*y[j], y[j]*x[i]]]);
		fi;
	od;
od;

# f and g at the same position are right zeros for each other
rtzerorels := [];
for i in [1 .. 3] do
	Append(rtzerorels, [[x[i]*y[i],y[i]]]);
	Append(rtzerorels, [[y[i]*x[i],x[i]]]);
od;

# f and g displaced by one are left zeros for each other
ltzerorels := [];
for i in [1 .. 2] do
	Append(ltzerorels, [[y[i+1]*x[i],y[i+1]]]);
	Append(ltzerorels, [[x[i]*y[i+1],x[i]]]);
od;

# symmetric group type relations
symrels := [];
for i in [1 .. 2] do
	Append(symrels, [[x[i]*x[i+1]*x[i], x[i+1]*x[i]]]);
	Append(symrels, [[x[i+1]*x[i]*x[i+1], x[i+1]*x[i]]]);

	Append(symrels, [[y[i]*y[i+1]*y[i], y[i]*y[i+1]]]);
	Append(symrels, [[y[i+1]*y[i]*y[i+1],y[i]*y[i+1]]]);
od;


rels := Concatenation(idrels, commrels, ltzerorels, rtzerorels,symrels);


# subset of  commrels which works - verify this
commrels := [];
for i in [1 ..3] do
	for j in [1 .. 3] do
		if i -j > 1 then
			Append(commrels, [[x[i]*x[j], x[j]*x[i]]]);
			Append(commrels, [[y[i]*y[j], y[j]*y[i]]]);
			Append(commrels, [[x[i]*y[j], y[j]*x[i]]]);
		fi;
	od;
od;


#####################
##
## Check that it is a homomorphic preimage
##
#####################



g4 := f4/rels;                          
phi := NaturalHomomorphismByGenerators(g4, o4);


###########################
###
### Check that it is in fact a presentation
#######
##########################

psi := IsomorphismTransformationSemigroup(g4);
Size(Range(psi));


##############################
##
##  check that all congruences are rees
##
#########################

a_non_rees_congruence :=    
function(s)
  local e,x,y,i,j;

	e := EnumeratorSorted(s);
	for i in [1 .. Length(e)] do
		for j in [i+1 .. Length(e)] do
			x := e[i];
			y := e[j];
			if not IsReesCongruence(
				SemigroupCongruenceByGeneratingPairs(s, [[x,y]])) then

				return SemigroupCongruenceByGeneratingPairs(s, [[x,y]]);
			fi;
		od;
	od;
	return fail;
end;



jcl := GreensJClasses(o4);;
i2 := SemigroupIdealByGenerators(o4, [Representative(jcl[2])]);
i3 := SemigroupIdealByGenerators(i2, [Representative(jcl[3])]);
c3 := ReesCongruenceOfSemigroupIdeal(i3);
time;

q := i2/c3;
IsZeroSimpleSemigroup(q);  # takes about 50 sec
time;

irms := IsomorphismReesMatrixSemigroup(q);





