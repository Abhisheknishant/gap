##################################################################
##
##

Further ideas: check that the elementary idempotents actually
generate the semigroup.

##  On example.
##  Find a presentation for On
##  Show that On is RC
##  Find Rees Matrix representation of the top D-class
##
##################################################################

##################################################################
##
##  Part 1.  Create O5. It is well known that 
##  On is generated by the maps s_i which shift i+1->i leaving 
##  everything else fixed, i < n, and the maps t_i
##  and which shift i->i+1, leaving everything else fixed, i < n
## 

s1 := Transformation([1,1,3,4,5]);
s2 := Transformation([1,2,2,4,5]);
s3 := Transformation([1,2,3,3,5]);
s4 := Transformation([1,2,3,4,4]);

t1 := Transformation([2,2,3,4,5]);
t2 := Transformation([1,3,3,4,5]);
t3 := Transformation([1,2,4,4,5]);
t4 := Transformation([1,2,3,5,5]);

o5 := Semigroup([s1,s2,s3,s4,t1,t2,t3,t4]);

Size(o5);

bettergens := function(gens)
	local
		subsetsgens,
		x,
		n;

	gens := Set(gens);
	n := Size(Semigroup(gens));
	subsetsgens := Combinations(gens);

	RemoveSet(subsetsgens, gens);
	RemoveSet(subsetsgens, []);

	for x in subsetsgens do
		if Size(Semigroup(x)) = n then
			return x;
		fi;
	od;
	return fail;
end;


##
## A presentation for On
##
##

f5 := FreeSemigroup(["x1","x2","x3","x4","y1","y2","y3","y4"]);
x := GeneratorsOfSemigroup(f5){[1..4]};
y := GeneratorsOfSemigroup(f5){[5..8]};

# generators are idempotents
idrels := List([1 .. 4], i->[x[i]^2, x[i]]);
Append(idrels, List([1 .. 4], i->[y[i]^2, y[i]]));

# if generators are far enough apart, they commute
commrels := [];
for i in [1 ..4] do
	for j in [1 .. 4] do
		if AbsInt(i-j) > 1  then
			Append(commrels, [[x[i]*x[j], x[j]*x[i]]]);
			Append(commrels, [[y[i]*y[j], y[j]*y[i]]]);
			Append(commrels, [[x[i]*y[j], y[j]*x[i]]]);
		fi;
	od;
od;

# f and g at the same position are right zeros for each other
rtzerorels := [];
for i in [1 .. 4] do
	Append(rtzerorels, [[x[i]*y[i],y[i]]]);
	Append(rtzerorels, [[y[i]*x[i],x[i]]]);
od;

# f and g displaced by one are left zeros for each other
ltzerorels := [];
for i in [1 .. 3] do
	Append(ltzerorels, [[y[i+1]*x[i],y[i+1]]]);
	Append(ltzerorels, [[x[i]*y[i+1],x[i]]]);
od;

# symmetric group type relations
symrels := [];
for i in [1 .. 3] do
	Append(symrels, [[x[i]*x[i+1]*x[i], x[i+1]*x[i]]]);
	Append(symrels, [[x[i+1]*x[i]*x[i+1], x[i+1]*x[i]]]);

	Append(symrels, [[y[i]*y[i+1]*y[i], y[i]*y[i+1]]]);
	Append(symrels, [[y[i+1]*y[i]*y[i+1],y[i]*y[i+1]]]);
od;


rels := Concatenation(idrels, commrels, ltzerorels, rtzerorels,symrels);


# subset of  commrels which works - verify this
commrels := [];
for i in [1 ..4] do
	for j in [1 .. 4] do
		if i -j > 1 then
			Append(commrels, [[x[i]*x[j], x[j]*x[i]]]);
			Append(commrels, [[y[i]*y[j], y[j]*y[i]]]);
			Append(commrels, [[x[i]*y[j], y[j]*x[i]]]);
		fi;
	od;
od;




##################################################################
##
##  Part 1.  Create OP5. It is well known that 
##  On is generated by the maps s_i which shift i+1->i leaving 
##  everything else fixed, i < n, and the maps t_i
##  and which shift i->i+1, leaving everything else fixed, i < n
## 

s1 := Transformation([1,1,3,4,5]);
s2 := Transformation([1,2,2,4,5]);
s3 := Transformation([1,2,3,3,5]);
s4 := Transformation([1,2,3,4,4]);
s5 := Transformation([1,2,3,4,1]);

t1 := Transformation([2,2,3,4,5]);
t2 := Transformation([1,3,3,4,5]);
t3 := Transformation([1,2,4,4,5]);
t4 := Transformation([1,2,3,5,5]);
t5 := Transformation([5,2,3,4,5]);

o5 := Semigroup([s1,s2,s3,s4,s5,t1,t2,t3,t4,t5]);

Size(o5);

bettergens := function(gens)
	local
		subsetsgens,
		x,
		n;

	gens := Set(gens);
	n := Size(Semigroup(gens));
	subsetsgens := Combinations(gens);

	RemoveSet(subsetsgens, gens);
	RemoveSet(subsetsgens, []);

	for x in subsetsgens do
		if Size(Semigroup(x)) = n then
			return x;
		fi;
	od;
	return fail;
end;


##
## A presentation for OPn
##
##

f5 := FreeSemigroup(["x1","x2","x3","x4","x5","y1","y2","y3","y4","y5"]);
x := GeneratorsOfSemigroup(f5){[1..5]};
y := GeneratorsOfSemigroup(f5){[6..10]};

# generators are idempotents
idrels := List([1 .. 5], i->[x[i]^2, x[i]]);
Append(idrels, List([1 .. 5], i->[y[i]^2, y[i]]));

# if generators are far enough apart, they commute
commrels := [];
for i in [1 ..4] do
	for j in [1 .. 4] do
		if AbsInt(i-j) > 1  then
			Append(commrels, [[x[i]*x[j], x[j]*x[i]]]);
			Append(commrels, [[y[i]*y[j], y[j]*y[i]]]);
			Append(commrels, [[x[i]*y[j], y[j]*x[i]]]);
		fi;
	od;
od;
Append(commrels, [[x[5]*x[2],x[2]*x[5]], [x[5]*x[3],x[3]*x[5]]]);
Append(commrels, [[y[5]*y[2],y[2]*y[5]], [y[5]*y[3],y[3]*y[5]]]);
Append(commrels, [[x[5]*y[2],y[2]*x[5]], [x[5]*y[3],y[3]*x[5]]]);
Append(commrels, [[y[5]*x[2],x[2]*y[5]], [y[5]*x[3],x[3]*y[5]]]);

# f and g at the same position are right zeros for each other
rtzerorels := [];
for i in [1 .. 5] do
	Append(rtzerorels, [[x[i]*y[i],y[i]]]);
	Append(rtzerorels, [[y[i]*x[i],x[i]]]);
od;

# f and g displaced by one are left zeros for each other
ltzerorels := [];
for i in [1 .. 4] do
	Append(ltzerorels, [[y[i+1]*x[i],y[i+1]]]);
	Append(ltzerorels, [[x[i]*y[i+1],x[i]]]);
od;
Append(ltzerorels, [[y[1]*x[5],y[1]]]);
Append(ltzerorels, [[x[5]*y[1],x[5]]]);

# symmetric group type relations
symrels := [];
for i in [1 .. 4] do
	Append(symrels, [[x[i]*x[i+1]*x[i], x[i+1]*x[i]]]);
	Append(symrels, [[x[i+1]*x[i]*x[i+1], x[i+1]*x[i]]]);

	Append(symrels, [[y[i]*y[i+1]*y[i], y[i]*y[i+1]]]);
	Append(symrels, [[y[i+1]*y[i]*y[i+1],y[i]*y[i+1]]]);
od;
Append(symrels, [[x[5]*x[1]*x[5], x[1]*x[5]]]);
Append(symrels, [[x[1]*x[5]*x[1], x[1]*x[5]]]);

Append(symrels, [[y[5]*y[1]*y[5], y[5]*y[1]]]);
Append(symrels, [[y[1]*y[5]*y[1],y[5]*y[1]]]);


rels := Concatenation(idrels, commrels, ltzerorels, rtzerorels,symrels);


# subset of  commrels which works - verify this
commrels := [];
for i in [1 ..4] do
	for j in [1 .. 4] do
		if i -j > 1 then
			Append(commrels, [[x[i]*x[j], x[j]*x[i]]]);
			Append(commrels, [[y[i]*y[j], y[j]*y[i]]]);
			Append(commrels, [[x[i]*y[j], y[j]*x[i]]]);
		fi;
	od;
od;



