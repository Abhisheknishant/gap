\documentclass[12pt]{article}

\usepackage{amsmath,theorem}

\title{Tutorial -- Computing with Semigroups in GAP}

\author{Isabel Ara\'ujo and Andrew Solomon\\
School of Mathematical and Computational Sciences\\
The University of St. Andrews, Scotland\\
{\small \tt \{isabel,andrews\}@dcs.st-and.ac.uk}}

\theoremstyle{plain} \newtheorem{Thm}{Theorem}
\theoremstyle{plain} \newtheorem{Cor}{Corollary}
\theoremstyle{plain} \newtheorem{Lemma}{Lemma}
\theoremstyle{plain} \newtheorem{Prop}{Proposition}
\theoremstyle{plain} \newtheorem{Ex}{Exercise}


\date{}
\def\gap{\sf GAP}
\def\d{${\mathcal{D}}$}
\def\l{${\mathcal{L}}$}
\def\r{${\mathcal{R}}$}
\def\h{${\mathcal{H}}$}

\begin{document}
\maketitle


Over the course of a decade {\gap} has come to be the most widely used tool
for computational group theory. Due to its ready availability --
it is {\em free} and is ported to many platforms -- {\gap}'s
user base is already numbered in the thousands, and its functionality
is being extended through the efforts of a growing number of 
enthusiastic share package authors around the world, together
with {\gap}'s core developer community. 

Until recently, the main
focus of computational abstract algebra has been on group theory and 
commutative algebra, but due to a recent surge of interest in computing with
semigroups, graphs, Lie algebras, near-rings and the like, the 
scope of {\gap} has broadened to support a more general class of 
mathematical structures.
In line with this, the recently  released 
{\gap}~4.1 supports semigroups as a principal component. 

{\gap} is used both as a `desk calculator' for automating
large or tedious hand calculations, and also 
as a software development platform in which to implement
mathematical algorithms.  This tutorial emphasises the use of 
{\gap} as a desk calculator
for semigroups. There are five sections,  and in each section
we use different features to investigate the structure of 
a well known semigroup. The material in each section is intended
to be independent from the rest, so they can be approached in any
order.
\begin{enumerate}
\item {\bf Endomorphisms of a finite chain} introduces the reader to
transformation semigroups, congruences and Green's relations;
\item {\bf Orientation preserving mappings} uses transformation semigroups
as a starting point for working with congruences and quotient semigroups,
and Rees matrix semigroups;
\item {\bf The power set semigroup} will be of interest to potential 
{\gap} developers, showing how to create new types of multiplicative elements,
and how to use finitely presented semigroups, semigroup homomorphisms and
the built in Todd-Coxeter enumerator;
\item {\bf Endomorphisms of the symmetric group} deals with 
selecting element representation for efficiency,
moving between semigroups using isomorphisms, 
and studying semigroups whose elements are themselves homomorphisms;
\item {\bf The Heisenberg group} showcases {\gap}'s features for working
with infinite finitely presented semigroups, such as the Knuth-Bendix 
procedure.
\end{enumerate}

\section{Endomorphisms of a finite chain}
In this section we use {\gap} to investigate the structure of 
$O_n$, the semigroup of endomorphisms of a finite chain.  
The user will gain experience in working with:
\begin{itemize}
\item transformation semigroups;
\item congruences and Rees congruences;
\item Green's relations, Green's classes and eggboxes.
\end{itemize}


Consider the set $[n] = \{1, 2, \ldots, n\}$ with the usual total order. 
An endomorphism of $[n]$ is a map $\phi: [n] \rightarrow [n]$ 
such that  $i < j$ implies $i\phi \leq j\phi$. Let $O_n$ denote
the semigroup of singular endomorphisms of the chain $[n]$.
It is a simple combinatorial observation \cite{tgl94} that $O_n$ has size
$$\sum_{k=1}^{n-1} \binom{n-1}{k-1} \binom{n}{k} - 1 = \binom{2n-1}{n-1} -1.$$

We will work with the case $n=4$, so that $O_4$ has size $34$. 
In {\gap}:
\begin{verbatim}
gap> Binomial(7,3)-1;
34
\end{verbatim}


The `smallest' endomorphisms are the ones 
which shift one point only and leave the rest fixed. Precisely,
for $i \in \{1, \ldots, 3\}$, define 
$s_i$ to be the endomorphism  which maps $i+1$ to $i$ and 
fixes everything else; and $t_i$ to be the one which maps 
$i$ to $i+1$ and fixes everything
else.  To enter a transformation: 
\begin{verbatim}
gap> s1 := Transformation([1,1,3,4]);
Transformation( [ 1, 1, 3, 4 ] )
\end{verbatim}

To check that this is a generating set,
create the semigroup generated by these transformations
and compute the size:
\begin{verbatim}
gap> o4 := Semigroup(s1,s2,s3,t1,t2,t3);
<semigroup with 6 generators>
gap> Size(o4);
34
\end{verbatim}
\begin{Ex}
Confirm that $s_1, \ldots, t_3$ is a minimal generating set for $O_4$.
\end{Ex}


\subsection{$O_n$ has only Rees congruences}
Let's create an arbitrary congruence on $O_4$.
\begin{verbatim}
gap> c := SemigroupCongruenceByGeneratingPairs(o4, [[s2*s1,t1*s2]]);
<semigroup congruence with 1 generating pairs>
gap> EquivalenceRelationPartition(c);
[ [ Transformation( [ 1, 1, 1, 1 ] ), Transformation( [ 1, 1, 1, 2 ] ), 
      Transformation( [ 1, 1, 1, 3 ] ), Transformation( [ 1, 1, 1, 4 ] ), 
      Transformation( [ 1, 1, 2, 2 ] ), Transformation( [ 1, 1, 3, 3 ] ), 
      Transformation( [ 1, 1, 4, 4 ] ), Transformation( [ 1, 2, 2, 2 ] ), 
      Transformation( [ 1, 3, 3, 3 ] ), Transformation( [ 1, 4, 4, 4 ] ), 
      Transformation( [ 2, 2, 2, 2 ] ), Transformation( [ 2, 2, 2, 3 ] ), 
      Transformation( [ 2, 2, 2, 4 ] ), Transformation( [ 2, 2, 3, 3 ] ), 
      Transformation( [ 2, 2, 4, 4 ] ), Transformation( [ 2, 3, 3, 3 ] ), 
      Transformation( [ 2, 4, 4, 4 ] ), Transformation( [ 3, 3, 3, 3 ] ), 
      Transformation( [ 3, 3, 3, 4 ] ), Transformation( [ 3, 3, 4, 4 ] ), 
      Transformation( [ 3, 4, 4, 4 ] ), Transformation( [ 4, 4, 4, 4 ] ) ] ]
\end{verbatim}
{\em To interpret this output, note that  a list is printed as 
$[a_1, a_2, \ldots, a_n]$. Therefore the list above has a single
element, which is a list.}

Since {\tt EquivalenceRelationPartition} lists precisely the  nonsingleton
classes of an equivalence relation, we see that {\tt c} is a Rees congruence.
In fact, there is a function which tests this:

\begin{verbatim}
gap> IsReesCongruence(c);
true
\end{verbatim}

Since the join of two Rees congruences is again Rees, 
and every congruence in a finite semigroup is the join of a
finite number of congruences generated by pairs,  we have:
\begin{Prop}\label{reespair}
For a finite semigroup, if every congruence generated by a pair 
is Rees, then every congruence is Rees.
\end{Prop}

\begin{Ex} If you're feeling adventurous, use Proposition \ref{reespair}
to verify that every congruence of $O_4$ is Rees. This may take over a minute
depending on the performance of the system.\\
{\rm Hint: If you've already checked the congruence generated by $(a,b)$ don't 
also check the congruence generated by $(b,a)$.}
\end{Ex}
It turns out (see \cite{tglsol99}) that every congruence of $O_n$ is Rees. 

\subsection{Green's Structure of $O_n$}
The first observation of this section is that $O_4$ is a regular semigroup:
\begin{verbatim}
gap> IsRegularSemigroup(o4);
true
\end{verbatim}
This can also be seen by the command:
\begin{verbatim}
gap> DisplayTransformationSemigroup(o4);
Rank 3: *[H size = 1, 4 L classes, 3 R classes]
Rank 2: *[H size = 1, 6 L classes, 3 R classes]
Rank 1: *[H size = 1, 4 L classes, 1 R classes]
\end{verbatim}
{\em The `*' indicates that the {\d}-class is regular.}

In fact we can show that the {\d}-classes form a chain:
\begin{verbatim}
gap> dcl := GreensDClasses(o4);
[ {Transformation( [ 1, 1, 3, 4 ] )}, {Transformation( [ 1, 1, 1, 4 ] )}, 
  {Transformation( [ 1, 1, 1, 1 ] )} ]
gap> IsGreensLessThanOrEqual(dcl[2], dcl[1]);
true
gap> IsGreensLessThanOrEqual(dcl[3], dcl[2]);
true
\end{verbatim}
{\em Notice that {\tt dcl} above is a list of \d-classes, and each
\d-class is printed as a representative enclosed in curly braces.}

Our understanding of the Green's structure of this semigroup 
can be regarded as complete once we have an eggbox picture of 
each \d-class which can be accomplished as follows:
\begin{verbatim}
gap> DisplayEggBoxOfDClass(dcl[1]);
[ [  1,  0,  1,  0 ],
  [  1,  1,  0,  0 ],
  [  0,  1,  0,  1 ] ]
\end{verbatim}
{\em {\tt DisplayEggBoxOfDClass} displays a matrix whose rows are
{\r}-classes, columns are {\l}-classes and a $1$ indicates that the
{\h}-class in that position is a group.}

\section{Orientation preserving mappings}
The semigroup $OP_n$ of orientation preserving transformations
of the set $\{1, \ldots, n\}$
is a straightforward extension of the semigroup of endomorphisms,
$O_n$, and can be thought
of as order preserving mappings drawn on a cylinder. For more details see,
for example, \cite{arthur_opn?} or \cite{cathig_opn}.

The semigroup is generated by just two maps: $s$, which maps 
$2$ to $1$ and fixes all other points,  and $c$, the $n$-cycle.
We will study $OP_3$ and $OP_5$ using it to demonstrate:
\begin{itemize}
\item fast algorithms for transformation semigroups;
\item Rees congruences and quotient semigroups;
\item Rees matrix semigroups.
\end{itemize}

\subsection{The freeway -- fast algorithms for transformation semigroups}
In this subsection we exhibit some very fast algorithms specifically
for transformation semigroups.  Enter the semigroup $OP_5$ as follows:

\begin{verbatim}
gap> s := Transformation([1,1,3,4,5]); 
Transformation( [ 1, 1, 3, 4, 5 ] )
gap> c := Transformation([2,3,4,5,1]);
Transformation( [ 2, 3, 4, 5, 1 ] )
gap> op5 := Semigroup(s,c);
<semigroup with 2 generators>
\end{verbatim}

To see the structure of this semigroup type:
\begin{verbatim}
gap> DisplayTransformationSemigroup(op5);
Rank 5: *[H size = 5, 1 L classes, 1 R classes]
Rank 4: *[H size = 4, 5 L classes, 5 R classes]
Rank 3: *[H size = 3, 10 L classes, 10 R classes]
Rank 2: *[H size = 2, 10 L classes, 10 R classes]
Rank 1: *[H size = 1, 5 L classes, 1 R classes]
gap> Size(op5);
610
\end{verbatim}
{\em The `*' indicates that the \d-class is regular.}

The following observation allows us to explore the structure of 
each \d-class of $OP_5$ as a Rees matrix semigroup:
\begin{Prop}\label{regfact}
Let $S$ be a finite semigroup, then the principal factor 
of every regular element is a completely $0$-simple semigroup.
\end{Prop}
Therefore there is a correspondence between regular 
\d-classes and Rees matrix semigroups, as given in the following
example. First find the list of \d-classes:
\begin{verbatim}
gap> dcl := GreensDClasses(op5);;
\end{verbatim}
By inspecting the elements of {\tt dcl}, identify the
rank 4 \d-class and assign it to the variable {\tt d4}. 
Then create the corresponding Rees matrix semigroup using:
\begin{verbatim}
gap> rms := AssociatedReesMatrixSemigroupOfDClass(d4);
Rees Zero Matrix Semigroup over Monoid( [ (), (1,5,4,3), 0 ], ... )
\end{verbatim}
Finally, investigate the structure of {\tt rms} using 
{\tt SandwichMatrixOfReesZeroMatrixSemigroup}, {\tt Elements} etc.
Note: in {\gap}, a Rees {\it Zero} Matrix Semigroup  is different from 
a Rees Matrix Semigroup. A Rees Matrix Semigroup over a $0$-group 
has up to $I \times \Lambda$ elements of the form $(0; i, \lambda)$ --- in the 
corresponding Rees Zero Matrix Semigroup, these are all collapsed to a 
single zero element.


These computations take under a second on a Pentium 400. 
As with permutation groups, there are fast algorithms for
computing Green's relations on transformation semigroups.
The particular methods demonstrated above were developed  
by Linton et.~al.  \cite{linton_tsemi} and implementation
of these algorithms for {\gap}~4.1 is work in progress.
See end notes for information on how to obtain a preliminary
version of this software.
 

\subsection{The scenic route -- Quotient semigroups}
Once again, we construct the 
Rees matrix semigroup associated with a principal factor, but
this time, by creating the principal factor explicitly. Since 
factor semigroups are not transformation semigroups with
special fast algorithms, we scale our example back to the 
relatively modest $OP_3$. 

\begin{Ex}
Create the semigroup $OP_3$ in {\gap} as the variable {\tt op3}.
\end{Ex}
Firstly, we discover that, like $OP_5$,  $OP_3$ is regular.
\begin{verbatim}
gap> IsRegularSemigroup(op3);
true
\end{verbatim}
So by Proposition \ref{regfact}, every principal factor is 
a zero simple semigroup.
We demonstrate here how to create a principal factor of
$OP_3$ and then find an isomorphic Rees matrix semigroup.
First we choose a \d-class:
\begin{Ex}
Use {\tt GreensDClasses(op3)} 
to find the \d-classes of $OP_3$
of rank 2 and of rank 1 and assign them to 
{\tt d2} and {\tt d1} respectively.\\
{\rm Hint: If {\tt dcl} is the list of \d-classes, then
{\tt dcl[i]} is the $i$th element of that list.}
\end{Ex}

Create the principal ideal {\tt i2}, generated by an element of
the \d-class {\tt d2}.
Then create the ideal {\tt i1}  of {\tt i2} generated by an element of
{\tt d1}.
\begin{verbatim}
gap> i2 := SemigroupIdealByGenerators(op3, [Representative(d2)]);
gap> i1 := SemigroupIdealByGenerators(i2, [Representative(d1)]);
\end{verbatim}

Now create the Rees congruence associated with {\tt i1}
\begin{verbatim}
gap> c1 := ReesCongruenceOfSemigroupIdeal(i1);
\end{verbatim}

Finally, the quotient semigroup (the principal factor) is created with
\begin{verbatim}
gap> q := i2/c1;

\end{verbatim}

Now before you can ask the computer for the Rees Matrix 
representation, it has to know that the semigroup is $0$-simple.
One {\em could} type:
\begin{verbatim}
gap> IsZeroSimpleSemigroup(q);
true
\end{verbatim}
But by Proposition \ref{regfact}, we could save time and just inform {\gap}
that the semigroup is simple.
\begin{verbatim}
gap> SetIsZeroSimpleSemigroup(q, true);
\end{verbatim}

Finally, to find the Rees matrix representation, 

\begin{verbatim}
gap> irms := IsomorphismReesMatrixSemigroup(q);;
\end{verbatim}

The Rees matrix semigroup is then {\tt Source(irms)} and 
{\tt q} is {\tt Range(irms)}.  In particular, to see the 
sandwich matrix of the Rees matrix semigroup
enter:

\begin{verbatim}
gap> SandwichMatrixOfReesZeroMatrixSemigroup(Source(irms));
\end{verbatim}


\section{The power set semigroup}
In this section we find a presentation for the power set
of a finite set as a semigroup under the operation join.  
This will give the user experience in:
\begin{itemize}
\item creating new arithmetic elements;
\item working with finitely presented semigroups;
\item creating homomorphisms of semigroups;
\item Todd-coxeter enumeration.
\end{itemize}

Consider the semigroup of subsets of $\{1,2,3,4\}$ under the operation
of join, with generators
$\{1, 2\}$, $\{2, 3\}$ and $\{3, 4$\}.

To represent this in {\gap} we need to define the elements and a
multiplication on them. This is done through an {\em element specification}.

\begin{verbatim}
gap> JoinSetElementSpec :=
> rec(
>   # name of the new elements
>   ElementName := "JoinSet",
> 
>   # arithmetic operations
>   Multiplication := function(a, b) return Union(a, b); end,
> 
>   # Mathematical properties of the elements
>   MathInfo := IsCommutativeElement
> );
\end{verbatim}
The element specification is just a record with certain distinguished
components. In this simple example they are
{\tt ElementName, Multiplication} and {\tt MathInfo}.
In order to make these multiplicative elements, we need a 
creation function which we can now obtain with
\begin{verbatim}
gap> MakeJoinSet := ArithmeticElementCreator(JoinSetElementSpec);
function( x ) ... end
\end{verbatim}
and now elements can be made as shown below.
\begin{verbatim}
gap> a := MakeJoinSet([1,2]);
[ 1, 2 ]
gap> b := MakeJoinSet([2,3]);
[ 2, 3 ]
gap> c := MakeJoinSet([3,4]);
[ 3, 4 ]
\end{verbatim}
To verify that these really are multiplicative elements, 
try multiplying them (and see what happens when you 
try to multiply plain lists).
We wish to find a presentation for the semigroup generated by
{\tt a}, {\tt b} and {\tt c}.
\begin{verbatim}
gap> s := Semigroup(a,b,c);
<semigroup with 3 generators>
gap> Elements(s);
[ [ 1, 2 ], [ 1, 2, 3 ], [ 1, 2, 3, 4 ], [ 2, 3 ], [ 2, 3, 4 ], [ 3, 4 ] ]
\end{verbatim}

To find a presentation for this semigroup, we construct a finitely
presented semigroup as a quotient of a free semigroup and
show that it is isomorphic.
\begin{verbatim}
gap> f := FreeSemigroup("x","y","z");
<free semigroup on the generators [ x, y, z ]>
gap> x := GeneratorsOfSemigroup(f)[1];;
gap> y := GeneratorsOfSemigroup(f)[2];;
gap> z := GeneratorsOfSemigroup(f)[3];;
\end{verbatim}
{\em Notice that the letters `x', `y' and `z' in the creation of the 
free semigroup are strings which are given as names for the variables.
In the subsequent lines, the variables {\tt x, y} and {\tt z} are assigned
to the generators of the semigroup.}

Define the finitely presented semigroup:
\begin{verbatim}
gap> rels := [ [ x^2, x ], [ y^2, y ], [ z^2, z ], 
> [x*y,y*x], [x*z,z*x], [x*y*z, x*z], [y*z,z*y]];;
gap> g:= f/rels;                                                               
<fp semigroup on the generators [ x, y, z ]>
\end{verbatim}
To ensure that the relations of the finitely presented semigroup {\tt g}
hold in {\tt s}, define a homomorphism:
\begin{verbatim}
gap> psi := NaturalHomomorphismByGenerators(g, s);                             
MappingByFunction( <fp semigroup on the generators 
[ x, y, z ]>, <semigroup with 3 generators>, function( e ) ... end )
\end{verbatim}

\begin{Ex}
Check that the homomorphism so constructed maps the ith generator
of {\tt g} to the ith generator of {\tt s}.
{\rm Hint: To get the 1st generator of {\tt g} use:
\begin{verbatim}
gap> gx := GeneratorsOfSemigroup(g)[1];;
\end{verbatim}
and to see its image under {\tt psi} use:
\begin{verbatim}
gap> gx^psi;                                      
[ 1, 2 ]
\end{verbatim}}
\end{Ex}

\begin{Ex} 
Verify that if {\tt g} were not a homomorphic primage of {\tt s},
attempting to create  the  homomorphism would fail.
\end{Ex}

Now we know we have a presentation of a preimage of {\tt s}, we only 
need to check that the size of {\tt g} is the size of {\tt s}.
This can be accomplished in two ways. Since this is a small example,
we can simply issue the command:
\begin{verbatim}
gap> Size(g);                                                                  
6
gap> time;
180
\end{verbatim}
this command uses the Knuth Bendix rewriting procedure \cite{simsbook}  to 
get a confluent rewriting system, and then enumerates the elements.
Usually more efficient for nontrivial examples is 
\begin{verbatim}
gap> tci := IsomorphismTransformationSemigroup(g);
MappingByFunction( <fp semigroup on the generators 
[ x, y, z ]>, <semigroup with 3 generators>, function( x ) ... end )
gap> time;
30
gap> Size(Range(tci));
6
\end{verbatim}
which uses the Todd-Coxeter \cite{walker_tc} procedure to find a 
faithful transformation representation of the semigroup which is then
returned as the range of the isomorphism {\tt tci}.

Since the size of the finitely presented preimage {\tt g} of {\tt s} is the
same as the size of {\tt s} we have verified that {\tt g} is a 
presentation for {\tt s}.



\section{Endomorphisms of the symmetric group}
This section investigates the structure of 
the semigroup of endomorphisms of the symmetric group on five points.
We emphasise the ability to move between the semigroup
under investigation, and the semigroup in which the computations
are actually performed, often a transformation semigroup 
(for which there are fast algorithms -- see \cite{linton_tsemi}).
In this section experience will be gained in:
\begin{itemize}
\item semigroups whose elements are homomorphisms;
\item changing element representation for efficiency;
\item moving between semigroups via isomorphisms;
\item investigating Green's relations.
\end{itemize}

Consider the semigroup of endomorphisms, $End(S_5)$, 
of the symmetric group $S_5$.
An endomorphism of $S_5$ has kernel either $S_5$, the alternating
group  $A_5$ 
or the trivial subgroup,
since these are the only normal subgroups of $S_5$.
The endomorphisms with trivial kernel are precisely the inner automorphisms 
and there are 120 of them.
The endomorphism with kernel $S_5$ 
maps everything to the identity.
The ones with kernel $A_5$ are the homomorphisms mapping all even permutations
to the identity and odd permutations to a single involution --
there are 25 of these. 
Adding all this up shows that $End(S_5)$ is a semigroup of size 146. 
The following four endomorphisms of $S_5$ form a  generating 
set for $End(S_5)$:
\begin{eqnarray*}
x & \rightarrow & (1,2,3,4,5)^{-1} * x * (1,2,3,4,5)\\
x & \rightarrow & (1,2)^{-1} * x * (1,2)\\
x & \rightarrow & () \mbox{ if }x\mbox{ is even};\ (1,2) \mbox{ otherwise }\\
x & \rightarrow & 
                () \mbox{ if } x \mbox{ is even};\ (1,2)(3,4)\mbox{ otherwise}.
\end{eqnarray*}

We create the semigroup and check that the generating
set given above does indeed generate the whole semigroup.
First create $S_5$ and its alternating subgroup $A_5$:
\begin{verbatim}
gap> s5 := SymmetricGroup( 5 );
Sym( [ 1 .. 5 ] )
gap> a5 := AlternatingGroup(5);
Alt( [ 1 .. 5 ] )
\end{verbatim}
and then introduce the generators 
\begin{verbatim}
gap> endo1 := GroupHomomorphismByFunction(s5, s5,                     
> x -> (1,2,3,4,5)^-1 * x * (1,2,3,4,5) );;
gap> endo2 := GroupHomomorphismByFunction(s5, s5,
> x -> (1,2)^-1 * x * (1,2) );;
gap> endo3 := GroupHomomorphismByFunction(s5, s5,
> function(x) 
> if x in a5 then return (); 
> else return (1,2); fi; end);;
gap> endo4 := GroupHomomorphismByFunction(s5, s5,
> function(x) 
> if x in a5 then return (); 
> else return (1,2)*(3,4); fi; end);;
\end{verbatim}

Before we build the semigroup, it would be well to change the 
{\em representation} of the generators into transformations
(endofunctions of the set $\{1, \ldots, n\}$)
so that multiplication is as fast as possible. Note, this is only 
a change of representation, mathematically {\gap} still regards them
as endomorphisms of $S_5$.
\begin{verbatim}
gap> endo1 := TransformationRepresentation(endo1);
<mapping: SymmetricGroup( [ 1 .. 5 ] ) -> SymmetricGroup( [ 1 .. 5 ] ) >
gap> endo2 := TransformationRepresentation(endo2);
<mapping: SymmetricGroup( [ 1 .. 5 ] ) -> SymmetricGroup( [ 1 .. 5 ] ) >
gap> endo3 := TransformationRepresentation(endo3);
<mapping: SymmetricGroup( [ 1 .. 5 ] ) -> SymmetricGroup( [ 1 .. 5 ] ) >
gap> endo4 := TransformationRepresentation(endo4);
<mapping: SymmetricGroup( [ 1 .. 5 ] ) -> SymmetricGroup( [ 1 .. 5 ] ) >
\end{verbatim}
Finally build the semigroup
\begin{verbatim}
gap> semiendos := Semigroup( endo1, endo2, endo3, endo4 );
<semigroup with 4 generators>
gap> Size( semiendos);
146
\end{verbatim}
which confirms that we have a generating set.

\begin{Ex}
Confirm that this is a minimal generating set for $End(S5)$.
\end{Ex}

\subsection{Finding the Green's class structure of $End(S_5)$}
        
Methods for transformation semigroups are in general
much faster then for an arbitrary semigroup. Note that a 
{\em transformation semigroup} is a semigroup whose 
elements are {\em mathematically} transformations, not
just represented as transformations as our endomorphisms are.
Therefore, we need to make 
an isomorphism from {\tt semiendos} to the transformation semigroup
{\tt tsemiendos} and investigate the Green's structure of the latter. 

Start by creating the isomorphism $\phi : $\texttt{semiendos}$\rightarrow$ 
\texttt{tsemiendos} and asking for its range:
\begin{verbatim}
gap> phi := IsomorphismTransformationSemigroup(semiendos);
MappingByFunction( <semigroup with 4 generators>, 
<semigroup with 4 generators>, function( a ) ... end )
gap> tsemiendos := Range(phi);
<semigroup with 4 generators>
\end{verbatim}
\begin{Ex}
Look at a few of the elements of {\tt tsemiendos} and work out
what the isomorphism is.
\end{Ex}

Now create the $\mathcal{D}$-classes
\begin{verbatim}
gap> dcl := GreensDClasses( tsemiendos );;
\end{verbatim}

\begin{Ex}
Find the size of each of the $\mathcal{D}$-classes.
\end{Ex}

To quickly apprehend the structure of {\tt tsemiendos} type:
\begin{verbatim}
gap> DisplayTransformationSemigroup(tsemiendos);
Rank 120: *[H size = 120, 1 L classes, 1 R classes]
Rank 2: *[H size = 1, 10 L classes, 1 R classes]
Rank 2: [H size = 1, 15 L classes (1 image types), 1 R classes (1 kernel types)]
Rank 1: *[H size = 1, 1 L classes, 1 R classes]
\end{verbatim}
{\em The `*' indicates that the \d-class is regular.}

Clearly, the rank 120 elements comprise the group of automorphsisms
of $S_5$, and the rank 1 element is the `zero' mapping everything to the 
identity. So, to completely determine the poset of 
$\mathcal{D}$-classes,  it only remains to decide the order relation
between the two rank 2 \d-classes:
\begin{verbatim}
gap> IsGreensLessThanOrEqual( dcl[3], dcl[2] );
true
\end{verbatim}

\begin{Ex}
Describe the action of the endomorphisms in the two middle  
$\mathcal{D}$-classes
\end{Ex}
{\bf Hints}
\begin{enumerate}
\item  To get the 2nd element of the list of \d-classes, type
\begin{verbatim}
gap> d2 := dcl[2];;
\end{verbatim}
\item To get a representative element of a \d-class, (say {\tt d2})
use 
\begin{verbatim}
gap> x :=  Representative(d2);
\end{verbatim}
\item To see the preimage of an element {\tt x} of {\tt tsemiendos} under
{\tt phi} use:
\begin{verbatim}
gap> a := PreImageElm(phi, x);     
MappingByFunction( Sym( [ 1 .. 5 ] ), Sym( 
[ 1 .. 5 ] ), function( x ) ... end )
\end{verbatim}
\item To see the image of an element {\tt a} of {\tt semiendos} under
{\tt phi} use 
\begin{verbatim}
gap> a^phi;
\end{verbatim}
\item To see what the group element {\tt (1,2)} 
maps to under the endomorphism {\tt a} use:
\begin{verbatim}
gap> (1,2)^a;
(1,2)
\end{verbatim}
\end{enumerate}


\section{An infinite example -- The Heisenberg group}
The Heisenberg group is an infinite nilpotent group with
solvable word problem. It turns out that, while one can
find a confluent rewriting system for the Heisenberg group,
it cannot be done using the ShortLex word ordering, so
it is a good example in which to experiment with:
\begin{itemize}
\item infinite finitely presented groups and semigroups;
\item commutative finitely presented semigroups;
\item rewriting systems.
\end{itemize}

In \cite{eps} a group presentation for 
the Heisenberg group is given as follows. 
$$\langle \alpha ,\beta ,\gamma \mid 
[ \alpha ,\beta ] \gamma ^{-1} ,
[ \alpha ,\gamma ] , [ \beta ,\gamma ] \rangle .$$  

\subsection{Solving the word problem}
We use {\gap} to find a confluent rewriting system for 
this group allowing us to test equality of two words.
We start by creating the group. 

First construct the free group on three generators.
\begin{verbatim}
gap> f := FreeGroup( "gamma", "beta", "alpha");
<free group on the generators [ gamma, beta, alpha ]>
gap> g := GeneratorsOfGroup(f)[1];
gap> b := GeneratorsOfGroup(f)[2];
gap> a := GeneratorsOfGroup(f)[3];
\end{verbatim}
Notice that we have made {\tt gamma}  the first 
generator, since we need the basic wreath product 
word ordering with  $\alpha > \beta > \gamma$ 
in order to produce a confluent rewriting system.

Now create the Heisenberg group by factoring the free group 
by the group relators.
\begin{verbatim}
gap> relators := [Comm(a,b)*g^-1, Comm(a,g), Comm(b,g)];;
gap> h := f/relators;
<fp group on the generators [ gamma, beta, alpha ]>
\end{verbatim}

Since the Knuth-Bendix procedure is a semigroup algorithm, 
we find an isomorphism of the Heisenberg group with 
a finitely presented semigroup:
\begin{verbatim}
gap> phi := IsomorphismFpSemigroup( h );;
gap> s := Range( phi );
<fp semigroup on the generators [ <identity ...>, gamma^-1, 
gamma, beta^-1, beta, alpha^-1, alpha ]>
\end{verbatim}

We finally build a rewriting system for the Heisenberg semigroup,
with respect to the basic wreath product ordering:
\begin{verbatim}
gap> rws := 
KnuthBendixRewritingSystem( s, IsBasicWreathLessThanOrEqual );;
gap> MakeConfluent( rws );
\end{verbatim}

We can now test for equality of words in the semigroup
\begin{verbatim}
gap> sgens := GeneratorsOfSemigroup( s );
[ <identity ...>, gamma^-1, gamma, beta^-1, 
  beta, alpha^-1, alpha ]
gap> sgens[2] * sgens[7] = sgens[7] * sgens[2];
true
\end{verbatim}

If we had not explicitly created the rewriting system using
the basic wreath product ordering, attempting to test the equality of
two elements would have caused {\gap} to attempt to create a confluent 
rewriting system using the ShortLex ordering  -- 
a procedure which would not have terminated.

To get the semigroup generators of the free semigroup of which 
the Heisenberg group is a quotient:
\begin{verbatim}
gap> fgens := FreeGeneratorsOfFpSemigroup(s);
[ <identity ...>, gamma^-1, gamma, beta^-1, beta, alpha^-1, alpha ]
\end{verbatim}
Now we can see the normal form produced by the rewriting system, for example:
\begin{verbatim}
gap> ReducedForm(rws, fgens[2]*fgens[7]);
alpha*gamma^-1
gap> ReducedForm(rws, fgens[7]*fgens[2]);
alpha*gamma^-1
\end{verbatim}

The rewriting system in {\gap} is a  general framework for the developer 
working with finitely presented structures.
It flexibly supports any  notion of 
{\em rule} and methods for
adding rules, reducing words and testing for confluence. 

\subsection{The Heisenberg group is infinite}
One can easily demonstrate this well known fact by considering the 
largest commutative quotient of the Heisenberg group. If this quotient
is infinite, then the Heisenberg group is certainly infinite. 
Since finiteness of a commutative semigroup is decidable (see, for example
Gilman's paper \cite{rhg79}) we are able to test the claim in {\gap}.
In the transcript below, {\tt aq} is the largest commutative 
quotient of the Heisenberg group {\tt s}:
\begin{verbatim}
gap> aq := Abelianization(s);
<fp semigroup on the generators [ <identity ...>, gamma^-1, gamma, beta^-1, 
  beta, alpha^-1, alpha ]>
gap> IsFinite(aq);
false
\end{verbatim}


\section*{Acknowledgements and Further Information}
The material presented here represents the combined efforts of
a number of mathematicians over the course of more than a decade. These
people are collectively known as The {\gap} Group. 
The particular functionality  in support of semigroups is principally due to 
Robert Arthur, G\"{o}tz Pfeiffer and the authors.

To learn more about {\gap}, or to obtain {\gap} for your
own use,  you can:
\begin{itemize}
\item visit the website {\tt http://www-gap.dcs.st-and.ac.uk/\~{}gap/}
\item email  {\tt gap@dcs.st-and.ac.uk}
\item or write to The {\gap} Group, Mathematical Institute, 
St. Andrews, Scotland.
\end{itemize}

The specialized software for transformation semigroups (Sections 1, 2.1
and 4.1) and commutative semigroups (Section 5.2) demonstrated 
above are work in progress.
Preliminary versions may be obtained as a separate download
from the {\gap} website and installed using the {\gap} share-package
mechanism.


\bibliographystyle{plain}
\bibliography{/home/andrews/tex/biblio}




\end{document}


