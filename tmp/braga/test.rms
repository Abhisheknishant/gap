one := Transformation([1,2]);
zero := Transformation([1,1]);
sl := Semigroup(one,zero);
rms := ReesMatrixSemigroup(sl, [[one, zero],[zero, one]]);
a := ReesMatrixSemigroupElement(rms,one, 1,1);
z := ReesMatrixSemigroupElement(rms, zero, 1, 1);
a *z;
dcl := GreensDClasses(rms);
Elements(dcl[1]);
Size(rms);
Elements(rms);

li := LeftMagmaIdealByGenerators(rms, [z]);

IsRegularSemigroup(rms); 


####################


left := Transformation([1,1]);
right := Transformation([2,2]);
rz := Monoid(left, right);
rms := ReesMatrixSemigroup(rz, [[left, right], [right, left]]);
dcl := GreensDClasses(rms);

##############################
gap> s := Transformation([1,1,3]);
Transformation( [ 1, 1, 3 ] )
gap> c := Transformation([2,3,1]);
Transformation( [ 2, 3, 1 ] )
gap> 
gap> op3 := Semigroup(s,c);
<semigroup with 2 generators>
gap> 
gap> dcl := GreensDClasses(op3);
[ {Transformation( [ 1, 1, 3 ] )}, {Transformation( [ 2, 3, 1 ] )}, 
  {Transformation( [ 1, 1, 1 ] )} ]
gap> rms := ReesMatrixSemigroup(op3, [[s,c],[c,s]]);
Rees Matrix Semigroup over Semigroup( [ Transformation( [ 1, 1, 3 ] ), 
  Transformation( [ 2, 3, 1 ] ) ] )
gap> Size(rms);
96
gap> i := IsomorphismTransformationSemigroup(rms);
MappingByFunction( Rees Matrix Semigroup over Semigroup( 
[ Transformation( [ 1, 1, 3 ] ), Transformation( [ 2, 3, 1 ] ) 
 ] ), <semigroup with 96 generators>, function( a ) ... end )
gap> trms := Range(i);
<semigroup with 96 generators>
gap> DisplayTransformationSemigroup(trms);
Rank 48: *[H size = 3, 2 L classes, 2 R classes]
Rank 16: *[H size = 2, 6 L classes, 6 R classes]
Rank 2: *[H size = 1, 6 L classes, 2 R classes]
gap> 
gap>     
gap> dcl := GreensDClasses(rms);
[ {(Transformation( [ 1, 1, 3 ] );1,1)}, {(Transformation( [ 2, 3, 1 ] );1,1)}
    , {(Transformation( [ 1, 1, 1 ] );1,1)} ]
gap> time;
248220
gap> Size(GreensHClass
    GreensHClassEnumeratorGetElement
    GreensHClassOfElement
    GreensHClasses
gap> Size(GreensHClassOfElement(Reprentativ
    identifier has no completions
gap> Size(GreensHClassOfElement(Representative(dcl[1]));
Function: number of arguments must be 2 (not 1)
not in any function
Entering break read-eval-print loop, you can 'quit;' to quit to outer loop,
or you can return a list of arguments to continue
brk> quit;
Syntax error: ) expected
Size(GreensHClassOfElement(Representative(dcl[1]));
                                                  ^
gap> Size(GreensHClassOfElement(rms,Representative(dcl[1]));
Syntax error: ) expected
Size(GreensHClassOfElement(rms,Representative(dcl[1]));
                                                      ^
gap> Size(GreensHClassOfElement(rms,Representative(dcl[1])));
2
gap> IsReesCongruenceSemigroup(rms);
false
gap> Size(GreensHClassOfElement(rms,Representative(dcl[3])));
1
gap> pi := SemigroupIdealByGenerators(rms, [Representative(dcl[1])]);
<SemigroupIdeal with 1 generators>
gap> pi1 := SemigroupIdealByGenerators(pi, [Representative(dcl[3])]); 
<SemigroupIdeal with 1 generators>
gap> q := pi/pi1;
Error, no method found! For debugging hints type ?Recovery from NoMethodFound
Error no 1st choice method found for `QUO' on 2 arguments at
Error( no_method_found );
<function>( <arguments> ) called from read-eval-loop
Entering break read-eval-print loop, you can 'quit;' to quit to outer loop,
or you can return to continue
brk> quit;
gap> c1 := ReesCongruenceOfSemigroupIdeal(pi1);
q := pi/c1;
<semigroup congruence>
gap> q := pi/c1;
<quotient of SemigroupIdeal( [ (Transformation( [ 1, 1, 3 ] );1,1) 
 ] ) by SemigroupCongruence( ... )>
gap> IsZeroSimpleSemigroup(q);
true
gap> Elements(q)
> ;
[ {(Transformation( [ 1, 1, 1 ] );1,1)}, {(Transformation( [ 1, 1, 2 ] );1,1)}
    , {(Transformation( [ 1, 1, 2 ] );1,2)}, {(Transformation( [ 1, 1, 2 ] );
    2,1)}, {(Transformation( [ 1, 1, 2 ] );2,2)}, 
  {(Transformation( [ 1, 1, 3 ] );1,1)}, {(Transformation( [ 1, 1, 3 ] );1,2)}
    , {(Transformation( [ 1, 1, 3 ] );2,1)}, {(Transformation( [ 1, 1, 3 ] );
    2,2)}, {(Transformation( [ 1, 2, 1 ] );1,1)}, 
  {(Transformation( [ 1, 2, 1 ] );1,2)}, {(Transformation( [ 1, 2, 1 ] );2,1)}
    , {(Transformation( [ 1, 2, 1 ] );2,2)}, {(Transformation( [ 1, 2, 2 ] );
    1,1)}, {(Transformation( [ 1, 2, 2 ] );1,2)}, 
  {(Transformation( [ 1, 2, 2 ] );2,1)}, {(Transformation( [ 1, 2, 2 ] );2,2)}
    , {(Transformation( [ 1, 3, 1 ] );1,1)}, {(Transformation( [ 1, 3, 1 ] );
    1,2)}, {(Transformation( [ 1, 3, 1 ] );2,1)}, 
  {(Transformation( [ 1, 3, 1 ] );2,2)}, {(Transformation( [ 1, 3, 3 ] );1,1)}
    , {(Transformation( [ 1, 3, 3 ] );1,2)}, {(Transformation( [ 1, 3, 3 ] );
    2,1)}, {(Transformation( [ 1, 3, 3 ] );2,2)}, 
  {(Transformation( [ 2, 1, 1 ] );1,1)}, {(Transformation( [ 2, 1, 1 ] );1,2)}
    , {(Transformation( [ 2, 1, 1 ] );2,1)}, {(Transformation( [ 2, 1, 1 ] );
    2,2)}, {(Transformation( [ 2, 1, 2 ] );1,1)}, 
  {(Transformation( [ 2, 1, 2 ] );1,2)}, {(Transformation( [ 2, 1, 2 ] );2,1)}
    , {(Transformation( [ 2, 1, 2 ] );2,2)}, {(Transformation( [ 2, 2, 1 ] );
    1,1)}, {(Transformation( [ 2, 2, 1 ] );1,2)}, 
  {(Transformation( [ 2, 2, 1 ] );2,1)}, {(Transformation( [ 2, 2, 1 ] );2,2)}
    , {(Transformation( [ 2, 2, 3 ] );1,1)}, {(Transformation( [ 2, 2, 3 ] );
    1,2)}, {(Transformation( [ 2, 2, 3 ] );2,1)}, 
  {(Transformation( [ 2, 2, 3 ] );2,2)}, {(Transformation( [ 2, 3, 2 ] );1,1)}
    , {(Transformation( [ 2, 3, 2 ] );1,2)}, {(Transformation( [ 2, 3, 2 ] );
    2,1)}, {(Transformation( [ 2, 3, 2 ] );2,2)}, 
  {(Transformation( [ 2, 3, 3 ] );1,1)}, {(Transformation( [ 2, 3, 3 ] );1,2)}
    , {(Transformation( [ 2, 3, 3 ] );2,1)}, {(Transformation( [ 2, 3, 3 ] );
    2,2)}, {(Transformation( [ 3, 1, 1 ] );1,1)}, 
  {(Transformation( [ 3, 1, 1 ] );1,2)}, {(Transformation( [ 3, 1, 1 ] );2,1)}
    , {(Transformation( [ 3, 1, 1 ] );2,2)}, {(Transformation( [ 3, 1, 3 ] );
    1,1)}, {(Transformation( [ 3, 1, 3 ] );1,2)}, 
  {(Transformation( [ 3, 1, 3 ] );2,1)}, {(Transformation( [ 3, 1, 3 ] );2,2)}
    , {(Transformation( [ 3, 2, 2 ] );1,1)}, {(Transformation( [ 3, 2, 2 ] );
    1,2)}, {(Transformation( [ 3, 2, 2 ] );2,1)}, 
  {(Transformation( [ 3, 2, 2 ] );2,2)}, {(Transformation( [ 3, 2, 3 ] );1,1)}
    , {(Transformation( [ 3, 2, 3 ] );1,2)}, {(Transformation( [ 3, 2, 3 ] );
    2,1)}, {(Transformation( [ 3, 2, 3 ] );2,2)}, 
  {(Transformation( [ 3, 3, 1 ] );1,1)}, {(Transformation( [ 3, 3, 1 ] );1,2)}
    , {(Transformation( [ 3, 3, 1 ] );2,1)}, {(Transformation( [ 3, 3, 1 ] );
    2,2)}, {(Transformation( [ 3, 3, 2 ] );1,1)}, 
  {(Transformation( [ 3, 3, 2 ] );1,2)}, {(Transformation( [ 3, 3, 2 ] );2,1)}
    , {(Transformation( [ 3, 3, 2 ] );2,2)} ]
gap> Size(last);
73
gap> j := IsomorphismReesMatrixSemigroup(q);
MappingByFunction( Rees Matrix Semigroup over Monoid( 
[ (), (1,2), 0 ], ... ), <quotient of SemigroupIdeal( 
[ (Transformation( [ 1, 1, 3 ] );1,1) 
 ] ) by SemigroupCongruence( ... )>, function( x ) ... end )
gap> SandwichMatrixOfReesMatrixSemigroup(Range(j));
Error, no method found! For debugging hints type ?Recovery from NoMethodFound
Error no 1st choice method found for `SandwichMatrixOfReesMatrixSemigroup' on \
1 arguments at
Error( no_method_found );
<function>( <arguments> ) called from read-eval-loop
Entering break read-eval-print loop, you can 'quit;' to quit to outer loop,
or you can return to continue
brk> quit;
gap> SandwichMatrixOfReesMatrixSemigroup(Source(j));
[ [ (), 0, (1,2), 0, 0, 0 ], [ 0, (), 0, (1,2), 0, 0 ], 
  [ (), 0, 0, (1,2), (), (1,2) ], [ 0, (), (1,2), 0, (1,2), () ], 
  [ (), (1,2), 0, 0, (), (1,2) ], [ (1,2), (), 0, 0, (1,2), () ] ]
gap> qdcl := GreensDClasses(Source(j));
time;
[ {0}, {(();1,1)} ]
gap> time;
39490
gap> Size(qdcl[1]);
1
gap> Size(qdcl[2]);
72
gap> Size(qdcl);
2
gap> Size(q);   
73
gap> Size(Source(j));
73
gap> 


