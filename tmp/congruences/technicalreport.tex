%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%   Title:  Computing Congruences of Magmas and Semigroups 
%%   
%%   Authors: Robert Fitzgerald Morse
%%            Andrew Solomon
%%
%%   Submitted to ISSAC 2000 Proceedings, January 16, 2000 
%%
%% $Id: technicalreport.tex,v 1.25 2000/01/18 01:46:20 gap Exp $
\documentclass{acmconf}
\usepackage{amsmath,amssymb,mathrsfs,algorithmic,algorithm}

\author{ 
\thanks{The research of 
the first author is supported by ARSAF Grant A6D-1001.}
Robert Fitzgerald Morse 
and  Andrew Solomon}
\title{Computing Congruences of Magmas and Semigroups}
\affiliation{Department of Electrical Engineering and Computer Science\\
         University of Evansville\\
         Evansville, Indiana, 47722 USA\\ \vspace{0.5cm}
         Department of Computer Science\\ \vspace{0.15cm}
         University of St. Andrews,
         Fife KY16 9SS, United Kingdom}

%\date{\today}

\def\gap{\sf GAP}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{corollary}{Corollary}
\newtheorem{notation}{Notation}

\begin{document}

\maketitle
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\section{Introduction} \label{S:intro}
This paper presents a collection of methods for efficiently computing with 
congruences on magmas and semigroups. To the authors' knowledge
this records the first attempt to formulate such algorithms, either on paper
or as computer programs, and as indicated at several points throughout
the text, there is great potential to develop faster and more sophisticated 
algorithms and systems building on these initial investigations.
This work forms part of a larger effort \cite{pAS99}
to develop serious tools for computating with semigroups and magmas
within {\gap} \cite{gap}.

Algorithms are presented  for computing with congruences
on magmas and semigroups. The first procedure computes the equivalence 
classes of a congruence on a magma given a set of generating pairs.
The algorithm is optimized so that it is also 
an efficient method for computing congruences  on semigroups and
is based on an algorithm for finding the blocks of 
a transitive permutation group due to Atkinson, et.~al.~\cite{pA84}. 

In support of the algorithm above we present a procedure for
finding the equivalence classes of the smallest equivalence relation 
containing a
set of generating pairs. This algorithm is  also used to find the join
of two congruences. Experimental results show this method to be more
efficient than computing the join using the first algorithm.  

Building on the above algorithms  we give a better than naive method
for computing all minimal congruences on a semigroup when the 
Green's structure of the semigroup is known. This method
is an application of a theorem of Rhodes \cite{pR67} characterizing
all minimal congruences on a semigroup.

Finally, assuming the ability to compute minimal congruences,
we give an algorithm for computing all congruences on a magma
via a breadth first search through the lattice of all congruences,
finding successive covers as minimal congruences on quotients by
lower congruences.


\section{Theoretical background} \label{S:theory}
A magma is a set equipped with a single binary operation. 
Our development follows that of Howie \cite{bH76} for semigroups. However,
we note that this development does not assume associativity 
of the binary operation.
Let $(M,\cdot)$ be a 
magma. A relation $\mathbf R$ on the set $M$ is called 
\emph{left compatible} (with the operation on $M$) if
for all $a\in M$ and for all $(s,t)\in \mathbf R$ we have  
$(as,at)$ an element of $\mathbf R$. Similarly,
$\mathbf R$ is \emph{right compatible} if for all $a\in M$ and
for all $(s,t)\in\mathbf R$ we have $(sa,ta)\in\mathbf R$.
The relation $\mathbf R$ is \emph{compatible}
if for all $(s,t),(u,v)\in \mathbf R$ it follows
$(su,tv)$ is an element of $\mathbf R$. 

A left (right) compatible equivalence relation is called a 
\emph{left (right) congruence} and a compatible equivalence relation
is called a \emph{congruence}. 
Left and right congruences are related to
congruences in the following manner:

\begin{proposition} \label{P:a}
A relation on a magma is a congruence if and only if
it is both a left and right congruence.
\end{proposition}

Let $T\subseteq M^2$. The (left, right) 
congruence generated by
$T$ is the smallest (left, right) compatible equivalence relation 
containing $T$. 

Suppose $M$ is generated by a subset $G$ of $M$. An
equivalence relation
$\mathbf E$ on $M$ is \emph{weak left compatible} when for all
$s,t\in M$ and $g\in G$ if $(s,t)\in \mathbf E$ then 
$(gs,gt)\in \mathbf E$. The equivalence relation $\mathbf E$
is called \emph{weak right compatible}
when for all $s,t\in M$ and $g\in G$ if $(s,t)\in \mathbf E$ then
$(sg,tg)\in \mathbf E$.
The following proposition shows that for semigroups if an 
equivalence relation is weak left (right) 
compatible it is a left (right) congruence. 

\begin{proposition} \label{P:b}
Let $S$ be a semigroup generated by the set $G$ and 
$\mathbf E$ an equivalence relation on $S$.
If $\mathbf E$ is weak left (right) compatible then 
$\mathbf E$ is a left (right) congruence.
\end{proposition}

\emph{Proof} Let $a\in S$ and $a=g_1g_2\cdots g_n$ where $g_i$ are elements
of the generating set $G$. We induct on the length $n$ of $a$ as a word in the
generators. 
Let $(s,t)\in \mathbf E$. If $a=g_1$ then by weak left compatibility 
we have $(as,at)\in\mathbf E$. Suppose if $a=g_1g_2\cdots g_n$ then
$(as,at)\in\mathbf E$. Let $a=gg_1g_2\cdots g_n$. Then 
$$
(as,at)=(gg_1g_2\cdots g_ns,gg_1g_2\cdots g_nt)=(gs',gt')
$$ 
where $s'=g_1g_2\cdots g_ns$ and $t'=g_1g_2\cdots g_nt$. By the induction
hypothesis $(s',t')\in \mathbf E$. By weak compatibility
$(gs',gt')\in\mathbf E$.
Since $S$ is associative we have $(gs',gt')=(as,at)$. Hence $\mathbf E$ is
a left congruence. The argument is similar for weak right compatibility.
$\square$

The following example shows that the associativity condition in 
Proposition~\ref{P:b} is required.
Consider the following multiplication table for a magma with 5 elements:

\begin{table}[h]
\begin{center}
\begin{tabular}{ l | l   l   l   l   l  }
    & $a$ & $b$ & $c$ & $d$ & $e$ \\ \hline
$a$ & $b$ & $c$ & $d$ & $e$ & $b$ \\ 
$b$ & $c$ & $d$ & $e$ & $b$ & $c$\\ 
$c$ & $d$ & $a$ & $b$ & $c$ & $d$\\
$d$ & $e$ & $b$ & $c$ & $d$ & $e$\\ 
$e$ & $b$ & $c$ & $d$ & $e$ & $b$\\ 
\end{tabular}
\end{center}
\end{table}

The magma is not associative as $b(eb)=e$ 
but $(be)b=a$. The magma is generated by
$a$ as $a^2=b$, $a^3=c$ $a^4=d$ and $a^5=e$ where the
products of the powers are left parenthesized.
The partition $\{\{c,e\},\{b,d\}\}$ induces an equivalence 
relation $\mathbf E$ which is weak left and right compatible.
But $\mathbf E$ is neither left nor right compatible as
$(c b, c d)=(a,c)\not\in \mathbf E$ and
$(c b,e b)=(a,c)\not\in\mathbf E$. 

The converse of Proposition~\ref{P:b} is not true in
the sense that there are  magmas in which
the weak left (right) compatible equivalence 
relations are exactly the left (right) 
congruences of the magma but the magma is not associative.

Two consequences of the discussion above are that: in general, 
congruences can only be computed for {\em finite} non-associative magmas; 
and that some congruences can be computed for finitely generated infinite
semigroups.

\section{Computing congruences given by generating pairs} \label{s:cong}
In this section we develop an algorithm for computing the
congruence on a magma $M$ generated by a given set $T\subseteq M^2$
of generating pairs.    

It is computationally more efficient to work with the
partition associated with the equivalence relation than
the set of tuples of the relation. 
Moreover, we represent the partition 
as a set of non-singleton blocks;
if an element is not in any of the blocks then it is 
assumed that it is related only to itself. This
representation  permits us to work with equivalence relations
on infinite sets in which only a finite number of elements
are related to elements other than themselves.
For example, the diagonal relation of any set is represented
by the empty set of blocks.

The following lemma gives a construction for the  
partition associated with smallest 
equivalence relation containing a given set of generating pairs.

\begin{lemma} \label{L:a} 
Let A be a set, $\mathbf E\subseteq A^2$ an equivalence relation on $A$,
and $\mathcal P$ the partition of non-singleton blocks associated with 
$\mathbf E$.
If $(a,b)\in A^2$, then
the following construction gives the partition
$\mathcal P'$ of non-singleton blocks
associated with the  
smallest equivalence containing $\mathbf E\cup \{(a,b)\}$:
\begin{enumerate}
\item If there exists $B$ in $\mathcal P$  
      such that $\{a,b\}\subseteq B$, then $\mathcal P'=\mathcal P$.
\item If there exists $B$ in $\mathcal P$ such that
   $a\in B$ and for all $B'$ in $\mathcal P$, $b$ is not in  $B'$ then 
   $\mathcal P'=\mathcal P-\{B\}\cup \{B\cup\{ b\}\}$.
\item If there exists $B$ in $\mathcal P$ such that
   $b\in B$ and for all $B'$ in $\mathcal P$, $a$ is not in  $B'$ then 
   $\mathcal P'=\mathcal P-\{B\}\cup \{B\cup\{ a\}\}$.
\item If there exists $B,B'$ in $\mathcal P$ such that $B\neq B'$ and
   $a\in B$ and $b\in B'$, then $\mathcal P'=\mathcal P-\{B,B'\}\cup \{B\cup B'\}$.
\item If for all $B$ in $\mathcal P$ $a\not\in B$ and $b\not\in B$ then
   $\mathcal P'=\mathcal P\cup \{\{a,b\}\}$ 
\end{enumerate}
\end{lemma}

A \emph{disjoint-set data structure} maintains a collection of
disjoint dynamic sets.  Each set in the collection 
is identified by a fixed representative, which is a member of that set.  
Let $S=\{S_1,\dots,S_k\}$ be a collection of disjoint sets. We
denote with $S_x$ the unique set containing $x$ and with $r_x$ the
representative of $S_x$. 
The disjoint-set data structure provides three operations:
\textsc{Make-Set}, which adds a set to the collection insuring
the collection is still disjoint;  \textsc{Union},
which unites two sets in the collection;  
and \textsc{Find-Set}, which finds the representative of the set containing
a given element if it exists.

Run time analysis of disjoint-set data structures
is based on $n$,
the number of \textsc{Make-Set} operations and $m$, the total
number of \textsc{Make-Set}, \textsc{Union}, and \textsc{Find-Set} operations
executed. Implementations using rooted trees and employing 
certain heuristics have for all practical purposes
linear running times in terms of $m$
\cite{pT75} (see also \cite{bCLR90}).

In our application, the 
collection of disjoint sets will 
represent a partition with 
each non-singleton block a set in this collection.
The three disjoint-set operations specified above can be used
to implement the set constructions of Lemma~\ref{L:a}.
However, in our algorithms presented below, we will continue to
use the set notation in Lemma~\ref{L:a} instead of the 
disjoint-set operations explicitly.
The following notation is maintained. 
We denote the block in partition
$\mathcal P$ containing the element $a$ by $B_a$ and its
representative by $r_a$. In this case we say $B_a$ is defined.  
If $a$ is not an element of any block in the partition
then $B_a$ is undefined and we set $r_a=a$.  

\subsection{Algorithm for computing magma congruences}
Given a subset $T\subseteq M^2$, Algorithm~\ref{A:congruence} 
constructs a series of partitions of $M$ ending in the 
partition whose blocks are the non-singleton congruence classes
of the congruence generated by $T$. As noted above, we are
assuming the partitions constructed are represented as disjoint-set data
structure and every block is non-singleton and 
has a fixed representative.

\begin{algorithm}[h]
\caption{Compute the magma congruence given a set of generating pairs}
\label{A:congruence}
\begin{algorithmic}[1]
\REQUIRE 
Magma $M$ with generating set $G$ and a set $\emptyset\neq T\subseteq M^2$. 
\ENSURE $\mathcal F$ -- the partition of non-singleton blocks 
associated with the congruence on $M$ generated by $T$.
\IF{$M$ is non-associative}
        \STATE $G \leftarrow M$
\ENDIF
\STATE $\mathcal F \leftarrow$ The partition of non-singleton blocks 
associated with the 
smallest equivalence relation generated by $T$. Each block of this
partition has a fixed representative element. 
(See Algorithm~\ref{A:partition}.)
\REPEAT 
    \STATE  $(a,b)\leftarrow$ any tuple from $T$
    \STATE  $T\leftarrow T-\{(a,b)\}$
    \FORALL {$g\in G$}
        \IF{$r_{ga}\neq r_{gb}$}
            \IF {$B_{ga}$ and $B_{gb}$ are undefined}
                \STATE $\mathcal F\leftarrow\mathcal F\cup \{\{r_{ga},r_{gb}\}\}$
            \ELSIF {$B_{ga}$ and $B_{gb}$ are defined}
                \STATE $\mathcal F\leftarrow\mathcal 
                           F-\{B_{ga},B_{gb}\}\cup\{B_{ga}\cup B_{gb}\}$
            \ELSIF {$B_{ga}$ is undefined and $B_{gb}$ is defined}
                \STATE $\mathcal F\leftarrow\mathcal 
                           F-\{B_{gb}\}\cup\{B_{gb}\cup\{r_{ga}\}\}$
            \ELSIF {$B_{gb}$ is undefined and $B_{ga}$ is defined}
                \STATE $\mathcal F\leftarrow\mathcal 
                           F-\{B_{ga}\}\cup\{B_{ga}\cup\{r_{gb}\}\}$
            \ENDIF
            \STATE $T\leftarrow T\cup\{(r_{ga},r_{gb})\}$
        \ENDIF
        \IF{$r_{ag}\neq r_{bg}$}
            \IF {$B_{ag}$ and $B_{bg}$ are undefined}
                \STATE $\mathcal F\leftarrow\mathcal F\cup \{\{r_{ag},r_{bg}\}\}$
            \ELSIF {$B_{ag}$ and $B_{bg}$ are defined}
                \STATE $\mathcal F\leftarrow\mathcal 
                           F-\{B_{ag},B_{bg}\}\cup\{B_{ag}\cup B_{bg}\}$
            \ELSIF {$B_{ag}$ is undefined and $B_{bg}$ is defined}
                \STATE $\mathcal F\leftarrow\mathcal 
                           F-\{B_{bg}\}\cup\{B_{bg}\cup\{r_{ag}\}\}$
            \ELSIF {$B_{bg}$ is undefined and $B_{ag}$ is defined}
                \STATE $\mathcal F\leftarrow\mathcal 
                           F-\{B_{ag}\}\cup\{B_{ag}\cup\{r_{bg}\}\}$
            \ENDIF
            \STATE $T\leftarrow T\cup\{(r_{ag},r_{bg})\}$

        \ENDIF
    \ENDFOR
\UNTIL {$T=\emptyset$}
\end{algorithmic}
\end{algorithm}

Counting the number of disjoint-set operations required 
to complete Algorithm~\ref{A:congruence}
provides a measure of its run time efficiency. 
We also compare these counts for two methods of  
computing the join of two congruences below.

The following theorem is a proof of correctness for 
Algorithm~\ref{A:congruence} for finite magmas.

\begin{theorem} \label {T:a}
Let $M$ be a finite magma. Given a set of generating pairs $T\subseteq M^2$,
Algorithm~\ref{A:congruence} computes
the partition of M associated with the congruence generated by T.
\end{theorem}

\emph{Proof}
Let $\mathcal C$ be the congruence generated by $T$ and let
$\mathcal P$ be the partition of $M$ associated with $\mathcal C$.
The algorithm generates a series of partitions
$\mathcal F_0,\dots,\mathcal F_i$ each contained in $\mathcal P$
which we will show terminates with $\mathcal P$. 

The partition $\mathcal F=\mathcal F_0$ is initialized in
step 4 to the partition
associated with the smallest equivalence relation generated by $T$. 
Hence, $\mathcal F$ is initially contained in $\mathcal P$ as needed.
For $i>0$, steps 9-20 construct 
the partition $\mathcal F_i$ 
from $\mathcal F_{i-1}$ by adding 
a new previously unrelated pair of the form
$(ga,gb)$ where $g\in G$ and $a,b$ are in the same equivalence class
in $\mathcal F_{i-1}$. Similarly, steps 21-32 form the next partition
by adding the new pair $(ag,bg)$. Steps 9-20 and 21-32 follow the 
construction in Lemma~\ref{L:a} hence each partition induces the 
smallest equivalence relation containing the pairs so far considered.
Moreover, each new pair added is required for (weak) left or right 
compatibility. Hence, each partition in this series is contained in 
$\mathcal P$.

We complete the proof by showing that $\mathcal F = \mathcal P$ 
on completion of the algorithm. As the magma is finite and only
unrelated pairs in $\mathcal F$ are added to $T$ (steps 19 and 31), 
step 7 will eventually exhaust the
elements in $T$. Hence the algorithm will terminate.

Let $\mathbf F$ be the equivalence
relation induced by the partition $\mathcal F$ at completion of 
the algorithm. As shown above, $\mathbf F\subseteq\mathcal C$.
It remains to be shown that $\mathbf F$ is (weak) left and right
compatible. Then by Proposition~\ref{P:a} or Proposition~\ref{P:b}
we have $\mathbf F$ a congruence.

Let $(s,t)\in \mathbf F$. If $(s,t)\in T$, then at
some point in the execution steps 8-33
insure that for all $g\in G$,
$(gs,gt)$ and $(sg,tg)$ are in $\mathbf F$ also. 
Otherwise, for $(s,t)$ to be an element of $\mathbf F$
there must have been a sequence of pairs   
$(s,r_1),(r_1,r_2),\dots,(r_{j-1},r_j),(r_j,t)$
considered in its construction. Again steps 8-33
insure that for all $g\in G$, 
$(gs,gr_1),(gr_1,gr_2),\dots,(gr_{j-1},gr_j),(gr_j,gt)$ and 
$(sg,r_1g),(r_1g,r_2g),\dots,(r_{j-1}g,r_jg),(r_jg,tg)$ are elements
of $\mathbf F$. By transitivity of $\mathbf F$ we have
$(gs,gt)$ and $(sg,tg)$ in $\mathbf F$. Hence $\mathbf F$ is
(weak) left and right compatible as needed.
$\square$ 

We note that Algorithm~\ref{A:congruence} 
can be used to compute congruences on infinite finitely
generated semigroups. However, the algorithm may not terminate:
it could be that the congruence has a congruence class
of infinite size or contains 
an infinite number of classes. 
Our {\gap} implementation allows for partial closure in that 
some termination criteria can be given to exit the computation. For example,
the question of whether two elements in an infinite semigroup
are in the same congruence class 
can be answered affirmatively without needing to 
compute the complete series of partitions.
The algorithm terminates once the partition is formed that 
related the two elements.
A negative answer unfortunately requires that the series be 
completely computed. 

\section{Computing the join of two congruences} \label{S:join}
The join of two congruences is the smallest equivalence relation
containing the two congruences. Suppose we have a set of
generating pairs for these two congruences as equivalence relations.
Then computing the equivalence relation generated by the union of these
generating sets finds the join of these two congruences.
The following algorithm computes the non-singleton equivalence classes
of the  
equivalence relation generated by a set of generating pairs. The underlying
set is implied -- we need only consider the elements which appear as 
components of the generating pairs. This allows us to work with 
infinite sets.
Algorithm~\ref{A:partition} uses Lemma~\ref{L:a} directly to construct 
the partition. As in Algorithm~\ref{A:congruence} we assume that the
partition is represented using a disjoint-set data structure.

\begin{algorithm}
\caption{Computes the partition associated with 
the equivalence relation generated by a 
set of pairs}
\label{A:partition}
\begin{algorithmic}[1]
\REQUIRE $T$ -- an finite subset of a set $A^2$
\ENSURE $\mathcal P$ -- the partition of non-singleton
blocks associated with the 
equivalence relation on $A$ generated by $T$
\STATE $\mathcal P\leftarrow\emptyset$
\FORALL{$(a,b)$ in $T$ }
    \IF {$B_a$ is undefined and $B_b$ is undefined}
         \STATE $\mathcal P\leftarrow\mathcal P\cup \{\{a,b\}\}$
    \ELSIF {$B_a$ and $B_b$ are defined}
         \STATE $\mathcal P\leftarrow\mathcal 
                       P-\{B_{a},B_{b}\}\cup\{B_{a}\cup B_{b}\}$
    \ELSIF {$B_a$ is undefined and $B_b$ is defined}
         \STATE $\mathcal P\leftarrow\mathcal 
                           P-\{B_{b}\}\cup\{B_{b}\cup\{a\}\}$
    \ELSIF {$B_b$ is undefined and $B_a$ is defined}
         \STATE $\mathcal P\leftarrow\mathcal 
                           P-\{B_{a}\}\cup\{B_{a}\cup\{b\}\}$
    \ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}
 
Let $M$ be a magma and let $\mathcal C$ and 
$\mathcal D$ be congruences
on $M$. Consider two sets of generating pairs 
$C_{\mathcal C}$ and $E_{\mathcal C}$ where 
$\mathcal C$ is the congruence generated by $C_{\mathcal C}$ and
$\mathcal C$ is the equivalence relation generated by $E_{\mathcal C}$.

The join of two congruences $\mathcal C$ and $\mathcal D$
can be computed using either Algorithm~\ref{A:congruence} or
Algorithm~\ref{A:partition}. To find the join using 
Algorithm~\ref{A:congruence}, we find the congruence generated
by $C_{\mathcal C}\cup C_{\mathcal D}$. Algorithm~\ref{A:partition}
can be used to find the join by computing the equivalence relation
generated by $E_{\mathcal C}\cup E_{\mathcal D}$. 


%The join of two congruences $\mathcal C$ and $\mathcal D$
%can be computed using Algorithm~\ref{A:congruence}
%by finding the congruence generated by 
%$C_{\mathcal C}\cup C_{\mathcal D}$ or finding the equivalence relation
%generated by $E_{\mathcal C}\cup E_{\mathcal D}$ using 
%Algorithm~\ref{A:partition}.

In many cases, $C_{\mathcal C}\cup C_{\mathcal D}$ will be significantly
smaller than $E_{\mathcal C}\cup E_{\mathcal D}$. 
In both Algorithm~\ref{A:congruence}  and Algorithm~\ref{A:partition}, 
the time complexity seems to be dependent on the number of 
generating pairs. However, our 
experimental results in Section~\ref{s:experiment}
show that computing $E_{\mathcal C}\cup E_{\mathcal D}$
for the congruences $\mathcal C$ and $\mathcal D$ 
and using Algorithm~\ref{A:partition}
requires significantly 
fewer disjoint-set operations than computing the congruence
generated by $C_{\mathcal C}\cup C_{\mathcal D}$ using 
Algorithm~\ref{A:congruence}.

\section{Computing the minimal congruences of a finite 
semigroup} \label{S:semicong}
Green's relations provide the most basic structural information about a 
semigroup, and a significant body of work has been devoted to computing them
efficiently. In particular, Linton et.~al.~\cite{linton} and 
Lallement and McFadden \cite{lallement} have given methods for computing
Green's relations on transformation semigroups, while 
Cannon \cite{cannon} and Pin and Froidure \cite{pin} have 
given methods for determining Green's relations for a 
generic finite semigroup using its Cayley graph.

In this section we give an algorithm to determine  the minimal congruences 
on a finite semigroup assuming knowledge of Green's relations. Our
design principle was to attempt to minimize the number of 
calls to Algorithm \ref{A:congruence}.

We briefly recall the definitions of Green's relations which may be 
found in any text on semigroup theory, for example Howie \cite{bH76} or
Grillet \cite{bG95}.

First we define Green's preorders as follows:
$a \leq_\mathscr{L} b$ ($a \leq_\mathscr{R} b$, $a \leq_\mathscr{J} b$) 
if the principal left (right, two-sided) ideal generated by $a$ is contained
in the principal left (right, two-sided) ideal generated by $b$.  
Put $a \leq_\mathscr{H} b$ if $a \leq_\mathscr{L} b$ and 
$a \leq_\mathscr{R} b$. 
As with any preorder, there is an associated equivalence relation
defined by $a \mathscr{L} b$ if both $a \leq_\mathscr{L} b$
and $b \leq_\mathscr{L} a$ hold. The equivalences 
$\mathscr{R}$, $\mathscr{J}$ and $\mathscr{H}$ are defined analogously.
Finally, note that in any semigroup $S$, the preorder $\leq_\mathscr{L}$
induces a partial order on the quotient set $S/\mathscr{L}$. 
Partial orders  are defined analogously on $S/\mathscr{R}$, $S/\mathscr{J}$
and $S/\mathscr{H}$.

In order to compute all minimal congruences naively, 
one notes that each minimal congruence
is principal (though the converse isn't necessarily true) so we simply compute
all principal congruences and select the minimal congruences among these.
The most costly operation is congruence closure, 
so the cost of this  algorithm is $n(n-1)/2$ where $n$ is the size of 
the semigroup.
Here we present an algorithm 
whose theoretical foundations lie in 
a theorem of Rhodes \cite{pR67} as cited in Grillet's book
\cite[Theorem V.2.6]{bG95}:
\begin{proposition}\label{p:rhodes}
Let  $\mathscr{M}$ be a minimal congruence on a finite semigroup $S$ 
and $\mu : S \rightarrow S/\mathscr{M}$ the natural homomorphism
associated with it.  Then $\mathscr{M}$ belongs
to one of the following classes:\\

Class I: $\mathscr{M}$ is contained in $\mathscr{H}$. Then there is a 
$\mathscr{J}$-class $J$ unique such that $x \mathscr{M} y$, $x \neq y$
implies $x, y \in J$ and $x \mathscr{H} y$.

Class II: $\mathscr{M}$ is disjoint from $\mathscr{H}$ and contained in
$\mathscr{J}$. Then there is a $\mathscr{J}$-class $J$ unique such that
$x \mathscr{M} y$, $x \neq y$ implies $x, y \in J$ and 
$H_x \neq H_y$.

Class III: $\mathscr{M}$ is disjoint from $\mathscr{H}$
and there exist $\mathscr{J}$-classes $A < B$ such that 
$\mu(B) \subseteq \mu(A)$. Then $A$ and $B$ are unique, and if
$x \mathscr{M} y$, $x \neq y$ then $x$ and $y$ are both in 
$A \cup B$ but not both in $A$.


Class IV: $\mathscr{M}$ is disjoint from $\mathscr{H}$
and there exist $\mathscr{J}$-classes $A$, $B$ such that
$\mu(A) = \mu(B)$, $A \not\leq B$ and $B  \not\leq A$. 
Then $A$ and $B$ are unique and contain no idempotent; 
$A$ and $B$ cover precisely the same elements in $S/\mathscr{J}$;
if $x \mathscr{M} y$, $x \neq y$, then $x \in A$ and  $y \in B$, or vice
versa; there is a one-to-one correspondence between $A$ and $B$ such that
$a \mathscr{M} b$ if and only if $a$ corresponds to $b$.
\end{proposition}

Since each minimal congruence is principal, our strategy
is to find a generating pair for each congruence in each of the 
four classes of Proposition \ref{p:rhodes}.
Note that the proposition presents necessary, but not sufficient
conditions for a congruence to be minimal, therefore if we search 
for all pairs generating a congruence which
satisfies the criteria of one of the classes,
we will obtain generating pairs for
all the minimal congruences in that class, together
with pairs generating some non-minimal congruences as well. 


\begin{algorithm}
\caption{Computes (at least) the Class I and II congruences}
\label{A:class12}
\begin{algorithmic}[1]
\REQUIRE Finite semigroup $S$ for which Green's $\mathscr{J}$-relation 
is known.
\ENSURE $C12$ -- a set containing all Class I and II minimal congruences.
\STATE $C12 \leftarrow \emptyset$

\FORALL{$j \in \mbox{GreensJClasses}(S)$}
	\STATE $f_j \leftarrow $ boolean function on a partition
	 returning true iff each part is contained in $j$
		
	\FORALL{unordered pairs $\{a,b\}$ of elements of  $j$} 
		\STATE $c$ := PrincipalConguence($S, (a,b)$);
		\STATE compute the partition of $c$, terminating when the list of 
			nonsingleton blocks of $c$ is computed, or when the partial closure
			fails to satisfy $f_j$.
			
		\IF{$f_j(c)$}
			\STATE \COMMENT{All nontrivial blocks of $c$ are contained in $j$}
			\STATE $C12 \leftarrow
			\mbox{MinimalElements}(C12 \cup \{c\})$
		\ENDIF
	\ENDFOR
\ENDFOR
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{Computes (at least) the Class III congruences}
\label{A:class3}
\begin{algorithmic}[1]
\REQUIRE Finite semigroup $S$ for which Green's $\mathscr{J}$-relation 
is known.
\ENSURE $C3$ -- a set containing all Class III minimal congruences.
\STATE $C3 \leftarrow \emptyset$
\FORALL{$j \in \mbox{GreensJClasses}(S)$}
	\FORALL{$k \in  \mbox{Covers}_{\leq_\mathscr{J}}(j)$} 
		\FORALL{$a \in j$} 
			\FORALL{$b \in k$}
				\STATE $c$ := PrincipalConguence($S, (a,b)$);
				\IF{$|b \cap j| \leq 1$ for all classes $b$ of $c$}
					\STATE $C3 \leftarrow
					\mbox{MinimalElements}(C3 \cup \{c\})$
				\ENDIF
			\ENDFOR
		\ENDFOR
	\ENDFOR
\ENDFOR
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{Computes (at least) the Class IV congruences}
\label{A:class4}
\begin{algorithmic}[1]
\REQUIRE Finite semigroup $S$ for which Green's $\mathscr{J}$-relation 
is known.
\ENSURE $C4$ -- a set containing all Class IV minimal congruences.
\STATE $C4 \leftarrow \emptyset$
\STATE $I \leftarrow \{j \in $ GreensJClasses($S$)$ \mid 
j $ contains no idempotent~$\}$

\FORALL{unordered pairs $\{j,k\}$ of elements of  $I$ where 
$j$ and $k$ cover the same elements of $S/\mathscr{J}$} 
	\FORALL{$a \in j$} 
		\FORALL{$b \in k$}
			\STATE $c$ := PrincipalConguence($S, (a,b)$);
			\STATE  \COMMENT{now just check 
			that this defines a bijection between $j$ and $k$}
			\IF{$|b| = 2$ and $b \subseteq j \cup k$ and 
				$b \cap j \neq \emptyset$ and
				$b \cap k \neq \emptyset$ for all classes $b$ of $c$}
				\STATE $C4 \leftarrow
				\mbox{MinimalElements}(C4 \cup \{c\})$
			\ENDIF
		\ENDFOR
	\ENDFOR
\ENDFOR
\end{algorithmic}
\end{algorithm}


\begin{theorem}
The minimal congruences of a semigroup are precisely the
minimal elements of the set of congruences computed by 
Algorithms \ref{A:class12}, \ref{A:class3} and \ref{A:class4}.
\end{theorem}
\emph{Proof.}
It is a straightforward matter to verify that
Algorithms \ref{A:class12}, \ref{A:class3} and \ref{A:class4}
together find (at least) all the principal congruences belonging to 
Classes I--IV of  Proposition \ref{p:rhodes}, and therefore
(at least) all minimal congruences. 
In fact, Algorithm \ref{A:class12} computes more than the class
I and II congruences, since no check is made to ensure that the 
congruence is either contained in, or disjoint from $\mathscr{H}$,
on the grounds that this check is itself quite expensive and the most 
expensive operation (computing the congruence) has already been done.
Finally all minimal congruences
are found by taking the minimal elements in the set of 
all congruences computed by these three algorithms. 
$\square$

It is difficult to analyse the complexity of this 
algorithm without making assumptions about the
structure of the semigroup. Therefore we content ourselves with the
following simple observations about two easy to analyse cases. 
When $S$ is $\mathscr{J}$-trivial
and the poset $S/\mathscr{J}$ is a chain, only Algorithm \ref{A:class3} 
does any work, computing one congruence for every $\mathscr{J}$-class except
the top one --- this amounts to $n-1$ operations, where $n$ is the size
of the semigroup. 
When the semigroup is $\mathscr{J}$-universal, 
Algorithm \ref{A:class12} computes at most $n(n-1)/2$ congruences
(the same number as the naive method) and the other two algorithms 
compute none.
Experiment confirms that the asymptotic behaviour of this method is 
not worse than the naive method, and is often much better 
(see Section \ref{s:experiment}).


\section{Computing all congruences on a magma}
The naive method of finding all congruences is to start with
the set consisting of all principal congruences, and then 
form pairwise joins of congruences, adding them to the set
until no new congruences are generated.

The method exhibited here involves building the lattice of congruences
up from the minimal congruences. Given a congruence $\sigma$ on a magma
$M$, we calculate the congruences which cover $\sigma$ in the lattice
of congruences on $M$ by `pulling back' the set of minimal congruences
on the magma $M/\sigma$. The precise method is based on the following
simple observation whose proof is left to the reader.
\begin{proposition}\label{T:pullback}
Let $\sigma$ be a congruence on a magma $M$. Then the congruences
which cover $\sigma$ are precisely the congruences
$\tau = \langle (x,y) \rangle \vee \sigma$ where 
$\{([x]_\sigma, [y]_\sigma)\}$ generates a minimal congruence $\tilde{\tau}$ on 
$M/\sigma$.
\end{proposition} 

%% Let $\{([x]_\sigma, [y]_\sigma)\}$  generate a minimal congruence 
%% $\tilde{\tau}$ in $M/\sigma$. Suppose, by way of contradiction, that 
%% $\tau  = \langle \{ (x_1, y_1), \ldots (x_n, y_n), (x,y)\} \rangle$ 
%% does not cover $\sigma$ in the congruence lattice of $M$. 
%% Then there is some other pair $(u,v) \in M \times M$ such that 
%% $\gamma = \langle \{ (x_1, y_1), \ldots (x_n, y_n), (u,v)\} \rangle$
%% lies strictly between $\sigma$ and $\tau$.
%% Since $(u,v) \in \tau \setminus \sigma$ and by minimality of $\tilde{\tau}$,
%% we must have that $([u]_\sigma, [v]_\sigma)$ also generates $\tilde{\tau}$,
%% and so $x$ and $y$ are related in the smallest congruence
%% containing $\sigma$ and $(u,v)$. Contradicting the assumption that
%% $\langle (u,v)\rangle$ is strictly contained in $\tau$.
%% $\square$

%% The proof is the simple observation that the following conditions are
%% equivalent:
%% \begin{enumerate}
%% \item $\langle ([x]_\sigma, [y]_\sigma) \rangle$ is a minimal 
%% congruence on $M/\sigma$;
%% \item for all $[u]_\sigma \neq [v]_\sigma \in M/\sigma$,
%% $\langle ([u]_\sigma, [v]_\sigma) \rangle 
%% = \langle ([x]_\sigma, [y]_\sigma) \rangle$;
%% \item $(x, y) \in \langle (u,v)\rangle \vee \sigma$ for all 
%% $(u,v) \in \tau \setminus \sigma$;
%% \item $\langle (x,y) \rangle \vee \sigma$ covers $\sigma$.
%% \end{enumerate}$\square$

This proposition results in Algorithm \ref{A:pullback}.  
As in the algorithm for finding minimal congruences
in finite semigroups, the principle informing the design of this 
algorithm is to minimize the number of calls to Algorithm \ref{A:congruence}.
As the data show (see Section \ref{s:experiment}), the performance of 
this algorithm  compared with the naive algorithm depends strongly upon
the magma. Intuitively, one would expect this method
to perform well with a congruence lattice which is like 
a tree rooted at the bottom, rather than one which is highly 
interconnected. 


\begin{algorithm}
\caption{Computes all congruences by iteration of Proposition 
\ref{T:pullback} }
\label{A:pullback}
\begin{algorithmic}[1]
\REQUIRE $M$ -- a magma
\ENSURE All congruences on $M$.
\STATE $n \leftarrow 0$ \COMMENT{the number of congruences 
	whose covers have been calculated}
\STATE clist $\leftarrow $ MinimalCongruences($M$)
\WHILE{$n < $ Length(clist) }
		\STATE $n \leftarrow n + 1$
		\STATE $C \leftarrow$ Covers(clist[$n$]) \COMMENT{computed as 
		in Proposition \ref{T:pullback}}
		\STATE Append to clist any elements of C not already there
\ENDWHILE
\STATE return clist
\end{algorithmic}
\end{algorithm}

The method promises greater gains for the future
if (as seems likely) fast methods for computing 
in quotient magmas are discovered, and for semigroups,
if methods can be found which compute Green's
relations on a quotient semigroup of a semigroup in which they are
already known.

\section{Experimental Results} \label{s:experiment}
In this section we attempt to measure the performance of our algorithms
by tabulating runtime and counts of various operations
when run against a battery of experimental semigroups. 
The runtimes quoted are only to give an idea of how actual running
time varies compared with the operation counts. They were obtained
with {\gap} 4.2 on a Pentium Pro 200MHz Linux machine with 96Mb of RAM.

We briefly introduce the semigroups we use in the experiments:
\begin{itemize}
\item $C_n$ -- the semigroup of order preserving, non-increasing
transformations of an $n$-chain, see \cite{pSol96} for details.
\item $OP_n$ -- the semigroup of orientation preserving transformations
of an $n$-cycle, see \cite{pArth99} or \cite{pHigg99}.
\item $T_n$ -- the semigroup of all transformations of an $n$-set.
\item $P_n$ -- the semigroup of ordered partitions of a natural
number, see \cite{tgl94} for details.
\end{itemize}

\subsection{Experiments with the join of two congruences}
We compare the two methods for computing the join of two congruences 
discussed in Section~\ref{S:join}
by counting the number of disjoint-set operations required to 
find the join. 
Random elements from the semigroups were used to generate congruences
$\mathcal C$ and $\mathcal D$. 
The sample results show that even with 
large generating sets (as equivalence relations) 
Algorithm~\ref{A:partition} requires significantly fewer 
disjoint-set operations.   

\begin{table}[h]
\begin{center}

\footnotesize{
\begin{tabular}{ | c | c | c | c | c | }
\hline
Semigroup & $|C_{\mathcal C}\cup C_{\mathcal D}|$ & 
$|E_{\mathcal C}\cup E_{\mathcal D}|$
& Algorithm~\ref{A:congruence} & Algorithm~\ref{A:partition}\\ \hline 
$OP3$     &  2 &  10 &  141&   35\\ \hline 
$OP3$     &  4 &  16 &  145&   31\\ \hline 
$OP4$     &  4 &  66 &  861&   131\\ \hline 
$T4$     &  4 &  462 &  3505&   1359\\ \hline 

\end{tabular}
}
\end{center}
\end{table}

\subsection{Experiments with the minimal congruences algorithm}
In the following table, `\#C' denotes the number of congruences which
are computed in full, 
$n$ is the size of the semigroup, and the time
does not include the time required for the computation of Green's
relations.  In our experiments, Green's relations are computed using algorithms
of Linton et.~al. \cite{linton} for computing with transformation semigroups as 
implemented in {\gap} \cite{gap}.


\noindent
{\small
\begin{tabular}{|l|l|l|l|l|l|}
\hline
Semigroup &  & \multicolumn{2}{c}{Naive} &  
						\multicolumn{2}{c}{Rhodes}\\
					&  $n$,$n(n-1)/2$ &	time (sec) & \#C & time (sec) & \#C \\
\hline \hline
$C_4$ & 13,78 & 1.43 & 78 & 0.37 & 20 \\
$P_5$ &15,105& 3.47 & 105 & 1.63 & 21 \\
$OP_3$ & 24,276 & 12.03 & 276 & 8.42 & 132 \\
$T_3$ &27,351& 23.94 & 351 & 15.83 & 189 \\ \hline 
\end{tabular} }

\subsection{Experiments with the `Pulling Back' algorithm for 
calculating all congruences}
Once again, in the following table,
`\#C' denotes the number of congruences which
are computed in full, while the timings
in the section using both the `Pulling Back' and the Rhodes
methods are of the form $a/b$ where $a$ includes
the time to compute Green's Relations,  and $b$ does not. This is because it 
isn't  reasonable to imagine that Green's relations would be
precomputed for all quotients of a semigroup, however this ratio
should decrease as new algorithms are found to compute Green's relations
on a quotient given a knowledge of Green's relations on its preimage.
Another factor which inflates the times for the `Pulling Back' method 
is that multiplication and equality in quotient semigroups is done naively,
by multiplying  and comparing congruence classes as lists of elements.
We believe that an obvious next step is to further the work of Cannon
\cite{cannon} and Pin and Froidure \cite{pin} by developing 
fast methods for computing in the quotients of finite semigroups by
quickly computing the `quotient' Cayley graph.

\noindent
{\tiny
\begin{tabular}{|l|l|l|l|l|l|l|}
\hline
Smg &  \multicolumn{2}{c}{Naive algorithm} &
            \multicolumn{2}{c}{Pulling Back}&
						\multicolumn{2}{c}{Pulling Back \& Rhodes}\\
          & time (sec) & \#C & time (sec) & \#C 
          & time (sec) & \#C \\
\hline \hline
$C_4$ & 316.97 & 6519 & 188.26 & 2299 & 417/98.3 & 1023 \\
$P_5$ &1510.00 & 21841 & 993.84 & 6096 & 1623.50/448.52  & 2416  \\
$OP_3$ &259.60  &  286 & 158.82 & 595 &  85.30/81.05     & 291\\ 
$T_3$ &42.18  & 366 &  369.39 & 800 &  218.53/211.79  &  458\\ \hline
\end{tabular}}
The reader will note that in this experiment, the correlation between
actual time taken and the number of congruences computed is not as
strong as in the computation of minimal congruences. This could be because
the computation of many congruences on a smaller (in this case, quotient)
semigroup is faster than the computation of a few congruences on
a larger semigroup. We anticipate that a deeper understanding of 
the performance of this algorithm will result in hybrid algorithms
which will choose a strategy dependent upon the structure of the 
semigroup.

\section*{Acknowledgments}
The second author thanks Steve Linton for several helpful discussions
concerning Section \ref{S:semicong}.

\begin{thebibliography}{9}

\bibitem{pAS99} Isabel Ara\'ujo and Andrew Solomon,
{\em Computing with Semigroups in GAP}, to appear in the
proceedings of the International Conference on Semigroups,
Braga, 1999, World Scientific (2000).

\bibitem{pArth99} R.~Arthur and N.~Ru\v{s}kuc,
`Presentations for two extensions of the monoid of order-preserving
mappings on a finite chain', {\em Southeast Asian Bull. Math (to appear)}.

\bibitem{pA84}
   M.~D. Atkinson, R.~A. Hassan and M.~P. Thorne, \emph{Group Theory on a 
   Micro-Computer}, in Computational Group Theory, M.~D. Atkinson, ed., 
   Academic Press, New York, 1984, pp. 275-280. 
 
\bibitem{cannon} J. J. Cannon, {\em Computing the  Ideal Structure
of Finite Semigroups}, Numer. Math. {\bf 18},  254--266, 1971.

\bibitem{pHigg99}
P.~Catarino and P.~M.~Higgins,
`The monoid of orientation preserving mappings on a chain',
{\em Semigroup Forum (to appear)}.

\bibitem{bCLR90}
   T.~H. Cormen, C.~E Leiserson, and R.~L Rivest, \emph{Introduction
   to Algorithms}, McGraw-Hill Book Company, New York, 1990.

\bibitem{pin} V\'eronique Froidure and J.-E. Pin,
{\em Algorithms for computing finite semigroups},
in Foundations of Computational Mathematics, F.~Cucker 
and M. Shub eds., Berlin, Lecture Notes in Computer Science,
Springer Verlag, (1997), 112--126. 



\bibitem{gap} The GAP Group, {\gap} -- Groups, Algorithms and Programming,
Version 4.1; http://www-gap.dcs.st-and.ac.uk/~gap (Aachen, St Andrews, 1999).

\bibitem{bG95}
	P.~A.~Grillet, \emph{Semigroups: an introduction to the structure
theory}, Marcel Dekker, New York, 1995.

\bibitem{bH76}
   J.~M. Howie, \emph{An Introduction to Semigroup Theory}, Academic Press,
   London, 1976.

\bibitem{lallement} G. Lallement and R. McFadden,
{\em On the determination of Green's Relations in Finite Transformation
Semigroups}, J. Symbolic Computation (1990) {\bf 10}, 481--498.

\bibitem{tgl94}
T.~G.~Lavers,
`Fibonacci numbers, ordered partitions, and transformations of a
finite set', {\em Australasian Journal of Combinatorics},
10:147--151, 1994.

\bibitem{linton}
S.~A.~Linton, G.~Pfeiffer, E.~F.~Robertson, and N.~Ru\v{s}kuc,
`Computing transformation semigroups',
{\em Journal of Symbolic Computation}, 11, 1998.

\bibitem{pR67}
	J.~Rhodes, \emph{A homomorphism theorem for finite semigroups},
	Math. Systems Thoery 1 (1967) 289--304.

\bibitem{pSol96}
A.~Solomon, {\em Catalan Monoids, Monoids of Local Endomorphisms, 
and Their Presentations}, Semigroup Forum Vol. 53 (1996) 351--368. \\

\bibitem{pT75}
   R.~E. Tarjan, \emph{On the efficiency of a good but not linear
   set merging algorithm}, \emph{J. ACM} {\bf 22}, 1975, pp. 215-225.
\end{thebibliography}

\end{document}
