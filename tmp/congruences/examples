RequirePackage("transemi");

Performance Analysis for Class 1 (seconds)
==========================================
														Sym(4)		Sym(5) 		O(3)		O4		T4											OP3		OP5		C6		T3
cI v.1(without Green) 					9 		  3523		1.4			21		143, 1048 using MONOID
cI v.1												5.2 		  1820		0.2			
cII v.1(with Green)											0				0.8			37		23425 (6h)
cI_II (without Green)																					740 (12min)
cI_II (with Green)																						274
cIII v.1(with Green)										0				0				0			1.6
cIV v.1(with Green)											0				0				0			1

Umbrella											4.6				1578						10-15	280-841					 				3.8					2024
AllMinCong(naive)							2.7				722			0.8			81		63687 (17h)													3848
AllCongruences																																														205-

Correctness Checked for:
O4, Sym(5), Sym(4), OP3, OP5, T4 

It is a simple exercise to see that the minimum congruence of 
Tn, On and OPn is the one making all right zeros equivalent - see On paper with Tim.
The symmetric groups are checked using GAP function NormalSubgroups

gap> mc6 := MinimalCongruencesOfSemigroup(c6);
time;
 Computed Class 1 and 2 Congruences in 146450 ms.
 Computed Class 3 Congruences in 415860 ms.
 Computed Class 4 Congruences in 1462020 ms.
Merged Congruences in 10 ms.
[ <semigroup congruence with 1 generating pairs> ]
gap> time;
2024340


ALL CONGRUENCES
---------------
T3 has a chain of 6 congruences.




gap> mc1 := MinimalCongruencesOfSemigroup(t4);
 Computed Class 1 and 2 Congruences in 272710 ms.
 Computed Class 3 Congruences in 3710 ms.
 Computed Class 4 Congruences in 3440 ms.
Merged Congruences in 0 ms.


o3 := Semigroup(
[Transformation([1,1,3]),
Transformation([2,2,3]), 
Transformation([1,2,2]),
Transformation([1,3,3])]);


o4 := Semigroup(
[Transformation([1,1,3,4]),
Transformation([2,2,3,4]), 
Transformation([1,2,2,4]),
Transformation([1,3,3,4]),
Transformation([1,2,3,3]),
Transformation([1,2,4,4]) ]);

s4 := Semigroup(
[Transformation([2,3,4,1]),
Transformation([2,1,3,4])]);


# note the class 1 method behaves badly on symmetric groups
# - about 20 minutes on Sym(5).

s := SymmetricGroup(5);

# this seems to be intractible using any methods
t4 := Semigroup(
[Transformation([1,1,3,4]),
Transformation([2,3,4,1]),
Transformation([2,1,3,4])]);


# this is a reasonable example which is better with the smart methods
t3 := Semigroup(
[Transformation([1,1,3]),
Transformation([2,3,1]),
Transformation([2,1,3])]);


# An example which might have a more interesting set of minimal congruences.
c3 := Semigroup( [
Transformation([1,1,3]),
Transformation([1,2,2])]);

c4 := Semigroup([
Transformation([1,1,3,4]),
Transformation([1,2,2,4]),
Transformation([1,2,3,3])]);

###########################################################
###
## FINDING ALL CONGRUENCES
##
##########################################################

##
## The pullback method
gap> AllCongruences(c4);
gap> time;
180270 # using rhodes method of finding minimal congruences
gap> time;
189640 # when using naive method of finding minimal congruences.
# this is unsurprising since we don't know anything 
# special about the greens relations in a quotient semigroup.

#Note also, there must be some error in finding minimal congruences using
# rhodes method,
# since the second method gives all 114 congruences, while 
# using rhodes method gives only 61.


##
## Using simple Join of pair generated congruences.
##
gap> AllCongruencesNaive(c4);
gap> time;
377500 # Uses Join algorithm

gap> time;
291270 # uses concatenation of generating pairs



op3 := Semigroup( [
Transformation([1,1,3]),
Transformation([2,3,1])
]);

c5 := Semigroup( [
Transformation([1,1,3,4,5]),
Transformation([1,2,2,4,5]),
Transformation([1,2,3,3,5]),
Transformation([1,2,3,4,4])
]);
All congruences takes >= 107215620 ms


c6 := Semigroup( [
Transformation([1,1,3,4,5,6]),
Transformation([1,2,2,4,5,6]),
Transformation([1,2,3,3,5,6]),
Transformation([1,2,3,4,4,6]),
Transformation([1,2,3,4,5,5])
]);


# testing min/max sets

divides :=                
function(a, b)
	return QuotientRemainder(b, a)[2] = 0;
end;



mins := [];
AddMinSet(mins, 10, divides);
AddMinSet(mins, 3, divides); 
AddMinSet(mins, 8, divides); 
AddMinSet(mins, 5, divides);
AddMinSet(mins, 17, divides);
AddMinSet(mins, 14, divides);
AddMinSet(mins, 2, divides); 

m := [];
AddMaxSet(m, 3, divides);
AddMaxSet(m, 12, divides);
AddMaxSet(m, 7, divides); 
AddMaxSet(m, 20, divides);
AddMaxSet(m, 2, divides); 
AddMaxSet(m, 80, divides);
AddMaxSet(m, 84, divides);

# testing EquivalenceIsFiner
a1 := EquivalenceRelationByPairs(Domain([1,2,3]), []);
a2 := EquivalenceRelationByPairs(Domain([1,2,3]), [[1,2]]);
EquivalenceIsFiner(a1, a2); # true
EquivalenceIsFiner(a1, a1); # true
EquivalenceIsFiner(a2, a1); # false

tim4 := Semigroup(
[Transformation([1,1,2,3]),
Transformation([1,2,2,3]),
Transformation([1,2,3,3])]);



tim5 := Semigroup(
[Transformation([1,1,2,3,4]),
Transformation([1,2,2,3,4]),
Transformation([1,2,3,3,4]),
Transformation([1,2,3,4,4])]);


####### latdraw 

for i in [1 .. 11] do
		Print("(", i, " (");             
		if Length(c[i]) > 1 then
			for j in [1 .. Length(c[i])-1 ] do
				Print(c[i][j]," ");
			od;
		fi;
		if not IsEmpty(c[i]) then
			Print(c[i][Length(c[i])], "))\n");
		else
			Print("))\n");
		fi;

od;


