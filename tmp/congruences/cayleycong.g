#############################################################################
##
#W  cayleycong.g                                              Robert F. Morse                  
##
#H  @(#)$Id: cayleycong.g,v 1.2 2000/02/17 04:48:45 gap Exp $
##
#Y  Copyright (C)  1996,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
#Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
##
##  This file contains the declaration and implementation of a category of 
##  equivalence relations and related attributes and operatations on this category
##  which are associated with any magma (Cayley table) which the partition
##  of this relation gives the principal congruences of a magma.
##
Revision.cayleycong_g :=
    "@(#)$Id: cayleycong.g,v 1.2 2000/02/17 04:48:45 gap Exp $";

#############################################################################
##
#C IsPrincipalCongruenceEquivalenceRelation
##
## A category of equivalence relations which are associated with the
## Cayley table of a finite magma. The partitions (including the singletons)
## of this equivalence relation describe all the (not necessarily distinct)
## principal congruences of the magma  
##
DeclareCategory("IsPrincipalCongruenceEquivalenceRelation",
                     IsEquivalenceRelation);

#############################################################################
##
#A UnderlyingMagma(<PrinCongEquivRel>)  is the underlying magma for which
## the principal congruence equivalence is associated with
##
DeclareAttribute("UnderlyingMagma",IsPrincipalCongruenceEquivalenceRelation); 

#############################################################################
##
#A PrincipalCongruences(<per>)
## 
## Computed set of principal congruences given the principal congruence
## equivalence relation of the magma which it is associated to
##
DeclareAttribute("PrincipalCongruences", 
    IsPrincipalCongruenceEquivalenceRelation);

#############################################################################
##
#O PrincipalCongruenceEquivalenceRelation(<magma>)
##
## Construct the principal congruence equivalence relation given a magma
## 
DeclareOperation("PrincipalCongruenceEquivalenceRelation",[IsMagma]);

#############################################################################
##
#O PrincipalCongruenceEquivalenceRelation(<magma>)
##
## Constructor for Principal Congruence Equivalence Relation
##
InstallMethod(PrincipalCongruenceEquivalenceRelation, 
              "compute the principal congruence eqivalence for magmas", 
              true, [IsMagma], 0,

    function(m)

        local mt,           # Multiplication table for magma
              table,        # A table of relations between tuples of elements
                            #     in the magma
              i,j,k,        # Simple index variables 
              sz,           # Size of magma
              p1,p2,forest, # Variables used for the closure
              temp,         # temp variable
              d,er,fam,     # variables for computing the object
              t,gn,         # index variables
              TableEmpty;   # boolean for quiting closure
   

        ## Find the smallest equivalence relation on Domain([1..sz^2])
        ## generated by pairs related by elementary translations
        ##
        ## Initialize variables
        ##
        mt := MultiplicationTable(AsList(m));
        sz := Size(m);

        i:=1; j:=1; gn:=1; TableEmpty:=false;

        ## Combine closure with constructing generators
        ## 
        while not TableEmpty do

            ## Find all the elementary translations for an (i,j)
            ## pair where i<j

            if gn<=(sz^2-sz)/2 then 
                if j < sz then
                   j:=j+1;
                else
                   i:= i+1;j:=i+1;
                fi;
                gn := gn+1;

                temp := Set(List([1..sz],k->SortedList([mt[k][i],mt[k][j]])));
                temp := Union(temp, 
                   Set(List([1..sz],k->SortedList([mt[i][k],mt[j][k]]))) );
                temp := Filtered(temp,x->[i,j]<>x);
                temp := List(temp,x-> [(i-1)*sz+j, (x[1]-1)*sz+x[2]]);
                table := temp;
            else
                TableEmpty := true;
            fi;

            ## Initialize the forest only the first time through
            ##
            if gn=2 then forest := [table[1]]; fi;

            ## find the closure of the relations found above
            ##
            ## Closure follows relation.gi
            ##
            for t in table do 

                p1 := Length(forest)+1;
                p2 := Length(forest)+1;

                for k in [1..Length(forest)] do
                    if p1>Length(forest) and t[1] in forest[k] then
                        p1 := k;
                        if p2 <=Length(forest) then break; fi;
                    fi;    
                    if p2>Length(forest) and t[2] in forest[k] then
                        p2 := k;
                        if p1<=Length(forest) then break; fi;
                    fi;    
                od;

                ##
                ## For the pair (a,b) if a is in one block and b is in another
                ##     merge the two blocks 
                ##
                if p1<=Length(forest) and p2<=Length(forest) and not p1=p2 then
                    Append(forest[p1],forest[p2]);
                    Unbind(forest[p2]);
                    if not p2=Length(forest) then
                        forest[p2]:=forest[Length(forest)];
                        Unbind(forest[Length(forest)]);
                    fi;                       

                ##
                ##  These cases are if only one of the components
                ##      is in a block 
                ##
                elif p1<=Length(forest) and p2>Length(forest) then
                    Add(forest[p1],t[2]);
                elif p2<=Length(forest) and p1>Length(forest) then
                    Add(forest[p2],t[1]);
                ##
                ## Neither component is in a block
                ##
                ##
                elif p1>Length(forest) and p2>Length(forest) then
                    Add(forest,t);
                fi;
            od;                                     
        od;

        ## Create an IsPrincipalCongruenceEquivalenceRelation object
        ## and set attributes
        ##
        d := Domain([1..sz^2]);

        fam :=  GeneralMappingsFamily( ElementsFamily(FamilyObj(d)), 
                    ElementsFamily(FamilyObj(d)) );

        er :=  Objectify(NewType(fam, 
		IsPrincipalCongruenceEquivalenceRelation and 
                    IsEquivalenceRelationDefaultRep), rec());
        SetEquivalenceRelationPartition(er, forest);

	SetSource(er,d);
	SetRange(er,d);
        Setter(UnderlyingMagma)(er,m);
        return er; 

    end );

#############################################################################
##
#O PrincipalCongruences(<principlecongruenceequivrelation>)
## 
## Using the principal congruence associated with a magma create
## the principal congruence generated by the set of pairs in each
## partition. 
##
InstallMethod(PrincipalCongruences, 
              "principal congruences of a magma", true, 
              [IsPrincipalCongruenceEquivalenceRelation],0,

   function(per)
        local 
            elms,   # Elements of of the underlying magma
            part,   # parition of per
            p,      # non-trival block in part
            eqs,    # set of equivalences (congruences) 
            s,m;    # size, underlying magma

        ## Initialize variables
        ##
        m := UnderlyingMagma(per);
        s := Size(m);
        elms := AsSortedList(m);
        part := EquivalenceRelationPartition(per);

        ## Start with the trivial relation
        ##
        eqs := Set([MagmaCongruenceByGeneratingPairs(m,[])]);

        ## For each non-trivial block look at the principal congruence
        ##    it represents and add it to the set of congruences
        ##
        for p in part do
            AddSet(eqs,MagmaCongruenceByGeneratingPairs(m,
               List(p,x->[elms[QuoInt(x-1,s)+1],elms[RemInt(x-1,s)+1]]) ));
        od;
        
        ## Return the set of prinicpal congruences
        ##
        return eqs;
   end );

#############################################################################
##
#E
##
