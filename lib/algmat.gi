#############################################################################
##
#W  algmat.gi                   GAP library                     Thomas Breuer
#W                                                            Willem de Graaf
##
#H  @(#)$Id$
##
#Y  Copyright (C)  1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
##
##  This file contains those functions that mainly deal with matrix algebras,
##  that is, associative matrix algebras and matrix Lie algebras.
##
Revision.algmat_gi :=
    "@(#)$Id$";


#############################################################################
##
#M  RingByGenerators( <mats> )  . . . .  ring generated by a list of matrices
##
##  If <mats> is a list of matrices over a field then we construct a matrix
##  algebra over its prime field.
##
InstallOtherMethod( RingByGenerators,
    "method for a list of matrices over a finite field",
    true,
    [ IsFFECollCollColl ], 0,
    mats -> FLMLORByGenerators( GF( Characteristic( mats ) ), mats ) );

InstallOtherMethod( RingByGenerators,
    "method for a list of matrices over the Cyclotomics",
    true,
    [ IsCyclotomicsCollCollColl ], 0,
    mats -> FLMLORByGenerators( Integers, mats ) );


#############################################################################
##
#M  DefaultRingByGenerators( <mats> )  . . ring containing a list of matrices
##
##  If <mats> is a list of matrices over a field then we construct a matrix
##  algebra over its prime field.
##  (So this may differ from the result of 'RingByGenerators' if the
##  characteristic is zero.)
##
InstallOtherMethod( DefaultRingByGenerators,
    "method for a list of matrices over a finite field",
    true,
    [ IsFFECollCollColl ], 0,
    mats -> FLMLORByGenerators( GF( Characteristic( mats ) ), mats ) );

InstallOtherMethod( DefaultRingByGenerators,
    "method for a list of matrices over the Cyclotomics",
    true,
    [ IsCyclotomicsCollCollColl ], 0,
    mats -> FLMLORByGenerators( Rationals, mats ) );


#############################################################################
##
#M  RingByGenerators( <mats> )  . .  ring generated by a list of Lie matrices
##
##  If <mats> is a list of Lie matrices over a finite field then we construct
##  a matrix Lie algebra over its prime field.
##
InstallOtherMethod( RingByGenerators,
    "method for a list of Lie matrices over a finite field",
    true,
    [ IsLieObjectCollection and IsMatrixCollection ], 0,
    function( mats )

    local Fam;

    # Check whether the matrices lie in the Lie family of a family of
    # ordinary matrices.
    Fam:= UnderlyingFamily( ElementsFamily( FamilyObj( mats ) ) );
    if not HasElementsFamily( Fam ) then
      TryNextMethod();
    fi;
    Fam:= ElementsFamily( Fam );
    if not HasElementsFamily( Fam ) then
      TryNextMethod();
    fi;
    Fam:= ElementsFamily( Fam );

    # Handle the cases that the entries of the matrices
    # are FFEs or cyclotomics.
    if IsFFEFamily( Fam ) then
      return FLMLORByGenerators( GF( Characteristic( Fam ) ), mats );
    elif IsIdentical( Fam, CyclotomicsFamily ) then
      return FLMLORByGenerators( Integers, mats );
    else
      TryNextMethod();
    fi;
    end );


#############################################################################
##
#M  DefaultRingByGenerators( <mats> )   . . ring cont. a list of Lie matrices
##
##  If <mats> is a list of Lie matrices over a field then we construct
##  a matrix Lie algebra over its prime field.
##  (So this may differ from the result of 'RingByGenerators' if the
##  characteristic is zero.)
##
InstallOtherMethod( DefaultRingByGenerators,
    "method for a list of Lie matrices",
    true,
    [ IsLieObjectCollection and IsMatrixCollection ], 0,
    function( mats )

    local Fam;

    # Check whether the matrices lie in the Lie family of a family of
    # ordinary matrices.
    Fam:= UnderlyingFamily( ElementsFamily( FamilyObj( mats ) ) );
    if not HasElementsFamily( Fam ) then
      TryNextMethod();
    fi;
    Fam:= ElementsFamily( Fam );
    if not HasElementsFamily( Fam ) then
      TryNextMethod();
    fi;
    Fam:= ElementsFamily( Fam );

    # Handle the cases that the entries of the matrices
    # are FFEs or cyclotomics.
    if IsFFEFamily( Fam ) then
      return AlgebraByGenerators( GF( Characteristic( Fam ) ), mats );
    elif IsIdentical( Fam, CyclotomicsFamily ) then
      return AlgebraByGenerators( Rationals, mats );
    else
      TryNextMethod();
    fi;
    end );


#############################################################################
##
#M  RingWithOneByGenerators( <mats> )  ring-with-one gen. by list of matrices
##
##  If <mats> is a list of matrices over a field then we construct a matrix
##  algebra over its prime field.
##
InstallOtherMethod( RingWithOneByGenerators,
    "method for a list of matrices over a finite field",
    true,
    [ IsFFECollCollColl ], 0,
    mats -> FLMLORWithOneByGenerators( GF( Characteristic(mats) ), mats ) );

InstallOtherMethod( RingWithOneByGenerators,
    "method for a list of matrices over the Cyclotomics",
    true,
    [ IsCyclotomicsCollCollColl ], 0,
    mats -> FLMLORWithOneByGenerators( Integers, mats ) );

#T how to formulate this for any field?


#############################################################################
##
#M  FLMLORByGenerators( <F>, <mats> )
#M  FLMLORByGenerators( <F>, <empty>, <zero> )
#M  FLMLORByGenerators( <F>, <mats>, <zero> )
##
InstallMethod( FLMLORByGenerators,
    "method for division ring and list of matrices over it",
    IsElmsCollColls,
    [ IsDivisionRing, IsCollection and IsList ], 0,
    function( F, mats )
    local dims, A;

    # Check that all entries in 'mats' are square matrices of the same shape.
    if not IsMatrix( mats[1] ) then
      TryNextMethod();
    fi;
    dims:= DimensionsMat( mats[1] );
    if    dims[1] <> dims[2]
       or not ForAll( mats, mat ->     IsMatrix( mat )
                                   and DimensionsMat( mat ) = dims ) then
      TryNextMethod();
    fi;

    if ForAll( mats, mat -> ForAll( mat, row -> IsSubset( F, row ) ) ) then
      A:= Objectify( NewType( FamilyObj( mats ),
                                  IsFLMLOR
                              and IsGaussianSpace
                              and IsGaussianMatrixSpaceRep ),
                     rec() );
    else
      A:= Objectify( NewType( FamilyObj( mats ),
                                  IsFLMLOR
                              and IsVectorSpace
                              and IsNonGaussianMatrixSpaceRep ),
                     rec() );
    fi;

    SetLeftActingDomain( A, F );
    SetGeneratorsOfLeftOperatorRing( A, AsList( mats ) );
    A!.vectordim:= dims;

    # If the generators are associative elements then so is 'A'.
    if ForAll( mats, IsAssociativeElement ) then
      SetIsAssociative( A, true );
    fi;

    # Return the result.
    return A;
    end );

InstallOtherMethod( FLMLORByGenerators,
    "method for division ring, empty list, and square matrix",
    true,
    [ IsDivisionRing, IsList and IsEmpty, IsMatrix ], 0,
    function( F, empty, zero )
    local dims, A;

    # Check whether this method is the right one.
    dims:= DimensionsMat( zero );
    if not IsElmsColls( FamilyObj( F ), FamilyObj( zero ) ) then
#T explicit 2nd argument above!
      TryNextMethod();
    elif dims[1] <> dims[2] then
      Error( "<zero> must be a square matrix" );
    fi;

    A:= Objectify( NewType( CollectionsFamily( FamilyObj( zero ) ),
                                IsFLMLOR
                            and IsGaussianSpace
                            and IsGaussianMatrixSpaceRep
                            and IsTrivial ),
                   rec() );
    SetLeftActingDomain( A, F );
    SetGeneratorsOfLeftModule( A, empty );
    SetZero( A, zero );
    A!.vectordim:= dims;

    # Return the result.
    return A;
    end );

InstallOtherMethod( FLMLORByGenerators,
    "method for division ring, list of matrices	over it, and matrix",
    true,
    [ IsDivisionRing, IsCollection and IsList, IsMatrix ], 0,
    function( F, mats, zero )
    local dims, A;

    # Check whether this method is the right one.
    if not IsElmsCollColls( FamilyObj( F ), FamilyObj( mats ) ) then
      TryNextMethod();
    fi;
#T explicit 2nd argument above!

    # Check that all entries in 'mats' are matrices of the same shape.
    if not IsMatrix( mats[1] ) then
      TryNextMethod();
    fi;
    dims:= DimensionsMat( mats[1] );
    if    dims[1] <> dims[2]
       or not ForAll( mats, mat ->     IsMatrix( mat )
                                   and DimensionsMat( mat ) = dims ) then
      TryNextMethod();
    fi;

    if ForAll( mats, mat -> ForAll( mat, row -> IsSubset( F, row ) ) ) then
      A:= Objectify( NewType( FamilyObj( mats ),
                                  IsFLMLOR
                              and IsGaussianSpace
                              and IsGaussianMatrixSpaceRep ),
                     rec() );
    else
      A:= Objectify( NewType( FamilyObj( mats ),
                                  IsFLMLOR
                              and IsVectorSpace
                              and IsNonGaussianMatrixSpaceRep ),
                     rec() );
    fi;

    SetLeftActingDomain( A, F );
    SetGeneratorsOfLeftOperatorRing( A, AsList( mats ) );
    SetZero( A, zero );
    A!.vectordim:= dims;

    # If the generators are associative elements then so is 'A'.
    if ForAll( mats, IsAssociativeElement ) then
      SetIsAssociative( A, true );
    fi;

    # Return the result.
    return A;
    end );


#############################################################################
##
#M  FLMLORByGenerators( <F>, <lie-mats> )
#M  FLMLORByGenerators( <F>, <empty>, <lie-zero> )
#M  FLMLORByGenerators( <F>, <lie-mats>, <lie-zero> )
##
InstallMethod( FLMLORByGenerators,
    "method for division ring and list of Lie matrices over it",
    IsElmsCollLieColls,
    [ IsDivisionRing, IsLieObjectCollection and IsList ], 0,
    function( F, mats )
    local dims, A;

    # Check that all entries in 'mats' are square matrices of the same shape.
    if not IsMatrix( mats[1] ) then
      TryNextMethod();
    fi;
    dims:= DimensionsMat( mats[1] );
    if    dims[1] <> dims[2]
       or not ForAll( mats, mat ->     IsMatrix( mat )
                                   and DimensionsMat( mat ) = dims ) then
      TryNextMethod();
    fi;

    if ForAll( mats, mat -> ForAll( mat, row -> IsSubset( F, row ) ) ) then
      A:= Objectify( NewType( FamilyObj( mats ),
                                  IsFLMLOR
                              and IsGaussianSpace
                              and IsGaussianMatrixSpaceRep ),
                     rec() );
    else
      A:= Objectify( NewType( FamilyObj( mats ),
                                  IsFLMLOR
                              and IsVectorSpace
                              and IsNonGaussianMatrixSpaceRep ),
                     rec() );
    fi;

    SetLeftActingDomain( A, F );
    SetGeneratorsOfLeftOperatorRing( A, AsList( mats ) );
    A!.vectordim:= dims;

    # 'A' consists of Lie objects, so it is a Lie algebra.
    SetIsLieAlgebra( A, true );

    # Return the result.
    return A;
    end );

InstallOtherMethod( FLMLORByGenerators,
    "method for division ring, empty list, and Lie matrix",
    true,
    [ IsDivisionRing, IsList and IsEmpty, IsMatrix and IsLieObject ], 0,
    function( F, empty, zero )
    local dims, A;

    # Check whether this method is the right one.
    dims:= DimensionsMat( zero );
    if not IsElmsLieColls( FamilyObj( F ), FamilyObj( zero ) ) then
#T explicit 2nd argument above!
      TryNextMethod();
    elif dims[1] <> dims[2] then
      Error( "<zero> must be a square matrix" );
    fi;

    A:= Objectify( NewType( CollectionsFamily( FamilyObj( zero ) ),
                                IsFLMLOR
                            and IsGaussianSpace
                            and IsGaussianMatrixSpaceRep
                            and IsTrivial ),
                   rec() );
    SetLeftActingDomain( A, F );
    SetGeneratorsOfLeftModule( A, empty );
    SetZero( A, zero );
    A!.vectordim:= dims;

    # Return the result.
    return A;
    end );

InstallOtherMethod( FLMLORByGenerators,
    "method for division ring, list of Lie matrices over it, and Lie matrix",
    true,
    [ IsDivisionRing, IsLieObjectCollection and IsList,
      IsLieObject and IsMatrix ], 0,
    function( F, mats, zero )
    local dims, A;

    # Check whether this method is the right one.
    if not IsElmsCollLieColls( FamilyObj( F ), FamilyObj( mats ) ) then
      TryNextMethod();
    fi;
#T explicit 2nd argument above!

    # Check that all entries in 'mats' are matrices of the same shape.
    if not IsMatrix( mats[1] ) then
      TryNextMethod();
    fi;
    dims:= DimensionsMat( mats[1] );
    if    dims[1] <> dims[2]
       or not ForAll( mats, mat ->     IsMatrix( mat )
                                   and DimensionsMat( mat ) = dims ) then
      TryNextMethod();
    fi;

    if ForAll( mats, mat -> ForAll( mat, row -> IsSubset( F, row ) ) ) then
      A:= Objectify( NewType( FamilyObj( mats ),
                                  IsFLMLOR
                              and IsGaussianSpace
                              and IsGaussianMatrixSpaceRep ),
                     rec() );
    else
      A:= Objectify( NewType( FamilyObj( mats ),
                                  IsFLMLOR
                              and IsVectorSpace
                              and IsNonGaussianMatrixSpaceRep ),
                     rec() );
    fi;

    SetLeftActingDomain( A, F );
    SetGeneratorsOfLeftOperatorRing( A, AsList( mats ) );
    SetZero( A, zero );
    A!.vectordim:= dims;

    # 'A' consists of Lie objects, so it is a Lie algebra.
    SetIsLieAlgebra( A, true );

    # Return the result.
    return A;
    end );


#############################################################################
##
#M  FLMLORWithOneByGenerators( <F>, <mats> )
#M  FLMLORWithOneByGenerators( <F>, <empty>, <zero> )
#M  FLMLORWithOneByGenerators( <F>, <mats>, <zero> )
##
InstallMethod( FLMLORWithOneByGenerators,
    "method for division ring and list of matrices over it",
    IsElmsCollColls,
    [ IsDivisionRing, IsCollection and IsList ], 0,
    function( F, mats )
    local dims, A;

    # Check that all entries in 'mats' are square matrices of the same shape.
    if not IsMatrix( mats[1] ) then
      TryNextMethod();
    fi;
    dims:= DimensionsMat( mats[1] );
    if    dims[1] <> dims[2]
       or not ForAll( mats, mat ->     IsMatrix( mat )
                                   and DimensionsMat( mat ) = dims ) then
      TryNextMethod();
    fi;

    if ForAll( mats, mat -> ForAll( mat, row -> IsSubset( F, row ) ) ) then
      A:= Objectify( NewType( FamilyObj( mats ),
                                  IsFLMLORWithOne
                              and IsGaussianSpace
                              and IsGaussianMatrixSpaceRep ),
                     rec() );
    else
      A:= Objectify( NewType( FamilyObj( mats ),
                                  IsFLMLORWithOne
                              and IsVectorSpace
                              and IsNonGaussianMatrixSpaceRep ),
                     rec() );
    fi;

    SetLeftActingDomain( A, F );
    SetGeneratorsOfLeftOperatorRingWithOne( A, AsList( mats ) );
    A!.vectordim:= dims;

    # If the generators are associative elements then so is 'A'.
    if ForAll( mats, IsAssociativeElement ) then
      SetIsAssociative( A, true );
    fi;

    # Return the result.
    return A;
    end );

InstallOtherMethod( FLMLORWithOneByGenerators,
    "method for division ring, empty list, and square matrix",
    true,
    [ IsDivisionRing, IsList and IsEmpty, IsMatrix ], 0,
    function( F, empty, zero )
    local A;

    # Check whether this method is the right one.
    if not IsElmsColls( FamilyObj( F ), FamilyObj( zero ) ) then
#T explicit 2nd argument above!
      TryNextMethod();
    elif Length( zero ) <> Length( zero[1] ) then
      Error( "<zero> must be a square matrix" );
    fi;

    A:= Objectify( NewType( CollectionsFamily( FamilyObj( zero ) ),
                                IsFLMLORWithOne
                            and IsGaussianSpace
                            and IsGaussianMatrixSpaceRep
                            and IsAssociative ),
                   rec() );
    SetLeftActingDomain( A, F );
    SetGeneratorsOfLeftOperatorRingWithOne( A, empty );
    SetZero( A, zero );
    A!.vectordim:= DimensionsMat( zero );

    # Return the result.
    return A;
    end );

InstallOtherMethod( FLMLORWithOneByGenerators,
    "method for division ring, list of matrices	over it, and matrix",
    true,
    [ IsDivisionRing, IsCollection and IsList, IsMatrix ], 0,
    function( F, mats, zero )
    local dims, A;

    # Check whether this method is the right one.
    if    not HasCollectionsFamily( FamilyObj( F ) )
       or not IsElmsColls( CollectionsFamily( FamilyObj( F ) ),
                           FamilyObj( mats ) ) then
      TryNextMethod();
    fi;
#T explicit 2nd argument above!

    # Check that all entries in 'mats' are matrices of the same shape.
    if not IsMatrix( mats[1] ) then
      TryNextMethod();
    fi;
    dims:= DimensionsMat( mats[1] );
    if    dims[1] <> dims[2]
       or not ForAll( mats, mat ->     IsMatrix( mat )
                                   and DimensionsMat( mat ) = dims ) then
      TryNextMethod();
    fi;

    if ForAll( mats, mat -> ForAll( mat, row -> IsSubset( F, row ) ) ) then
      A:= Objectify( NewType( FamilyObj( mats ),
                                  IsFLMLORWithOne
                              and IsGaussianSpace
                              and IsGaussianMatrixSpaceRep ),
                     rec() );
    else
      A:= Objectify( NewType( FamilyObj( mats ),
                                  IsFLMLORWithOne
                              and IsVectorSpace
                              and IsNonGaussianMatrixSpaceRep ),
                     rec() );
    fi;

    SetLeftActingDomain( A, F );
    SetGeneratorsOfLeftOperatorRingWithOne( A, AsList( mats ) );
    SetZero( A, zero );
    A!.vectordim:= dims;

    # If the generators are associative elements then so is 'A'.
    if ForAll( mats, IsAssociativeElement ) then
      SetIsAssociative( A, true );
    fi;

    # Return the result.
    return A;
    end );


#############################################################################
##
#M  IsUnit( <A>, <mat> )  . . . . . . . . . . .  for matrix FLMLOR and matrix
##
InstallMethod( IsUnit,
    "method for matrix FLMLOR and matrix",
    IsCollsElms,
    [ IsMatrixFLMLOR, IsMatrix ], 0,
    function ( A, m )
    m:= m^-1;
    return m <> fail and m in A;
    end );


#############################################################################
##
#M  RadicalOfAlgebra( <A> ) . . . . . . . . for an associative matrix algebra
##
##  The radical of an associative algebra <A>  defined as the ideal of all
##  elements $x$ of <A> such that $x y$ is nilpotent for all $y$ in <A>.
##
##  For Gaussian matrix algebras this is easy to calculate,
##  for arbitrary associative algebras the task is reduced to the
##  Gaussian matrix algebra case.
##
InstallMethod( RadicalOfAlgebra,
    "method for associative Gaussian matrix algebra",
    true,
    [ IsAlgebra and IsGaussianMatrixSpaceRep and IsMatrixFLMLOR ], 0,
    function( A )

    local F,           # the field of A
          p,           # the characteristic of F
          n,           # the dimension of A
          bas,         # a list of basis vectors of A
          eqs,         # equation set
          i,j,k,u,v,   # loop variables
          R,           # a basis of the radical
          bb,          # a list of basis vectors of the algebra over F_p
          lemat,       # the length of the matrices in bb
          l,           # the intger such that p^l <= lemat < p^{l+1}
          B,           # bb together with the identity matrix
          I,           # a list of basis vectors of an ideal of A
          t,           # the length of I
          pexp,        # a power of the prime p
          X,Y,         # matrices
          w,wc,        # vectors
          G,           # the prime field of F
          canbas,      # canonical basis
          bsp,         # a vector space
          d,           # the degree of F
          dim,         # the dimension of the vector space where A acts on
          r;           # a primitive root of F

    # Check associativity.
    if not IsAssociative( A ) then
      TryNextMethod();
    fi;

    F:= LeftActingDomain( A );
    p:= Characteristic( F );
    n:= Dimension( A );
    bas:= BasisVectors( BasisOfDomain( A ) );

    if p = 0 then

      # First we treat the characteristic 0 case.
      # According to Dickson's theorem we have that in this case
      # the radical of 'A' is $\{ x\in A \mid Tr(xy) = 0 \forall y \in A \}$,
      # so it can be computed by solving a system of linear equations.

      eqs:= List( [ 1 .. n ], x -> [] );

      for i in [1..n] do
        for j in [i..n] do
          eqs[i][j]:= TraceMat( bas[i] * bas[j] );
          eqs[j][i]:= eqs[i][j];
        od;
      od;

      return SubalgebraNC( A, List( NullspaceMat( eqs ),
                                    x -> LinearCombination( bas, x ) ),
                           "basis" );

    else

      # If 'p' is greater than 0, then the situation is more difficult.
      # We follow the algorithm presented in
      # "L. Ronyai, Computing the Structure of Finite Algebras,
      # J. Symbolic Computation (1990), 355-373".
      # The calculation splits into two cases.
      # In the first case we have $'F' = F_p$ the prime field.
      # Then a sequence of ideals $I_0, \ldots, I_l$ is calculated such that
      # $I_l$ is the radical of 'A'.
      # The second case where $'F' = F_{p^d}$ is more complicated.
      # Here we transform 'A' to an algebra over $F_p$ and then
      # calculate the radical.  Finally this radical is transformed back.

      d:= DegreeOverPrimeField( F );
      dim:= Length( bas[1] );

      if 1 < d then

        # We produce a basis of an isomorphic matrix algebra with entries
        # in $F_p$.

        r:= PrimitiveRoot( F );
        bb:= [];
        G:= GF(p);
        canbas:= CanonicalBasis( AsField( G, F ) );
        for i in bas do
          X:= TransposedMat( i );
          Y:= [];
          for k in [1..dim] do
            for j in [0..d-1] do
              w:= r^j*X[k];
              wc:= [];
              for u in [1..dim] do
                Append( wc, Coefficients( canbas, w[u] ) );
              od;
              Add( Y, wc );
            od;
          od;
          Add( bb, TransposedMat( Y ) );
        od;

      else

        bb:= bas;
        G:= F;

      fi;

      # We calculate the radical of the algebra over 'F_p'.

      B:= ShallowCopy( bb );
      lemat:= Length( B[1] );
      Add( B, IdentityMat( lemat, G ) );

      # 'l' is the unique integer satisfying 'p^l <= lemat < p^{l+1}'.
      l:= LogInt( lemat, p );

      I:= ShallowCopy( bb );
      t:= n;
      pexp:= 1;

      for i in [0..l] do

        # Calculate $I_i$ (see the paper by Ronyai).

        eqs:= MutableNullMat( t, n+1, G );
        for j in [1..t] do
          for k in [1..n+1] do
            X:= List( I[j] * B[k], IntVecFFE );
            eqs[j][k]:= ( TraceMat( X^pexp ) / pexp ) * One( G );
          od;
        od;

        R:= NullspaceMat( eqs );

        if Length( R ) = 0 then
          return TrivialSubalgebra( A );
        fi;

        I:= List( R, x -> LinearCombination( I, x ) );
        t:= Length(I);
        pexp:= pexp*p;

      od;

      if 1 < d then

        # Transform back.

        bsp:= BasisByGeneratorsNC( VectorSpace( G, bb ), bb );
        R:= List( I, i -> LinearCombination( bas, Coefficients( bsp, i )) );

      else

        R:= I;

      fi;

      return SubalgebraNC( A, R, "basis" );
    fi;

    end );


#############################################################################
##
#F  CentralizerInAssociativeGaussianMatrixAlgebra( <base>, <gens> )
##
##  is a list of basis vectors of the $R$-FLMLOR that is the centralizer
##  of the $R$-FLMLOR with generators <gens> in the $R$-FLMLOR
##  with $R$-basis vectors <base>.
##
##  View the centralizer condition for the matrix $a$ as an equation system
##  \[ \sum_{b\in B} c_b ( b a - a b ) = 0 \ , \]
##  where $B$ is a basis of <A> and $c_b$ in the coefficients field.
##  Then the centralizer is spanned by the matrices
##  $\sum_{b\in B} c_b b$ where the vector $c$ is a basis vector of
##  the solution space.
##
CentralizerInAssociativeGaussianMatrixAlgebra := function( base, gens )
#T better use structure constants ?

    local gen, mat, sol;

    for gen in gens do

      mat:= List( base, b -> Concatenation( b * gen - gen * b ) );
      sol:= NullspaceMat( mat );

      # Replace 'base' by a vector space base of the centralizer.
      base:= List( sol, x -> LinearCombination( base, x ) );
      
    od;

    return base;
end;


#############################################################################
##
#M  Centralizer( <A>, <mat> ) . . . . . . . . .  for matrix FLMLOR and matrix
##
InstallMethod( Centralizer,
    "method for associative Gaussian matrix FLMLOR, and matrix",
    IsCollsElms,
    [ IsMatrixFLMLOR and IsAssociative and IsGaussianSpace,
      IsMatrix ], 0,
    function( A, mat )
    return SubalgebraNC( A,
               CentralizerInAssociativeGaussianMatrixAlgebra(
                   BasisVectors( BasisOfDomain( A ) ),
                   [ mat ] ),
               "basis" );
    end );


#############################################################################
##
#M  Centralizer( <A>, <C> ) . . . . . . . for matrix FLMLOR and matrix FLMLOR
##
InstallMethod( Centralizer,
    "method for associative Gaussian matrix FLMLOR, and FLMLOR",
    IsIdentical,
    [ IsMatrixFLMLOR and IsAssociative and IsGaussianSpace,
      IsMatrixFLMLOR ], 0,
    function( A, C )
    return SubalgebraNC( A,
               CentralizerInAssociativeGaussianMatrixAlgebra(
                   BasisVectors( BasisOfDomain( A ) ),
                   GeneratorsOfAlgebra( C ) ),
               "basis" );
    end );


#############################################################################
##
#M  Centralizer( <A>, <mat> ) . . . . . for matrix FLMLOR-with-one and matrix
##
InstallMethod( Centralizer,
    "method for associative Gaussian matrix FLMLOR-with-one, and matrix",
    IsCollsElms,
    [ IsMatrixFLMLOR and IsFLMLORWithOne
                     and IsAssociative and IsGaussianSpace,
      IsMatrix ], 0,
    function( A, mat )
    return SubalgebraWithOneNC( A,
               CentralizerInAssociativeGaussianMatrixAlgebra(
                   BasisVectors( BasisOfDomain( A ) ),
                   [ mat ] ),
               "basis" );
    end );


#############################################################################
##
#M  Centralizer( <A>, <C> ) . .  for matrix FLMLOR-with-one and matrix FLMLOR
##
InstallMethod( Centralizer,
    "method for associative Gaussian matrix FLMLOR-with-one, and FLMLOR",
    IsIdentical,
    [ IsMatrixFLMLOR and IsFLMLORWithOne
                     and IsAssociative and IsGaussianSpace,
      IsMatrixFLMLOR ], 0,
    function( A, C )
    return SubalgebraWithOneNC( A,
               CentralizerInAssociativeGaussianMatrixAlgebra(
                   BasisVectors( BasisOfDomain( A ) ),
                   GeneratorsOfAlgebra( C ) ),
               "basis" );
    end );


#############################################################################
##
#F  FullMatrixAlgebraCentralizer( <F>, <lst> )
##
##  Compute the centralizer of the list of matrices <lst> in the full
##  matrix algebra over <F>. 
##
FullMatrixAlgebraCentralizer := function( F, lst )

    local len,      # length of 'lst'
          dims,     # dimensions of the matrices
          n,        # number of rows/columns
          n2,       # square of 'n'
          eq,       # equation system
          u,i,j,k,  # loop variables
          bc,       # basis of solutions of the equation system
          Bcen,     # basis vectors of the centralizer
          M;        # one centralizing matrix

    len:= Length( lst );
    if len = 0 then 
      Error( "cannot compute the centralizer of an empty set" );
    fi;

    dims:= DimensionsMat( lst[1] );
    n:= dims[1];
    n2:= n*n;

    # In the equations matrices are viewed as vectors of length 'n*n'.
    # Position '(i,j)' in the matrix corresponds with position '(i-1)*n+j'
    # in the vector.

    eq:= MutableNullMat( n2, n2 * len, F );
    for u in [ 1 .. len ] do
      for i in [1..n] do
        for j in [1..n] do
          for k in [1..n] do
            eq[(i-1)*n+k][(u-1)*n2+(i-1)*n+j]:= 
              eq[(i-1)*n+k][(u-1)*n2+(i-1)*n+j] + lst[u][k][j];
            eq[(k-1)*n+j][(u-1)*n2+(i-1)*n+j]:=
              eq[(k-1)*n+j][(u-1)*n2+(i-1)*n+j] - lst[u][i][k];
          od;
        od;
      od;
    od;

    # Translate the vectors back to matrices.
    bc:= NullspaceMat( eq );
    Bcen:= [];
    for i in bc do
      M:= [];
      for j in [ 1 .. n ] do
        M[j]:= i{ [ (j-1)*n+1 .. j*n ] };
      od;
      Add( Bcen, M );
    od;

    return Algebra( F, Bcen, "basis" );
end;


#############################################################################
##
#M  Centralizer( <A>, <S> ) . . . . . . . for full associative matrix algebra
##
InstallMethod( Centralizer,
    "method for full (associative) matrix FLMLOR, and FLMLOR",
    IsIdentical,
    [ IsMatrixFLMLOR and IsFullMatrixModule, IsFLMLOR ], 0,
    function( A, S )
    if not IsAssociative( A ) then
      TryNextMethod();
    fi;
    return FullMatrixAlgebraCentralizer( LeftActingDomain( A ),
                                         GeneratorsOfAlgebra( S ) );
    end );

InstallMethod( Centralizer,
    "method for full (associative) matrix FLMLOR, and left module",
    IsIdentical,
    [ IsMatrixFLMLOR and IsFullMatrixModule, IsLeftModule ], 0,
    function( A, S )
    if not IsAssociative( A ) then
      TryNextMethod();
    fi;
    return FullMatrixAlgebraCentralizer( LeftActingDomain( A ),
                                         GeneratorsOfLeftModule( S ) );
    end );

InstallMethod( Centralizer,
    "method for full (associative) matrix FLMLOR, and list of matrices",
    IsIdentical,
    [ IsMatrixFLMLOR and IsFullMatrixModule, IsCollection and IsList ], 0,
    function( A, S )
    if not IsAssociative( A ) then
      TryNextMethod();
    fi;
    return FullMatrixAlgebraCentralizer( LeftActingDomain( A ), S );
    end );

InstallMethod( Centralizer,
    "method for full (associative) matrix FLMLOR, and empty list",
    true,
    [ IsMatrixFLMLOR and IsFullMatrixModule, IsList and IsEmpty ], 0,
    function( A, S )
    if not IsAssociative( A ) then
      TryNextMethod();
    fi;
    return A;
    end );


#############################################################################
##
#F  FullMatrixFLMLOR( <R>, <n> )  . . .  FLMLOR of <n>-dim. matrices over <R>
##
##  Let $E_{i,j}$ be the matrix with value 1 in row $i$ and $column $j$, and
##  zero otherwise.
##  Clearly the full associative matrix algebra is generated by all
##  $E_{i,j}$, $i$ and $j$ ranging from 1 to <n>.
##  Define the matrix $F$ as permutation matrix for the permutation
##  $(1, 2, \ldots, n)$.  Then $E_{i,j} = F^{i-1} E_{1,1} F^{1-j}$.
##  Thus $F$ and $E_{1,1}$ are sufficient to generate the algebra.
##
FullMatrixFLMLOR := function( R, n )

    local i,      # loop over the rows
          gens,   # list of generators
          one,    # the identity of the field
          A;      # algebra, result

    gens:= MutableNullMat( n, n, R );
    gens:= [ gens, List( gens, ShallowCopy ) ];
    one:= One( R );

    # Construct the generators.
    gens[1][1][1]:= one;
    gens[2][1][n]:= one;
    for i in [ 2 .. n ] do
      gens[2][i][i-1]:= one;
    od;

    # Construct the FLMLOR.
    A:= AlgebraWithOneByGenerators( R, gens );
    SetIsFullMatrixModule( A, true );

    # Return the FLMLOR.
    return A;
end;

FullMatrixAlgebra := FullMatrixFLMLOR;
MatrixAlgebra := FullMatrixFLMLOR;
MatAlgebra := FullMatrixFLMLOR;


#############################################################################
##
#F  FullMatrixLieAlgebra( <R>, <n> )
#F                  . . full matrix Lie algebra of <n>-dim. matrices over <R>
##
##  The set $\{ E_{1,j}, E_{k,1}; 1 \leq j, k \leq n \}$ is a generating
##  system.
#T  What is a nicer generating system ?
##
FullMatrixLieFLMLOR := function( F, n )

    local null,   # null matrix
          one,    # identity of 'F'
          gen,    # one generator
          gens,   # list of generators
          i,      # loop over the rows
          A;      # algebra, result

    # Construct the generators.
    null:= MutableNullMat( n, n, F );
    one:= One( F );


    gen:= List( null, ShallowCopy );
    gen[1][1]:= one;
    gens:= [ LieObject( gen ) ];

    for i in [ 2 .. n ] do

      gen:= List( null, ShallowCopy );
      gen[1][i]:= one;
      Add( gens, LieObject( gen ) );

      gen:= List( null, ShallowCopy );
      gen[i][1]:= one;
      Add( gens, LieObject( gen ) );

    od;

    # construct the algebra
    A:= AlgebraByGenerators( F, gens );

    SetIsFullMatrixModule( A, true );

    # return the algebra
    return A;
end;

FullMatrixLieAlgebra := FullMatrixLieFLMLOR;
MatrixLieAlgebra := FullMatrixLieFLMLOR;
MatLieAlgebra := FullMatrixLieFLMLOR;


#############################################################################
##
#M  DirectSumOfAlgebras( <A1>, <A2> ) . .  for two associative matrix FLMLORs
##
##  Construct an associative matrix FLMLOR.
##
#T embeddings/projections should be provided!
##
InstallOtherMethod( DirectSumOfAlgebras,
    "method for two associative matrix FLMLORs",
    IsIdentical,
    [ IsMatrixFLMLOR and IsAssociative,
      IsMatrixFLMLOR and IsAssociative ], 0,
    function( A1, A2 )

    local b1,   # Basis vectors of 'A1'.
          b2,   # Basis vectors of 'A2'.
          p1,   # Length of the matrices of 'b1'.
          p2,   # Length of the matrices of 'b2'.
          B,    # A basis of 'A1 \oplus A2'.
          i,    # Loop variable.
          Q,    # A matrix.
          A;    # result

    if LeftActingDomain( A1 ) <> LeftActingDomain( A2 ) then
      Error( "<A1> and <A2> must be written over the same domain" );
    fi;

    # We do not really need a basis for the arguments
    # but if we have one then we use it.
#T Do we really have so many algebra generators? (distinguish from basis?)
    if HasBasisOfDomain( A1 ) and HasBasisOfDomain( A2 ) then
      b1:= BasisVectors( BasisOfDomain( A1 ) );
      b2:= BasisVectors( BasisOfDomain( A2 ) );
    else
      b1:= GeneratorsOfAlgebra( A1 );
      b2:= GeneratorsOfAlgebra( A2 );
    fi;

    p1:= A1!.vectordim[1];
    p2:= A2!.vectordim[1];
#T unauthorized access!

    B:= [];
    for i in b1 do
      Q:= MutableNullMat( p1+p2, p1+p2, LeftActingDomain( A1 ) );
      Q{ [ 1 .. p1 ] }{ [ 1 .. p1 ] }:= i;
      Add( B, Q );
    od;
    for i in b2 do
      Q:= MutableNullMat( p1+p2, p1+p2, LeftActingDomain( A1 ) );
      Q{ [ p1+1 .. p1+p2 ] }{ [ p1+1 .. p1+p2 ] }:= i;
      Add( B, Q );
    od;

    A:= AlgebraByGenerators( LeftActingDomain( A1 ), B );
    if HasBasisOfDomain( A1 ) and HasBasisOfDomain( A2 ) then
      UseBasis( A, B );
    fi;

    SetIsAssociative( A, true );
#T nec. ?

    return A;
    end );


#############################################################################
##
#M  DirectSumOfAlgebras( <A1>, <A2> ) . . . . . .  for two matrix Lie FLMLORs
##
##  Construct a matrix Lie FLMLOR.
##
#T embeddings/projections should be provided!
##
InstallOtherMethod( DirectSumOfAlgebras,
    "method for two matrix Lie FLMLORs",
    IsIdentical,
    [ IsMatrixFLMLOR and IsLieAlgebra,
      IsMatrixFLMLOR and IsLieAlgebra ], 0,
    function( A1, A2 )

    local b1,   # Basis vectors of 'A1'.
          b2,   # Basis vectors of 'A2'.
          p1,   # Length of the matrices of 'b1'.
          p2,   # Length of the matrices of 'b2'.
          B,    # A basis of 'A1 \oplus A2'.
          i,    # Loop variable.
          Q,    # A matrix.
          A;    # result

    if LeftActingDomain( A1 ) <> LeftActingDomain( A2 ) then
      Error( "<A1> and <A2> must be written over the same domain" );
    fi;

    # We do not really need a basis for the arguments
    # but if we have one then we use it.
#T Do we really have so many algebra generators? (distinguish from basis?)
    if HasBasisOfDomain( A1 ) and HasBasisOfDomain( A2 ) then
      b1:= BasisVectors( BasisOfDomain( A1 ) );
      b2:= BasisVectors( BasisOfDomain( A2 ) );
    else
      b1:= GeneratorsOfAlgebra( A1 );
      b2:= GeneratorsOfAlgebra( A2 );
    fi;

    p1:= A1!.vectordim[1];
    p2:= A2!.vectordim[1];
#T unauthorized access!
    B:= [];
    for i in b1 do
      Q:= MutableNullMat( p1+p2, p1+p2, LeftActingDomain( A1 ) );
      Q{ [ 1 .. p1 ] }{ [ 1 .. p1 ] }:= i;
      Add( B, LieObject( Q ) );
    od;
    for i in b2 do
      Q:= MutableNullMat( p1+p2, p1+p2, LeftActingDomain( A1 ) );
      Q{ [ p1+1 .. p1+p2 ] }{ [ p1+1 .. p1+p2 ] }:= i;
      Add( B, LieObject( Q ) );
    od;

    A:= AlgebraByGenerators( LeftActingDomain( A1 ), B );
    if HasBasisOfDomain( A1 ) and HasBasisOfDomain( A2 ) then
      UseBasis( A, B );
    fi;
    SetIsLieAlgebra( A, true );

    return A;
    end );


#############################################################################
##
#F  EmptyMatrix( <char> )
##
##  is an empty matrix in characteristic <char> that acts on empty lists
##  and can be added to or multiplied with empty lists.
##
#T store in the family as an attribute?
##
EmptyMatrix := function( char )

    local Fam, mat;

    # Get the right family.
    if char = 0 then
      Fam:= CollectionsFamily( CollectionsFamily( CyclotomicsFamily ) );
    else
      Fam:= CollectionsFamily( CollectionsFamily( FFEFamily( char ) ) );
    fi;

    # Construct the matrix.
    mat:= Objectify( NewType( Fam,
                                  IsList
                              and IsEmpty
                              and IsMatrix
                              and IsZero
                              and IsAssociativeElement
                              and IsCommutativeElement
                              and IsJacobianElement
                              and IsAttributeStoringRep ),
                     rec() );

    SetName( mat, Concatenation( "EmptyMatrix( ", String( char ), " )" ) );
    SetInverse( mat, EmptyMatrix );
    SetAdditiveInverse( mat, EmptyMatrix );
    SetDimensionsMat( mat, [ 0, 0 ] );
    SetLength( mat, 0 );

    return mat;
end;


InstallMethod( \+, IsIdentical,
    [ IsMatrix and IsEmpty, IsMatrix and IsEmpty ], 0,
    function( m1, m2 ) return m1; end );

InstallOtherMethod( \*, IsIdentical,
    [ IsMatrix and IsEmpty, IsMatrix and IsEmpty ], 0,
    function( m1, m2 ) return m1; end );

InstallOtherMethod( \*, true,
    [ IsMatrix and IsEmpty, IsList and IsEmpty ], 0,
    function( m1, m2 ) return []; end );

InstallOtherMethod( \*, true,
    [ IsList and IsEmpty, IsMatrix and IsEmpty ], 0,
    function( m1, m2 ) return []; end );

InstallOtherMethod( \*, true,
    [ IsMatrix and IsEmpty, IsRingElement ], 0,
    function( m, scalar ) return m; end );

InstallOtherMethod( \*, true,
    [ IsRingElement, IsMatrix and IsEmpty ], 0,
    function( scalar, m ) return m; end );

InstallMethod( \^, true,
    [ IsMatrix and IsEmpty, IsInt ], 0,
    function( emptymat, n ) return emptymat; end );


#############################################################################
##
#F  NullAlgebra( <R> )  . . . . . . . . . . . . .  null algebra over ring <R>
##
NullAlgebra := R -> FLMLORByGenerators( R, [],
                        EmptyMatrix( Characteristic( R ) ) );
    

#T #############################################################################
#T ##
#T #M  FpAlgebra( <F>, <A> )
#T ##
#T InstalMethod( FpAlgebra,
#T     "method for ring and associative FLMLOR-with-one",
#T     true,
#T     [ IsRing, IsFLMLORWithOne ], 0,
#T     function( F, A )
#T 
#T     local base,         # base of 'A'
#T           baselen,      # length of 'base'
#T           len,          # no. of generators
#T           free,         # free algebra
#T           basewords,    # expressions of base vectors in terms of generators
#T           rels,         # relators list
#T           i,            # loop over 'base'
#T           j,            # loop over 'base'
#T           rel,          # one relator
#T           coeff,        # coefficients of product of basis vectors
#T           k;            # loop over 'coeff'
#T 
#T     # Change the left acting domain if necessary.
#T     if F <> LeftActingDomain( A ) then
#T       A:= AsFLMLOR( F, A );
#T     fi;
#T 
#T     base:= BasisVectors( StandardBasis( A ) );
#T     baselen:= Length( base );
#T     len:= Length( GeneratorsOfAlgebra( A ) );
#T     free:= FreeAssociativeAlgebra( F, len );
#T 
#T hier!
#T     # Construct the words corresponding to the basis elements.
#T     basewords:= List( A.standardBasis.basewords,
#T              x -> MappedExpression( x,
#T                    AlgebraGenerators( A.standardBasis.freeAssociativeAlgebra ),
#T                    AlgebraGenerators( free ) ) );
#T 
#T     # Construct the relators given by the multiplication table.
#T     rels:= [];
#T     for i in [ 1 .. baselen ] do
#T       for j in [ 1 .. baselen ] do
#T         coeff:= Coefficients( A.standardBasis, base[i] * base[j] );
#T         rel:= basewords[i] * basewords[j];
#T         for k in [ 1 .. baselen ] do
#T           rel:= rel - coeff[k] * basewords[k];
#T         od;
#T         if rel <> Zero( free ) then
#T           Add( rels, rel );
#T         fi;
#T       od;
#T     od;
#T 
#T     # Remove duplicate relators.
#T     rels:= Set( rels );
#T 
#T     # Construct the f.p. algebra.
#T     return free / rels;
#T     end );
#T 
#T 
#T #############################################################################
#T ##
#T #V  StandardBasisSpecialMatrixAlgebraOps
#T ##
#T ##  We need the functions 'Print', 'SiftedVector', 'Coefficients',
#T ##  and the right functions are already in 'StandardBasisModuleOps'.
#T ##
#T StandardBasisSpecialMatrixAlgebraOps :=
#T           OperationsRecord( "StandardBasisSpecialMatrixAlgebraOps", 
#T                             StandardBasisModuleOps );
#T 
#T #############################################################################
#T ##
#T #F  SpecialMatrixAssociativeAlgebraOps.StandardBasis( <A> )
#T ##
#T ##  Let $A$ be an associative matrix algebra over the field $F$.
#T ##
#T ##  Define $A_i$ to be the linear space generated by all words of length at
#T ##  most $i$, in terms of the generators of $A$.
#T ##  (The identity matrix is not a word of length zero, it need not be
#T ##  contained in the algebra at all.)
#T ##
#T ##  Then $\{ 0 \} = A_0 <leq A_1 \leq \ldots \ldots A_k = A$ for $k$
#T ##  sufficiently large.
#T ##
#T ##  We are interested in computing a vector space basis.  For $i > 0$,
#T ##  every element of $A_{i+1}$ is a sum of products of elements in $A_i$ with
#T ##  generators, so if we have a basis $B_i$ of $A_i$, and compute a basis of
#T ##  the space generated by the products $b g$ where $b$ ranges over $B_i$,
#T ##  and $g$ ranges over the generators of $A$, we get a basis of $A_{i+1}$.
#T ##
#T ##  The basis will be in semi-echelon form.
#T ##
#T ##  Additionally this function stores components 'freeAssociativeAlgebra' and
#T ##  'basewords'.
#T ##  This can be used to express every algebra element in terms of the
#T ##  generators, and compute preimages under homomorphisms.
#T ##
#T #T We have in a sense the structure constants when constructing the basis!
#T #T So it is not necessary to do the muliplications of matrices once more ...
#T ##
#T SpecialMatrixAssociativeAlgebraOps.StandardBasis := function( A )
#T 
#T     local zero,      # zero of the field
#T           n,         # dimension of matrices
#T           base,      # list of matrices in the standard basis
#T           ech,       # list of matrices in the echelonized basis
#T           heads,     # list with info about leading entries
#T           found,     # flag: Has a new base vector been found?
#T           g,         # loop over generators of 'A'
#T           b,         # loop over base vectors
#T           new,       # one product
#T           expr,      # actual expression for 'new'
#T           orig,      # candidate for base vector
#T           origword,  # corresponding expression
#T           row,       # loop over rows of the matrix
#T           col,       # loop over columns of the matrix
#T           F,         # free algebra
#T           basewords, # list of expressions for 'base' vectors in terms of 'F'
#T           echwords,  # list of expressions for 'ech'  vectors in terms of 'F'
#T           i, k,      # loop over generators and base
#T           zeromat,   # zero matrix
#T           B;         # the basis record, result
#T 
#T     zero:= Zero( A.field );
#T 
#T     if Length( AlgebraGenerators( Parent( A ) ) ) = 0 then
#T       n:= Length( Zero( Parent( A ) ) );
#T     else
#T       n:= Length( AlgebraGenerators( Parent( A ) )[1] );
#T     fi;
#T 
#T     base := [];
#T     ech  := [];
#T     heads:= 0 * [ 1 .. n ];
#T     heads:= List( [ 1 .. n ], x -> Copy( heads ) );
#T 
#T     # The generators of the free algebra correspond to the generators of 'A'.
#T     F:= FreeAssociativeAlgebra( A.field, Length( AlgebraGenerators( A ) ) );
#T     basewords:= [];
#T     echwords:=  [];
#T 
#T     # Compute a basis for $A_1$.
#T     for i in [ 1 .. Length( AlgebraGenerators( A ) ) ] do
#T 
#T       new:= A.algebraGenerators[i];
#T       orig:= new;
#T       expr:= AlgebraGenerators( F )[i];
#T       origword:= expr;
#T 
#T       # Reduce the matrix modulo 'ech'.
#T       row:= 1;
#T       col:= 1;
#T       while row <= n and col <= n do
#T       
#T         # Get the first nonzero column.
#T #T use DepthVector ( see UMAOps )
#T         while row <= n and col <= n and new[row][col] = zero do
#T           if col = n then
#T             row:= row+1;
#T             col:= 1;
#T           else
#T             col:= col+1;
#T           fi;
#T         od;
#T   
#T         if row <= n and col <= n then
#T   
#T           # The matrix is nonzero.
#T           if heads[row][col] <> 0 then
#T   
#T             # Reduce 'new' with the base vector.
#T             expr:= expr - new[row][col] * echwords[ heads[row][col] ];
#T             new:=  new  - new[row][col] * ech[      heads[row][col] ];
#T   
#T           else
#T   
#T             # We found a new base vector.
#T             Add( base,      orig     );
#T             Add( basewords, origword );
#T   
#T             Add( ech     , new  / new[row][col] );
#T             Add( echwords, expr / new[row][col] );
#T             heads [row][col]:= Length( base );
#T   
#T             row:= n + 1;
#T   
#T           fi;
#T 
#T         else
#T 
#T           # We have a zero matrix.
#T           zeromat:= new;
#T   
#T         fi;
#T   
#T       od;
#T 
#T     od;
#T 
#T     # Form the closure until 'base' becomes stable.
#T     found:= true;
#T 
#T     while found do
#T 
#T       found:= false;
#T 
#T       for i in [ 1 .. Length( AlgebraGenerators( A ) ) ] do
#T 
#T         g:= A.algebraGenerators[i];
#T 
#T         for k in [ 1 .. Length( base ) ] do
#T 
#T           b:= base[k];
#T           new:= A.algebraProduct( A, b, g );
#T           orig:= new;
#T 
#T           expr:= F.algebraProduct( F, basewords[k], F.algebraGenerators[i] );
#T           origword:= expr;
#T 
#T           # Reduce the matrix modulo 'ech'.
#T           row:= 1;
#T           col:= 1;
#T           while row <= n and col <= n do
#T     
#T             # Get the first nonzero column.
#T             while row <= n and col <= n and new[row][col] = zero do
#T #T use DepthVector!
#T               if col = n then
#T                 row:= row+1;
#T                 col:= 1;
#T               else
#T                 col:= col+1;
#T               fi;
#T             od;
#T 
#T             if row <= n and col <= n then
#T 
#T               # The matrix is nonzero.
#T               if heads[row][col] <> 0 then
#T 
#T                 # Reduce 'new' with the base vector.
#T                 expr:= expr - new[row][col] * echwords[ heads[row][col] ];
#T                 new:=  new  - new[row][col] * ech[      heads[row][col] ];
#T 
#T               else
#T 
#T                 # We found a new base vector.
#T                 Add( base,      orig     );
#T                 Add( basewords, origword );
#T 
#T                 Add( ech     , new  / new[row][col] );
#T                 Add( echwords, expr / new[row][col] );
#T                 heads [row][col]:= Length( base );
#T 
#T                 row:= n + 1;
#T                 found:= true;
#T 
#T               fi;
#T 
#T             else
#T 
#T               # We have a zero matrix.
#T               zeromat:= new;
#T   
#T             fi;
#T 
#T           od;
#T         od;
#T       od;
#T     od;
#T 
#T     # Store the zero matrix.
#T     if IsBound( zeromat ) and not IsBound( A.zero ) then
#T       A.zero:= zeromat;
#T     fi;
#T 
#T     # Make the standard basis record.
#T     B:= rec(
#T              basisVectors     := base,
#T              isBasis          := true,
#T              isStandardBasis  := true,
#T              structure        := A,
#T              freeAssociativeAlgebra      := F,
#T              basewords        := basewords,
#T              semiEchelonBasis := rec(
#T                     isBasis            := true,
#T                     isSemiEchelonized := true,
#T                     basisVectors       := ech,
#T                     heads              := heads,
#T                     freeAssociativeAlgebra        := F,
#T                     basewords          := echwords,
#T                     structure          := A,
#T                     operations         := SemiEchelonBasisSpecialMatrixAlgebraOps ),
#T #T ???
#T              operations       := StandardBasisSpecialMatrixAlgebraOps );
#T 
#T     # Compute the base change matrix.
#T     if Length( B.basisVectors ) > 0 then
#T       B.basechange:= List( B.basisVectors,
#T                          x -> Coefficients( B.semiEchelonBasis, x ) ) ^ -1;
#T #T this should be a relative basis then ??
#T #T (Think about generic 'StandardBasis' concept ...)
#T     fi;
#T 
#T     # Return the standard basis record.
#T     return B;
#T     end;
#T 
#T #T Note that the free algebra and the words are incorrect!
#T #T But at the moment we do not have nonassociative free algebras ...
#T SpecialMatrixLieAlgebraOps.StandardBasis :=
#T                             SpecialMatrixAssociativeAlgebraOps.StandardBasis;
#T 
#T 
#T #############################################################################
#T ##
#T #F  SpecialUnitalMatrixAssociativeAlgebraOps.StandardBasis( <A> )
#T ##
#T ##  Let $A$ be a matrix algebra-wth-one over the field $F$.
#T ##
#T ##  Define $A_i$ to be the linear space generated by all words of length at
#T ##  most $i$, in terms of the generators of $A$.
#T ##  (The identity matrix is a word of length zero.)
#T ##
#T ##  Then $F I = A_0 <leq A_1 \leq \ldots \ldots A_k = A$ for $k$
#T ##  sufficiently large.
#T ##
#T ##  We are interested in computing a vector space basis.  For $i > 0$,
#T ##  every element of $A_{i+1}$ is a sum of products of elements in $A_i$ with
#T ##  generators, so if we have a base $B_i$ of $A_i$, and compute a base of
#T ##  the space generated by the products $b g$ where $b$ ranges over $B_i$,
#T ##  and $g$ ranges over the generators of $A$, we get a base of $A_{i+1}$.
#T ##
#T ##  The base will be in semi-echelon form.
#T ##
#T ##  Additionally this function stores components 'freeAssociativeAlgebra' and
#T ##  'basewords'.
#T ##  They can be used to express every algebra element in terms of the
#T ##  generators, and compute preimages under homomorphisms.
#T ##
#T SpecialUnitalMatrixAssociativeAlgebraOps.StandardBasis := function( A )
#T 
#T     local zero,      # zero of the field
#T           n,         # dimension of matrices
#T           base,      # list of matrices in the standard base
#T           ech,       # list of matrices in the echelonized base
#T           heads,     # list with info about leading entries
#T           found,     # flag: Has a new base vector been found?
#T           g,         # loop over generators of 'A'
#T           b,         # loop over base vectors
#T           new,       # one product
#T           expr,      # actual expression for 'new'
#T           orig,      # candidate for base vector
#T           origword,  # corresponding expression
#T           row,       # loop over rows of the matrix
#T           col,       # loop over columns of the matrix
#T           F,         # free algebra
#T           basewords, # list of expressions for 'base' vectors in terms of 'F'
#T           echwords,  # list of expressions for 'ech'  vectors in terms of 'F'
#T           i, k,      # loop over generators and base
#T           zeromat,   # zero matrix
#T           row,       #
#T           j, l,      #
#T           B;         # basis record, result
#T 
#T     zero:= Zero( A.field );
#T 
#T     n:= A.vectordim[1];
#T 
#T     base := [];
#T     ech  := [];
#T     heads:= 0 * [ 1 .. n ];
#T     heads:= List( [ 1 .. n ], x -> Copy( heads ) );
#T 
#T     # The generators of the free algebra correspond to the generators of 'A'.
#T     F:= FreeAssociativeAlgebra( A.field, Length( A.algebraGenerators ) );
#T     AlgebraGenerators( F );
#T     basewords:= [];
#T     echwords:=  [];
#T 
#T     # Compute a basis for $A_0$.
#T     base[1]      := One( A );
#T     ech[1]       := base[1];
#T     heads[1][1]  := 1;
#T     basewords[1] := One( F );
#T     echwords[1]  := basewords[1];
#T 
#T     # Form the closure until 'base' becomes stable.
#T     found:= true;
#T 
#T     while found do
#T 
#T       found:= false;
#T 
#T       for i in [ 1 .. Length( A.algebraGenerators ) ] do
#T 
#T         g:= A.algebraGenerators[i];
#T 
#T         for k in [ 1 .. Length( base ) ] do
#T 
#T           b:= base[k];
#T           new:= b * g;
#T           orig:= new;
#T 
#T           expr:= basewords[k] * F.algebraGenerators[i];
#T           origword:= expr;
#T 
#T           # Reduce the matrix modulo 'ech'.
#T           row:= 1;
#T           col:= DepthVector( new[row] );
#T           while col > n and row < n do
#T             row:= row + 1;
#T             col:= DepthVector( new[row] );
#T           od;
#T           
#T           for j in [ row .. n ] do
#T             for l in [ 1 .. n ] do
#T               if heads[j][l] <> 0 and new[j][l] <> zero then
#T 
#T                 expr := expr - new[j][l] * echwords[ heads[j][l] ];
#T                 new  := new  - new[j][l] * ech[      heads[j][l] ];
#T 
#T               fi;
#T             od;
#T           od;
#T 
#T           # Check whether 'new' is the zero marix.
#T           col:= DepthVector( new[row] );
#T           while col > n and row < n do
#T             row:= row + 1;
#T             col:= DepthVector( new[row] );
#T           od;
#T 
#T           if col > n then
#T 
#T             # We have a zero matrix.
#T             zeromat:= new;
#T 
#T           else
#T 
#T             # We found a new base vector.
#T             Add( base,      orig     );
#T             Add( basewords, origword );
#T 
#T             Add( ech     , new  / new[row][col] );
#T             Add( echwords, expr / new[row][col] );
#T             heads [row][col]:= Length( base );
#T 
#T             row:= n + 1;
#T             found:= true;
#T 
#T           fi;
#T 
#T         od;
#T       od;
#T     od;
#T 
#T     # Store the zero matrix.
#T     if IsBound( zeromat ) and not IsBound( A.zero ) then
#T       A.zero:= zeromat;
#T     fi;
#T 
#T     # Make the standard basis record.
#T     B:= rec(
#T              basisVectors     := base,
#T              isBasis          := true,
#T              isStandardBasis  := true,
#T              structure        := A,
#T              freeAssociativeAlgebra      := F,
#T              basewords        := basewords,
#T              semiEchelonBasis := rec(
#T                     basisVectors       := ech,
#T                     heads              := heads,
#T                     freeAssociativeAlgebra        := F,
#T                     basewords          := echwords,
#T                     isBasis            := true,
#T                     isSemiEchelonized := true,
#T                     structure          := A,
#T                     operations         := SemiEchelonBasisSpecialMatrixSpaceOps ),
#T #T  ???
#T              operations       := StandardBasisSpecialMatrixAlgebraOps );
#T 
#T     # Compute the base change matrix.
#T     if Length( B.basisVectors ) > 0 then
#T       B.basechange:= List( B.basisVectors,
#T                          x -> Coefficients( B.semiEchelonBasis, x ) ) ^ -1;
#T     fi;
#T 
#T     # Return the standard basis record.
#T     return B;
#T     end;
#T 
#T 
#T  Fehler in 'StandardBasis' f"ur NICHT spezielle Algebren !!

#T #############################################################################
#T ##
#T #F  Fingerprint( <A> ) . . . . . . . . . . . . . . fingerprint of algebra <A>
#T #F  Fingerprint( <A>, <list> ) . . . . . . . . . . fingerprint of algebra <A>
#T ##
#T ##  If there is only one argument then the standard fingerprint is computed.
#T ##  This works for two-generator algebras acting only.
#T ##
#T Fingerprint := function( arg )
#T 
#T     # Check the arguments.
#T     if Length( arg ) = 0 or Length( arg ) > 2 then
#T       Error( "usage: Fingerprint( <matalg> [, <list> ] )" );
#T     fi;
#T 
#T     if   Length( arg ) = 2 then
#T 
#T       return arg[1].operations.Fingerprint( arg[1], arg[2] );
#T 
#T     elif Length( arg ) = 1 then
#T 
#T       if not IsBound( arg[1].fingerprint ) then
#T         arg[1].fingerprint:=
#T                         arg[1].operations.Fingerprint( arg[1], "standard" ); 
#T       fi;
#T       return arg[1].fingerprint;
#T 
#T     else
#T       Error( "number of generating matrices must be 2" );
#T     fi;
#T     end;
#T 
#T #############################################################################
#T ##
#T #F  Nullity( <mat> )
#T ##
#T Nullity := function( mat )
#T     return Dimensions( BaseNullspace( mat ) )[1];
#T     end;
#T 
#T #############################################################################
#T ##
#T #F  MatrixAssociativeAlgebraOps.Fingerprint( <A>, <list> )
#T ##
#T MatrixAssociativeAlgebraOps.Fingerprint := function( A, list )
#T 
#T     local fp,     # fingerprint, result
#T           a,      # first generator
#T           b,      # second generator
#T           ab,     # product of 'a' and 'b'
#T           word;   # actual word
#T 
#T     if list = "standard" then
#T 
#T       if Length( AlgebraGenerators( A ) ) <> 2 then
#T         Error( "exactly two generators needed for standard finger print" );
#T       fi;
#T 
#T       # Compute the nullities of the 6 standard elements.
#T       fp:= [];
#T       a:= AlgebraGenerators( A )[1];
#T       b:= AlgebraGenerators( A )[2];
#T       ab:= a * b;
#T       word:= ab + a + b;    fp[1]:= Nullity( word );
#T       word:= word + ab * b; fp[2]:= Nullity( word );
#T       word:= a + b * word;  fp[3]:= Nullity( word );
#T       word:= b + word;      fp[4]:= Nullity( word );
#T       word:= ab + word;     fp[5]:= Nullity( word );
#T       word:= a + word;      fp[6]:= Nullity( word );
#T       
#T     else
#T 
#T       # Compute the nullities of the words with numbers in the list.
#T       fp:= List( list, x -> Nullity( ElementAlgebra( A, x ) ) );
#T 
#T     fi;
#T     return fp;
#T     end;
#T 
#T #############################################################################
#T ##
#T #F  MatrixAssociativeAlgebraOps.RepresentativeOperation( <A>, <v>, <w>, <opr> )
#T ##
#T ##  Let $A$ be a matrix algebra over the field $F$, $v$ and $w$ vectors in
#T ##  the natural module.  Compute an element of $A$ that maps $v$ to $w$.
#T ##
#T ##  We compute the coefficients $a_i$ in the equation system
#T ##  $\sum_{i=1}^n a_i ( v \cdot b_i ) = w$ where $b_i$ runs over a vector
#T ##  space base of $A$.
#T ##
#T ##  For a tuple $(v_1, \ldots, v_k)$ of vectors we simply replace $v b_i$ by
#T ##  the concatenation of the $v_j b_i$ for all $j$, and replace $w$ by the
#T ##  concatenation $(w_1, \ldots, w_k)$, and solve this system.
#T ##
#T MatrixAssociativeAlgebraOps.RepresentativeOperation := function( A, v, w, opr )
#T 
#T     local B,       # basis of 'A'
#T           vectors, # basis vectors of 'B'
#T           mat,     # matrix of the equation system
#T           a,       # coefficients of solution w.r. to 'B'
#T           i,       # loop over 'a'
#T           j,       # loop over vectors in 'v'
#T           repr;    # representative, result
#T 
#T     B:= Basis( A );
#T     if Dimension( A ) = 0 then
#T       if w = 0 * w then
#T         return Zero( A );
#T       else
#T         return false;
#T       fi;
#T     fi;
#T 
#T     vectors := BasisVectors( B );
#T 
#T     if   opr = OnPoints or opr = OnRight then
#T 
#T       # Compute the matrix of the equation system, \ldots
#T       mat:= List( vectors, x -> v * x );
#T 
#T       # \ldots the coefficient vector $a$, \ldots
#T       a:= SolutionMat( mat, w );
#T 
#T     elif opr = OnTuples or opr = OnPairs then
#T 
#T       # Compute the matrix of the equation system, \ldots
#T       mat:= [];
#T       for i in vectors do
#T         mat[i]:= [];
#T         for j in [ 1 .. Length( v ) ] do
#T           Append( mat[i], v[j] * i );
#T         od;
#T       od;
#T 
#T       # \ldots the coefficient vector $a$, \ldots
#T       a:= SolutionMat( mat, Concatenation( w ) );
#T 
#T     else
#T #T !!!
#T       Error( "sorry, this operation is not yet supported" );
#T     fi;
#T 
#T     # \ldots and the representative.
#T     i:= DepthVector( a );
#T     if i > Length( a ) then
#T       repr:= Zero( A );
#T     else
#T       repr:= a[i] * vectors[i];
#T     fi;
#T     for j in [ i+1 .. Length( a ) ] do
#T       if a[j] <> Zero( A.field ) then
#T #T DepthVector mit Zusatzoption, erste Stellen auszulassen !
#T         repr:= repr + a[j] * vectors[j];
#T       fi;
#T     od;
#T 
#T     # Return the result.
#T     return repr;
#T     end;
#T 
#T 
#T #############################################################################
#T ##
#T #F  SemiEchelonBasisSpecialMatrixAlgebraOps.BasisVectors( <B> )
#T ##
#T ##  The basis has no vectors only if it was constructed with the algebra as
#T ##  only argument.
#T ##  If the algebra knows space generators then the same function is used as
#T ##  for special matrix spaces.
#T ##  Otherwise the process of closure under the action of the algebra on
#T ##  itself is used.
#T ##
#T SemiEchelonBasisSpecialMatrixAlgebraOps.BasisVectors := function( B )
#T 
#T     local SB;
#T 
#T     if IsBound( B.structure.spaceGenerators ) then
#T       return SemiEchelonBasisSpecialMatrixSpaceOps.BasisVectors( B );
#T     elif Length( AlgebraGenerators( B.structure ) ) = 0 then
#T       B.heads:= [];
#T       return [];
#T     else
#T       SB:= StandardBasis( B.structure ).semiEchelonBasis;
#T #T change this !
#T #T use CUA !
#T       B.heads:= SB.heads;
#T       return BasisVectors( SB );
#T     fi;
#T     end;
#T 
#T #############################################################################
#T ##
#T #F  MatrixAssociativeAlgebraOps.AbstractExpression( <A>, <elm> )
#T ##
#T ##  returns a record with components 'generators' and 'expression',
#T ##  giving an arithmetic expression of <elm> in terms of the generators
#T ##  of <A>.
#T ##
#T MatrixAssociativeAlgebraOps.AbstractExpression := function( A, elm )
#T 
#T     local B,       # basis of 'A'
#T           coeff,   # coefficients list
#T           expr,    # the expression, result
#T           i;       # loop over 'coeff'
#T 
#T     B:= Basis( A );
#T     coeff:= Coefficients( B, elm );
#T     expr:= Zero( B.freeAssociativeAlgebra );
#T     for i in [ 1 .. Length( coeff ) ] do
#T       if coeff[i] <> Zero( A.field ) then
#T         expr:= expr + coeff[i] * B.basewords[i];
#T       fi;
#T     od;
#T     return rec( generators := AlgebraGenerators( A.basis.freeAssociativeAlgebra ),
#T                 expression := expr );
#T     end;
#T 
#T #############################################################################
#T ##
#T #F  MatrixAssociativeAlgebraOps.FieldMultiplicity( <A>, <elm> )
#T ##
#T MatrixAssociativeAlgebraOps.FieldMultiplicity := function( A, elm )
#T     return elm[1][1];
#T     end;
#T 
#T #############################################################################
#T ##
#T #F  MatrixAssociativeAlgebraOps.NaturalModule( <A> )
#T ##
#T MatrixAssociativeAlgebraOps.NaturalModule := function( A )
#T 
#T     local gens,   # module generators
#T           N;      # natural module, result
#T 
#T     if Length( AlgebraGenerators( Parent( A ) ) ) = 0 then
#T       gens:= IdentityMat( A.field, Length( Zero( Parent( A ) ) ) );
#T     else
#T       gens:= Parent( A ).algebraGenerators[1]^0;
#T     fi;
#T #T wirklich Erzeuger angeben ?
#T     N:= Module( A, gens );
#T     N.isNaturalModule:= true;
#T     N.spaceGenerators:= gens;
#T     return N;
#T     end;
#T 
#T #############################################################################
#T ##
#T #F  MatrixAssociativeAlgebraOps.FpAlgebra( <F>, <A> ) . . . . . . . presentation of algebra
#T ##
#T MatrixAssociativeAlgebraOps.FpAlgebra := function( F, A )
#T 
#T     if One( A ) <> false then
#T       return UnitalMatrixAssociativeAlgebraOps.FpAlgebra( F, A );
#T     else
#T       Error( "presentation exists only if a mult. neutral element exists" );
#T     fi;
#T     end;
#T 

#############################################################################
##
#E  algmat.gi . . . . . . . . . . . . . . . . . . . . . . . . . . . ends here



