#############################################################################
##
#W  basismut.gd                 GAP library                     Thomas Breuer
##
#H  @(#)$Id$
##
#Y  Copyright (C)  1996,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
##
##  This file declares the categories and operations for mutable bases.
##
##  It is useful to have a *mutable basis* of a free module when successively
##  closures with new vectors are formed, since one does not want to create
##  a new module and a corresponding basis for each step.
##  
##  Note that the situation here is different from the situation with
##  stabilizer chains, which are (mutable or immutable) records that do not
##  need to know about the groups they describe.
##  There are several reasons to store the underlying module
##  in an immutable basis.
##  - One cannot have bases without vectors if the module is not stored.
##    (The call 'BasisOfDomain( <V> )' may return such a basis.)
##  - In some cases it is cheaper to compute coefficients only after a
##    (positive) membership test, which is a question to the module.
##    This occurs for example for finite fields and cyclotomic fields,
##    of course it is not allowed where 'Coefficients' is used to
##    implement the membership test.
##  
##  So immutable bases and mutable bases are different categories of objects.
##  The only thing they have in common is that one can ask both for
##  their basis vectors and for the coefficients of a given vector
##  (and maybe the more general question for coefficients of a multiple,
##  as in FBA).
##
##  A mutable basis of a free left module is
##  - an object in 'IsMutable'
##    (hence unable to store attributes and properties)
##  - that is constructed by 'MutableBasisByGenerators',
##  - that can be asked for the number of basis vectors by
##    'NrBasisVectors',
##  - that can be first argument of 'Coefficients' and 'BasisVectors',
##  - that can be modified by 'CloseMutableBasis' 
##    (whose methods have to guarantee consistency),
##  - and for that one can eventually get an immutable basis with same
##    basis vectors by 'ImmutableBasis'.
##  
##  Since mutable bases do not admit arbitrary changes of their lists of
##  basis vectors, a mutable basis is *not* a list.
##  It is, however, a collection, more precisely its family is the family
##  of its collection of basis vectors.
##
##  Similar to the situation with bases,
##  {\GAP} supports three types of mutable bases, namely
##  1. mutable bases that store an immutable basis;
##     this is the default
##  2. mutable bases that store a mutable basis for a nicer module;
##     this works if we have access to the mechanism of computing
##     nice vectors, and requires the construction with
##     'MutableBasisViaNiceMutableBasisMethod2' or
##     'MutableBasisViaNiceMutableBasisMethod3'
##  3. mutable bases that use special information to perform their tasks;
##     examples are mutable bases of Gaussian row and matrix spaces
##
##  *Constructor* for mutable bases is 'MutableBasisByGenerators'.
##
Revision.basismut_gd :=
    "@(#)$Id$";


#############################################################################
##
#C  IsMutableBasis( <obj> )
##
IsMutableBasis := NewCategory( "IsMutableBasis", IsMutable );


#############################################################################
##
#O  MutableBasisByGenerators( <R>, <vectors> )
#O  MutableBasisByGenerators( <R>, <vectors>, <zero> )
##
##  is a mutable basis for the <R>-free module generated by the vectors
##  in the list <vectors>.
##  The optional argument <zero> is the zero vector of the module.
##
##  *Note* that <vectors> will in general *not* be the basis vectors of the
##  mutable basis!
#T provide 'AddBasisVector' to achieve this?
##
MutableBasisByGenerators := NewConstructor( "MutableBasisByGenerators",
    [ IsRing, IsCollection ] );


#############################################################################
##
#F  MutableBasisViaNiceMutableBasisMethod2( <M>, <vectors> )
#F  MutableBasisViaNiceMutableBasisMethod3( <M>, <vectors>, <zero> )
##
##  Let <M> be a free $R$-left module that is handled via nice bases.
##  'MutableBasisViaNiceMutableBasisMethod?' returns a mutable basis for the
##  $R$-free module generated by the vectors in the list <vectors>.
##  The optional argument <zero> is the zero vector of the module.
##
##  *Note* that <M> is only used in calls to 'NiceVector' and 'UglyVector'.
##
MutableBasisViaNiceMutableBasisMethod2 := NewOperationArgs(
    "MutableBasisViaNiceMutableBasisMethod2" );

MutableBasisViaNiceMutableBasisMethod3 := NewOperationArgs(
    "MutableBasisViaNiceMutableBasisMethod3" );


#############################################################################
##
#O  NrBasisVectors( <MB> )
##
NrBasisVectors := NewOperation( "NrBasisVectors", [ IsMutableBasis ] );


#############################################################################
##
#O  ImmutableBasis( <MB> )
##
##  is the immutable basis with the same basis vectors as in the
##  mutable basis <MB>, and with underlying module constructed from these
##  vectors.
##
ImmutableBasis := NewOperation( "ImmutableBasis", [ IsMutableBasis ] );


#############################################################################
##
#O  CloseMutableBasis( <MB>, <v> )
##
##  changes the mutable basis <MB> such that afterwards it describes the
##  span of the old basis vectors together with <v>.
##
##  *Note* that this does in general *not* mean that <v> is added to the
##  basis vectors of <MB> if <v> enlarges the dimension.
##
CloseMutableBasis := NewOperation( "CloseMutableBasis",
    [ IsMutableBasis, IsVector ] );


#############################################################################
##
#E  basismut.gd . . . . . . . . . . . . . . . . . . . . . . . . . . ends here



