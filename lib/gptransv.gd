#############################################################################
##
#W  gptransv.gd			GAP Library		       Gene Cooperman
#W							     and Scott Murray
##
#H  @(#)$Id$
##
#Y  Copyright (C)  1996,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
#Y  (C) 1999 School Math and Comp. Sci., University of St.  Andrews, Scotland
##
##  Defines the category transversals with representations:
##  TransvBySchreierTree, TransvByHomomorphism, TransvByDirProd, 
##  TransvByTrivSubgrp, TransvBySiftFunct.
##  Common operations/attributes: Size, Enumerator, Iterator, Random,
##  TransversalElt, SiftOneLevel.
##
##  Requires: hash (for Schreier trees), 
##     quotientgp (for hom images).
Revision.gptransv_gd :=
    "@(#)$Id$";

DeclareInfoClass( "InfoTransversal" );

#############################################################################
#############################################################################
##
##  General transversals
##
#############################################################################
#############################################################################

#############################################################################
##
#O  TransversalElt( <ss>, <elt> )
##
##  Return representative of the coset containing the given element.
##  The representative is unique, ie. TransversalElt will return the
##  same thing for different elements of the same coset.
##
DeclareOperation( "TransversalElt", [ IsRightTransversal, IsAssociativeElement ] );

#############################################################################
##
#O  SiftOneLevel( <ss>, <elt> )
##
##  SiftOneLevel( tr, g ) = g $\*$ TransversalElt( tr, g ).
##  For some kinds of transversal TransversalElt is more efficient,
##  for others SiftOneLevel is.
##
DeclareOperation( "SiftOneLevel", [ IsRightTransversal, IsAssociativeElement ] );


#############################################################################
#############################################################################
##
##  Transversals by Schreier tree
##
##  Transversals of stabiliser subgroups.  We store a Schreier tree
##  to allow us to find transversal elements.
##  Note: SiftOneLevel is more efficient that TransversalElt.
##  Transversals can be extended as more generators are found for the 
##  stabiliser.
##  Orbit generators are generators for the original group, stored separately
##  so we can add extra generators to form a shallower tree.
##  Orbits are stored as hash tables.
##
#############################################################################
#############################################################################


#############################################################################
##
#R  IsTransvBySchreierTree
##
DeclareRepresentation( "IsTransvBySchreierTree",
    IsComponentObjectRep and IsRightTransversal,
    [ "OrbitGenerators", "BasePoint", "Action", "HashTable" ] );
DeclareCategoryCollections( "IsTransvBySchreierTree" );
TransvBySchreierTreeFamily := NewFamily( "ScheierTransvRep", IsTransvBySchreierTree );

#############################################################################
##
#F  SchreierTransversal( <basePoint>, <Action>, <strongGens> )
##
##  Create a transversal by Schreier tree for the subgroup stabilising
##  basePoint inside the group generated by strongGens.
##  This is the only correct way to create a transversal by Schreier 
##  tree.
##
DeclareGlobalFunction( "SchreierTransversal", [ IsObject, IsFunction, IsList ] );

#############################################################################
##
#O  OrbitGenerators( <ss> )
##
##  The elements used to compute the orbit.  This will be a generator for 
##  the larger group, homever it will often by redundant to keep the 
##  Schreier tree shallow.
##
DeclareOperation( "OrbitGenerators", [ IsTransvBySchreierTree ] );

#############################################################################
##
#O  OrbitGeneratorsInv( <ss> )
##
##  Inverses of the orbit generators
##
DeclareOperation( "OrbitGeneratorsInv", [ IsTransvBySchreierTree ] );

#############################################################################
##
#O  BasePointOfSchreierTransversal( <ss> )
##
##  The base point of a transversal by Schreier tree, ie. the point
##  stabilised.
##
DeclareOperation( "BasePointOfSchreierTransversal", [ IsTransvBySchreierTree ] );

#############################################################################
##
#A  One( <ss> )
##
##  The group identity.
##
DeclareAttribute( "One", IsTransvBySchreierTree );

##  gdc - These really take arg:  2 or 3 args.  How to declare?
#############################################################################
##
#F  ExtendSchreierTransversal( <ss>, <newGens> )
#F  ExtendSchreierTransversal( <ss>, <newGens>, <newGensInv> )
##
##  Extend a tranversal by Schreier tree with new generators
##
DeclareGlobalFunction( "ExtendSchreierTransversal", 
	[ IsTransvBySchreierTree, IsList ] );

#############################################################################
##
#F  ExtendSchreierTransversalShortCube( <ss>, <newGens> )
#F  ExtendSchreierTransversalShortCube( <ss>, <newGens>, <newGensInv> )
##
##  gdc - Ideally, ExtendSchreierTransversal should be a field
##        of the Schreier tree, chosen by SchreierTransversal().
##  gdc - This is the new function with the cube control tree
##  EXPERIMENTAL IDEA:  IT WOULD NEED TO BE TUNED.  NOT CURRENTLY
##   COMPETITIVE WITH METHOD BELOW.
##
DeclareGlobalFunction( "ExtendSchreierTransversalShortCube" );

#############################################################################
##
#F  ExtendSchreierTransversalShortTree( <ss>, <newGens> )
#F  ExtendSchreierTransversalShortTree( <ss>, <newGens>, <newGensInv> )
##
##  gdc - This is the original function with the traditional control tree
##  BASED ON:
##   ``A Random Base Change Algorithm for Permutation Groups'', G.~Cooperman
##   and L.~Finkelstein, J. of Symbolic Computation 17, 1994,
##   pp.~513--528
##
DeclareGlobalFunction( "ExtendSchreierTransversalShortTree" );

#############################################################################
##
##  ExtendTransversalOrbitGenerators(  <ss>, <newGens> )
##  ExtendTransversalOrbitGenerators(  <ss>, <newGens>, <newGensInv> )
##
##  This shouldn't be used.
##
##DeclareGlobalFunction( "ExtendTransversalOrbitGenerators",
##	[ IsTransvBySchreierTree, IsList ] );

#############################################################################
##
#F  CompleteSchreierTransversal( <ss> )
##
##  Complete the transversal.  In order to ensure that the Schreier tree does
##  not become too deep, the Extend... functions do not complete the
##  transversal.  Rather they extend it by depth one.
##
DeclareGlobalFunction( "CompleteSchreierTransversal", [IsTransvBySchreierTree] );

#############################################################################
##
#A  PreferredGenerators( <ss> )
##
##  Returns the preferred generators.  The preferred generators are always 
##  used first when computing the Schreier tree.
##
DeclareAttribute( "PreferredGenerators", IsTransvBySchreierTree );

#############################################################################
##
#F  SchreierTreeDepth( <ss> )
##
##  The depth of the Schreier tree.
##
DeclareGlobalFunction( "SchreierTreeDepth", [ IsTransvBySchreierTree ] );


#############################################################################
#############################################################################
##
##  Transversals by homomorphic images
##
##  Transversal of the kernel of a homomorphism.
##  Stores a quotient group for the kernel of a homomorphism;  
##  Transversal elements are computed by finding a chain for the image group
##  and doing shadowed stripping.
##  Note: TransversalElt is more efficient that SiftOneLevel
##
#############################################################################
#############################################################################

#############################################################################
##
#R  IsTransvByHomomorphism
##
DeclareRepresentation( "IsTransvByHomomorphism",
    IsComponentObjectRep and IsAttributeStoringRep and IsRightTransversal,
    [ "Homomorphism", "QuotientGroup" ] );
DeclareCategoryCollections( "IsTransvByHomomorphism" );
TransvByHomomorphismFamily := NewFamily( "TransvByHomomorphism", IsTransvByHomomorphism );

#############################################################################
##
#F  HomTransversal( <h> )
##
##  Create a hom transversal for the given homomorphism.
##
DeclareGlobalFunction( "HomTransversal",
    [IsGroupHomomorphism] );

#############################################################################
##
#O  Homomorphism( <homtr> )
##
##  The homomorphism of a hom transversal.
##
DeclareOperation( "Homomorphism", [IsTransvByHomomorphism] );

#############################################################################
##
#A  QuotientGroup( <homtr> )
##
##  The quotient group of a hom transversal
##
DeclareAttribute( "QuotientGroup", IsTransvByHomomorphism );

#############################################################################
##
#O  ImageGroup( <homtr> )
##
##  The image group of a hom transversal.
##
DeclareOperation( "ImageGroup", [IsTransvByHomomorphism] );


#############################################################################
#############################################################################
##
##  Transversals by direct products
##
##  Stores projection and injection for a direct product.  
##  The chain subgroup is the kernel of the projection.
##
#############################################################################
#############################################################################


#############################################################################
##
#R  IsTransvByDirProd
##
DeclareRepresentation( "IsTransvByDirProd",
    IsComponentObjectRep and IsRightTransversal,
    [ "Projection", "Injection" ] );
DeclareCategoryCollections( "IsTransvByDirProd" );
TransvByDirProdFamily := NewFamily( "TransvByDirProd", IsTransvByDirProd );

#############################################################################
##
#F  DirProdTransversal( <proj>, <inj> )
##
##  Create a direct product transversal.
##
DeclareGlobalFunction( "DirProdTransversal",
    [ IsGroupHomomorphism, IsGroupHomomorphism ] );

#############################################################################
##
#O  Projection( <dpt> )
##
##  Projection of a direct product transversal.
##
DeclareOperation( "Projection", [IsTransvByDirProd] );
#############################################################################
##
#O  Injection( <dpt> )
##
##  Injection of a direct product transversal.
##
DeclareOperation( "Injection", [IsTransvByDirProd] );


#############################################################################
#############################################################################
##
##  Transversal by Trivial subgroup
##
##  For use when our group is small enough to enumerate.
##
#############################################################################
#############################################################################

#############################################################################
##
#R  IsTransvByTrivSubgrp
##
DeclareRepresentation( "IsTransvByTrivSubgrp",
    IsComponentObjectRep and IsRightTransversal,
    [ "Group" ] );
DeclareCategoryCollections( "IsTransvByTrivSubgrp" );
TransvByTrivSubgrpFamily := NewFamily( "TransvByTrivSubgrp", IsTransvByTrivSubgrp );

#############################################################################
##
#F  TransversalByTrivial( <G> )
##
##  Create a transversal by trivial subgroup
##
DeclareGlobalFunction( "TransversalByTrivial",
    [ IsGroup ] );

#############################################################################
#############################################################################
##
##  Transversal by sift function
##
##  Given a group, subgroup, and sift function from group to subgroup
##      that is constant on cosets, this defines a transversal.
##  One typically prefers a normalized sift function that is the
##      the identity map on subgroups.
##  For situations when there is a non-group theoretic method for 
##  computing the transversal element.  eg. using row reduction for
##  the stabiliser of an invariant subspace.                                 
##  Note: SiftOneLevel is more efficient than TransversalElt
##
#############################################################################
#############################################################################

#############################################################################
##
#R  IsTransvBySiftFunct
##
DeclareRepresentation( "IsTransvBySiftFunct",
    IsComponentObjectRep and IsAttributeStoringRep and IsRightTransversal,
    [ "Sift", "ParentGroup", "Subgroup", "Size" ] );
DeclareCategoryCollections( "IsTransvBySiftFunct" );
TransvBySiftFunctFamily := NewFamily( "TransvBySiftFunct", IsTransvBySiftFunct );

#############################################################################
##
#F  TransversalBySiftFunction( <supergroup>, <subgroup>, <sift> )
##
##  Create a transversal by sift function
##
DeclareGlobalFunction( "TransversalBySiftFunction",
    [ IsFunction, IsGroup ] );

#E
