#############################################################################
##
#W  grp.gd                      GAP library                     Thomas Breuer
#W                                                             & Frank Celler
#W                                                             & Bettina Eick
#W                                                           & Heiko Theissen
##
#H  @(#)$Id$
##
#Y  Copyright (C)  1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
#Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
##
##  This file contains the declarations of operations for groups.
##
#1
##  Unless explicitly declared otherwise, all subgroup series are descending. 
##  That is they are stored in decreasing order.

#2
##  If a group <U> is created as a subgroup of another group <G>, <G>
##  becomes the parent of <U>. There is no `universal' parent group,
##  parent-child chains can be arbitrary long. {\GAP} stores the result of some
##  operations with the parent like `Normalizer' as an attribute.

Revision.grp_gd :=
    "@(#)$Id$";


GroupString := function(arg) return "Group"; end;
#T !!!

IsPrimeInt := "2b defined";

#############################################################################
##
#F  KeyDependentFOA( <name>, <grpreq>, <keyreq>, <keytest> )  . e.g., `PCore'
##
KeyDependentFOA := function( name, grpreq, keyreq, keytest )
    local str, nname, oper, attr, func;
    
    if keytest = "prime"  then
        keytest := function( key )
            if not IsPrimeInt( key )  then
                Error( name, ": <p> must be a prime" );
            fi;
        end;
    fi;

    # Create the two-argument operation.
    str:= ShallowCopy( name );
    Append(str,"Op");

    oper:= NewOperation( str, [ grpreq, keyreq ] );
    BIND_GLOBAL( str, oper );

    # Create the mutable attribute and install the default method.
    str := "Computed";
    Append( str, name );
    Append( str, "s" );
    attr:= NewAttribute( str, grpreq, "mutable" );
    BIND_GLOBAL( str, attr );
    nname:= "Set"; APPEND_LIST_INTR( nname, str );
    BIND_GLOBAL( nname, SETTER_FILTER( attr ) );
    nname:= "Has"; APPEND_LIST_INTR( nname, str );
    BIND_GLOBAL( nname, TESTER_FILTER( attr ) );

    InstallMethod( attr, true, [ grpreq ], 0, grp -> [  ] );

    # Create the function that mainly calls the operation.
    func:= function( grp, key )
        local   known,  i, erg;
        
        if not IsFinite( grp )  then
            Error( name, ": <G> must be finite" );
        fi;
        keytest( key );
        known := attr( grp );
        i := 1;
        while     i < Length( known )
              and known[ i ] < key  do
            i := i + 2;
        od;
	# Start storing only after the result has been computed.
        # This avoids errors if a calculation had been interrupted.

        if i > Length( known )  or  known[ i ] <> key  then
	    erg := oper( grp, key );
            known{ [ i .. Length( known ) ] + 2 } :=
              known{ [ i .. Length( known ) ] };
            known[ i ] := key;
            known[ i + 1 ] := erg;
        fi;
        return known[ i + 1 ];
    end;
    BIND_GLOBAL( name, func );
end;


#############################################################################
##

#V  InfoGroup
##
DeclareInfoClass( "InfoGroup" );


#############################################################################
##
#C  IsGroup( <obj> )
##
##  A group is a magma with inverses and associative multiplication.
##
IsGroup := IsMagmaWithInverses and IsAssociative;


#############################################################################
##
#A  GeneratorsOfGroup( <G> )
##
GeneratorsOfGroup := GeneratorsOfMagmaWithInverses;
SetGeneratorsOfGroup := SetGeneratorsOfMagmaWithInverses;
HasGeneratorsOfGroup := HasGeneratorsOfMagmaWithInverses;


#############################################################################
##
#P  IsCyclic( <G> )
##
##  A group is cyclic if it can be generated by one element.
DeclareProperty( "IsCyclic", IsGroup );

InstallSubsetMaintainedMethod( IsCyclic, IsGroup and IsCyclic, IsGroup );

InstallFactorMaintainedMethod( IsCyclic,
    IsGroup and IsCyclic, IsCollection, IsGroup );

InstallTrueMethod( IsCyclic, IsGroup and IsTrivial );

InstallTrueMethod( IsCommutative, IsGroup and IsCyclic );


#############################################################################
##
#P  IsElementaryAbelian( <G> )
##
##  A group <G> is elementary abelian if it is commutative and if there is a
##  prime $p$ such that the order of each element in <G> is divisible by $p$.
##
DeclareProperty( "IsElementaryAbelian", IsGroup );

InstallSubsetMaintainedMethod( IsElementaryAbelian,
    IsGroup and IsElementaryAbelian, IsGroup );

InstallFactorMaintainedMethod( IsElementaryAbelian,
    IsGroup and IsElementaryAbelian, IsCollection, IsGroup );

InstallTrueMethod( IsElementaryAbelian, IsGroup and IsTrivial );


#############################################################################
##
#P  IsFinitelyGeneratedGroup( <G> )
##
DeclareProperty( "IsFinitelyGeneratedGroup", IsGroup );

InstallFactorMaintainedMethod( IsFinitelyGeneratedGroup,
    IsGroup and IsFinitelyGeneratedGroup, IsCollection, IsGroup );

InstallTrueMethod( IsFinitelyGeneratedGroup, IsGroup and IsTrivial );

#############################################################################
##
#P  IsSubsetLocallyFiniteGroup(<M>) . . . . test if a group is locally finite
##
##  A group is called locally finite if every finitely generated subgroup is
##  finite.
##
DeclareProperty( "IsSubsetLocallyFiniteGroup", IsGroup );

# this true method will enforce that many groups are finite, which is needed
# implicitly
InstallTrueMethod( IsFinite, IsFinitelyGeneratedGroup and IsGroup
                             and IsSubsetLocallyFiniteGroup );

InstallTrueMethod( IsSubsetLocallyFiniteGroup, IsFinite and IsGroup );

InstallSubsetMaintainedMethod( IsSubsetLocallyFiniteGroup,
    IsGroup and IsSubsetLocallyFiniteGroup, IsGroup );

#############################################################################
##
#P  IsNilpotentGroup( <G> )
##
##  A group is nilpotent if it is the direct product of its sylow subgroups.
DeclareProperty( "IsNilpotentGroup", IsGroup );

InstallSubsetMaintainedMethod( IsNilpotentGroup,
    IsGroup and IsNilpotentGroup, IsGroup );

InstallFactorMaintainedMethod( IsNilpotentGroup,
    IsGroup and IsNilpotentGroup, IsCollection, IsGroup );

InstallTrueMethod( IsNilpotentGroup, IsGroup and IsCommutative );


#############################################################################
##
#P  IsPerfectGroup( <G> )
##
##  A group is perfect if it equals its derived subgroup.
DeclareProperty( "IsPerfectGroup", IsGroup );

InstallFactorMaintainedMethod( IsPerfectGroup,
    IsGroup and IsPerfectGroup, IsCollection, IsGroup );


#############################################################################
##
#P  IsSimpleGroup( <G> )
##
##  A group is simple, if it has no nontrivial normal subgroups.
DeclareProperty( "IsSimpleGroup", IsGroup );

InstallIsomorphismMaintainedMethod( IsSimpleGroup,
    IsGroup and IsSimpleGroup, IsGroup );


#############################################################################
##
#P  IsSupersolvableGroup( <G> )
##
##  a group is supersolvable if it has a normal series with cyclic factors.
DeclareProperty( "IsSupersolvableGroup", IsGroup );

InstallSubsetMaintainedMethod( IsSupersolvableGroup,
    IsGroup and IsSupersolvableGroup, IsGroup );

InstallFactorMaintainedMethod( IsSupersolvableGroup,
    IsGroup and IsSupersolvableGroup, IsCollection, IsGroup );

InstallTrueMethod( IsSupersolvableGroup, IsNilpotentGroup );


#############################################################################
##
#P  IsMonomialGroup( <G> )
##
##  A group is monomial if every irreducible complex character is induced
##  from a linear character of a subgroup.
DeclareProperty( "IsMonomialGroup", IsGroup );

InstallFactorMaintainedMethod( IsMonomialGroup,
    IsGroup and IsMonomialGroup, IsCollection, IsGroup );

InstallTrueMethod( IsMonomialGroup, IsSupersolvableGroup and IsFinite );


#############################################################################
##
#P  IsSolvableGroup( <G> )
##
##  A group is solvable if it has a subnormal series with cyclic factors.
DeclareProperty( "IsSolvableGroup", IsGroup );

InstallSubsetMaintainedMethod( IsSolvableGroup,
    IsGroup and IsSolvableGroup, IsGroup );

InstallFactorMaintainedMethod( IsSolvableGroup,
    IsGroup and IsSolvableGroup, IsCollection, IsGroup );

InstallTrueMethod( IsSolvableGroup, IsMonomialGroup );
InstallTrueMethod( IsSolvableGroup, IsSupersolvableGroup );


#############################################################################
##
#A  AbelianInvariants( <G> )
##
##  Computes the abelian invariants of the commutator factor group of <G>.
##  They are given as a list of the orders of a set of independent
##  generators of $G/G'$ (see "IndependentGeneratorsOfAbelianGroup").
##  
DeclareAttribute( "AbelianInvariants", IsGroup );

#############################################################################
##
#A  AsGroup( <D> )  . . . . . . . . . . . . . collection <D>, viewed as group
##
##  if the elements of the collection <D> form a group the command returns
##  this group, otherwise it returns `fail'.
DeclareAttribute( "AsGroup", IsCollection );


#############################################################################
##
#A  ChiefSeries( <G> )
##
##  A series of normal subgroups of <G> which cannot be refined further.
##  That is there is no normal subgroup <N> of <G> with $U_{i+1}\< N\< U_i$.
DeclareAttribute( "ChiefSeries", IsGroup );


#############################################################################
##
#O  ChiefSeriesUnderAction( <U>, <G> )
##
##  is a chief series of the group <G> with respect to the action of the
##  supergroup <U>.
##
DeclareOperation( "ChiefSeriesUnderAction",
    [ IsGroup, IsGroup ] );


#############################################################################
##
#O  ChiefSeriesThrough( <G>,<list> )
##
##  is a chief series of the group <G> going through the normal subgroups in
##  <l>. <l> must be a list of normal subgroups of <G> contained in each
##  other, sorted by descending size.
##
DeclareOperation( "ChiefSeriesThrough",
    [ IsGroup, IsList ] );


#############################################################################
##
#A  CommutatorFactorGroup( <G> )
##
##  computes the commutator factors group of <G>.
DeclareAttribute( "CommutatorFactorGroup", IsGroup );


#############################################################################
##
#A  CompositionSeries( <G> )
##
##  A composition series is a subnormal series which cannot be refined.
DeclareAttribute( "CompositionSeries", IsGroup );
#T and for module?

#############################################################################
##
#F  DisplayCompositionSeries( <G> )
##
##  Displays a composition series of <G> in a nice way, identifying the
##  simple factors.
DeclareGlobalFunction( "DisplayCompositionSeries" );


#############################################################################
##
#A  ConjugacyClasses( <G> )
##
##  returns the conjugacy classes of elements of <G>. See `ConjugacyClass'
##  ("ConjugacyClass") for details.
DeclareAttribute( "ConjugacyClasses", IsGroup );


#############################################################################
##
#A  ConjugacyClassesMaximalSubgroups( <G> )
##
##  returns the conjugacy classes of maximal subgroups of <G>.
##  Representatives of the classes can be computed directly by
##  `MaximalSubgroupClassReps' (see "MaximalSubgroupClassReps").
##
DeclareAttribute( "ConjugacyClassesMaximalSubgroups", IsGroup );


#############################################################################
##
#A  MaximalSubgroups( <G> )
##
##  returns a list of all maximal subgroups of <G>. This may take up much
##  space, therefore the command should be avoided if possible. See
##  "ConjugacyClassesMaximalSubgroups".
DeclareAttribute( "MaximalSubgroups", IsGroup );


#############################################################################
##
#A  MaximalSubgroupClassReps( <G> )
##
##  returns a list of conjugacy representatives of the maximal subgroups
##  of <G>.
DeclareAttribute("MaximalSubgroupClassReps",IsGroup);


#############################################################################
##
#A  PerfectResiduum( <G> )
##
##  is the smallest normal subgroup of <G> that has a solvable factor group.
DeclareAttribute( "PerfectResiduum", IsGroup );

#############################################################################
##
#A  RepresentativesPerfectSubgroups( <G> )
##
##  returns a list of conjugacy representatives of perfect subgroups of <G>.
##  This uses the library of perfect groups (see "PerfectGroup"), thus it
##  will issue an error if the library data is insufficient to determine all
##  perfect subgroups.
DeclareAttribute( "RepresentativesPerfectSubgroups", IsGroup );


#############################################################################
##
#A  ConjugacyClassesPerfectSubgroups( <G> )
##
##  returns a list of the conjugacy classes of perfect subgroups of <G>.
##  (see "RepresentativesPerfectSubgroups".)
DeclareAttribute( "ConjugacyClassesPerfectSubgroups", IsGroup );


#############################################################################
##
#A  ConjugacyClassesSubgroups( <G> )
##
##  This attribute returns the list of conjugacy classes of subgroups of the
##  group <G>. It also is applicable for lattices of subgroups (see
##  "LatticeSubgroups").
DeclareAttribute( "ConjugacyClassesSubgroups", IsGroup );


#############################################################################
##
#A  LatticeSubgroups( <G> )
##
##  computes the lattice of conjugacy classes of subgroups of the group <G>.
##  This lattice has the conjugacy classes of subgroups as an attribute 
##  (see "ConjugacyClassesSubgroups") and
##  permits to test maximality/minimality relations.
DeclareAttribute( "LatticeSubgroups", IsGroup );

#############################################################################
##
#A  DerivedLength( <G> )
##
##  The derived length of a group is the number of steps in the derived
##  series. (As there is always the group, it is the series length minus 1.)
DeclareAttribute( "DerivedLength", IsGroup );


#############################################################################
##
#A  DerivedSeriesOfGroup( <G> )
##
##  The derived series of a group is obtained by $U_i=U_{i-1}'$. It stops 
##  if $U_i$ is perfect.
DeclareAttribute( "DerivedSeriesOfGroup", IsGroup );


#############################################################################
##
#A  DerivedSubgroup( <G> )
##
##  The derived subgroup $G'$ of $G$ is the subgroup generated by all
##  commutators of elements of $G$. It is normal in $G$ and the factor
##  $G/G'$ is the largest abelian factor of $G$.
DeclareAttribute( "DerivedSubgroup", IsGroup );


#############################################################################
##
#A  DimensionsLoewyFactors( <G> )
##
DeclareAttribute( "DimensionsLoewyFactors", IsGroup );


#############################################################################
##
#A  ElementaryAbelianSeries( <G> )
##
##  returns a series of normal subgroups of $G$ such that all factors are
##  elementary abelian. If the group is not solvable (and thus no such series
##  exists) it returns `fail'.
DeclareAttribute( "ElementaryAbelianSeries", IsGroup );


#############################################################################
##
#A  Exponent( <G> )
##
##  The exponent $e$ of a group <G> is the lcm of the orders of its
##  elements, that is $e$ is the smallest integer such that $g^e=1$ for all
##  $g\in G$
DeclareAttribute( "Exponent", IsGroup );


#############################################################################
##
#A  FittingSubgroup( <G> )
##
##  The Fitting subgroup of a group <G> is its largest nilpotent normal
##  subgroup.
DeclareAttribute( "FittingSubgroup", IsGroup );


#############################################################################
##
#A  PrefrattiniSubgroup( <G> )
##
##  XXXXXXX
##  The frattini subgroup is the core of a prefrattini subgroup.
##
DeclareAttribute( "PrefrattiniSubgroup", IsGroup );

#############################################################################
##
#A  FrattiniSubgroup( <G> )
##
##  The frattini subgroup of a group <G> is the intersection of all maximal
##  subgroups of <G>.
DeclareAttribute( "FrattiniSubgroup", IsGroup );


#############################################################################
##
#A  InvariantForm( <D> )
##
DeclareAttribute( "InvariantForm", IsGroup );


#############################################################################
##
#A  JenningsSeries( <G> )
##
DeclareAttribute( "JenningsSeries", IsGroup );


#############################################################################
##
#A  LowerCentralSeriesOfGroup( <G> )
##
##  The lower central series of a group <G> is defined as $U_{i+1}:=[G,U_i]$. It
##  is a central series of normal subgroups. The name derives from the fact
##  that $U_i$ is contained in every $i$-th step subgroup of a central series.
DeclareAttribute( "LowerCentralSeriesOfGroup", IsGroup );


#############################################################################
##
#A  MaximalNormalSubgroups( <G> )
##
DeclareAttribute( "MaximalNormalSubgroups", IsGroup );


#############################################################################
##
#A  NormalMaximalSubgroups( <G> )
##
DeclareAttribute( "NormalMaximalSubgroups", IsGroup );


#############################################################################
##
#A  NormalSubgroups( <G> )
##
##  returns a list of all normal subgroups of <G>.
DeclareAttribute( "NormalSubgroups", IsGroup );


#############################################################################
##
#F  NormalSubgroupsAbove
##
DeclareGlobalFunction("NormalSubgroupsAbove");


############################################################################
##
#A  NrConjugacyClasses( <G> )
##
##  returns the number of conjugacy classes of <G>.
DeclareAttribute( "NrConjugacyClasses", IsGroup );


#############################################################################
##
#O  Omega( <G>, <n> )
##
##  For a $p$ group <G>, one defines $\Omega_n=\{g\in G\mid g^{p^n}=1\}$.
##
DeclareGlobalFunction( "Omega" );
DeclareOperation( "OmegaOp",
    [ IsGroup, IsPosInt, IsPosInt ] );
DeclareAttribute( "ComputedOmegas", IsGroup, "mutable" );


#############################################################################
##
#O  Agemo( <G>, <n> )
##
##  For a $p$ group <G>, one defines
##  $\mho=\langle g^{p^n}\mid g\in G\rangle$.
DeclareGlobalFunction( "Agemo" );
DeclareOperation( "AgemoOp",
    [ IsGroup, IsPosInt, IsPosInt ] );
DeclareAttribute( "ComputedAgemos", IsGroup, "mutable" );


#############################################################################
##
#A  RadicalGroup( <G> )
##
##  is the radical of <G>, i.e., the largest normal solvable subgroup of <G>.
##
DeclareAttribute( "RadicalGroup", IsGroup );


#############################################################################
##
#A  OrdersClassRepresentatives( <G> )
##
##  is a list of orders of representatives of conjugacy classes of the group
##  <G>, in the same ordering as the conjugacy classes.
##
DeclareAttribute( "OrdersClassRepresentatives", IsGroup );


#############################################################################
##
#A  RationalClasses( <G> )
##
##  returns a list of the rational classes of the group <G>. (see
##  "RationalClass".)
DeclareAttribute( "RationalClasses", IsGroup );


#############################################################################
##
#A  SizesCentralizers( <G> )
##
##  is a list that stores at position $i$ the size of the centralizer of any
##  element in the $i$-th conjugacy class of the group $G$.
##
DeclareAttribute( "SizesCentralizers", IsGroup );


#############################################################################
##
#A  SizesConjugacyClasses( <G> )
##
##  is a list that stores at position $i$ the size of the $i$-th conjugacy
##  class of the group $G$.
##
DeclareAttribute( "SizesConjugacyClasses", IsGroup );


#############################################################################
##
#A  GeneratorsSmallest( <G> )
##
##  returns a ``smallest'' generating set for the group <G>. This is the
##  lexicographically (using {\GAP}s order of group elements) smallest list
##  $l$ of elements of <G> such that $G=\langle
##  l\rangle$ and $l_i\not\in\langle l_1,\ldots,l_{i-1}$ and $1\not\in l$.
##  The comparison of two groups via lexicographic comparison of their
##  sorted element lists yields the same relation as lexicographic comparison
##  of their smallest generating sets.
DeclareAttribute( "GeneratorsSmallest", IsGroup );


#############################################################################
##
#A  MinimalGeneratingSet( <G> )
##
##  returns a generating set of <G> of minimal possible length.
DeclareAttribute( "MinimalGeneratingSet", IsGroup );


#############################################################################
##
#A  SmallGeneratingSet(<G>) small generating set (hopefully even irredundant)
##
##  returns a generating set of <G> which has few elements. As neither
##  irredundancy, nor minimal length is proven it runs much faster than
##  `MinimalGeneratingSet'. It can be used whenever a short generating set is
##  desired which not necessarily needs to be optimal.
DeclareAttribute( "SmallGeneratingSet", IsGroup );

#############################################################################
##
#A  SupersolvableResiduum( <G> )
##
##  The supersolvable residuum of a group <G> is its smallest normal
##  subgroup with supersolvable factor group.
DeclareAttribute( "SupersolvableResiduum", IsGroup );


#############################################################################
##
#F  SupersolvableResiduumDefault( <G> ) . . . . supersolvable residuum of <G>
##
##  `SupersolvableResiduumDefault' returns a record with components
##  `ssr' :
##      the supersolvable residuum of the group <G>, that is,
##      the largest normal subgroup of <G> with supersolvable factor group,
##  `ds' :
##      a chain of normal subgroups of <G>, descending from <G> to the
##      supersolvable residuum, such that any refinement of this chain
##      is a normal series.
##
DeclareGlobalFunction( "SupersolvableResiduumDefault" );


#############################################################################
##
#A  ComplementSystem( <G> )
##
##  A complement system of a group <G> is a set of hall $p'$-subgroups of
##  <G> such that every pair of subgroups from this set commutes as subgroups.
##  Complement systems exist only for solvable groups. The operation returns
##  `fail' if the group <G> is not solvable.
DeclareAttribute( "ComplementSystem", IsGroup );


#############################################################################
##
#A  SylowSystem( <G> )
##
##  A sylow system of a group <G> is a set of sylow subgroups of <G> such
##  that every pair of sylow subgroups from this set commutes as subgroups.
##  Sylow systems exist only for solvable groups. The operation returns
##  `fail' if the group <G> is not solvable.
DeclareAttribute( "SylowSystem", IsGroup );

#############################################################################
##
#A  HallSystem( <G> )
##
##  returns a list of hall $\pi$ subgroups for all sets $\pi$ of primes
##  which occur in the order of <G>.
##  Hall systems exist only for solvable groups. The operation returns
##  `fail' if the group <G> is not solvable.
DeclareAttribute( "HallSystem", IsGroup );


#############################################################################
##
#A  TrivialSubgroup( <G> ) . . . . . . . . . .  trivial subgroup of group <G>
##
TrivialSubgroup := TrivialSubmagmaWithOne;
SetTrivialSubgroup := SetTrivialSubmagmaWithOne;
HasTrivialSubgroup := HasTrivialSubmagmaWithOne;

#############################################################################
##
#A  Socle( <G> ) . . . . . . . . . .  socle of <G>
##
##  The socle is the subgroup generated by all minimal normal subgroups.
DeclareAttribute( "Socle", IsGroup );


#############################################################################
##
#A  UpperCentralSeriesOfGroup( <G> )
##
##  The upper central series of a group <G> is defined as
##  $U_i/U_{i+1}:=Z(G/U_{i+1})$. It
##  is a central series of normal subgroups. The name derives from the fact
##  that $U_i$ contains every $i$-th step subgroup of a central series.
DeclareAttribute( "UpperCentralSeriesOfGroup",
    IsGroup );


#############################################################################
##
#O  EulerianFunction( <G>, <n> )
##
DeclareOperation( "EulerianFunction", [ IsGroup, IsPosInt ] );


#############################################################################
##
#F  AgemoAbove( <G>, <C>, <p> )
##
DeclareGlobalFunction( "AgemoAbove" );


#############################################################################
##
#O  AsSubgroup( <G>, <U> )
##
##  creates a subgroup of <G> which contains the same elements as <U>
DeclareOperation( "AsSubgroup", [ IsGroup, IsGroup ] );


#############################################################################
##
#O  ClassMultiplicationCoefficient( <G>, <i>, <j>, <k> )
#O  ClassMultiplicationCoefficient( <G>, <C_i>, <C_j>, <C_k> )
##
DeclareOperation( "ClassMultiplicationCoefficient",
    [ IsGroup, IsPosInt,
      IsPosInt, IsPosInt ] );


#############################################################################
##
#F  ClosureGroupDefault( <G>, <elm> ) . . . . . closure of group with element
##
##  This functions returns the closure of the group <G> with the element
##  <elm>.
##  If <G> has the attribute 'AsListSorted' then also the result has this
##  attribute.
##  This is used to implement the default method for 'Enumerator' and
##  'EnumeratorSorted', via the function 'EnumeratorOfGroup'.
##
DeclareGlobalFunction( "ClosureGroupDefault" );


#############################################################################
##
#O  ClosureGroup( <G>, <obj> )  . . .  closure of group with element or group
##
##  creates the group generated by teh elements of <G> and <obj>. <obj> can
##  be either an element or a list of elements or another group.
DeclareOperation( "ClosureGroup", [ IsGroup, IsObject ] );


#############################################################################
##
#O  CommutatorSubgroup( <G>, <H> )
##
DeclareOperation( "CommutatorSubgroup", [ IsGroup, IsGroup ] );


#############################################################################
##
#O  ConjugateGroup( <G>, <obj> )  . . . . . . conjugate of group <G> by <obj>
##
##  To form a conjugate (group) by any object acting via '\^', one can use
##  the operator '\^'.
#T This should not be restricted to objects in the parent, or?
#T (Remember the hacks in the dispatchers of 'Centralizer' and 'Normalizer'
#T in GAP-3!)
##
#T Do we need 'ConjugateSubgroupNC', which does not check containment in
#T the parent?
##
DeclareOperation( "ConjugateGroup", [ IsGroup, IsObject ] );


#############################################################################
##
#O  ConjugateSubgroups( <G>, <U> )
##
##  returns a list of all images of the group <U> under conjugation action
##  by <G>.
DeclareOperation( "ConjugateSubgroups", [ IsGroup, IsGroup ] );


#############################################################################
##
#O  Core( <S>, <U> )
##
##  returns the core of <U> in <S>, that is the intersection of all
##  <S>-conjugates of <U>.
##
InParentFOA( "Core", IsGroup, IsGroup, NewAttribute );


#############################################################################
##
#O  CosetTable( <G>, <H> )
##
DeclareOperation( "CosetTable", [ IsGroup, IsGroup ] );


#############################################################################
##
#A  CosetTableInWholeGroup( <G> )
##
DeclareAttribute( "CosetTableInWholeGroup", IsGroup );


#############################################################################
##
#O  FactorGroup( <G>, <N> )
##
##  returns the image of the `NaturalHomomorphismByNormalSubgroup(<G>,<N>)'.
DeclareOperation( "FactorGroup", [ IsGroup, IsGroup ] );


#############################################################################
##
#O  Index( <G>, <U> )
##
##  returns the index $[G:U]={|G| \over |U|}$.
##
InParentFOA( "Index", IsGroup, IsGroup, NewAttribute );


#############################################################################
##
#A  IndexInWholeGroup( <G> )
##
DeclareAttribute( "IndexInWholeGroup", IsGroup );


#############################################################################
##
#A  IndependentGeneratorsOfAbelianGroup( <A> )
##
##  returns a set of generators <g> of prime-power order of the abelian
##  group <A> such that <A> is the direct product of the cyclic groups
##  generated by the $g_i$.
DeclareAttribute( "IndependentGeneratorsOfAbelianGroup",
  IsGroup and IsAbelian );


#############################################################################
##
#O  IsConjugate( <G>, <x>, <y> )
#O  IsConjugate( <G>, <U>, <V> )
##
##  tests whether the elements <x> and <y> or the subgroups <U> and <V> are
##  conjugate under <G>. This command is only a shortcut to
##  `RepresentativeOperation'.
DeclareOperation( "IsConjugate", [ IsGroup, IsObject, IsObject ] );


#############################################################################
##
#O  IsNormal( <G>, <U> )
##
InParentFOA( "IsNormal", IsGroup, IsGroup, NewProperty );


#############################################################################
##
#F  IsPNilpotent( <G>, <p> )
##
##  A group is $p$-nilpotent if it possesses a normal $p$-complement.
##
KeyDependentFOA( "IsPNilpotent", IsGroup, IsPosInt, "prime" );


#############################################################################
##
#F  IsPSolvable( <G>, <p> )
##
##  A group is $p$-solvable if every chief factor is either not divisible
##  by $p$ or solvable.
##
KeyDependentFOA( "IsPSolvable", IsGroup, IsPosInt, "prime" );


#############################################################################
##
#O  IsSubgroup( <G>, <U> )
##
DeclareOperation( "IsSubgroup", [ IsGroup, IsGroup ] );
#T really needed? (compat3.g?)


#############################################################################
##
#O  IsSubnormal( <G>, <U> )
##
##  A subgroup <U> of the group <G> is subnormal if it is contained in a
##  subnormal series of <G>.
DeclareOperation( "IsSubnormal", [ IsGroup, IsGroup ] );


#############################################################################
##
#O  NormalClosure( <G>, <U> )
##
##  The normal closure of <U> in <G> is the smallest normal subgroup of <G>
##  which contains <U>.
##
InParentFOA( "NormalClosure", IsGroup, IsGroup, NewAttribute );


#############################################################################
##
#O  NormalIntersection( <G>, <U> )
##
DeclareOperation( "NormalIntersection", [ IsGroup, IsGroup ] );


#############################################################################
##
#O  Normalizer( <G>, <U> )
#O  Normalizer( <G>, <g> )
##
##  Computes the normalizer $N_G(U)$, that is the stabilizer of $U$ under
##  the conjugation action of $G$.
##  The second form computes $N_G(\langle g\rangle)$.
##
InParentFOA( "Normalizer", IsGroup, IsObject, NewAttribute );


#############################################################################
##
#O  CentralizerModulo(<G>,<N>,<elm>)   full preimage of C_(G/N)(elm.N)
##
##  Computes the full preimage of the centralizer $C_(G/N)(elm\cdot N)$ in
##  <G> (without necessarily constructing the factor group).
DeclareOperation("CentralizerModulo", [IsGroup,IsGroup,IsObject]);


#############################################################################
##
#F  PCentralSeries( <G>, <p> )
##
KeyDependentFOA( "PCentralSeries", IsGroup, IsPosInt, "prime" );


#############################################################################
##
#F  PRump( <G>, <p> )
##
##  ????
KeyDependentFOA( "PRump", IsGroup, IsPosInt, "prime" );


#############################################################################
##
#F  PCore( <G>, <p> )
##
##  The $p$-core of <G> is the largest normal $p$-subgroup of <G>. It is the
##  core of a $p$-Sylow subgroup of <G>.
##
KeyDependentFOA( "PCore", IsGroup, IsPosInt, "prime" );


#############################################################################
##
#O  SubnormalSeries( <G>, <U> )
##
InParentFOA( "SubnormalSeries", IsGroup, IsGroup, NewAttribute );


#############################################################################
##
#F  SylowSubgroup( <G>, <p> )
##
##  returns a $p$-Sylow subgroup of the finite group <G>. This is a
##  $p$-subgroup <U> such that the index $[G:U]$ is coprime to $p$.
##  It computes Sylow subgroups via the operation `SylowSubgroupOp'.
##
KeyDependentFOA( "SylowSubgroup", IsGroup, IsPosInt, "prime" );


#############################################################################
##
#F  SylowComplement( <G>, <p> )
##
##  returns a $p$-Sylow complement of the finite group <G>. This is a
##  subgroup <U> of order coprime to $p$ such that the index $[G:U]$ is a
##  $p$-power.
##
KeyDependentFOA( "SylowComplement", IsGroup, IsPosInt, "prime" );


#############################################################################
##
#F  HallSubgroup( <G>, <pi> )
##
##  computes a $\pi$-Hall subgroup for a set $\pi$ of primes. This is a
##  subgroup which is only divisible by primes in $\pi$ and whose index is
##  coprime to all primes in $\pi$. 
##  A group is solvable if and only if for all sets $\pi$ of primes dividing
##  the group order $\pi$-Hall subgroups exist.
##  The function computes Hall subgroups via the operation `HallSubgroupOp'.
##
KeyDependentFOA( "HallSubgroup", IsGroup, IsList, ReturnTrue );


#############################################################################
##
#O  NrConjugacyClassesInSupergroup( <U>, <G> )
##
DeclareOperation( "NrConjugacyClassesInSupergroup", [ IsGroup, IsGroup ] );


#############################################################################
##
#O  GroupByGenerators( <gens> ) . . . . . . . . . . . . . group by generators
#O  GroupByGenerators( <gens>, <id> ) . . . . . . . . . . group by generators
##
DeclareOperation( "GroupByGenerators", [ IsCollection ] );


#############################################################################
##
#F  Group( <gen>, ... )
#F  Group( <gens>, <id> )
##
##  'Group( <gen>, ... )' is the group generated by the arguments <gen>, ...
##
##  If the only  argument <obj> is a list  that is not  a matrix then 'Group(
##  <obj> )' is the group generated by the elements of that list.
##
##  If there  are two arguments,   a list <gens>  and  an element <id>,  then
##  'Group( <gens>, <id> )'  is the group generated  by <gens>, with identity
##  <id>.
##
DeclareGlobalFunction( "Group" );


#############################################################################
##
#F  InstallGroupMethod( <coll-prop>, <grp-prop>, <func> )
##
GROUP_METHODS      := [];
InstallGroupMethod := InstallMethodsFunction2(GROUP_METHODS);
RunGroupMethods    := RunMethodsFunction2(GROUP_METHODS);


#############################################################################
##
#F  Subgroup( <G>, <gens> ) . . . . . . . subgroup of <G> generated by <gens>
#F  SubgroupNC( <G>, <gens> )
##
##  creates the subgroup <U> of <G> generated by <gens>. The `Parent' of <U>
##  will be <G>.
##  The `NC' version does not check, whether the elements in <gens> actually lie
##  in <G>.
##
DeclareSynonym( "Subgroup", SubmagmaWithInverses );

DeclareSynonym( "SubgroupNC", SubmagmaWithInversesNC );


#############################################################################
##
#R  IsRightTransversal  . . . . . . . . . . . . . . . . . . right transversal
##
DeclareRepresentation( "IsRightTransversal",
    IsEnumerator and IsDuplicateFreeList and
    IsComponentObjectRep and IsAttributeStoringRep,
    [ "group", "subgroup" ] );

#############################################################################
##
#O  RightTransversal( <G>, <U> )
##
##  A right transversal is a list of representatives for the right cosets
##  $U{\setminus}G$ (consisting of cosets $Ug$).
##  `RightTransversal' returns an object that behaves like an immutable
##  list of length $[<G>{:}<U>]$. For elements of <G>, the function
##  `PositionCanonical' however will return the position of a representative
##  in the transversal that defines the same coset. This can be very useful
##  for commands like `Operation' or `Permutation'.
##
InParentFOA( "RightTransversal", IsGroup, IsGroup, NewAttribute );


#############################################################################
##
#F  IsomorphismTypeFiniteSimpleGroup( <G> ) . . . . . . . . . ismorphism type
##
DeclareGlobalFunction( "IsomorphismTypeFiniteSimpleGroup" );


#############################################################################
##
#A  IsomorphismPcGroup( <G> )
##
DeclareAttribute( "IsomorphismPcGroup", IsGroup );

#############################################################################
##
#A  IsomorphismFpGroup( <G> )
##
##  returns an isomorphism from <G> to an isomorphic finitely presented
##  group <F>. The presentation (and thus the generators in which it is
##  presented) is chosen by the method to obtain a short presentation.
DeclareAttribute( "IsomorphismFpGroup", IsGroup );

#############################################################################
##
#A  IsomorphismFpGroupByGenerators( <G>,<gens>[,<string>] )
##
##  returns an isomorphism from <G> to an isomorphic finitely presented
##  group <F>. The generators of <F> correspond to the generators of <G>
##  given in <gens>.
##  If <string> is given it is used to name the generators of the finitely
##  presented group.
DeclareOperation( 
    "IsomorphismFpGroupByGenerators", [IsGroup, IsList, IsString] );
DeclareOperation( 
    "IsomorphismFpGroupBySubnormalSeries", [IsGroup, IsList, IsString] );
DeclareOperation( 
    "IsomorphismFpGroupByCompositionSeries", [IsGroup, IsString] );
DeclareGlobalFunction( "IsomorphismFpGroupByPcgs" );

#############################################################################
##
#A  PrimePowerComponents( <g> )
##
DeclareAttribute( "PrimePowerComponents", IsMultiplicativeElement );


#############################################################################
##
#O  PrimePowerComponent( <g>, <p> )
##
DeclareOperation( "PrimePowerComponent",
    [ IsMultiplicativeElement, IsPosInt ] );


#############################################################################
##
#O  PowerMapOfGroup( <G>, <n>, <ccl> )
##
##  is a list of positions, at position $i$ the position of the conjugacy
##  class containing the <n>-th powers of the elements in the $i$-th class
##  of the list <ccl> of conjugacy classes.
##
DeclareOperation( "PowerMapOfGroup",
    [ IsGroup, IsInt, IsHomogeneousList ] );


#############################################################################
##
#F  PowerMapOfGroupWithInvariants( <G>, <n>, <ccl>, <invariants> )
##
##  is a list of integers, at position $i$ the position of the conjugacy
##  class containimg the <n>-th powers of elements in class $i$ of <ccl>.
##  The list <invariants> contains all invariants besides element order
##  that shall be used before membership tests.
##
##  Element orders are tested first in any case since they may allow a
##  decision without forming the <n>-th powers of elements.
##
DeclareGlobalFunction( "PowerMapOfGroupWithInvariants" );


#############################################################################
##
#O  KnowsHowToDecompose(<G>,<gens>)      test whether the group can decompose 
##                                       into the generators
##
DeclareOperation("KnowsHowToDecompose",[IsGroup,IsList]);


#############################################################################
##
#O  HasAbelianFactorGroup(<G>,<N>)
##
##  tests whether $G/N$ is abelian.
DeclareGlobalFunction("HasAbelianFactorGroup");

#############################################################################
##
#O  HasElementaryAbelianFactorGroup(<G>,<N>)
##
##  tests whether $G/N$ is elementary abelian.
DeclareGlobalFunction("HasElementaryAbelianFactorGroup");


#############################################################################
##
#F  IsGroupOfFamily(<G>)
##
##  This filter indicates that the group <G> is the group which is stored in
##  the family of its elements as `WholeGroup'.
DeclareFilter("IsGroupOfFamily");


#############################################################################
##

#E  grp.gd  . . . . . . . . . . . . . . . . . . . . . . . . . . . . ends here
##


