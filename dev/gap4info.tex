\documentclass{article}
\usepackage{a4}
\parindent=0pt
\parskip=\medskipamount
\def\GAP{\textsf{GAP}}
\let\code\texttt
\def\var#1{{\rmfamily\slshape#1}}
\def\bs{$\backslash$}
\title{Informational and Debugging Messages in \GAP\ 4}
\author{Steve Linton}
\begin{document}
\maketitle
\section{Introduction}

This is my notes of a meeting on Thursday September 14th 1995. I will
concentrate on the conclusions and the resons for them rather than the
deliberation.

\section{Reasons for messages}
A number of reasons for emitting messages from the \GAP\ library were
considered. They might:
\begin{description}
\item[Educate] giving the na\"\i ve user an idea of how the
calculations are being performed;
\item[Inform] giving the more sophisticated, but unfamiliar user an
idea of which algorithm is being used and how;
\item[Reassure] the user that something is still happing;
\item[Indicate progress] so that the user can estimate how long the
program will take;
\item[Help program tuning] providing higher-level profiling
information;
\item[Help control one-off computations] revealing for instance, when
an unnecessary and expensive computation is starting;
\item[Help program debugging] either by the original designer or a
subsequent maintainer/improver or
\item[Warn] the user when the program has some reason to think it may
not be doing what they wanted.
\end{description}

These haver been ordered to reflect some grouping which were perceived
to exist. The eventual conclusion was that the highest priority was
debugging/tuning/control, and the next reassurance/progress
monitoring/informing and that attempting to educate na\"ive users was
over-ambitious. Warning is a somewhat separate issue and likely to be rare.

\section{Control of Messages}

It is important for the user to be able to select which messages they
wish to see. The question is how to group the messages for this. The
final scheme agreed, was as follows:

Each message will have associated with it a non-empty list of
``categories'' and a level. The user will be able to set a level of
information for each category on a scale of:

\begin{description}
\item[0] no messages at all;
\item[1] a few messages, outlining the general progression of the
algorithm, and not assuming knowledge of the code;
\item[2] a moderate level of debugging messages which may assume some
knowledge of the code;
\item[3] all messages -- output may be copious.
\end{description}

A particular message will then be printed if the level of information
set for any of its categories is greater than or equal to the level of
the message.

It should be possible to globally set the level of all categories to a
value (which should normally be 0 or 1 or output may be excessive).

\section{Kernel Support}

Kernel support for these messages is needed simply to keep the source
code reasonably readable. In principle, the desired result could be
achieved by:

\begin{verbatim}
if ForAny([cat1,cat2,...,catn], c->level[c] >= level) then
	Print(<stuff>);
fi;
\end{verbatim}

This cannot simply be packaged as a \GAP\ function, since it would
then evaluate its arguments even when not printing, which would take
too long.

Accordingly, a keyword (probably \code{Info}) will be added so that

\begin{verbatim}
Info([cat1,cat2,...,catn],level,<stuff>);
\end{verbatim}

has the same effect as the above code fragment. It may also be
responsible for printing the \code{\#I} and optionally the CPU time
used and memory allocated.

\section{Defining the Categories}

It was eventually concluded that there are two likely ways in which a
user might wish to select which messages to see:
\begin{itemize}
\item messages about computations of a particular kind (eg
normalizer computations) and
\item messages about computations with a particular type of object (eg
permutation groups).
\end{itemize}

A problem that seems not worth solving is that we can only select
messages from code written to compute with a particular type of
object and not messages from code that actually \emph{is} computing
with that type of object. For example permutation group computations
performed by the generic group routines would be selected with the
other generic group routines, not with the permutation group routines.

A few messages, for example about conversions, will fit into more
categories, but this is not a problem.

In order that both developers and users should be able to remember
them, it was decided that there should be a fairly short list of
``public'' categories, defined and documented centrally. This does not
prevent developers defining ``private'' categories intended mainly for
use by them in debugging their own code.

\section{Other Issues of Good Practice}

Where possible, info messages should not run to more than one line.
 
Info messages should be in English (North American is acceptable).

Level 1 messages should be fairly rare. A user with everything
switched to level 1 should not be completely swamped. 

Avoid substantial computation in producing level 1 messages.

Avoid computation with side-effects at all levels.

Since most messages in a given file will have the same set of
categories, it is acceptable to put that list into a variable. To
protect against errors when code is moved between files, that variable
should have a unique name, and to avoid namespace pollution, it should
be unbound at the end of the file. Private categories should also have
unique names.

\section{Miscellaneous}

Tracing was agreed to be desirable, and complementary to these
methods, as a way to understand the behaviour of code supplied from
elsewhere, and perhaps lacking messages.

The possibility of an Assert keyword, operating in a similar way to
Info was discussed.

\end{document}




 





