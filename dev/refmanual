General process:
================

The idea is to store reference documentation as far as possible in the
GAP code. As the GAP code (for practical, conceptual, historical or
whatever) reasons keeps information separate that we want to keep together
for the manual (for example, which filters may imply 'IsFinite'), it seems
to be reasonable to access the manual files not sequantially but via a data
base built from them. (Otherwise we would have to read the full source
probably a few thousand times.)
This data base is internal and still to be specified.

The actual manual builder then takes 'skeleton' files that contain the
manual outline and fills these from the data base, producing a TeX file for
the manual. These skeleton files may contain further manual content that
would not reasonable fit into the GAP library.


   .g, .gd, .gi files      .msk files (manual skeleton)
         \                      /
	  \Database builder    /
	   \                  /
	    V                /
         Database           /
              \            /
	       \          /
	        V        V
             Manual builder
	            |
		    V
                 .tex files (for the reference manual)

We did see no reason not to make .msk files also TeXable (though without the
converter they would just print an outline), therefore the manual builder
will basically just replace information placeholders with the actual
information.

As an example consider the following declaration in a .gd file:

#############################################################################
##
#C  IsPiffle(<Wof>)
##
##  The subcategory of woffles consisting of all piffles. A piffle is a
##  woffle that can be borked.
##
IsPiffle := NewCategory("IsPiffle",IsWoffle);


Then the skeleton:


\Declaration{IsPiffle}
\beginexample
gap> 1+1;
\endexample
\Implications


would be converted to TeX code that outputs something like:


IsPiffle(<Wof>)    C

The subcategory of woffles consisting of all piffles. A piffle is a
woffle that can be borked.

gap> 1+1;

Implies: IsWoffle
(and probably further stuff).

Information pieces:
===================

By generous extrapolation of this example the following information pieces
are imaginable:

1. Formal file header, containing version number and 'this file
   implements ..' line
2. Header Text (like in 'mapping.gd') that explains the general setup.
   We may allow several header texts in one file, allowing to give heder
   texts to different sections of code.
3. Declarations in the comment (the #A, #C #P &c. lines)
4. Explanatory comment in a ## function/declaration header
5. Declaration lines. (Assignements of 'NewWhatever')
6. Implementation lines (Install(Other)Method
7. Implication lines (InstallTrueMethod &c.)

All this information will be fetched from the library files and be put into
the data base. (To make it not unhandily large, it might be a good idea to
store text not explicitly, but as 'filename, linerange', because it usually
will be accessed only once.)

Sometimes this information can be split further apart, sometimes information
is only sensible in context with other information. The commands available
in the skeleton files therefore access this information in different style.

Skeleton files:
===============

Each skeleton file will produce one TeX file. The Skeleton file contains the
TeX text for that TeX file and some special commands that will be replaced
by information fetched from the data base. Information in square brackets is
not compulsory

\FileHeader[nr]{file}
The (nr-th) header text of the given file (type 2).
(A file may have several header texts, see below.)

\Declaration{gizmo}
<gizmo> may be an operation, category, representation ,...
This creates a section for the gizmo. This section consists of the following
information:
- The declaration from the comment (information 3)
- Requirements to the arguments (from information 5)
- Explanatory text in the comment header (information 4)

A letter (CRPAO...) is printed to indicate whether it is a category, property
or whatsoever.

If the gizmo is an operation (thus also attribute, property) or
operation args, the explanatory text consists of the text from the 'gd'
file, followed by the (selected by #+, see below) 'gi' files.
?? should we guarantee anything about order ?? make it choosable ??

If the gizmo is an OperationArgs, the header may contain #D lines that give
argument restrictions (like the argflags list in NewOperation). These will
be dealt with like the argflags in NewOperation.

If a method for this operation is installed by 'InstallOtherMethod' and has
comment text (#+ selection) and has a declaration (#M line) this declaration
line will be added to the initial declaration lines (see multiple
declarations below). In this case situation the string NUMBER in the text
part will be replaced by the ordinal  indicating the position of the
declaration line in the declaration lines. (This allows text in the form:
'The NUMBER usage is ...')

If the gizmo is a property or an attribute letters S and T will be printed,
if setter and tester are installed under the standard names. (they will be
indexed under there full names however)

For attributes, it will print M if the attribute is mutable.

The following commands will work for the last gizmo declared:

\Implications[lev]
(Only sensible for categories &c.)
<lev> (defaulting to 1) is an integer interpreted binary:
1 List all categories &c. implied by the gizmo
2 List everything that implies gizmo
4 List everything that may follow from gizmo (if other gizmoes are set as
well) (information 7)
8 List everything that may (together with other things) may imply gizmo
(information 7)

\Methods
(Only sensible for operations)
Lists all argument tuple requirements for which methods are installed.

Multiple Declarations:
----------------------

A Declaration may declare multiple uses: Either in the 'gd' file multiple
uses are declared one by one or 'gi' files install other methods that have a
declaration header and comment text (see above). In this case, all
declarations are given (first the ones from the 'gd' file, then the oned
from the 'gi' files).
(Duplicate lines, originating from 'InstallOtherMethod' headers, are
ignored. 

\RequireVersion{filename}{version}

Issue an error if file <filename> is not at least <version>. 

At some point we might want to introduce further commands like %texonly ore
%htmlonly to permit to obtain the html files also directly from the skeleton
files, but this does not seem to be urgent.

Lines starting with %% are comments that should go to the TeX file, they are
copied with the initial %% replaced by %. Other comment lines will be
removed.

Formal TeXability:
------------------

A skeleton file alone should be TeXable (and then basically just print the
information therin), this requires a suitable header and footer. They can be
separated by a %header and %footer line. They will be stripped off by the
converter and be replaced by suitable manual header files.

GAP Files:
==========

It seemed to us that information is most best kept in .gd files, but there
were enough exception to this rule to persuade us to consider also the other
files. (One reason for this is to permit to print information about the
actual methods installed, for example if - though the operation  is general
- only methods for a very restricted set of parameters are installed.)

To limit the information printed in the manual (there might be - for
whatever reason - hideous comments, declarations or method installements
in the library that should not get into the manual, the following scheme is
used:

Text in a 'gd' file that starts with '#-' is not printed.

Text in a 'gi' and 'g' file that starts with '#+' is printed (otherwise it
is ignored)

Notes and ToDo statements (#N and #T) are generally ignored.

Each header text in a file is introduced by a '#<x>' comment (where <x> is a
number) in the first
line, this permits to have several header texts in a file.

A text block ends if either the commented area ends or a new text block
(#<x>) explicitly is started.

Text in text blocks is stripped of the initial comment characters (#) and
all leading spaces and the put into the TeX file.

Getting started:
================

We will try to provide a converter as soon as possible. Until then, the best
strategy for documenting is probably to document the 'gd' files (as already
done for example for 'mapping.gd').


