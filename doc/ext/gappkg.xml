<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  gappkg.tex                GAP documentation             Werner Nickel -->
<!-- %W                                                       Alexander Hulpke -->
<!-- %% -->
<!-- %H  @(#)<M>Id: gappkg.tex,v 4.19 2006/03/09 16:59:53 gap Exp </M> -->
<!-- %% -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Writing a GAP Package">
<Heading>Writing a GAP Package</Heading>

This chapter explains  the basics of how to write  a &GAP; package so
that it interfaces properly to &GAP;. For the role of &GAP; packages
and  the ways  to load  them,
see Chapter&nbsp;<Ref Chap="GAP Packages"/>.
<P/>
There are  two basic aspects of  creating a &GAP; package.  First, it
is  a convenient  possibility  to load  additional functionality  into
&GAP; including  a smooth  integration of the  package documentation.
And  secondly,  a  package  is  a way  to  make  your  code  available
to  other  &GAP; users.  The  &GAP;  Group  provides some  help  with
the  distribution  of  packages.  In  particular,  a  package  can  be
submitted  to a  refereeing process.  Check out  the &GAP;  Web pages
<URL>http://www.gap-system.org</URL> for more details.
<P/>
We start this  chapter with a description how  the directory structure
of a  &GAP; package must  look like and  then add remarks  on certain
aspects  of creating  a  package, some  of these  only  apply to  some
packages. 


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The Files of a GAP Package">
<Heading>The Files of a GAP Package</Heading>

All files of a &GAP; package must be collected in a single directory.
To use the  package with &GAP; this directory must  be a subdirectory
of a  <F>pkg</F> directory  in (one  of) the  &GAP; root  directories,
see <Ref Sect="GAP Root Directory"/>.
(For  example, if  &GAP; is  installed in
<F>/usr/local/gap4</F> then put  the files of your package <C>MyPack</C> in
the directory  <F>/usr/local/gap4/pkg/mypack</F>.)
Let us call this directory the <E>home directory</E> of the package.
<P/>
There  are  three file  names  with  a  special  meaning in  the  home
directory of  a package:
<F>PackageInfo.g</F> and  <F>init.g</F> which  must be
present and <F>read.g</F> which is optional.
<P/>
The file  <F>PackageInfo.g</F> contains meta-information about  the package
(package  name,  version,  author(s),  relations  to  other  packages,
homepage, download archives, banner, ...). This is used by the package
loading mechanism and also for the  distribution of a package to other
users. The  content of this file  is explained via a  template file 
below (see <Ref Sect="The PackageInfo.g File"/>).
<P/>
The file <F>init.g</F> is read when the package is loaded
(see <Ref Func="LoadPackage"/>).
In principle  this file  could contain  the whole
&GAP; code  of a package,  but usually  it contains mainly
<Ref Func="Read"/> or
<Ref Func="ReadPackage"/> statements for reading further files
of the package. For
many packages it may be  useful to have declaration and implementation
parts in  different files,
see <Ref Sect="Declaration and Implementation Part of a Package"/>
below for more details. In that case  it can be useful to read in only
the declaration parts from the <F>init.g</F> file and to add 
a file  <F>read.g</F> which contains the
<Ref Func="ReadPackage"/> statements  for the
implementation parts.
<P/>
There is one  further rule for the location of  kernel library modules
or  external  programs
which is explained in <Ref Sect="Installation of GAP Package Binaries"/>
below.
<P/>
All other files can be organized as  you like. But we suggest that you
have  a look  at  existing  packages and  use  a  similar scheme.  For
example, collect your &GAP; code in  files in a subdirectory <F>lib</F> or
<F>gap</F>, put the documentation in  a subdirectory <F>doc</F>,
put source code for compilation in <F>src</F>,
data libraries in extra subdirectories and so on.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Writing Documentation">
<Heading>Writing Documentation</Heading>

<Index Key="README" Subkey="for a GAP package"><C>README</C></Index>
If you  intend to  make your  package available to  other users  it is
essential  to include  a documentation  how  to install  and use  your
programs.
<P/>
Concerning the installation  you should produce a  file <F>README</F> which
gives a short  description of the purpose of the  package and contains
proper instructions how to install your package. Again, check out some
existing packages to get an idea how this could look like.
<P/>
Concerning  the  documentation  of  the   use  of  the  package  there
are  currently  two  recognised   ways  of  producing  &GAP;  package
documentation.
First, there is an XML-based documentation format
that is defined in and can be used with the &GAPDoc; package
(see&nbsp;<Ref Chap="Introduction and Example" BookName="gapdoc"/>).
Second, there is a method which requires the documentation to be
written in &TeX; according to the format described in
the document <Q>The gapmacro.tex Manual Format</Q>.
<P/>
In  principle it  is also  possible to  use some  completely different
documentation   format.  In   that  case   you  need   to  study   the
Chapter&nbsp;<Ref Chap="Interface to the GAP Help System"/> to learn
how to make your documentation available to the &GAP; help system.
There should be at least a text version of your documenation provided for use
in the terminal running  &GAP; and some nicely printable version in
<C>.pdf</C> and/or <C>.dvi</C> format.
Many &GAP; users like to browse the documentation in HTML format
via their Web browser.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="An Example of a GAP Package">
<Heading>An Example of a GAP Package</Heading>

We illustrate  the creation  of a  &GAP; package by  an example  of a
basic package. 
<!-- %%  ???(The following assumes  that you are using &GAP; under UNIX.) -->
<P/>
Create  the  following  directories  in  your  home  area:  <F>pkg</F>  and
<F>pkg/test</F>. Inside the directory <F>test</F> create an empty file <F>init.g</F>,
and a file <F>PackageInfo.g</F> with the following contents.
<P/>
<Log><![CDATA[
SetPackageInfo( rec(
  PackageName := "test",
  Version := "1.0",
  AvailabilityTest := ReturnTrue,
  Autoload := false,
  BannerString := Concatenation( [
      "#I  loading the GAP package ``test'' in version ",
      ~.Version, "\n" ] ),
  PackageDoc := rec(
      BookName  := "test",
      SixFile   := "doc/manual.six",
      Autoload  := true ) ) );
]]></Log>
<P/>
This file  declares the &GAP;  package with name <Q>test</Q>  in version
1.0. There are no requirements that have to be tested,
so <Ref Func="ReturnTrue"/> is used as test function.
The  package is  not autoloaded, and  it has  its individual
banner string.  The package  documentation consists of  one autoloaded
book; the <C>SixFile</C> component is needed by the &GAP; help system.
<P/>
Now start &GAP; with the command
<Log><![CDATA[
gap -l "./;"
]]></Log>
<P/>
(The <C>-l "./;"</C>  option adds the current directory to  the &GAP; root
directories and  allows &GAP; to  find the packages installed  in the
<F>./pkg</F> directory.)
<P/>
<Log><![CDATA[
gap> LoadPackage("test");
#I  loading the GAP package ``test'' in version 1.0
true
]]></Log>
<P/>
This &GAP; package is too simple  to be useful, but we have succeeded
in loading it via <Ref Func="LoadPackage"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The WWW Homepage of a Package">
<Heading>The WWW Homepage of a Package</Heading>

If  you want  to  distribute  your package  you  should  create a  WWW
homepage containing some basic  information, archives for download and
the <F>README</F> file with installation  instructions, and maybe a copy of
the package's <F>PackageInfo.g</F> file.
<P/>
The  responsibility  for  this  WWW   homepage  is  with  the  package
authors/maintainers.
<P/>
If you tell us about your package
(say, by mail to <Email>support@gap-system.org</Email>)
we may agree to add a link to your package homepage from the &GAP; website
and to redistribute the current version of your package via the &GAP;
download sites.
We can also provide some service for producing several archive formats from
the archive you  provide (e.g., you produce a <C>.tar.gz</C> version of your
archive and we produce also a <C>.tar.bz2</C>, a <C>.zoo</C>
and a <C>-win.zip</C> version from this). 
<P/>
Please,  consider  to  submit  your  package  to  the  &GAP;  package
refereeing process.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The PackageInfo.g File">
<Heading>The PackageInfo.g File</Heading>

We  suggest to  create  a  <F>PackageInfo.g</F> file  for  your package  by
copying the one in the <C>Example</C> package, distributed with &GAP;, and
to adjust it for your package. Within &GAP; you can look at that file
by
<P/>
<Log><![CDATA[
Pager(StringFile(Filename(DirectoriesLibrary(), 
                          "../pkg/example/PackageInfo.g")));
]]></Log>
<P/>
As a first step the example in <Ref Sect="An Example of a GAP Package"/>
shows the information needed for the package loading mechanism of a simple
package.  If  your  package  depends on  the  functionality  of  other
packages, the  component <C>Dependencies</C>  given in  the
<F>PackageInfo.g</F> file becomes  important,
see <Ref Sect="Requesting one GAP Package from within Another"/> below.
<P/>
The  other entries  become relevant  if  you want  to distribute  your
package: they  contain lists  of authors and/or  maintainers including
contact information,  URLs of the  package archives and  README files,
status information, text  for a package overview Web page,  and so on.
See the  mentioned template  file for  a list  and explanation  of all
recognized entries.
<P/>
Once   you   have   created   the  <F>PackageInfo.g</F>   file   for   your
package,   you    can   test    its   validity   with    the   command
<C>ValidatePackageInfo</C>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Requesting one GAP Package from within Another">
<Heading>Requesting one &GAP; Package from within Another</Heading>

It is possible for one &GAP; package <C>A</C>, say,
to require another package <C>B</C>.
For that, one simply adds the name and the (least) version number of the
package <C>B</C> to the <C>NeededOtherPackages</C> component of the
<C>Dependencies</C> component of the <F>PackageInfo.g</F> file of the package
<C>A</C>.
In this situation, loading the package <C>A</C> forces that also the package
<C>B</C> is loaded, and that <C>A</C> cannot be loaded if <C>B</C> is not
available.
<P/>
If <C>B</C> is not essential for <C>A</C> but should be loaded if it is
available
(for example because <C>B</C> provides some improvements of the main system
that are useful for <C>A</C>)
then the name and the (least) version number of <C>B</C> should be added to
the <C>SuggestedOtherPackages</C> component of the <F>PackageInfo.g</F> file
of <C>A</C>.
In this situation, loading <C>A</C> forces an attempt to load also <C>B</C>,
but <C>A</C> is loaded even if <C>B</C> is not available.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Declaration and Implementation Part of a Package">
<Heading>Declaration and Implementation Part of a Package</Heading>

<Index Key="init.g" Subkey="for a GAP package"><C>init.g</C></Index>
<Index Key="read.g" Subkey="for a GAP package"><C>read.g</C></Index>
When &GAP; packages require each other in a circular way,
a <Q>bootstrapping</Q> problem arises of defining functions before they are
called.
The same problem occurs in the &GAP; library, it is resolved there
by separating declarations (which define global variables such as
filters and operations)
and implementations (which install global functions and methods)
in different files.
Any implementation file may use global variables defined in any declaration
file.
&GAP; initially reads all declaration files (in the library they have a
<C>.gd</C> suffix) and afterwards reads all implementation files
(which have a <C>.gi</C> suffix).
<P/>
Something similar is possible for &GAP; packages:
If a file <F>read.g</F> exists in the home directory of the package,
this file is read only <E>after</E> all the <F>init.g</F> files of all
(implicitly) required &GAP; packages are read.
Thus one can separate declaration and implementation for a &GAP; package
in the same way as done for the &GAP; library,
by creating a file <F>read.g</F>,
restricting the <Ref Func="ReadPackage"/> statements in
<F>init.g</F> to only load those files of the package that provide
declarations,
and to load the implementation files from <F>read.g</F>.
<P/>
Note that the separation of the &GAP; code of packages into declaration
part and implementation part does <E>not</E> allow one to actually
<E>call</E> functions from a package when the implementation part is read.
For example, suppose that the package <C>A</C> requires another package
<C>B</C> providing a new function <C>f</C> or a new global record <C>r</C>,
say, which are declared in the declaration part of the package <C>B</C>.
Then the code in the implementation part of package <C>A</C> may contain
calls to the functions defined in the declaration part of package <C>B</C>.
However, the implementation part of package <C>A</C> may be read
<E>before</E> the implementation part of package <C>B</C>,
for example because the package <C>B</C> or one of its needed or suggested
packages requires package <C>A</C>.
So one cannot assume that during the loading of package <C>A</C>,
the function <C>f</C> can be called, or that one can access components of
the record <C>r</C>.
<P/>
If a package needs initializations which depend on code that it provided
by other packages then one way out of this problem is to delay this
initialization until all required packages are completely loaded.
This can be done by moving the declaration and implementation of the
variables that are created in the initialization into a separate file
and to declare these variables in the <F>init.g</F> file of the package,
via a call to <Ref Func="DeclareAutoreadableVariables"/>.
<P/>
See Section&nbsp;<Ref Sect="Declaration and Implementation Part of a Package"/>
which discusses further the commands that should appear in the
declaration part (i.e., in the files read with
<Ref Func="ReadPackage"/> from <F>init.g</F>)
and in the implementation part (i.e., in the files read with
<Ref Func="ReadPackage"/> from <F>read.g</F>) of a package.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Standalone Programs in a GAP Package">
<Heading>Standalone Programs in a &GAP; Package</Heading>

&GAP; packages that  involve stand-alone programs are fundamentally
different from &GAP; packages that consist entirely of &GAP; code.
<P/>
This difference is threefold: A  user who installs the &GAP; package
must also  compile (or install) the package's  binaries, the
package must  check whether the binaries  are indeed available,
and finally the &GAP; code of the package has to start the external
binary and to communicate with it.
We will treat these three points in the following sections.
<P/>
If the package does not solely consist of an interface to an external
binary and if the external program called is not just special-purpose
code, but a generally available program, chances are high that sooner
or later other &GAP; packages might also require this program.
<P/>
We therefore strongly suggest to provide a documented &GAP; function
that will call the external binary. We also suggest to create actually
two &GAP;  packages; the first providing only the binary and the
interface and the second (requiring the first,
see&nbsp;<Ref Sect="Requesting one GAP Package from within Another"/>)
being the actual &GAP; package.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="Installation of GAP Package Binaries">
<Heading>Installation of &GAP; Package Binaries</Heading>

The scheme for the installation of package binaries which is described
further on is intended to permit  the installation on different
architectures which  share a common file  system (and share the
architecture independent file).
<P/>
A &GAP; package  which includes external binaries contains a <F>bin</F>
subdirectory. This subdirectory in turn contains subdirectories for
the different architectures on which the &GAP; package binaries are
installed.  The names of these directories must be the same as the
names of the architecture dependent subdirectories of the main <F>bin</F>
directory. Unless you use a tool like <C>autoconf</C> yourself, you must
obtain the correct name of the binary directory from the main &GAP;
branch. To help with this, the main &GAP; directory contains a file
<F>sysinfo.gap</F> which assigns the shell variable <C>GAParch</C> to the
proper name as determined by &GAP;'s <C>configure</C> process.
For example on a Linux system, the file <F>sysinfo.gap</F> may look like
this:
<P/>
<Log><![CDATA[
GAParch=i586-unknown-linux2.0.31-gcc
]]></Log>
<P/>
We suggest that your &GAP; package contains a file <F>configure</F> which
is  called with the  path of  the  &GAP; root directory  as
parameter. This file then  will  read <F>sysinfo.gap</F> and set  up
everything for compiling under the given architecture (for example
creating a <F>Makefile</F> from <F>Makefile.in</F>.
<P/>
The standard &GAP; distribution contains a &GAP; package <Q>example</Q>
whose installation script shows an example way of how to do this.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="Test for the Existence of GAP Package Binaries">
<Heading>Test for the Existence of GAP Package Binaries</Heading>

If an external binary is essential for the  workings of a &GAP; package,
the function stored in the component <C>AvailabilityTest</C> of the
<F>PackageInfo.g</F> file of the package should test whether the program
has been compiled on the architecture (and inhibit package loading
if this is not the case).
This is especially important if the package is loaded automatically.
<P/>
The easiest way to accomplish this is to use
<Ref Func="Filename" Label="for a directory and a string"/>
for checking for the actual binaries in the path given by
<Ref Func="DirectoriesPackagePrograms"/>
for the respective package.
For example the <Q>example</Q> &GAP; package could use the following commands
to test whether the binary <F>hello</F> has been compiled;
they issue a warning if not and will only load if it is indeed available.
<P/>
<Log><![CDATA[
...
AvailabilityTest := function()
  local path,file;
    # test for existence of the compiled binary
    path:=DirectoriesPackagePrograms("example");
    file:=Filename(path,"hello");
    if file=fail then
      Info(InfoWarning,1,
        "Package ``example'': The program `hello' is not compiled");
      Info(InfoWarning,1,
        "`HelloWorld()' is thus unavailable");
      Info(InfoWarning,1,
        "See the installation instructions; ",
        "type: ?Installing the Example package");
    fi;
    return file<>fail;
  end,
...
]]></Log>
<P/>
(In fact the <C>AvailabilityTest</C> function that is actually used
in the <Q>example</Q> package always returns <K>true</K>,
just the warnings are printed if the binary is not available.
This means that the binary is not regarded as essential for this
package.)
<P/>
You might also have to cope with the situation that external binaries will
only run under UNIX (and not, say on a Macintosh).
See&nbsp;<Ref Sect="Testing for the System Architecture"/>
for information on how to test for the architecture.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="Calling of and Communication with External Binaries">
<Heading>Calling of and Communication with External Binaries</Heading>

There are two reasons for this: the input data has  to be passed on to
the stand-alone program and the  stand-alone program  has to be  started
from within &GAP;.
<P/>
There are two principal ways of doing this.
<P/>
The first possibility is to write  all the data for the stand-alone to
one or  several files,  then start the  stand-alone with
<Ref Sect="Process"/> or <Ref Sect="Exec"/>
which then writes the output data to file, and finally read in
the standalone's output file.
<P/>
The second way is interfacing via iostreams,
see Section&nbsp;<Ref Sect="Input-Output Streams"/>.

</Subsection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Autoreadable Variables">
<Heading>Autoreadable Variables</Heading>

Package files containing method installations must be read
when the package is loaded.
Note that the completion mechanism used in the main &GAP; library
(see Section&nbsp;<Ref Sect="Completion Files"/>)
cannot be used for packages.
<P/>
For package files <E>not</E> containing method installations
&ndash;this applies to many data files&ndash;
another mechanism allows one to delay reading such files
until the data are actually accessed.

<#Include Label="DeclareAutoreadableVariables">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Version Numbers">
<Heading>Version Numbers</Heading>

<Index Key="GAPInfo.Version"><C>GAPInfo.Version</C></Index>
A version number is a string which contains nonnegative integers separated
by non-numeric characters. Examples of valid version numbers are for
example:
<P/>
<Log><![CDATA[
"1.0"   "3.141.59"  "2-7-8.3" "5 release 2 patchlevel 666"
]]></Log>
<P/>
Version numbers are interpreted as  lists of integers and are compared
in that way. Thus version <C>"2-3"</C> is larger than version <C>"2-2-5"</C>
but smaller than <C>"11.0"</C>.
<P/>
It  is  possible  for  code  to require  &GAP;  packages  in  certain
versions. In this case, all versions,  whose number is equal or larger
than  the requested  number  are acceptable.  It is  the  task of  the
package author to provide upwards compatibility.
<P/>
Loading a specific version of a package (that is, <E>not</E> one with a
larger version number) can be achieved by prepending <C>=</C> to the desired
version number.
For example, <C>LoadPackage( "example", "=1.0" )</C> will load version
<C>"1.0"</C> of the package <C>"example"</C>,
even if version <C>"1.1"</C> is available.
As a consequence, version numbers must not start with <C>=</C>,
so <C>"=1.0"</C> is not a valid version number.
<P/>
The global  variable <C>GAPInfo.Version</C> contains the  version number of
the  version  of  &GAP;  and  also  can  be  checked  against,
using <Ref Func="CompareVersionNumbers"/>.
<P/>
Package authors should choose a version numbering scheme that admits a
new  version  number even  after  tiny  changes  to the  package.  The
automatic update of  package archives in the  &GAP; distribution will
only work if a package has a new version number.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Wrapping Up a GAP Package">
<Heading>Wrapping Up a GAP Package</Heading>

<Index Key="zoo"><C>zoo</C></Index>
The releases of &GAP; packages are independent of releases of &GAP;.
Therefore &GAP; packages should be wrapped up in separate files that can be
installed onto any version of &GAP;. Similarly a &GAP; package can be
upgraded any time without the need to wait for new releases of &GAP;.
<P/>
Because it is independent of the version of &GAP; a &GAP; package should be
archived from the &GAP; <F>pkg</F>  directory,
that is all files are archived with the path starting the package's name.
<P/>
<Index Key="GAPDocManualLab"><C>GAPDocManualLab</C></Index>
The archive of  a &GAP; package should contain all  files necessary for the
package to  work. In  particular there should  be a  compiled documentation,
which includes the <F>manual.six</F>, <F>manual.toc</F> and <F>manual.lab</F>
file in the
documentation subdirectory which are created by &TeX;ing the documentation,
if you  use the  <F>gapmacro.tex</F> or  &GAPDoc; document  formats.
(The first two are needed by the &GAP; help system,
and the <F>manual.lab</F> file is needed if the main manuals or another
package is referring to your package.
Use the command <C>GAPDocManualLab( packagename );</C> to create this file
for your help books if you use &GAPDoc;.)
<P/>
Currently, the &GAP; distribution provides archives in four different
formats.
<P/>
<List>
<Item>
  <F>.tar.gz</F>, a standard UNIX <C>tar</C> archive,
  compressed with <C>gzip</C>
</Item>
<Item>
  <F>.tar.bz2</F>, a standard UNIX <C>tar</C> archive,
  compressed with <C>bzip2</C>
</Item>
<Item>
  <F>.zoo</F>, a special version of <C>zoo</C> archives,
  that can essentially be used on all operating systems with the
  <C>unzoo</C> utility provided with the &GAP; distribution
</Item>
<Item>
  <F>-win.zip</F>, an archive in <C>zip</C> format,
  where text files should have DOS/Windows style line breaks
</Item>
</List>
<P/>
For convenience of possible users it is sensible that you archive your
package also in one or several of these formats.
<P/>
For packages which are redistributed via the &GAP; Web site, we offer
an automatic conversion of any of  the formats listed above to all the
others.

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->

