
<!-- 

  cvshints.xml          GAP documentation    

  Copyright (C) 2005,  The GAP Group

Reminder on basic CVS commands.

-->

<Chapter Label="Chap-CVS">
<Heading>Basic <C>cvs</C>-commands for &GAP; developers</Heading>

The source code for the &GAP; kernel, the &GAP; library and most &GAP;
packages is kept in a central repository in St.&nbsp;Andrews. The tool
to administrate this repository is called CVS, the 
<Q>Concurrent Versions System</Q>.
<P/>
This chapter recalls some basic CVS commands. Most of the time very few
commands are sufficient. But there are also rare tasks like tagging a new
release branch, or transferring changes from one branch to another, for
which some developers may not remember the details by heart.

<Section Label="Sect-BasicCVS">
<Heading>Basic commands to use one CVS branch</Heading>

If you know basic CVS usage, you can skip this section apart from
the address of the &GAP; CVS repository below.

<P/>
To work on the &GAP; source code, one <Q>checks out</Q> a working copy.
All changes are first done in this working copy and then <Q>commited</Q>
to the repository. CVS automatically takes care of revision numbers
for all the files and keeps all old revisions in the repository.

<P/>
To check out a working copy, you first have to have the password for access 
to the development version. Once you have this, you have to do the following
<E>exactly once</E>:

<Verb>
    cvs -d :pserver:gap@cvs.gap-system.org:/gap/CVS login
</Verb>

After that you have to type in the password. Your local CVS client will
put something into <C>~/.cvspass</C> in your home directory.

<P/>
Now you can check out the complete source code by doing:

<Verb>
    cvs -d :pserver:gap@cvs.gap-system.org:/gap/CVS checkout 4.0
</Verb>

This will create a directory called <F>4.0</F> in the current directory, 
under which your working copy resides. Note that this needs about
500 Mb of disk space.

<P/>
Every subdirectory under the tree <F>4.0</F> contains a subdirectory
called <F>CVS</F>. Usually you should not touch these. They are used
for CVS interals.

<P/>
From now on you can always update your working copy from the repository
by doing

<Verb>
    cvs update
</Verb>

in any subdirectory of <F>4.0</F> (including <F>4.0</F>). This will update
the current directory and all its subdirectories recursively.

<P/>
CVS will report on the status of the update:

<List>
    <Item> U or P means the local file was updated/patched by CVS. </Item>
    <Item> M means the local file has changes that are not in CVS 
        (use <C>cvs diff</C> to see which) </Item>
    <Item> C means conflicts, see below.</Item>
</List>

Note that if you made changes to any files and the repository has
changed since your last update or checkout, then CVS tries to merge
the changes into your working copy. Usually this works well, however
conflicts may occur (indicated by a letter C before the filename in the
output of <C>cvs update</C>, see above). In this case you have to edit
the files by hand, looking for occurances of the string 
<Q>&lt;&lt;&lt;&lt;&lt;&lt;</Q> to resolve the conflicts.

<P/>
Note also, that newly created subdirectories in the repository are 
<E>not automatically</E> checked out by <C>cvs update</C>. To achieve
this, use 

<Verb>
    cvs update -d
</Verb>

When you have changed files in your working copy, you can use

<Verb>
    cvs commit
</Verb>

in the corresponding directory to commit your changes to the repository.
This command commits all changes in all files in the current directory
and in all subdirectories recursively. If you want to commit only changes
to certain files, then put their names after the <C>cvs commit</C>
command.

<P/>
You are asked to submit a log entry describing your changes. This
log entry is stored together with the changed files in the repository.
To this end, an editor is opened and after saving and closing it the
commit is performed. It is good practice to put your name or initials
into the log entry, such that one knows afterwards, whom to ask about a
particular change.

<P/>
If you created new files you have to do

<Verb>
    cvs add FILENAME
</Verb>

in the directory of the new file, with <Q>FILENAME</Q> replaced with the
name of the new file. This marks the file for addition in the next commit,
that is, it will appear in the repository after the next commit.

<P/>
Note that non-ASCII files have to be added with the option <C>-kb</C> (directly
after the <Q>add</Q>). This prevents certain changes that CVS automatically
do to text files, which could destroy binary files. Usually it is not
good idea at all to put binary files into the repository, because things
like differences between revisions, compact storage of different
revisions, and merging of conflicting changes do not work well. Also
lots of disk space is needed to keep old revisions of binary files.

<P/>
To remove a file from the repository, first delete it in your working copy
and then use

<Verb>
    cvs remove FILENAME
</Verb>

analogously. Note that old revisions of the file still reside in the
repository, however, checkouts no longer fetch them.

</Section>

<Section Label="Sect-RevisionsCVS">
<Heading>Revision numbers of files</Heading>

CVS automatically keeps a revision number for each revision of each file.
For every commit, this revision number is increased. You can access
any old revision of a file by using commands like

<Verb>
    cvs update -r 1.17 FILENAME
</Verb>

which retrieves revision 1.17 of file <F>FILENAME</F>. Note that from this
command on further <C>cvs update</C> calls will always retain this revision
of that file in your working copy, the revision is <Q>sticky</Q>. If you 
want to get rid of this sticky revision and update again to the latest
revision, just use

<Verb>
    cvs update -A FILENAME
</Verb>

You can get information about the revision in your working copy and in the
repository by doing

<Verb>
    cvs status FILENAME
</Verb>

This also shows you possible sticky tags. Another interesting command
is 

<Verb>
    cvs log FILENAME
</Verb>

which shows you the revision history together with the log entries of
the file <F>FILENAME</F>. In addition, at the beginning of the output
a list of symbolic <Q>tags</Q> and their meaning in terms of revision
numbers is shown. A symbolic tag marks all the revisions of all files
having some common property. For example, the symbolic tag <Q>GAP4R4</Q>
refers to the revision that was last released with &GAP; version&nbsp;4,
release&nbsp;4. See the next section for details.

<P/> 
You can always use symbolic tags instead of revision numbers,
for example in a call like

<Verb>
    cvs update -r GAP4R4
</Verb>

</Section>

<Section Label="Sect-BranchCVS">
<Heading>Branches and the revisions tree</Heading>

The set of revision numbers of a file in the CVS repository is <E>not</E>
necessarily totally ordered. Rather, one can fork of <Q>branches</Q> such
that a partial order like a tree results. 

<P/>
For &GAP;, the development version is the main branch, and a new branch
is created for every major release. So for example the branch for
the currently released version of &GAP; version&nbsp;4, release&nbsp;4 has the
symbolic tag <Q>GAP4R4</Q>. By convention, changes that shall
go into the released version with the next bugfix or update are kept in that
branch.

<P/>
Therefore, any change in the development version, that shall be published
with the next bugfix or update, has to be transferred into the released
branch. This is done as follows:

<P/>
We assume that you have a checked out working copy of the development
version and that the change is done in file <F>xyz.g</F> between
revisions 1.98 and 1.99, already checked into the repository.
If more than one file was changed, you have to repeat the process
described below for each of those. Note that the revision numbers
are different for each file!

<P/>
The first step is to check out the latest version in the released branch.
Assuming that we work on the GAP4R4 branch, this is done by:

<Verb>
    cvs update -r GAP4R4 xyz.g
</Verb>

Now we have to change this revision in the same way as the file was changed
between revisions 1.98 and 1.99 in the development version. This is done
as follows:

<Verb>
    cvs update -j 1.98 -j 1.99 xyz.g
</Verb>

Note that this might produce conflicts (see section 
<Ref Sect="Sect-BasicCVS"/>), which have to be resolved by hand (search
for the string <Q>&lt;&lt;&lt;&lt;&lt;&lt;</Q>).

<P/>
Now the change has to be commited to the GAP4R4 branch by

<Verb>
    cvs commit xyz.g
</Verb>

and entering a log entry describing the change. Note, that the file in your
working copy is now <Q>sticky</Q> to the GAP4R4 branch and you have to do

<Verb>
    cvs update -A xyz.g
</Verb>

to get rid of the sticky tag and again work with the latest development
version.

<P/>
Remember to edit <F>4.0/dev/Update</F> (see section 
<Ref Sect="Sect-CommitForRelease"/>), such that the information about
your change is not lost.

<P/>
Another possibility is to check out a full working copy of the released
branch. This is done by using the <C>-r GAP4R4</C> option already in the
<C>cvs checkout</C> command described in section 
<Ref Sect="Sect-BasicCVS"/>. If you do this you can skip the two steps
<C>cvs update -r GAP4R4 xyz.g</C> and <C>cvs update -A xyz.g</C> above. On 
the other hand, you need twice as much disk space to keep two full working
copies.

<P/>
<E>To be continued with <Q>Forking off a new Branch</Q> for a release.</E>

</Section>

<Section Label="Sect-LogCVS">
<Heading>Digging out differences between revisions, log entries, 
and change dates</Heading>

Internally CVS uses the programs <C>diff</C> and <C>patch</C> to keep
track of different revisions of files. In the repository, all old
revisions are kept by only storing differences between revisions.
The user also has access to those differences with the commands described
in this section.

<P/>
To show the differences between say revisions 1.27 and 1.28 of file 
<F>xyz.g</F> you can use the following command:

<Verb>
    cvs diff -r 1.27 -r 1.28 -u xyz.g
</Verb>

Note that the <C>-u</C> switch chooses the so-called unified output
format (see <C>man diff</C> for different possibilities). Of course,
the output format is a matter of taste.

<P/>
Often it is convenient to first check the log entries (see section
<Ref Sect="Sect-RevisionsCVS"/>) using <C>cvs log xyz.g</C> to find out 
between which revisions the change you are interested in has been
applied.

<P/>
One can also specify symbolic tags or dates for either of the revisions.
In this case, dates refer to the most recent version no later than the
date you specify:

<Verb>
    cvs diff -u -D 1997/11/24 -r GAP4R4 xyz.g
</Verb>

If you give only one revision number, tag, or date, your current working
copy (may it be changed locally or not) is compared to that revision.
If you use <C>cvs diff -u xyz.g</C> without any revision, your current
working copy is compared to the latest revision in the repository.

</Section>

</Chapter>

