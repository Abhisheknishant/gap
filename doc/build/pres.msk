%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  pres.msk                   GAP documentation             Volkmar Felsch  
%A                                                           Alexander Hulpke
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%%
\Chapter{Presentations and Tietze Transformations}

A finite presentation describes a group but usually there is a multitude of
presentations that describe isomorphic groups. Therefore a presentation in
{\GAP} is different from a finitely presented group though there are ways to
translate between both. 

An important feature of presentations is that they can be modified (see
"Tietze Transformations").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Presentations}

\Declaration{PresentationFpGroup}
\Declaration{FpGroupPresentation}
\beginexample
gap> f:=FreeGroup("a","b");
Group( [ a, b ], ... )
gap> g:=f/[f.1^2,f.2^3,(f.1*f.2)^3];
Group( [ a, b ], ... )
gap> p:=PresentationFpGroup(g);
<< presentation with 2 gens and 3 rels of total length 11 >>
gap> h:=FpGroupPresentation(p);
Group( [ f1, f2 ], ... )
gap> h=g;
false
\endexample

\Declaration{PresentationViaCosetTable}

In general the command `IsomorphismFpGroup' (see "IsomorphismFpGroup")
should be used to compute a presentation for a finite group. 

\beginexample
gap> G := GeneralLinearGroup( 2, 7 );
GL(2,7)
gap> GeneratorsOfGroup(G);
[ [ [ Z(7), 0*Z(7) ], [ 0*Z(7), Z(7)^0 ] ], 
  [ [ Z(7)^3, Z(7)^0 ], [ Z(7)^3, 0*Z(7) ] ] ]
gap> Size(G);
2016
gap> P:=PresentationViaCosetTable(G);
<< presentation with 2 gens and 5 rels of total length 46 >>
gap> TzPrintRelators(P);
#I  1. _x2^3
#I  2. _x1^6
#I  3. _x1*_x2*_x1*_x2*_x1*_x2*_x1*_x2*_x1*_x2*_x1*_x2
#I  4. _x1*_x2*_x1^-1*_x2*_x1*_x2^-1*_x1^-1*_x2*_x1*_x2*_x1^-1*_x2^-1
#I  5. _x1^-3*_x2*_x1*_x2*_x1^-1*_x2^-1*_x1^-1*_x2^-1*_x1^-2*_x2
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroup Presentations}

\Declaration{PresentationSubgroup}
\Declaration{PresentationSubgroupRrs}

\beginexample
gap> g:=f/[f.1^2,f.2^3,(f.1*f.2)^5];
Group( [ a, b ], ... )
gap> u:=Subgroup(g,[g.1,g.1^g.2]);
Group( [ a, b^-1*a*b ], ... )
gap> p:=PresentationSubgroup(g,u);
<< presentation with 3 gens and 4 rels of total length 12 >>
\endexample

The Reduced Reidemeister-Schreier algorithm is a modification of the
Reidemeister-Schreier algorithm of George Havas \cite{Hav74b}.  It was
proposed by Joachim Neub{\accent127u}ser and first implemented in 1986 by
Andrea Lucchini and Volkmar Felsch in the SPAS system \cite{Spa89}. Like
the Reidemeister-Schreier algorithm of George Havas, it needs only the
presentation of <G> and a coset table of <H> in <G> to construct a
presentation of <H>.

Whenever you call the `PresentationSubgroupRrs' command, it first obtains
a coset table of <H> in <G> if not given.
Next, a set of generators of <H> is determined by reconstructing the
coset table and introducing in that process as many Schreier generators
of <H> in <G> as are needed to do a Felsch strategy coset enumeration
without any coincidences. (In general, though containing redundant
generators, this set will be much smaller than the set of all Schreier
generators.  That is  why  we  call  the  method  the  *Reduced*
Reidemeister-Schreier.)

After having constructed this set of *primary subgroup generators* , say,
the coset table is extended to an *augmented coset table* which describes
the action of the group generators on coset representatives, i.e., on
elements instead of cosets. For this purpose, suitable words in the
(primary) subgroup generators have to be associated to the coset table
entries. In order to keep the lengths of these words short, additional
*secondary subgroup generators* are introduced as abbreviations of
subwords. Their number may be large.

Finally, a Reidemeister rewriting process is used to get defining
relators for <H> from the relators of <G>. As the resulting presentation
of <H> is a presentation on primary *and* secondary generators, in
general  you will  have  to  simplify  it  by appropriate Tietze
transformations (see "Tietze Transformations") or by the `DecodeTree'
command (see "DecodeTree") before you can use it.  Therefore it is
returned in the form of a presentation, <P> say.

Compared with the Modified Todd-Coxeter method described below, the
Reduced Reidemeister-Schreier method (as well as Havas{\pif} original
Reidemeister-Schreier program) has the advantage that it does not require
generators of <H> to be given if a coset table of <H> in <G> is known.
This provides a possibility to compute a presentation of the normal
closure of a given subgroup (see the `PresentationNormalClosureRrs'
command below).

As you may be interested not only to get the resulting presentation, but
also to know what the involved subgroup generators are, the function
`PresentationSubgroupRrs' will also provide a  list  of the primary
generators of <H> as words in the generators of <G>.  It is provided in
the attribute `PrimaryGeneratorWords' of the resulting presentation <P>.

\Declaration{PrimaryGeneratorWords}
\beginexample
gap> PrimaryGeneratorWords(p);
[ a, b^-1*a*b ]
\endexample

\Declaration{PresentationSubgroupMtc}

\beginexample
gap> p:=PresentationSubgroupMtc(g,u);
#I  there are 3 generators and 4 relators of total length 12
#I  there are 2 generators and 3 relators of total length 14
<< presentation with 2 gens and 3 rels of total length 14 >>
\endexample

The so called Modified Todd-Coxeter method was proposed, in slightly
different forms, by Nathan S.~Mendelsohn and William O.~J.~Moser in 1966.
Moser{\pif}s method was proved in \cite{BC76}.
It was generalized to cover a broad
spectrum of different versions (see the survey \cite{Neu82}).

The `Modified Todd-Coxeter' method performs an enumeration of coset
representatives.  It proceeds like an ordinary coset enumeration (see
"Coset Enumeration"), but as the product of a coset
representative by a group generator or its inverse need not be a coset
representative itself, the Modified Todd-Coxeter has to store a kind of
correction element for each coset table entry.  Hence it builds up a so
called *augmented coset table* of <H> in <G> consisting of the ordinary
coset table and a second table in parallel which contains the associated
subgroup elements.

Theoretically, these subgroup elements could be expressed as words in the
given generators of  <H>, but in  general these words tend  to become
unmanageable because of their  enormous lengths.  Therefore, a highly
redundant list of subgroup generators is built up starting from the given
(``*primary*'') generators   of  <H>  and   adding  additional
(``*secondary*'') generators which are defined as  abbreviations of
suitable words of length two in the preceding generators such that each
of the subgroup elements in the augmented coset table can be expressed as
a word of length at most one in the resulting (primary *and* secondary)
subgroup generators.

Then a rewriting process (which is essentially a kind of Reidemeister
rewriting process) is used to get relators for <H> from the defining
relators of <G>.

The resulting presentation involves all the primary, but not all the
secondary generators of <H>.  In fact, it contains only those secondary
generators which explicitly occur in the augmented coset table. If we
extended this presentation by those secondary generators which are not
yet contained in it as additional generators, and by the definitions of
all secondary  generators as additional relators, we would get a
presentation of <H>, but, in general, we would end up with a large number
of generators and relators.

On the other hand, if we avoid this extension, the current presentation
will not necessarily define <H> although we have used the same rewriting
process which in the case of the `SubgroupPresentationRrs' command
computes a defining set of relators for <H> from an augmented coset table
and defining relators of <G>. The different behaviour here is caused by
the fact that coincidences may have occurred in the Modified Todd-Coxeter
coset enumeration.

To overcome this problem without extending the presentation by all
secondary generators, the `SubgroupPresentationMtc' command applies the
so called *tree decoding* algorithm which provides a more economical
approach.  The reader is strongly recommended to carefully read section
"DecodeTree" where this algorithm is described in more detail. Here we
will only mention that this procedure adds many fewer additional
generators and relators in a process which in fact eliminates all
secondary generators from the presentation and hence finally provides a
presentation of <H> on the primary, i.e., the  originally given,
generators  of <H>.  This  is  a  remarkable  advantage  of  the
`SubgroupPresentationMtc'    command    compared    to    the
`SubgroupPresentationRrs' command.  But note that, for some particular
subgroup <H>, the Reduced Reidemeister-Schreier method might quite well
produce a more concise presentation.

The resulting presentation is returned in the form of a presentation,
<P> say.

As the function `PresentationSubgroupRrs' desribed above (see there for
details), the function `PresentationSubgroupMtc' returns a list of the
primary  subgroup generators  of  <H>  in the attribute
`PrimaryGeneratorWords' of <P>. In fact, this list is not very exciting here
because it is just a copy of the list `<H>.generators', however it is
needed to guarantee a certain consistency between the results of the
different functions for computing subgroup presentations.

Though the tree  decoding routine already involves a lot of Tietze
transformations,  we recommend that you try  to further simplify the
resulting presentation by appropriate Tietze transformations (see "Tietze
Transformations").

\Declaration{PresentationNormalClosureRrs}
\Declaration{PresentationNormalClosure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Relators in a Presentation}

In order to speed up the Tietze transformation routines,
each relator in a presentation <P> is internally represented by a
list of positive or negative generator numbers, i.e., each factor of the
proper {\GAP} word is represented by the position number of the
corresponding generator with respect to the current list of generators,
or by the respective negative number, if the factor is the inverse of a
generator. Note that the numbering of the generators in tietze words is
always relative to a generator list and bears no relation to the internal
numbering of generators in a family of associative words.

\Declaration{TietzeWordAbstractWord}
\Declaration{AbstractWordTietzeWord}

\beginexample
gap> F := FreeGroup( "a", "b", "c" ,"d");
Group( [ a, b, c, d ], ... )
gap> tzword := TietzeWordAbstractWord(
> Comm(F.4,F.2) * (F.3^2 * F.2)^-1, GeneratorsOfGroup(F){[2,3,4]} );
[ -3, -1, 3, -2, -2 ]
gap> AbstractWordTietzeWord( tzword,GeneratorsOfGroup(F){[2,3,4]});
d^-1*b^-1*d*c^-2
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Information about Presentations}

If some presentation <P>, say, contains a large presentation, then
it would be a nuisance to wait for the end of an unintentionally started
printout of all of its components.  Therefore, whenever
you use the standard print facilities to display a presentation,
{\GAP} will provide just one line of text containing the number of
generators, the number of relators, and the total length of all relators.

\Declaration{TzPrintStatus}
\Declaration{TzPrintGenerators}
\Declaration{TzPrintRelators}
\Declaration{TzPrintPresentation}
\Declaration{TzPrint}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Changing Presentations}

\Declaration{AddGenerator}
\Declaration{AddRelator}
\Declaration{RemoveRelator}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{SimplifiedFpGroup}

\Declaration{SimplifiedFpGroup}
\beginexample
gap> F6 := FreeGroup( 6, "G" );;
gap> G := F6 / [ F6.1^2, F6.2^2, F6.4*F6.6^-1, F6.5^2, F6.6^2,
> F6.1*F6.2^-1*F6.3, F6.1*F6.5*F6.3^-1, F6.2*F6.4^-1*F6.3,
> F6.3*F6.4*F6.5^-1, F6.1*F6.6*F6.3^-2, F6.3^4 ];;
gap> H := SimplifiedFpGroup( G );
Group( [ f1, f2 ], ... )
gap> RelatorsOfFpGroup(H);
[ f1^2, f1*f2^-1*f1*f2^-1, f2^4 ]
\endexample

In fact, the command

\begintt
H := SimplifiedFpGroup( G ); 
\endtt

is an abbreviation of the command sequence

\begintt
P := PresentationFpGroup( G, 0 );;
SimplifyPresentation( P );
H := FpGroupPresentation( P ); 
\endtt

which applies a rather simple-minded strategy of Tietze transformations
to the intermediate presentation <P>.
If for some concrete group the resulting presentation is unsatisfying,
then you should try a more sophisticated, interactive use of the
available Tietze transformation commands (see "Tietze Transformations").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Tietze Transformations}

The {\GAP} commands being described in this section can be used to modify
a group presentation in a presentation by Tietze transformations.

In general, the aim of such modifications will be to *simplify* the given
presentation, i.e., to reduce the number of generators and the number of
relators without increasing too much the sum of all relator lengths which
we will call the *total length* of the presentation. Depending on the
concrete presentation under investigation one may end up with a nice,
short presentation or with a very huge one.

Unfortunately there cannot be an algorithm which could be applied to find the
shortest presentation which can be obtained by Tietze transformations
from a given one. Therefore, what {\GAP} offers are some lower-level
Tietze transformation commands and, in addition, some higher-level
commands which apply the lower-level ones in a kind of default strategy
which of course cannot be the optimal choice for all presentations.

The design of these commands follows closely the concept of the ANU
Tietze transformation program \cite{Hav69} and its
later revisions (see \cite{HKRR84}, \cite{Rob88}).

\Declaration{TzGo}
\Declaration{SimplifyPresentation}

\beginexample
gap> F2 := FreeGroup( "a", "b" );;
gap> G := F2 / [ F2.1^9, F2.2^2, (F2.1*F2.2)^4, (F2.1^2*F2.2)^3 ];;
gap> a := G.1;; b := G.2;;
gap> H := Subgroup( G, [ (a*b)^2, (a^-1*b)^2 ] );;
gap> Index( G, H );
408
gap> P := PresentationSubgroup( G, H );
<< presentation with 8 gens and 36 rels of total length 111 >>
gap> PrimaryGeneratorWords(P);
[ b, a*b*a ]
gap> TzOptions(P).protected:=2;
2
gap> TzOptions(P).printLevel:=2;
2
gap> SimplifyPresentation(P);
#I  eliminating _x7 = _x5^-1
#I  eliminating _x5 = _x4
#I  eliminating _x18 = _x3
#I  eliminating _x8 = _x3
#I  there are 4 generators and 8 relators of total length 21
#I  there are 4 generators and 7 relators of total length 18
#I  eliminating _x4 = _x3^-1*_x2^-1
#I  eliminating _x3 = _x2*_x1^-1
#I  there are 2 generators and 4 relators of total length 14
#I  there are 2 generators and 4 relators of total length 13
#I  there are 2 generators and 3 relators of total length 9
gap> TzPrintRelators( P );
#I  1. _x1^2
#I  2. _x2^3
#I  3. _x2*_x1*_x2*_x1
\endexample

Roughly speaking, `TzGo' consists of a loop over a
procedure which involves two phases: In the *search phase* it calls
`TzSearch' and `TzSearchEqual' described below which try to reduce the
relator lengths by substituting common subwords of relators, in the
*elimination phase* it calls the command `TzEliminate' described below
(or, more precisely, a subroutine of `TzEliminate' in order to save some
administrative overhead) which tries to eliminate generators that can be
expressed as words in the remaining generators.

If `TzGo' succeeds in reducing the number of generators,
the number of relators, or the total length of all relators, then it
displays the new status before returning (provided that you did not set
the print level to zero). However, it does not provide any output if all
these three values have remained unchanged, even if the `TzSearchEqual'
command involved has changed the presentation such that another call of
`TzGo' might provide further progress. Hence, in such a
case it makes sense to repeat the call of the command for several times
(or to call instead the `TzGoGo' command which we will describe below).

\Declaration{TzGoGo}
\Declaration{TzGoCheap}

The result of the tietze transformations can be affected substantially by
the options parameters (see "Tietze Options").
To demonstrate the effect of the `eliminationsLimit' parameter, we will
give an example in which we handle a subgroup of index 240 in a group of
order 40320 given by a presentation due to B.~H. Neumann.  First we
construct a presentation of the subgroup, and then we apply to it the
\>TzGoGo'  command for different  values of the `eliminationsLimit
parameter (including the default value 100). In fact, we also alter the
`printLevel' parameter, but this is only done in order to suppress most
of the output.  In all cases the resulting presentations cannot be
improved any more by applying the `TzGoGo' command again, i.e., they are
the best results which we can get without substituting new generators.

\beginexample
gap> F3 := FreeGroup( "a", "b", "c" );;
gap> G := F3 / [ F3.1^3, F3.2^3, F3.3^3, (F3.1*F3.2)^5,
> (F3.1^-1*F3.2)^5, (F3.1*F3.3)^4, (F3.1*F3.3^-1)^4,
> F3.1*F3.2^-1*F3.1*F3.2*F3.3^-1*F3.1*F3.3*F3.1*F3.3^-1,
> (F3.2*F3.3)^3, (F3.2^-1*F3.3)^4 ];;
gap> a := G.1;; b := G.2;; c := G.3;;
gap> H := Subgroup( G, [ a, c ] );;
gap> for i in [ 28, 29, 30, 94, 100 ] do
> Pi:=PresentationSubgroup(G,H);
> TzOptions(Pi).eliminationsLimit:=i;
> Print("#I eliminationsLimit set to ",i,"\n");
> TzOptions(Pi).printLevel:=0;
> TzGoGo(Pi);
> TzPrintStatus(Pi);
> od;
#I eliminationsLimit set to 28
#I  there are 2 generators and 95 relators of total length 10817
#I eliminationsLimit set to 29
#I  there are 2 generators and 5 relators of total length 35
#I eliminationsLimit set to 30
#I  there are 3 generators and 98 relators of total length 2928
#I eliminationsLimit set to 94
#I  there are 4 generators and 78 relators of total length 1667
#I eliminationsLimit set to 100
#I  there are 3 generators and 90 relators of total length 3289
\endexample

Similarly, we demonstrate the influence of the `saveLimit' parameter by
just continuing the preceding example for some different values of the
`saveLimit' parameter (including its default value 10), but without
changing the `eliminationsLimit' parameter which keeps its default value
100.

\beginexample
gap> for i in [ 9, 10, 11, 12, 15 ] do
> Pi:=PresentationSubgroup(G,H);
> TzOptions(Pi).saveLimit:=i; 
> Print("#I saveLimit set to ",i,"\n");        
> TzOptions(Pi).printLevel:=0;
> TzGoGo(Pi);                 
> TzPrintStatus(Pi);
> od;
#I saveLimit set to 9
#I  there are 3 generators and 97 relators of total length 5545
#I saveLimit set to 10
#I  there are 3 generators and 90 relators of total length 3289
#I saveLimit set to 11
#I  there are 3 generators and 103 relators of total length 3936
#I saveLimit set to 12
#I  there are 2 generators and 4 relators of total length 21
#I saveLimit set to 15
#I  there are 3 generators and 143 relators of total length 18326
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Elementary Tietze Transformations}

\Declaration{TzEliminate}
\Declaration{TzSearch}

Two of the Tietze option parameters which are listed in section "Tietze
Options" may strongly influence the performance and the results of the
`TzSearch' command.  These are  the parameters `saveLimit' and
`searchSimultaneous'. The first of them has the following effect:

When TzSearch has finished its main loop over all relators, then, in
general, there are relators which have changed and hence should be
handled again in another run through the whole procedure. However,
experience shows that it really does not pay to continue this way until
no more relators change. Therefore, `TzSearch' starts a new loop only if
the loop just finished has reduced the total length of the relators by at
least `saveLimit' per cent.

The default value of `saveLimit' is 10 percent.

To understand the effect of the option `searchSimultaneous', we
have to look in more detail at how `TzSearch' proceeds:

First, it sorts the list of relators by increasing lengths.  Then it
performs a loop over this list. In each step of this loop, the current
relator is treated as *short relator* $r_1$, and a subroutine is called
which loops over the succeeding relators, treating them as *long
relators*  $r_2$  and performing  the  respective  comparisons and
substitutions.

As this subroutine performs a very expensive process, it has been
implemented as a C routine in the {\GAP} kernel. For the given relator
$r_1$ of length $l_1$, say, it first determines the *minimal match
length* $l$ which is $l_1/2+1$, if $l_1$ is even, or $(l_1+1)/2$,
otherwise. Then it builds up a hash list for all subwords of length $l$
occurring in the conjugates of $r_1$ or $r_1^{-1}$, and finally it loops
over all long relators $r_2$ and compares the hash values of their
subwords of length $l$ against this list. A comparison of subwords which
is much more expensive is only done if a hash match has been found.

To improve the efficiency of this process we allow the subroutine to
handle several short relators simultaneously provided that they have the
same minimal match length.  If, for example, it handles $n$ short
relators simultaneously, then you save $n - 1$ loops over the long
relators $r_2$, but you pay for it by additional fruitless subword
comparisons. In general, you will not get the best performance by always
choosing the maximal possible number of short relators to be handled
simultaneously. In fact, the optimal choice of the number will depend on
the concrete presentation under investigation. You can use the parameter
`searchSimultaneous' to prescribe an upper bound for the number of
short relators to be handled simultaneously.

The default value of `searchSimultaneous' is 20.

\Declaration{TzSearchEqual}

The Tietze option  parameter  `searchSimultaneous' is  used by
`TzSearchEqual' in the same way as described for `TzSearch'.

However, `TzSearchEqual' does not use the parameter `saveLimit':
The loop over the relators is executed exactly once.

\Declaration{TzFindCyclicJoins}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Tietze Transformations that introduce or change generators}

Some of the Tietze transformation commands listed so far may eliminate
generators and hence change the given presentation to a presentation on a
subset of the given set of generators, but they all do *not* introduce
new generators. However, sometimes there  will be the need to substitute certain
words as new generators in order to improve your presentation. Therefore
{\GAP}   offers   the   two   commands   `TzSubstitute'   and
`TzSubstituteCyclicJoins' which introduce new generators. These commands
will be described next.

\Declaration{TzSubstitute}

More precisely: If, for instance, `word' is an abstract word, a call

\begintt
TzSubstitute( P, word );
\endtt

is more or less equivalent to

\begintt
AddGenerator( P );
g := P.generators[Length( P.generators )];
AddRelator( P, g^-1 * word );
\endtt

whereas a call

\begintt
TzSubstitute( P, word, string );
\endtt

is more or less equivalent to

\begintt
g := AbstractGenerator( string );
AddGenerator( P, g );
AddRelator( P, g^-1 * word );
\endtt

The  essential difference  is,  that `TzSubstitute', as a  Tietze
transformation of <T>, saves and updates the lists of generator images
and preimages if they are being traced under the Tietze transformations
applied to <T> (see the function `TzInitGeneratorImages' below), whereas
a call of the function `AddGenerator' (which  does not perform Tietze
transformations) will delete these lists and hence terminate the tracing.

In order to decide which arguments might be appropriate for the next call of
the second version of `TzSubstitute', it is often helpful to print out a
list of the most frequently occurring squarefree relator subwords of length
2. You can use the `TzPrintPairs' command described below to do this.

\beginexample
gap> G := PerfectGroup( IsSubgroupFpGroup,960, 1 );
A5 2^4
gap> P := PresentationFpGroup( G );
<< presentation with 6 gens and 21 rels of total length 84 >>
gap> GeneratorsOfPresentation(P);
[ _x1, _x2, _x3, _x4, _x5, _x6 ]
gap> TzGoGo( P );
#I  there are 3 generators and 10 relators of total length 81
#I  there are 3 generators and 10 relators of total length 80
gap> TzPrintGenerators( P );
#I  1.  _x1   31 occurrences   involution
#I  2.  _x2   26 occurrences
#I  3.  _x4   23 occurrences   involution
\endexample
\beginexample
gap> a:=GeneratorsOfPresentation(P)[1];;
gap> b:=GeneratorsOfPresentation(P)[2];;
gap> TzSubstitute(P,a*b);
#I  now the presentation has 4 generators, the new generator is _x7
#I  substituting new generator _x7 defined by _x1*_x2
#I  there are 4 generators and 11 relators of total length 83
gap> TzGo(P);
#I  there are 3 generators and 10 relators of total length 74
gap> TzPrintGenerators(P);
#I  1.  _x1   23 occurrences   involution
#I  2.  _x4   23 occurrences   involution
#I  3.  _x7   28 occurrences
\endexample

As an example of the second usage, we handle a subgroup of index 266
in the Janko group $J_1$.

\beginexample
gap> F2 := FreeGroup( "a", "b" );;
gap> J1 := F2 / [ F2.1^2, F2.2^3, (F2.1*F2.2)^7,
> Comm(F2.1,F2.2)^10, Comm(F2.1,F2.2^-1*(F2.1*F2.2)^2)^6 ];;
gap> a := J1.1;; b := J1.2;;
gap> H := Subgroup ( J1, [ a, b^(a*b*(a*b^-1)^2) ] );;
gap> P := PresentationSubgroup( J1, H );
<< presentation with 23 gens and 82 rels of total length 530 >>
gap> TzGoGo( P );
#I  there are 3 generators and 47 relators of total length 1368
#I  there are 2 generators and 46 relators of total length 3773
#I  there are 2 generators and 46 relators of total length 2570
gap> TzGoGo( P );
#I  there are 2 generators and 46 relators of total length 2568
gap> TzGoGo( P );
\endexample
Here we do not get any more progress without substituting a new generator.
{\GAP} cannot substitute a new generator without extending the total length,
so we have to explicitly ask for it.
\beginexample
gap> TzSubstitute( P );
#I  substituting new generator _x28 defined by _x6*_x23^-1
#I  eliminating _x28 = _x6*_x23^-1
gap> TzPrintPairs( P );
#I  1.  498  occurrences of  _x6 * _x23^-1
#I  2.  498  occurrences of  _x6^-1 * _x23
#I  3.  451  occurrences of  _x6 * _x23
#I  4.  451  occurrences of  _x6^-1 * _x23^-1
\endexample
\beginexample
gap> TzSubstitute( P, 2, 1 );
#I  substituting new generator _x29 defined by _x6^-1*_x23
#I  eliminating _x6 = _x23*_x29^-1
#I  there are 2 generators and 46 relators of total length 2882
gap> TzGoGo( P );
#I  there are 2 generators and 45 relators of total length 2349
#I  there are 2 generators and 45 relators of total length 2204
gap> TzSubstitute( P, 1, 2 );
#I  substituting new generator _x30 defined by _x23*_x29^-1
#I  eliminating _x29 = _x30^-1*_x23
#I  there are 2 generators and 45 relators of total length 2236
\endexample
\beginexample
gap> TzGoGo( P );
#I  there are 2 generators and 42 relators of total length 1628
#I  there are 2 generators and 38 relators of total length 816
#I  there are 2 generators and 18 relators of total length 311
#I  there are 2 generators and 14 relators of total length 254
#I  there are 2 generators and 13 relators of total length 222
#I  there are 2 generators and 11 relators of total length 161
#I  there are 2 generators and 10 relators of total length 101
gap> TzPrintPairs( P );
#I  1.  20  occurrences of  _x23 * _x30^-1
#I  2.  20  occurrences of  _x23^-1 * _x30
#I  3.  14  occurrences of  _x23 * _x30
#I  4.  14  occurrences of  _x23^-1 * _x30^-1
\endexample
Just for demonstration we make an inconvenient choice:
\beginexample
gap> TzSubstitute( P, 3, 1 );
#I  substituting new generator _x31 defined by _x23*_x30
#I  eliminating _x23 = _x31*_x30^-1
#I  there are 2 generators and 10 relators of total length 123
gap> TzGoGo( P );
#I  there are 2 generators and 9 relators of total length 108
\endexample

\Declaration{TzSubstituteCyclicJoins}
Any sequence of Tietze transformations applied to a presentation
<T>, starting from an ``old'' presentation $P_1$ and ending up with a
``new'' presentation $P_2$, defines an  isomorphism, $\varphi$ say,
between the groups defined by $P_1$ and $P_2$, respectively. Sometimes
it is desirable to know the images of the old generators or the preimages
of the new generators under $\varphi$. The {\GAP} Tietze transformations
functions are able to trace these images. This is not automatically done
because the involved words may grow to tremendous length, but it will be
done if you  explicitly  request for  it by calling the function
`TzInitGeneratorImages'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Tracing generator images through Tietze transformations}

\Declaration{TzInitGeneratorImages}
There  are a few restrictions  concerning the tracing of generator
images:

In  general,  the  functions  `AddGenerator', `AddRelator',  and
`RemoveRelator' described in section "Changing Presentations" do not
perform Tietze transformations as they may change the isomorphism type of
the presentation. Therefore, if any of them is called for a presentation
in which generator images and preimages are being traced, it will delete
these lists.

If the function `DecodeTree'  is called for  a presentation in which
generator images and preimages are being traced, it will not continue to
trace them. Instead, it will delete the corresponding lists, then decode
the  tree, and finally reinitialize  the tracing  for the resulting
presentation.

\Declaration{TzPrintGeneratorImages}
\beginexample
gap> G:=PerfectGroup(IsSubgroupFpGroup,960,1);
A5 2^4
gap> P := PresentationFpGroup( G );
<< presentation with 6 gens and 21 rels of total length 84 >>
gap> TzInitGeneratorImages( P );
gap> TzGo( P );
#I  there are 3 generators and 11 relators of total length 96
#I  there are 3 generators and 10 relators of total length 81
gap> TzPrintGeneratorImages( P );
#I  preimages of current generators as Tietze words in the old ones:
#I  1. [ 1 ]
#I  2. [ 2 ]
#I  3. [ 4 ]
#I  images of old generators as Tietze words in the current ones:
#I  1. [ 1 ]
#I  2. [ 2 ]
#I  3. [ 1, -2, 1, 3, 1, 2, 1 ]
#I  4. [ 3 ]
#I  5. [ -2, 1, 3, 1, 2 ]
#I  6. [ 1, 3, 1 ]
\endexample
\beginexample
gap> gens :=GeneratorsOfPresentation(P);
[ _x1, _x2, _x4 ]
gap> oldgens:=OldGeneratorsOfPresentation(P);
[ _x1, _x2, _x3, _x4, _x5, _x6 ]
gap> TzImagesOldGens(P);
[ _x1, _x2, _x1*_x2^-1*_x1*_x3*_x1*_x2*_x1, _x3, _x2^-1*_x1*_x3*_x1*_x2, 
  _x1*_x3*_x1 ]
gap> for i in [ 1 .. Length( oldgens ) ] do
> Print( oldgens[i], " = ",
> TzImagesOldGens(P)[i],"\n");                             
> od;
_x1 = _x1
_x2 = _x2
_x3 = _x1*_x2^-1*_x1*_x3*_x1*_x2*_x1
_x4 = _x3
_x5 = _x2^-1*_x1*_x3*_x1*_x2
_x6 = _x1*_x3*_x1
\endexample


\Declaration{TzPrintLengths}
\Declaration{TzPrintPairs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{DecodeTree}

\Declaration{DecodeTree}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Tietze Options}

Several of the Tietze transformation commands described above are
controlled by certain parameters, the *Tietze options*, which often have
a tremendous influence on their performance and results.  However, in
each application of the commands, an appropriate choice of these option
parameters will depend on the concrete presentation under investigation.
Therefore we have implemented the Tietze options in such a way that they
are associated to the presentation: Each presentation
keeps its own set of Tietze option parameters as an attribute.

\Declaration{TzOptions}

The following Tietze options are recognized by {\GAP}:

\beginitems
`protected':& 
  The first `protected' generators in a presentation <T> are
  protected from being eliminated by the Tietze transformations
  functions.  There are only  two exceptions:  The option
  `protected'   is   ignored   by   the   functions
  `TzEliminate(<T>,<gen>)' and `TzSubstitute(<T>,<n>,<eliminate>)'
  because they explicitly specify the generator to be eliminated.
  The default value of `protected' is 0.

`eliminationsLimit':& 
  Whenever the elimination phase of the `TzGo' command is entered
  for a presentation <T>,  then it  will eliminate at most
  `eliminationsLimit' generators (except for further ones which
  have turned out to  be trivial). Hence you may use  the
  `eliminationsLimit' parameter as a break criterion for the `TzGo'
  command. Note, however, that it is ignored by the `TzEliminate'
  command. The default value of `eliminationsLimit' is 100.

`expandLimit':& 
  Whenever the routine for eliminating more than 1 generators is
  called for a presentation <T> by the `TzEliminate' command or the
  elimination phase of the `TzGo' command, then it saves the given
  total length of the relators, and subsequently it checks the
  current total length against its value before each elimination.
  If the total length has increased to more than `expandLimit'
  per cent of its original value, then the routine returns instead
  of  eliminating another generator.  Hence you may use the
  `expandLimit' parameter as a break criterion for the `TzGo'
  command. The default value of `expandLimit' is 150.

`generatorsLimit':& 
  Whenever the elimination phase of the `TzGo' command is entered
  for a presentation <T> with $n$ generators, then it will
  eliminate at most $n - $`generatorsLimit' generators (except
  for generators which turn out to be trivial). Hence you may use
  the `generatorsLimit' parameter as a break criterion for the
  `TzGo' command. The default value of `generatorsLimit' is 0.

`lengthLimit':& 
  The Tietze transformation commands will never eliminate  a
  generator of a presentation <T>, if they cannot exclude the
  possibility that the resulting total length of the relators
  exceeds the value of `lengthLimit'. The default value of
  `lengthLimit' is `infinity'.

`loopLimit':& 
  Whenever the `TzGo' command is called for a presentation <T>,
  then it will loop over at most `loopLimit' of its basic
  steps. Hence you may use the `loopLimit' parameter as a break
  criterion for  the `TzGo'  command. The  default value of
  `loopLimit' is `infinity'.

`printLevel':& 
  Whenever  Tietze transformation commands are called for  a
  presentation <T> with `printLevel' $= 0$, they will not
  provide any output except for error messages. If `printLevel'
  $= 1$, they will display some reasonable amount of output which
  allows you to watch the progress of the computation and to decide
  about your next commands. In the case `<T>.printLevel' $= 2$, you
  will get a much more generous amount of output. Finally, if
  `printLevel' $= 3$, various messages on internal details will
  be added. The default value of `printLevel' is 1.

`saveLimit':& 
  Whenever the `TzSearch' command has finished its main loop over
  all relators of a presentation <T>, then it checks whether during
  this loop the total length of the relators has been reduced by at
  least `<T>.saveLimit' per cent. If this is the case, then
  `TzSearch' repeats its procedure instead of returning. Hence you
  may use the `saveLimit' parameter as a break criterion for the
  `TzSearch' command and, in particular, for the search phase of
  the `TzGo' command. The default value of `saveLimit' is 10.

`searchSimultaneous':& 
  Whenever the `TzSearch' or the `TzSearchEqual' command is called
  for a presentation <T>, then it is allowed to handle up to
  `searchSimultaneously' short relators simultaneously (see for
  the description of the `TzSearch' command for more details). The
  choice of this parameter may heavily influence the performance as
  well as the result of the `TzSearch' and the `TzSearchEqual'
  commands and hence also of the search phase of the `TzGo'
  command. The default value of `searchSimultaneous' is 20.
\enditems

\Declaration{TzPrintOptions}

