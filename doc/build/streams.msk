%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  streams.msk               GAP documentation              Frank Celler
%W                                                       Martin Schoenert
%W                                                         & Steve Linton
%%
%H  @(#)$Id: streams.msk,v 1.18 2006/07/02 12:01:48 gap Exp $
%%
%Y  Copyright 1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,   Germany
%Y  Copyright 2000,  St Andrews
%%
%%  This file contains the description of streams.
%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Streams}

\FileHeader{streams}[1]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Categories for Streams and the StreamsFamily}

\Declaration{IsStream}
\Declaration{IsClosedStream}
\Declaration{IsInputStream}
\Declaration{IsInputTextStream}
\Declaration{IsInputTextNone}
\Declaration{IsOutputStream}
\Declaration{IsOutputTextStream}
\Declaration{IsOutputTextNone}
\Declaration{StreamsFamily}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations applicable to All Streams}

\Declaration{CloseStream}

\Declaration{FileDescriptorOfStream}

\>UNIXSelect( <inlist>, <outlist>, <exclist>, <timeoutsec>, <timeoutusec> ) F

makes the UNIX C-library function `select' accessible from {\GAP}
for streams. The functionality is as described in the man page (see
`man select'). The first three arguments must be lists containing
UNIX file descriptors (integers) for streams. They can be obtained via
`FileDescriptorOfStream' (see~"FileDescriptorOfStream") for streams
to local processes and to local files. The argument <timeoutsec> is a
timeout in seconds as in the `struct timeval' on the C level. The argument
<timeoutusec> is
analogously in microseconds. The total timeout is the sum of both. If
one of those timeout arguments is not a small integer then no timeout is
applicable (`fail' is allowed for the timeout arguments).

The return value is the number of streams that are ready, this may be
0 if a timeout was specified. All file descriptors in the three lists
that are not yet ready are replaced by `fail' in this function. So 
the lists are changed!

This function is not available on the Macintosh architecture and is
only available if your operating system has `select', which is detected
during compilation of {\GAP}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for Input Streams}

Three operations normally used to read files: `Read', `ReadAsFunction'
and `ReadTest' can also be used to read {\GAP} input from a
stream. The input is immediately parsed and executed. When reading
from a stream <str>, the {\GAP} kernel generates calls to
`ReadLine(<str>)' to supply text to the parser. 

Three further operations: `ReadByte', `ReadLine' and `ReadAll', support
reading characters from an input stream without parsing them. This can be
used to read data in any format and process it in {\GAP}.

Additional operations for input streams support detection of end of
stream, and (for those streams for which it is appropriate) random access 
to the data.


\>Read( <input-text-stream> )!{for streams} O

reads the input-text-stream as  input  until `end-of-stream' occurs.  See
"File Operations" for details.


\>ReadAsFunction( <input-text-stream> )!{for streams} O

reads the input-text-stream as function and returns this function. See
"File Operations" for details.

\>ReadTest( <input-text-stream> )!{for streams} O

reads the input-text-stream as  test input until `end-of-stream' occurs.
See "File Operations" for details.

*Example*

\beginexample
gap> # a function with local `a' does not change the global one
gap> a := 1;;
gap> i := InputTextString( "local a; a := 10; return a*10;" );;
gap> ReadAsFunction(i)();
100
gap> a;
1
\endexample

\beginexample
gap> # reading it via `Read' does
gap> i := InputTextString( "a := 10;" );;
gap> Read(i);
gap> a;
10
\endexample


\Declaration{ReadByte}
\Declaration{ReadLine}
\Declaration{ReadAll}


*Example*

\beginexample
gap> i := InputTextString( "1Hallo\nYou\n1" );;
gap> ReadByte(i);
49
gap> CHAR_INT(last);
'1'
gap> ReadLine(i);
"Hallo\n"
gap> ReadLine(i);
"You\n"
gap> ReadLine(i);
"1"
gap> ReadLine(i);
fail
gap> ReadAll(i);
""
gap> RewindStream(i);;
gap> ReadAll(i);
"1Hallo\nYou\n1"
\endexample


\Declaration{IsEndOfStream}
\Declaration{PositionStream}
\Declaration{RewindStream}
\Declaration{SeekPositionStream}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for Output Streams}

\Declaration{WriteByte}
\Declaration{WriteLine}
\Declaration{WriteAll}

*Example*

\beginexample
gap> str := "";; a := OutputTextString(str,true);;
gap> WriteByte(a,INT_CHAR('H'));
true
gap> WriteLine(a,"allo");
true
gap> WriteAll(a,"You\n");
true
gap> CloseStream(a);
gap> Print(str);
Hallo
You
\endexample

\>PrintTo( <output-stream>, <arg1>, ... )!{for streams} F
\>AppendTo( <output-stream>, <arg1>, ... )!{for streams} F

These functions work like `Print', except that the output is
appended to the output stream <output-stream>.

*Example*

\beginexample
gap> str := "";; a := OutputTextString(str,true);;
gap> AppendTo( a, (1,2,3), ":", Z(3) );
gap> CloseStream(a);
gap> Print( str, "\n" );
(1,2,3):Z(3)
\endexample

\Declaration{LogTo}!{for streams}
\Declaration{InputLogTo}!{for streams}
\Declaration{OutputLogTo}!{for streams}


When  text is being  sent to an output text   stream via `PrintTo', `AppendTo',
`LogTo', etc., it  is, by default formatted just  as it would  be were it being
printed to  the screen. Thus,  it is broken into lines  of reasonable length at
(where possible) sensible places, lines containing elements of lists or records
are indented, and so forth.  This is appropriate if the output is eventually to
be viewed by a human, and harmless if it to passed  as input to {\GAP}, but may
be unhelpful if the output is to be  passed as input to  another program. It is
possible    to turn      off   this behaviour     for   a   stream   using  the
`SetPrintFormattingStatus' operation, and to test whether it is on or off using
`PrintFormattingStatus'.

\Declaration{SetPrintFormattingStatus}
\Declaration{PrintFormattingStatus}

*Example*
\beginexample
gap> s := "";; str := OutputTextString(s,false);;
gap> PrintTo(str,Primes{[1..30]});
gap> s;
"[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
 \n  73, 79, 83, 89, 97, 101, 103, 107, 109, 113 ]"
gap> Print(s,"\n");
[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 
  73, 79, 83, 89, 97, 101, 103, 107, 109, 113 ]
gap> SetPrintFormattingStatus(str, false);
gap> PrintTo(str,Primes{[1..30]});
gap> s;
"[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
 \n  73, 79, 83, 89, 97, 101, 103, 107, 109, 113 ][ 2, 3, 5, 7, 11, 13, 17, 19\
, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103\
, 107, 109, 113 ]"
gap> Print(s,"\n");
[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 
  73, 79, 83, 89, 97, 101, 103, 107, 109, 113 ][ 2, 3, 5, 7, 11, 13, 17, 19, 2\
3, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 1\
07, 109, 113 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{File Streams}

File streams  are  streams associated with  files.  An  input file stream
reads  the characters  it delivers from  a  file,  an output  file stream
prints the characters it receives to a file.  The following functions can
be used to create such streams.  They return `fail' if an error occurred,
in this case `LastSystemError' (see "LastSystemError") can be used to get
information about the error.

\Declaration{InputTextFile}


\Declaration{OutputTextFile}


*Example*

\beginexample
gap> # use a temporary directory
gap> name := Filename( DirectoryTemporary(), "test" );;
gap> # create an output stream, append output, and close again
gap> output := OutputTextFile( name, true );;
gap> AppendTo( output, "Hallo\n", "You\n" );
gap> CloseStream(output);
gap> # create an input, print complete contents of file, and close
gap> input := InputTextFile(name);;
gap> Print( ReadAll(input) );
Hallo
You
gap> CloseStream(input);
gap> # append a single line
gap> output := OutputTextFile( name, true );;
gap> AppendTo( output, "AppendLine\n" );
gap> # close output stream to flush the output
gap> CloseStream(output);
gap> # create an input, print complete contents of file, and close
gap> input := InputTextFile(name);;
gap> Print( ReadAll(input) );
Hallo
You
AppendLine
gap> CloseStream(input);
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{User Streams}

The following two commands create streams which accept characters
from, or deliver characters to, the user, via the keyboard or the {\GAP} session
display.

\Declaration{InputTextUser}

\Declaration{OutputTextUser}

The next function allows an interactive input from the user.

\Declaration{InputFromUser}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{String Streams}

String streams   are streams associated  with   strings.  An input string
stream reads  the characters it delivers  from a string, an output string
stream  appends the characters  it receives  to  a string.  The following
functions can be used to create such streams.

\Declaration{InputTextString}


\Declaration{OutputTextString}


*Example*

\beginexample
gap> # read input from a string
gap> input := InputTextString( "Hallo\nYou\n" );;
gap> ReadLine(input);
"Hallo\n"
gap> ReadLine(input);
"You\n"
gap> # print to a string
gap> str := "";;
gap> out := OutputTextString( str, true );;
gap> PrintTo( out, 1, "\n", (1,2,3,4)(5,6), "\n" );
gap> CloseStream(out);
gap> Print( str );
1
(1,2,3,4)(5,6)
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Input-Output Streams}

\FileHeader{streams}[2]

\Declaration{IsInputOutputStream}

\FileHeader{streams}[3]

\Declaration{InputOutputLocalProcess}

\beginexample
gap> d := DirectoryCurrent();
dir("./")
gap> f := Filename(DirectoriesSystemPrograms(), "rev");
"/usr/bin/rev"
gap> s := InputOutputLocalProcess(d,f,[]);
< input/output stream to rev >
gap> WriteLine(s,"The cat sat on the mat");
true
gap> Print(ReadLine(s));
tam eht no tas tac ehT
gap> x := ListWithIdenticalEntries(10000,'x');;
gap> ConvertToStringRep(x);
gap> WriteLine(s,x);
true
gap> WriteByte(s,INT_CHAR('\n'));
true
gap> y := ReadAll(s);;
gap> Length(y);
4095
gap> CloseStream(s);
gap> s;
< closed input/output stream to rev >
\endexample

\Declaration{ReadAllLine}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Dummy Streams}

The following  two commands create  dummy streams  which will consume all
characters and never deliver one.

\Declaration{InputTextNone}

\Declaration{OutputTextNone}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Handling of Streams in the Background}

This section describes a feature of the {\GAP} kernel that can be used
to handle pending streams somehow ``in the background''. This is currently
not available on the Macintosh architecture and only on operating
systems that have `select'.

Right before {\GAP} reads a keypress from the keyboard it calls a little
subroutine that can handle streams that are ready to be read or ready to
be written. This means that {\GAP} can handle these streams during
user input on the command line. Note that this does not work when {\GAP}
is in the middle of some calculation.

This feature is used in the following way. One can install handler
functions for reading or writing streams. This is done via:

\Declaration{InstallCharReadHookFunc}

Handlers can be removed via:

\Declaration{UnInstallCharReadHookFunc}

Note that handler functions must not return anything and get one integer
argument, which refers to an index in one of the following arrays
(according to whether the function was installed for input, output or
exceptions on the stream). Handler functions usually should not output
anything on the standard output because this ruins the command line
during command line editing.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Comma separated files}
\index{Spreadsheet}
\index{Excel}

In some situations it can be desirable to process data given in the form of
a spreadsheet (such as Excel). {\GAP} can do this using the CSV (comma
separated values) format, which spreadsheet programs can usually read in or
write out.

The first line of the spreadsheet is used as labels of record components,
each subsequent line then corresponds to a record. Entries enclosed in
double quotes are considered as strings and are permitted to contain the
separation character (usually a comma).

\Declaration{ReadCSV}

\Declaration{PrintCSV}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E  streams.tex . . . . . . . . . . . . . . . . . . . . . . . . ends here
