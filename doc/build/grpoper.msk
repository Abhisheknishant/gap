%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  grpoper.msk                GAP documentation            Alexander Hulpke
%A                                                          Heiko Theissen
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%%
\Chapter{Group Operations}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{About Operations}

Formally, a *group operation* is a triple $(G,\Omega,\mu)$, where $G$ is a
group, $\Omega$ a set and $\mu\colon\Omega\times G\to\Omega$ a function
(with certain properties). We call $\Omega$ the *domain* of the operation.

In {\GAP}, $G$ must be a group, $\Omega$ a
duplicate-free collection (an object that permits the access to its elements
via the <Omega>[<n>] operation, for example a list) and $\mu$ a function
\>opfun(<pnt>,<g>)
that returns the image $\mu(<pnt>,<g>)$.
In {\GAP} groups always operates from the right, that is
$\mu(\mu(<pnt>,<g>),<h>)=\mu(<pnt>,<gh>)$.

{\GAP} does not test whether an operation function `opfun' satisfies the
conditions for a group operation. If it does not, results are
unpredictable.

Various commonly used operations are already built into {\GAP}. They are
listed in the section "Basic Operations". For many of the built-in
operations special methods are available for functions like `Stabilizer'.

Usually, group operations can be passed as parameters to functions in the
following ways:

\>ExampleOperationFunction(<G>,<Omega>[,<opfun>])
\>ExampleOperationFunction(<G>,<Omega>,<gens>,<oprs>[,<opfun>])
\>ExampleOperationFunction(<extset>)

The first version gives the group, the domain and the operation function. If
the operation function <opfun> is not given, the built-in operation `OnPoints'
(which defines operation via the caret operator `^') is used. 
In the second version, <gens> must be a set of generators of <G> and <oprs>
a list of objects corresponding to <gens>. It implements the operation
$\mu(<pnt>,<g>)=<opfun>(<pnt>,<g>^\varphi)$, where $\varphi$ is the
homomorphism defined on <G> by mapping <gens> to <oprs>.
(It is not tested whether this mapping actually induces an homomorphism.)
The advantage of this notation is that {\GAP} does not need to construct
this homomorphism physically. (Construction of the homomorphism would imply
constructing the range group. If <G> is small but acts by matrices in a
large dimensional space it is undesirable to construct such a
high-dimensional matrix group.)

The third version takes an an external set <extset>. External sets
are {\GAP} objects that represent the triple (<G>,<Omega>,<opfun>). They are
described in section "External Sets". Most of the operations are attributes
for external sets.

The description of the command `Orbits' (see "Orbits") gives
examples for all kinds of parameters.
For commands like `Stabilizer' the domain is replaced by an element of
$\Omega$.

When acting on a domain <Omega>, operation functions like `Permuted' or
`OperationHomomorphism' use the command
`PositionCanonical' to determine the position of elements in the domain.
This can be used to act on a domain given by a list representatives for
which `PositionCanonical' is implemented, for example a `RightTransversal'
(see "RightTransversal").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{External Sets}

External sets are {\GAP} objects that represent a group operation.

\Declaration{IsExternalSet}
\Declaration{ExternalSet}
\beginexample
gap> g:=Group((1,2,3),(2,3,4));;
gap> e:=ExternalSet(g,[1..4]);
[ 1 .. 4 ]
\endexample

\Declaration{IsExternalSubset}
\Declaration{ExternalSubset}
\Declaration{IsExternalOrbit}
\Declaration{ExternalOrbit}
\beginexample
gap> e:=ExternalOrbit(g,g,(1,2,3));
(1,2,3)^G < <enumerator of perm group>
\endexample

\Declaration{ActingDomain}
\Declaration{FunctionOperation}
\Declaration{HomeEnumerator}
\beginexample
gap> ActingDomain(e);
Group( [ (1,2,3,4), (1,2) ], ... )
gap> FunctionOperation(e)=OnPoints;  
true
gap> HomeEnumerator(e);
<enumerator of perm group>
\endexample

\Declaration{StabilizerOfExternalSet}
\beginexample
gap> Representative(e);
(1,2,3)
gap> StabilizerOfExternalSet(e);
Group( [ (1,2,3) ], ... )
\endexample

\Declaration{ExternalOrbits}
\beginexample
gap> ExternalOrbits(g,g);
[ ()^G < <enumerator of perm group>, 
  (1,2)(3,4)^G < <enumerator of perm group>, 
  (2,3,4)^G < <enumerator of perm group>, 
  (2,4,3)^G < <enumerator of perm group> ]
\endexample

\Declaration{ExternalOrbitsStabilizers}
\beginexample
gap> e:=ExternalOrbitsStabilizers(g,g);
[ ()^G < <enumerator of perm group>, 
  (1,2)(3,4)^G < <enumerator of perm group>, 
  (2,3,4)^G < <enumerator of perm group>, 
  (2,4,3)^G < <enumerator of perm group> ]
gap> HasStabilizerOfExternalSet(e[3]);
true
gap> StabilizerOfExternalSet(e[3]);
Group( [ (2,4,3) ], ... )
\endexample

\Declaration{CanonicalRepresentativeOfExternalSet}
\Declaration{CanonicalRepresentativeDeterminatorOfExternalSet}
\Declaration{OperatorOfExternalSet}
\beginexample
gap> u:=Subgroup(g,[(1,2,3)]);;  
gap> e:=RightCoset(u,(1,2)(3,4));;  
gap> CanonicalRepresentativeOfExternalSet(e);
(2,4,3)
gap> OperatorOfExternalSet(e);
(1,2,3)
gap> FunctionOperation(e)((1,2)(3,4),last);
(2,4,3)
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Basic Operations}

\Declaration{OnPoints}
\Declaration{OnRight}
\Declaration{OnLeftInverse}
\Declaration{OnPairs}
\Declaration{OnSets}
\Declaration{OnTuples}
\Declaration{OnSetsSets}
\Declaration{OnSetsTuples}
\Declaration{OnTuplesSets}
\Declaration{OnTuplesTuples}
\beginexample
gap> Orbit(g,1,OnPoints);              
[ 1, 2, 3, 4 ]
gap> Orbit(g,(),OnRight);               
[ (), (1,2)(3,4), (1,3)(2,4), (1,4)(2,3), (2,4,3), (1,4,2), (1,2,3), 
  (1,3,4), (2,3,4), (1,3,2), (1,4,3), (1,2,4) ]
gap> Orbit(g,[1,2],OnPairs);
[ [ 1, 2 ], [ 2, 1 ], [ 3, 4 ], [ 4, 3 ], [ 1, 4 ], [ 4, 1 ], [ 2, 3 ], 
  [ 3, 2 ], [ 1, 3 ], [ 3, 1 ], [ 4, 2 ], [ 2, 4 ] ]
gap> Orbit(g,[1,2],OnSets); 
[ [ 1, 2 ], [ 3, 4 ], [ 1, 4 ], [ 2, 3 ], [ 1, 3 ], [ 2, 4 ] ]
\endexample
\beginexample
gap> Orbit(g,[[1,2],[3,4]],OnSetsSets);
[ [ [ 1, 2 ], [ 3, 4 ] ], [ [ 1, 4 ], [ 2, 3 ] ], [ [ 1, 3 ], [ 2, 4 ] ] ]
gap> Orbit(g,[[1,2],[3,4]],OnTuplesSets);
[ [ [ 1, 2 ], [ 3, 4 ] ], [ [ 3, 4 ], [ 1, 2 ] ], [ [ 1, 4 ], [ 2, 3 ] ], 
  [ [ 2, 3 ], [ 1, 4 ] ], [ [ 1, 3 ], [ 2, 4 ] ], [ [ 2, 4 ], [ 1, 3 ] ] ]
gap> Orbit(g,[[1,2],[3,4]],OnSetsTuples);
[ [ [ 1, 2 ], [ 3, 4 ] ], [ [ 2, 1 ], [ 4, 3 ] ], [ [ 1, 4 ], [ 2, 3 ] ], 
  [ [ 3, 2 ], [ 4, 1 ] ], [ [ 1, 3 ], [ 4, 2 ] ], [ [ 2, 4 ], [ 3, 1 ] ] ]
gap> Orbit(g,[[1,2],[3,4]],OnTuplesTuples);
[ [ [ 1, 2 ], [ 3, 4 ] ], [ [ 2, 1 ], [ 4, 3 ] ], [ [ 3, 4 ], [ 1, 2 ] ], 
  [ [ 4, 3 ], [ 2, 1 ] ], [ [ 1, 4 ], [ 2, 3 ] ], [ [ 4, 1 ], [ 3, 2 ] ], 
  [ [ 2, 3 ], [ 1, 4 ] ], [ [ 3, 2 ], [ 4, 1 ] ], [ [ 1, 3 ], [ 4, 2 ] ], 
  [ [ 3, 1 ], [ 2, 4 ] ], [ [ 4, 2 ], [ 1, 3 ] ], [ [ 2, 4 ], [ 3, 1 ] ] ]
\endexample

\Declaration{OnLines}
\beginexample
gap> gl:=GL(2,5);;v:=[1,0]*Z(5)^0;  
[ Z(5)^0, 0*Z(5) ]
gap> h:=Operation(gl,Orbit(gl,v,OnLines),OnLines);
Group( [ (2,3,5,6), (1,2,4)(3,6,5) ], ... )
\endexample

\Declaration{OnPartitions}
\Declaration{OnIndeterminates}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Operations}

\Declaration{OperationHomomorphism}
(See section "About Operations" for information about operations.)
\beginexample
gap> hom:=OperationHomomorphism(g,Arrangements([1..4],3),OnTuples);
<operation homomorphism>
gap> Image(hom);
Group( 
[ ( 1, 9,13)( 2,10,14)( 3, 7,15)( 4, 8,16)( 5,12,17)( 6,11,18)(19,22,23)
    (20,21,24), ( 1, 4, 5)( 2, 3, 6)( 7,14,19)( 8,13,20)( 9,17,21)
    (10,18,22)(11,15,23)(12,16,24) ], ... )
gap> Size(Range(hom));Size(Image(hom));
620448401733239439360000
12
gap> hom:=OperationHomomorphism(g,Arrangements([1..4],3),OnTuples,
> "surjective");;
gap> Size(Range(hom));
12
\endexample

\Declaration{Operation}
(See section "About Operations" for information about operations.)

\Declaration{SurjectiveOperationHomomorphismAttr}

\Declaration{UnderlyingExternalSet}
\begintt
gap> UnderlyingExternalSet(hom);
[ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 2 ], [ 1, 3, 4 ], [ 1, 4, 2 ], 
  [ 1, 4, 3 ], [ 2, 1, 3 ], [ 2, 1, 4 ], [ 2, 3, 1 ], [ 2, 3, 4 ], 
  [ 2, 4, 1 ], [ 2, 4, 3 ], [ 3, 1, 2 ], [ 3, 1, 4 ], [ 3, 2, 1 ], 
  [ 3, 2, 4 ], [ 3, 4, 1 ], [ 3, 4, 2 ], [ 4, 1, 2 ], [ 4, 1, 3 ], 
  [ 4, 2, 1 ], [ 4, 2, 3 ], [ 4, 3, 1 ], [ 4, 3, 2 ] ]
\endtt

\Declaration{SparseOperationHomomorphism}
\beginexample
gap> h:=Group(Z(3)*[[[1,1],[0,1]]]);                             
Group( [ [ [ Z(3), Z(3) ], [ 0*Z(3), Z(3) ] ] ], ... )
gap> hom:=OperationHomomorphism(h,GF(3)^2,OnRight);;                     
gap> Image(hom);
Group( [ (2,3)(4,9,6,7,5,8) ], ... )
gap> hom:=SparseOperationHomomorphism(h,[Z(3)*[1,0]],OnRight);;
gap> Image(hom);
Group( [ (1,2,3,4,5,6) ], ... )
\endexample

\Declaration{Blocks}
\beginexample
gap> g:=TransitiveGroup(8,3);
E(8) = 2[x]2[x]2
gap> Blocks(g,[1..8]);      
[ [ 1, 8 ], [ 2, 3 ], [ 4, 5 ], [ 6, 7 ] ]
gap> Blocks(g,[1..8],[1,4]);
[ [ 1, 4 ], [ 2, 7 ], [ 3, 6 ], [ 5, 8 ] ]
\endexample
(See section "About Operations" for information about operations.)

\Declaration{MaximalBlocks}
\Declaration{MinimalBlocks}
\Declaration{AllBlocks}
\beginexample
gap> MaximalBlocks(g,[1..8]);

gap> MinimalBlocks(g,[1..8]);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 1, 6 ], [ 1, 7 ], [ 1, 8 ] ]
gap> AllBlocks(g);       
[ [ 1, 8 ], [ 1, 2, 3, 8 ], [ 1, 4, 5, 8 ], [ 1, 6, 7, 8 ], [ 1, 3 ], 
  [ 1, 3, 5, 7 ], [ 1, 3, 4, 6 ], [ 1, 5 ], [ 1, 2, 5, 6 ], [ 1, 2 ], 
  [ 1, 2, 4, 7 ], [ 1, 4 ], [ 1, 7 ], [ 1, 6 ] ]
\endexample

\Declaration{Permutation}
\Declaration{PermutationCycle}
\beginexample
gap> Permutation((1,2,3)(4,5)(6,7),[4..7]);       
(1,2)(3,4)
gap> PermutationCycle((1,2,3)(4,5)(6,7),[4..7],4);
(1,2)
\endexample
\Declaration{Cycle}
\Declaration{CycleLength}
\Declaration{Cycles}
\Declaration{CycleLengths}
\beginexample
gap> Cycle((1,2,3)(4,5)(6,7),[4..7],4);
[ 4, 5 ]
gap> CycleLength((1,2,3)(4,5)(6,7),[4..7],4);
2
gap> Cycles((1,2,3)(4,5)(6,7),[4..7]);       
[ [ 4, 5 ], [ 6, 7 ] ]
gap> CycleLengths((1,2,3)(4,5)(6,7),[4..7]);
[ 2, 2 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Orbits and Stabilizers}

\Declaration{Orbit}
\beginexample
gap> g:=Group((1,3,2),(2,4,3));;
gap> Orbit(g,1);           
[ 1, 3, 2, 4 ]
gap> Orbit(g,[1,2],OnSets);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ], [ 2, 4 ] ]
\endexample
(See section "About Operations" for information about operations.)

\Declaration{Orbits}
\beginexample
gap> Orbits(g,[1..5]);                         
[ [ 1, 3, 2, 4 ], [ 5 ] ]
gap> Orbits(g,Arrangements([1..4],3),OnTuples);
[ [ [ 1, 2, 3 ], [ 3, 1, 2 ], [ 1, 4, 2 ], [ 2, 3, 1 ], [ 2, 1, 4 ], 
      [ 3, 4, 1 ], [ 1, 3, 4 ], [ 4, 2, 1 ], [ 4, 1, 3 ], [ 2, 4, 3 ], 
      [ 3, 2, 4 ], [ 4, 3, 2 ] ], 
  [ [ 1, 2, 4 ], [ 3, 1, 4 ], [ 1, 4, 3 ], [ 2, 3, 4 ], [ 2, 1, 3 ], 
      [ 3, 4, 2 ], [ 1, 3, 2 ], [ 4, 2, 3 ], [ 4, 1, 2 ], [ 2, 4, 1 ], 
      [ 3, 2, 1 ], [ 4, 3, 1 ] ] ]
gap> Orbits(g,GF(2)^2,[(1,2,3),(1,4)(2,3)], 
> [[[Z(2)^0,Z(2)^0],[Z(2)^0,0*Z(2)]],[[Z(2)^0,0*Z(2)],[0*Z(2),Z(2)^0]]]);   
[ [ [ 0*Z(2), 0*Z(2) ] ], 
  [ [ 0*Z(2), Z(2)^0 ], <an immutable GF2 vector of length 2>, 
      <an immutable GF2 vector of length 2> ] ]
gap> e:=ExternalSet(g,g,OnRight);
<enumerator of perm group>
gap> Orbits(e);
[ [ (), (1,3)(2,4), (1,2)(3,4), (1,4)(2,3), (2,3,4), (1,4,3), (1,3,2), 
      (1,2,4), (2,4,3), (1,2,3), (1,4,2), (1,3,4) ] ]
\endexample
(See section "About Operations" for information about operations.)

\Declaration{OrbitLength}
\Declaration{OrbitLengths}
\beginexample
gap> OrbitLength(g,[1,2,3,4],OnTuples);
12
gap> OrbitLengths(g,Arrangements([1..4],4),OnTuples);
[ 12, 12 ]
\endexample

\Declaration{OrbitStabilizer}
\Declaration{Stabilizer}
\beginexample
gap> Stabilizer(g,4);
Group( [ (1,3,2) ], ... )
gap> Stabilizer(g,[1,2],OnSets);
Group( [ (1,2)(3,4) ], ... )
gap> Stabilizer(g,[1,2],OnTuples);
Group( [  ], ... )
gap> OrbitStabilizer(g,[1,2],OnSets);    
rec(
  orbit := [ [ 1, 2 ], [ 3, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 4 ], [ 2, 3 ] ],
  stabilizer := Group( [ (1,2)(3,4) ], ... ) )
\endexample
(See section "About Operations" for information about operations.)
\Methods

\Declaration{RepresentativeOperation}
\beginexample
gap> RepresentativeOperation(g,1,3);
(1,3)(2,4)
gap> RepresentativeOperation(g,(1,2,3),(2,4,3));
(1,2,4)
gap> RepresentativeOperation(g,(1,2,3),(2,3,4));
fail
gap> RepresentativeOperation(g,Group((1,2,3)),Group((2,3,4)));
(1,2,4)
\endexample
(See section "About Operations" for information about operations.)
\Methods

The standard methods for all these operations are an Orbit-Stabilizer
algorithm. For permutation groups backtrack algorithms are used, for
solvable groups a special version for solvable groups (see \cite{SOGOS}) is
used.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Tests for operations}

\Declaration{IsTransitive}
\Declaration{Transitivity}
\beginexample
gap> IsTransitive(g,[1..5]);
false
gap> Transitivity(g,[1..4]);
2
\endexample
\Declaration{IsSemiRegular}
\Declaration{IsRegular}
\beginexample
gap> IsSemiRegular(g,Arrangements([1..4],3),OnTuples);
true
gap> IsRegular(g,Arrangements([1..4],3),OnTuples);    
false
\endexample
\Declaration{IsPrimitive}
\beginexample
gap> IsPrimitive(g,Orbit(g,(1,2)(3,4))); 
true
\endexample
%\declaration{IsFixpointFree}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{About the implementation}

\Declaration{OrbitsishFOA}
\Declaration{OrbitishFO}
