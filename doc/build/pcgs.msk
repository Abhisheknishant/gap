%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  pcgs.msk                    GAP documentation            Alexander Hulpke
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%%
\Chapter{Solvable Groups}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Polycyclic Generating Systems}

A Polycyclic Generating Set (*pcgs* for short) of a group <G> is a list
$P:=[g_1,\ldots,g_n]$ of elements of <G> such that the subgroups $U_i:=\langle
g_i,\ldots, g_n\rangle$ form a subnormal series of <G> with $U_1=G$,
$U_{n+1}=\langle 1\rangle$, the factors
$U_i/U_{i+1}$ nontrivial cyclic and generated by $U_{i+1}g_i$ \cite{SOGOS}.
This series of subgroups $U_i$ is called the *pc series* of the pcgs $P$.
We call the smallest $k$ such that $g_i^k\in U_{i+1}$ the *relative order*
$r_i$ of $g_i$.
Every finite solvable group posesses a pcgs and a finite group that posesses
a pcgs is solvable.

Usually a group has not one unique pcgs but there are a multitude of pcgs.

With respect to a pcgs every element of <G> can be represented in a unique
way as a product $g=g_1^{e_1}\cdot g_2^{e_2}\cdot\cdots\cdot g_n^{e_n}$ with
$0\le g_i\<r_i$. We call the integer vector $[e_1,\ldots,e_n]$ the *exponent
vector* of the element $g$. The smallest $k$ such that $e_k\not=0$ is called
the depth (or weight) of <g> and $e_k$ is the *leading exponent* of <g>.

If we have a pcgs for a factor group we can take preimages of the elements
in this pcgs and obtain a list of elements of the group that again have
relative orders and permit the calculation of exponent vectors.  We call
this a *modulo pcgs*. Such a modulo pcgs permits to use exponent
vectors for a proper factor while actually computing with group elements.
Every pcgs naturally is a modulo pcgs.

If we have a modulo pcgs for a group, it still may be difficult to compute
exponents. In {\GAP} we therefore introduce a further category
*generalized pcgs* which is a modulo pcgs that does not necessarily permit
the calculation of exponent vectors while the category of modulo pcgs always
implies the possibility to compute exponent vectors of elements.

\Declaration{IsGeneralPcgs}
\Declaration{IsModuloPcgs}
\Declaration{IsPcgs}

\Declaration{Pcgs}

\beginexample
gap> g:=Group((1,2,3,4),(1,2));;    
gap> Pcgs(g);
[ (3,4), (2,4,3), (1,4)(2,3), (1,2)(3,4) ]
gap> g:=Group((1,2,3,4,5),(1,2));;
gap> Pcgs(g);
fail
gap> HasPcgs(g);
false
\endexample

Many algorithms rely on the existence of a Pcgs. While every solvable finite
group has in theory a pcgs, it might be very difficult to compute one.
For this purpose {\GAP} utilizes the filter `CanEasilyComputePcgs':

\Declaration{CanEasilyComputePcgs}

Naturally every group which has a pcgs can easily compute one and if the
representation of a solvable group implies the possibility to compute a pcgs
this filter will also be set.

\beginexample
gap> g:=SmallGroup(24,10);
Group( [ f1, f2, f3, f4 ], ... )
gap> HasPcgs(g);
false
gap> CanEasilyComputePcgs(g);
true
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Constructing a Pcgs}

\Declaration{PcgsByPcSequence}
\beginexample
gap> PcgsByPcSequence(FamilyObj((1,2)),[(1,2),(1,2,3)]);
[ (1,2), (1,2,3) ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Exponent vectors}

All these functions can be applied to a modulo pcgs.

\Declaration{DepthOfPcElement}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> p:=Pcgs(g);
[ (3,4), (2,4,3), (1,4)(2,3), (1,2)(3,4) ]
gap> DepthOfPcElement(p,(1,4)(2,3));  
3
gap> DepthOfPcElement(p,(1,4)(2,3),2);
3
\endexample

\Declaration{ExponentOfPcElement}
\Declaration{ExponentsOfPcElement}
\Declaration{LeadingExponentOfPcElement}
\beginexample
gap> ExponentsOfPcElement(p,(1,2,3));
[ 0, 1, 0, 1 ]
gap> ExponentsOfPcElement(p,(1,2,3),[2,3]);
[ 1, 0 ]
gap> ExponentOfPcElement(p,(1,2,3),3); 
0
gap> LeadingExponentOfPcElement(p,(1,2,3));
1
\endexample

\Declaration{RelativeOrderOfPcElement}
\beginexample
gap> DepthOfPcElement(p,(1,2,3));     
2
gap> RelativeOrderOfPcElement(p,(1,2,3));
3
\endexample

\Declaration{PcElementByExponents}
\beginexample
gap> PcElementByExponents(p,[1,2,0,0]);
(2,3)
gap> p[1]*p[2]^2;
(2,3)
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Properties and Attributes of a Pcgs}

\Declaration{IsPrimeOrdersPcgs}
\Declaration{IsFiniteOrdersPcgs}

\Declaration{PcSeries}
\beginexample
gap> g:=SmallGroup(24,10);;p:=Pcgs(g);
[ f1, f2, f3, f4 ]
gap> PcSeries(p);
[ Group( [ f1, f2, f3, f4 ], ... ), Group( [ f2, f3, f4 ], ... ), 
  Group( [ f3, f4 ], ... ), Group( [ f4 ], ... ), Group( [  ], ... ) ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Induced Pcgs}

When computing with subgroups it must be ensured that the pcgs used
for each group are compatible with each other. This can be ensured by using 
induced pcgs for subgroups. A pcgs <Q> for a subgroup <H> of <G> is induced
by a pcgs <P> of <G> if the pc series of <Q> is obtained by intersecting the
subgroups in the pc series of <P> with <H> and if the leading exponents with
repect to <P> of the elements of <Q> are 1. This means that the matrix of
exponent vectors of <Q> with respect to <P> is in echelon form with normed
entries 1 at each ``step''.

An induced pcgs can be computed using a ``noncommutative gauss algorithm''.

\Declaration{InducedPcgs}
\Declaration{ParentPcgs}
\Declaration{IsInducedPcgs}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;p:=Pcgs(g);;
gap> ip:=InducedPcgs(p,Group((1,2,3),(1,2)));
[ (1,2), (1,2,3) ]
gap> ParentPcgs(ip);
[ (3,4), (2,4,3), (1,4)(2,3), (1,2)(3,4) ]
gap> IsInducedPcgs(p);
false
gap> IsInducedPcgs(ip);
true
\endexample

\Declaration{CanonicalPcgs}
\Declaration{IsCanonicalPcgs}
\beginexample
gap> g:=SmallGroup(24,10);
Group( [ f1, f2, f3, f4 ], ... )
gap> p:=Pcgs(g);
[ f1, f2, f3, f4 ]
gap> u:=Subgroup(g,[p[1]*p[3]^2*p[4],p[4]]);
Group( [ f1*f3^2*f4, f4 ], ... )
gap> i:=InducedPcgs(p,u);
[ f1*f3^2*f4, f3, f4 ]
gap> CanonicalPcgs(i);
[ f1, f3, f4 ]
\endexample

\Declaration{InducedPcgsByGenerators}
\Declaration{InducedPcgsByPcSequence}
\Declaration{InducedPcgsByPcSequenceAndGenerators}

\beginexample
gap> g:=Group((1,2,3,4),(1,2));;p:=Pcgs(g);;
gap> g:=Group((1,2,3,4),(1,2));;p:=Pcgs(g);;
gap> InducedPcgsByGenerators(p,[(2,3,4),(1,2)(3,4)]);
[ (2,4,3), (1,4)(2,3), (1,2)(3,4) ]
gap> InducedPcgsByPcSequence(p,[(1,2),(1,3,2)]);      
[ (1,2), (1,3,2) ]
\endexample

To avoid multiple calculations of induced pcgs a group <G> can store a *home
pcgs* <H> this is a pcgs which is likely to used for calculations (for example
the pcgs of a parent group) and there is an attribute
`InducedPcgsWrtHomePcgs' which holds an induced pcgs for <G> with
respect to the home pcgs <H>. When inducing a pcgs for <G> with respect
to a pcgs <P> such that <P> is induced by <H>, it is possible to simply
return the `InducedPcgsWrtHomePcgs'.
\Declaration{HomePcgs}
\Declaration{InducedPcgsWrtHomePcgs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Modulo Pcgs}

A modulo pcgs is a list of representatives for cosets that form a pcgs for a
factor group.

\Declaration{ModuloPcgs}
\Declaration{NumeratorOfModuloPcgs}
\Declaration{DenominatorOfModuloPcgs}
\beginexample
gap> s5:=Group((1,2,3,4,5),(1,2));;
gap> m:=ModuloPcgs(s5,DerivedSubgroup(s5));
[ (4,5) ]
gap> NumeratorOfModuloPcgs(m);
[ (1,2,3,4,5), (1,2) ]
gap> DenominatorOfModuloPcgs(m);
[ (1,3,2), (2,4,3), (2,3)(4,5) ]
\endexample

\>`<pcgs> mod <ipcgs>'{modulo!for pcgs}

if <ipcgs> is a pcgs for a subgroup <N> that is induced by <pcgs> and <N> is
normal in the group <G> generated by <pcgs> this returns a modulo pcgs
representing the factor <G>/<N>. The numerator and denominator of this
modulo pcgs will be <pcgs>, respectively <ipcgs>.

\beginexample
gap> g:=Group((1,2,3,4),(1,2));;p:=Pcgs(g);;
gap> ip:=InducedPcgsByGeneratorsNC(p,[(1,2)(3,4),(1,3)(2,4)]);
[ (1,4)(2,3), (1,2)(3,4) ]
gap> m:=p mod ip;
[ (3,4), (2,4,3) ]
gap> NumeratorOfModuloPcgs(m);
[ (3,4), (2,4,3), (1,4)(2,3), (1,2)(3,4) ]
gap> DenominatorOfModuloPcgs(m);
[ (1,4)(2,3), (1,2)(3,4) ]
gap> IsPcgs(NumeratorOfModuloPcgs(m));                        
true
\endexample

\Declaration{CorrespondingGeneratorsByModuloPcgs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Action on subfactors}

\Declaration{VectorSpaceByPcgsOfElementaryAbelianGroup}

\Declaration{LinearOperationLayer}
\Declaration{AffineOperationLayer}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Pcgs with special properties}

\Declaration{PcgsElementaryAbelianSeries}
\Declaration{IsPcgsElementaryAbelianSeries}

\Declaration{PcgsCentralSeries}
\Declaration{IsPcgsCentralSeries}

\Declaration{PcgsPCentralSeriesPGroup}
\Declaration{IsPcgsPCentralSeriesPGroup}

\beginexample
gap> g:=Group((1,2,3,4),(1,2));;            
gap> p:=PcgsElementaryAbelianSeries(g);
[ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ]
gap> IndicesNormalSteps(p);
[ 1, 2, 3, 5 ]
gap> g:=Group((1,2,3,4),(1,5)(2,6)(3,7)(4,8));;
gap> p:=PcgsCentralSeries(g);           
[ (1,5)(2,6)(3,7)(4,8), (5,6,7,8), (5,7)(6,8), (1,4,3,2)(5,6,7,8), 
  (1,3)(2,4)(5,7)(6,8) ]
gap> IndicesNormalSteps(p);
[ 1, 2, 4, 5, 6 ]
gap> q:=PcgsPCentralSeriesPGroup(g);             
[ (1,5)(2,6)(3,7)(4,8), (5,6,7,8), (5,7)(6,8), (1,4,3,2)(5,6,7,8), 
  (1,3)(2,4)(5,7)(6,8) ]
gap> IndicesNormalSteps(q);
[ 1, 3, 5, 6 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Special Pcgs}

See \cite{Eick97} for details.

\Declaration{SpecialPcgs}
\Declaration{LGFirst}
\Declaration{LGLayers}
\Declaration{LGWeights}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroup series associated to a Pcgs}

\Declaration{IndicesNormalSteps}
\Declaration{NormalSeriesByPcgs}

\beginexample
gap> g:=Group((1,2,3,4),(1,2));;               
gap> p:=PcgsElementaryAbelianSeries(g);;
gap> IndicesNormalSteps(p);
[ 1, 2, 3, 5 ]
gap> NormalSeriesByPcgs(p);
[ Group( [ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ], ... ), 
  Group( [ (2,4,3), (1,4)(2,3), (1,3)(2,4) ], ... ), 
  Group( [ (1,4)(2,3), (1,3)(2,4) ], ... ), Group( [  ], ... ) ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{1-Cohomology}

\index{one cohomology}
\index{cohomology}
\index{cocycles}

Let $G$ be a finite group and  $M$ an elementary abelian normal subgroup of
$G$.  Then the group of one coboundaries $B^1( G/M, M )$ is defined as

%display{tex}
$$
B^1( G/M, M ) = \{ \gamma : G/M \rightarrow M \; ; \; \exists m\in M\forall
		g\in G : \gamma( gM ) = (m^{-1})^g \cdot m \}
$$
%display{text}
% B^1(G/M,M)={ y: G/M -> M | There is a m in M such that for all g in G
%                              y(gM)=m^-1*g*m   holds }
%enddisplay
It is a $GF(p)$-vector space.  The group  of cocycles $Z^1(  G/M, M  )$ is
defined as
%display{tex}
$$
Z^1( G/M, M ) = \{ \gamma : G/M \rightarrow M \; ; \; \forall
		g_1, g_2\in G :
		\gamma(g_1M \cdot g_2M ) =
		\gamma(g_1M)^{g_2} \cdot \gamma(g_2M) \}
$$
%display{text}
% Z^1(G/M,M)={ y: G/M -> M | For all g1,g2 in G holds: 
%                             y(g1 M * g2 M)= y(g1 M)^g2 * y(g2 M)
%enddisplay

and is also a $GF(p)$-vector space.

Let $\alpha$ be the isomorphism of $M$ into a row vector space ${\cal W}$
and $(g_1,   ..., g_l)$ representatives for  a  generating set  of $G/M$.
Then  there exists a  monomorphism   $\beta$ of $Z^1(   G/M, M )$  in the
$l$-fold direct sum of ${\cal W}$, such that $\beta( \gamma ) = ( \alpha(
\gamma( g_1M ) ), ..., \alpha( \gamma( g_lM ) ) )$  for  every $\gamma\in
Z^1( G/M, M )$.

\Declaration{OneCocycles}
\Declaration{OneCoboundaries}

The operations return a record with (at least) the components:

\beginitems
`generators'&
Is a list or representatives for a generating set of $G/M$. Cocycles are
represented with respect to these generators.

`oneCocycles'&
A space of row vectors over GF($p$), representing $Z^1$. The vectors are
represented in dimension $a\cdot b$ where $a$ is the length of `generators'
and $p^b$ the size of $M$.

`oneCoboundaries'&
A space of row vectors that represents $B^1$.

`cocycleToList'&
is a function to convert a cocycle (a row vector in `oneCocycles') to
a corresponding list of elements of $M$.

`listToCocycle'&
is a function to convert a list of elements of $M$ to a cocycle.

`isSplitExtension'&
indicates whether $G$ splits over $M$.
The following components are only bound if the extension splits. Note that
if $M$ is given by a modulo pcgs all subgroups are given as subgroups of $G$
by generators corresponding to `generators' and thus may not contain the
denominator of the modulo pcgs. In this case taking the closure with this
denominator will give the full preimage of the complement in the factor
group.

`complement'&
One complement to $M$ in $G$.

`cocycleToComplement'&
is a function that takes one cocycle from `oneCocycles' and returns the
corresponding complement to $M$ in $G$ (with respect to the fixed complement
`complement').

`complementToCocycle'&
is a function that takes a complement and returns the corresponding cocycle.

\enditems

If the factor <G>/<M> is given by a (modulo) pcgs <gens> then special
methods are used that compute a presentation for the factor implicitly from
the pcgs.

\beginexample
gap> g:=Group((1,2,3,4),(1,2));
Group( [ (1,2,3,4), (1,2) ], ... )
gap> n:=Group((1,2)(3,4),(1,3)(2,4));;
gap> oc:=OneCocycles(g,n);
rec(
  oneCoboundaries := VectorSpace( GF(2), 
    [ [ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ], [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] 
     ] ),
  oneCocycles := VectorSpace( GF(2), [ [ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ], 
      [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] ] ),
  generators := [ (3,4), (2,4,3) ],
  isSplitExtension := true,
  complement := Group( [ (3,4), (2,4,3) ], ... ),
  cocycleToList := function ( c ) ... end,
  listToCocycle := function ( L ) ... end,
  cocycleToComplement := function ( c ) ... end,
  factorGens := [ (3,4), (2,4,3) ],
  complementToCocycle := function ( K ) ... end )
gap> oc.cocycleToList([ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ]);
[ (1,2)(3,4), (1,2)(3,4) ]
gap> oc.listToCocycle([(),(1,3)(2,4)]);
[ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ]
gap> oc.cocycleToComplement([ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ]);
Group( [ (1,2), (1,2,3) ], ... )
gap> oc.cocycleToComplement([ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ]);
Group( [ (3,4), (1,3,4) ], ... )
gap> oc.complementToCocycle(Group((1,2,4),(1,4)));
[ 0*Z(2), Z(2)^0, Z(2)^0, Z(2)^0 ]
\endexample

Sometimes it might be desirable to stop calculations in the non-splitting
case if only complements are desired. This
can be done via the more technical function `OCOneCocycles'.
\Declaration{OCOneCocycles}

\>`InfoCoh'{info class!cohomology}

The info class for the cohomology calculations is `InfoCoh'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Conjugacy classes in solvable groups}

There are a variety of algorithms to compute conjugacy classes and
centralizers in solvable groups via epimorphic images
(\cite{FelschNeubueser79},\cite{MeckyNeubueser89},\cite{Theissen93}).
Usually these are only invoked as methods, but it is possible to access the
algorithm directly.

\Declaration{ClassesSolvableGroup}

\beginexample
gap> g:=SmallGroup(24,12);
Group( [ f1, f2, f3, f4 ], ... )
gap> ClassesSolvableGroup(g,0,                                                 
> rec(consider:=CentralizerSizeLimitConsiderFunction(2)));                     
[ rec(
      representative := f1,
      centralizer := Group( [ f1, f3*f4 ], ... ) ), rec(
      representative := f1*f4,
      centralizer := Group( [ f1*f3, f3*f4 ], ... ) ) ]
\endexample

See also `SubgroupsSolvableGroup'.
