%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  create.tex                GAP manual                    Thomas Breuer
%A                                                       Martin Schoenert
%%
%H  @(#)$Id$
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Creating New Objects}

The first sections of this chapter inform how filters are created,
see~"Creating Categories", "Creating Representations",
"Creating Attributes and Properties", "Creating Other Filters".

Section~"Creating Operations" describes how operations are created.

Then the sections~"Creating Families", "Creating Types",
and~"Creating Objects" describe how families, types,
and objects are created.

A small example of the implementation of list objects is given
in Section~"Implementing List Objects".

Section~"External Representation" introduces the external representation
of objects.

Finally, Section~"Declaration and Implementation Part" explains some
rules for the organization of {\GAP} packages.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Categories}

\>NewCategory( <name>, <super> )

`NewCategory' returns a new category <cat> that has the name <name> and
is contained in the filter <super>, see~"Filters".
This means that every object in <cat> lies automatically also in <super>.

For example, if one wants to create a category of group elements
then <super> should be `IsMultiplicativeElementWithInverses' or a
subcategory of it.
If no specific supercategory of <cat> is known,
<super> may be `IsObject'.

The incremental rank (see~"Filters") of <cat> is 1.

Two functions that return special kinds of categories are of importance.

\>CategoryCollections( <cat> )

For a category <cat>,
`CategoryCollections' returns the *collections category* of <cat>.
This is a category in that all collections of objects in <cat> lie.

For example, a permutation lies in the category `IsPerm',
and every dense list of permutations and every domain of permutations
lies in the collections category of `IsPerm'.

\>CategoryFamily( <cat> )

For a category <cat>,
`CategoryFamily' returns the *family category* of <cat>.
This is a category in that all families lie that know from their
creation that all their elements are in the category <cat>,
see "Creating Families".

For example, a family of tuples is in the category
`CategoryFamily( IsTuple )',
and one can distinguish such a family from others by this category.
So it is possible to install methods for operations that require one
argument to be a family of tuples.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Representations}

\>NewRepresentation( <name>, <super>, <slots> )

`NewRepresentation' returns a new representation <rep> that has the name
<name> and is a subrepresentation of the representation <super>.
This means that every object in <rep> lies automatically also in <super>.
The third argument <slots> is a list either of integers or of strings.
In the former case, <rep> must be `IsPositionalObjectRep' or a
subrepresentation of it, and <slots> tells what positions of the objects
in the representation <rep> may be bound.
In the latter case, <rep> must be `IsComponentObjectRep' or a
subrepresentation of, and <slots> lists the admissible names of
components that objects in the representation <rep> may have.
The admissible positions resp. component names of <super> need not be
be listed in <slots>.

The incremental rank (see~"Filters") of <rep> is 1.

Note that none of the positions resp. component names is compulsory for
an object in the representation <rep>.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Attributes and Properties}

\>NewAttribute( <name>, <filt> )
\)NewAttribute( <name>, <filt>, <rank> )

`NewAttribute' returns a new attribute <attr> with name <name>.
The arguments for <attr> are expected to lie in the filter <filt>,
for example the attribute `Size' was created with second argument
`IsDomain'.
Note that a method for <attr> that does not require its argument to lie
in <filt> must be installed using `InstallOtherMethod'.
For the example, there is a method for `Size' that is applicable to
lists.

<filt> describes also the implied filters of <attr>, see~"Filters".

The optional third argument <rank> denotes the incremental rank
(see~"Filters") of the tester of <attr>, the default value is 1.

\>NewAttribute( <name>, <filt>, "mutable" )
\)NewAttribute( <name>, <filt>, "mutable", <rank> )

If the third argument is the string `"mutable"', the stored values of the
new attribute are not forced to be immutable.
This is useful for an attribute whose value is some partial information
that may be completed later.
For example, there is an attribute for the list of all Sylow subgroups
of a group that have been computed already,
and this list is mutable because one may want to enter groups into it
as they are computed.

\>NewProperty( <name>, <filt> )
\)NewProperty( <name>, <filt>, <rank> )

`NewProperty' returns a new property <prop> with name <name>.
The arguments for <prop> are expected to lie in the filter <filt>,
and <filt> describes the implied filters of <prop>.
The optional third argument <rank> denotes the incremental rank
(see~"Filters") of the property <prop> itself, i.e. *not* of its tester,
the default value is 1.

Each method that is installed for an attribute or a property
via `InstallMethod' must require exactly one argument,
and this must lie in the filter <filt> that was entered as second
argument of `NewAttribute' resp. `NewProperty'.

As for any operation (see~"Creating Operations"),
for attributes and properties one can install a method taking an argument
that does not lie in <filt> via `InstallOtherMethod',
but unlike other operations, attributes and properties do not admit
to install methods for more than one argument.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Other Filters}

\>NewFilter( <name> )
\)NewFilter( <name>, <rank> )

It is also possible (but rarely used) to create a simple filter
(see~"Filters") that is not a category, a representation,
or an attribute or property.
Such a new filter with name <name> is returned by `NewFilter'.
The optional second argument <rank> denotes the incremental rank
(see~"Filters") of the filter, the default value is 1.

Suppose <filt> is a filter returned by `NewFilter'.
Contrary to categories and representations, it is not necessary that
each object knows at the time of its creation whether or not it lies in
<filt>.
Contrary to attributes and properties, one cannot install methods to
compute the value of <filt> for an object, and also `Setter' and
`Tester' do not work for <filt>.

In order to change the value of <filt> for an object <obj>,
one can use only the functions

\>SetFilterObj( <obj>, <filt> )
\)ResetFilterObj( <obj>, <filt> )

`SetFilterObj' sets the value of <filt> for <obj> to `true',
`ResetFilterObj' sets the value of <filt> for <obj> to `false'.
The default value of <filt> for each object is `false'.

%T Categories and representations should not be operations,
%T the same for filters made by `NewFilter'!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Operations}

\>NewOperation( <name>, <args-filts> )

`NewOperation' returns an operation <opr> with name <name>.
The list <args-filts> describes requirements about the arguments
of <opr>, namely the number of arguments must be equal to the length of
<args-filts>, and the $i$-th argument must lie in the filter
`<args-filts>[$i$]'.

Each method that is installed for <opr> via `InstallMethod' must require
that the $i$-th argument lies in the filter `<args-filts>[$i$]'.

One can install methods for other arguments tuples via
`InstallOtherMethod',
this way it is also possible to install methods for a different number
of arguments than the length of <args-filts>.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Families}

\>NewFamily( <name> )
\)NewFamily( <name>, <req> )
\)NewFamily( <name>, <req>, <imp> )

`NewFamily' returns a new family <fam> with name <name>.
The argument <req>, if present, is a filter of which <fam> shall be a
subset.
If one tries to create an object in <fam> that does not lie in the filter
<req>, an error message is printed.
Also the argument <imp>, if present, is a filter of that <fam> shall be a
subset.
Any object that is created in the family <fam> will lie automatically in
the filter <imp>.

There are a few functions in {\GAP} that construct families.
As an example, consider

\>CollectionsFamily( <fam> )

`CollectionsFamily' is an attribute that takes a family <fam> as
argument, and returns the family of all collections over <fam>,
that is, of all dense lists and domains that consist of objects in
<fam>.

The `NewFamily' call in the standard method of `CollectionsFamily'
is executed with second argument `IsCollection',
since every object in the collections family must be a collection,
and with third argument the collections categories of the involved
categories in the implied filter of <fam>.

If <fam> is a collections family then

\>ElementsFamily( <fam> )

returns the family with collections family <fam>.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Types}

\>NewType( <fam>, <filt> )
\)NewType( <fam>, <filt>, <data> )

`NewType' returns the type given by the family <fam>
and the filter <filt>.
The optional third argument <data> is any object that denotes defining
data of the desired type.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Objects}

\>Objectify( <type>, <data> )

New objects are created by `Objectify'.
<data> is a list or a record, and <type> is the type that the desired
object shall have.
`Objectify' turns <data> into an object with type <type>.
That is, <data> is changed, and afterwards it will not be a list or a
record unless <type> is a type of a list resp. record.

If <data> is a list then `Objectify' turns it into a positional object,
if <data> is a record then `Objectify' turns it into a component object
(for examples, see~"Component Objects" and~"Positional Objects").

`Objectify' does also return the object that it made out of <data>.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Component Objects}

A *component object* is an object in the representation
`IsComponentObjectRep' or a subrepresentation of it.
Such an object <cobj> is built from subobjects that can be accessed via
`<cobj>!.<name>', similar to components of a record.
Also analogously to records, values can be assigned to components of
<cobj> via `<cobj>!.<name>:= <val>'.

Note that it is possible to add components and to change the values of
components also if <cobj> claims that it is immutable, i.e., if <cobj>
is not in the category `IsMutable'.

So one must be *very careful* when `!.' shall be used.
Especially, <name> must be among the admissible component names for
the representation of <cobj>, see~"Creating Representations".

The following example shows the implementation of an iterator
(see~"Iterators") for the domain of integers,
which is represented as component object.
See~"Positional Objects" for an implementation using positional objects.

The used succession of integers is $0, 1, -1, 2, -2, 3, -3, \ldots$,
that is, $a_n = n/2$ if $n$ is even,
and $a_n = (1-n)/2$ otherwise.

\begintt
    IsIntegersIteratorRep := NewRepresentation( "IsIntegersIteratorRep",
        IsComponentObjectRep, [ "counter" ] );

    InstallMethod( Iterator,
        "method for `Integers'",
        true,
        [ IsIntegers ], 0,
        function( Integers )
        return Objectify( NewType( IteratorsFamily,
                                       IsIterator
                                   and IsIntegersIteratorRep ),
                          rec( counter := 0 ) );
        end );

    InstallMethod( IsDoneIterator,
        "method for iterator of `Integers'",
        true,
        [ IsIterator and IsIntegersIteratorRep ], 0,
        ReturnFalse );

    InstallMethod( NextIterator,
        "method for iterator of `Integers'",
        true,
        [ IsIntegersIterator ], 0,
        function( iter )
        iter!.counter:= iter!.counter + 1;
        if iter!.counter mod 2 = 0 then
          return iter!.counter / 2;
        else
          return ( 1 - iter!.counter ) / 2;
        fi;
        end );
\endtt

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Positional Objects}

A *positional object* is an object in the representation
`IsPositionalObjectRep' or a subrepresentation of it.
Such an object <pobj> is built from subobjects that can be accessed via
`<pobj>![<pos>]', similar to positions in a list.
Also analogously to lists, values can be assigned to positions of
<pobj> via `<pobj>![<pos>]:= <val>'.

Note that it is possible to add entries and to change the values of
positions also if <pobj> claims that it is immutable, i.e., if <pobj>
is not in the category `IsMutable'.

So one must be *very careful* when `![]' shall be used.
Especially, <pos> must be among the admissible positions for
the representation of <pobj>, see~"Creating Representations".

The following example shows the implementation of an iterator
(see~"Iterators") for the domain of integers,
which is represented as positional object.
See~"Component Objects" for an implementation using component objects.

\begintt
    IsIntegersIteratorRep := NewRepresentation( "IsIntegersIteratorRep",
        IsPositionalObjectRep, [ 1 ] );

    InstallMethod( Iterator,
        "method for `Integers'",
        true,
        [ IsIntegers ], 0,
        function( Integers )
        return Objectify( NewType( IteratorsFamily,
                                       IsIterator
                                   and IsIntegersIteratorRep ),
                          [ 1 ] );
        end );

    InstallMethod( IsDoneIterator,
        "method for iterator of `Integers'",
        true,
        [ IsIterator and IsIntegersIteratorRep ], 0,
        ReturnFalse );

    InstallMethod( NextIterator,
        "method for iterator of `Integers'",
        true,
        [ IsIntegersIterator ], 0,
        function( iter )
        iter![1]:= iter![1] + 1;
        if iter![1] mod 2 = 0 then
          return iter![1] / 2;
        else
          return ( 1 - iter![1] ) / 2;
        fi;
        end );
\endtt

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Implementing List Objects}

A list in {\GAP} is an object in the category `IsList'.
Basic operations for lists are `Length', `\\[\\]', and `IsBound\\[\\]'.

Note that the access to the position <pos> in the list <list>
via `<list>[<pos>]' is handled by the call `\\[\\]( <list>, <pos> )'
to the operation `\\[\\]'.
to explain the somewhat strange name `\\[\\]' of this operation,
note that non-alphanumeric characters like `[' and `]' may occur in
{\GAP} variable names only if they are escaped by a `\\' character.

Analogously, the check `IsBound( <list>[<pos>] )' whether the position
<pos> of the list <list> is bound is handled by the call
`IsBound\\[\\]( <list>, <pos> )' to the operation
`IsBound\\[\\]'.

For mutable lists, also assignment to positions and unbinding of
positions via the operations `\\[\\]\\:\\=' and `Unbind\\[\\]'
are basic operations.
The assignment `<list>[<pos>]:= <val>' is handled by the call
`\\[\\]\\:\\=( <list>, <pos>, <val> )',
and `Unbind( <list>[<pos>] )' is handled by the call
`Unbind\\[\\]( <list>, <pos> )'.

All other operations for lists, e.g., `Add', `Append', `Sum',
are based on these operations.
This means that it is sufficient to install methods for the new list
objects only for the basic operations.

So new list objects are created as objects in the category `IsList'
for that methods for `Length', `\\[\\]', and `IsBound\\[\\]' are
installed,
and perhaps also for `\\[\\]\\:\\=' and `Unbind\\[\\]'.

One application for this is the implementation of *enumerators*
for domains.
An enumerator for the domain $D$ is a dense list whose entries are
in bijection with the elements of $D$.
If $D$ is large then it is not useful to write down all elements.
Instead one can implement such a bijection implicitly.
This works also for infinite domains.

In this situation, one implements a new representation of the
lists that are already available in {\GAP},
especially the family of such a list is the same as the family of
the domain $D$.

But it is also possible to implement new kinds of lists that lie in
new families, and thus are not equal to lists that were available
in {\GAP} before.
An example for this is the implementation of matrices
whose multiplication via '`*'' is the Lie product of matrices.

In this situation, it makes no sense to put the new matrices into the
same family as the original matrices.
Note that the product of two Lie matrices shall be defined but not the
product of an ordinary matrix and a Lie matrix.
So it is possible to have two lists that have the same entries but that
are not equal w.r.t. '`='' because they lie in different families.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{External Representation}

An operation is defined for elements rather than for objects in the sense
that if the arguments are replaced by objects that are equal to the old
arguments w.r.t. the equivalence relation '`='' then the result must be
equal to the old result w.r.t. '`=''.

But the implementation of many methods is representation dependent in the
sense that certain representation dependent subobjects are accessed.

For example, a method that implements the addition of univariate
polynomials may access coefficients lists of its arguments
only if they are really stored, 
in the case of sparsely represented polynomials a different approach is
needed.

In spite of this, for many operations one does not want to write an own
method for each tuple of representations of the arguments,
for example because there is no way to take advantage of the given
representation of objects,
or because one wants to install one representation independent method
first, and then add specific methods as they are needed to gain more
efficiency.

For this purpose,
one can define an *external representation* of objects in a given family,
install methods to compute this external representation for each
representation of the objects,
and then for other operations install methods that use only the external
representation.

The external representation of an object <obj> does in general *not* lie
in the same family as <obj>,
it only encodes the object <obj> in such a way that from this data and
the family of <obj> one can create an object that is equal to <obj>.
Usually the external representation of an object is a list or a record.
For example, a polynomial may have a suitable coefficients list as
external representation;
note that is may be necessary to have the zero coefficient as part of
the external representation of polynomials if the family of the
polynomials does not determine the zero coefficients uniquely.

To implement an external representation means to install methods for the
following two operations.

\>ExtRepOfObj( <obj> )
\>ObjByExtRep( <fam>, <data> )

`ExtRepOfObj' returns the external representation of its argument,
and `ObjByExtRep' returns an object in the family <fam> that has
external representation <data>.

Of course, `ObjByExtRep( FamilyObj( <obj> ), ExtRepOfObj( <obj> ) )'
must be equal to <obj>.
But it is *not* required that equal objects have equal external
representations.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Declaration and Implementation Part}

Each package of {\GAP} code consists of two parts,
the *declaration part* that defines the new categories and operations for
the objects the package deals with,
and the *implementation part* where the corresponding methods are
installed.
The declaration part should be representation independent,
representation dependent information should be dealt with in the
implementation part.

{\GAP} functions that are not operations and that are intended to be
called by users should be notified to {\GAP} in the declaration part via

\>NewOperationArgs( <name> )

`NewOperationArgs' returns a function that serves as a placeholder
for the function that will be installed in the implementation part,
and that will print an error message if it is called.

% what anbout
% \>InstallMethodArgs( ... ) ???


Calls to the following functions belong to the declaration part.

`InstallTrueMethod'
`NewAttribute',
`NewCategory',
`NewFilter',
`NewOperation',
`NewOperationArgs',
`NewProperty'.

Calls to the following functions belong to the implementation part.

`InstallMethod'
`InstallImmediateMethod'
`InstallOtherMethod'
`NewFamily',
`NewRepresentation',
`NewType',
`Objectify'.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E
