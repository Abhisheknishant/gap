%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  concepts.tex              GAP manual                    Thomas Breuer
%A                                                       Martin Schoenert
%%
%H  @(#)$Id$
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Objects and Elements}

An *object* is everything in {\GAP} that can be assigned to a variable,
so nearly everything in {\GAP} is an object.

Different objects can be regarded as equal w.r.t. the equivalence
relation '=',
in this case we say that the objects describe the same *element*.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Objects}

Nearly all things one deals with in {\GAP} are *objects*.
For example, an integer is an object, as is a list of integers, a matrix,
a permutation, a function, a list of functions, a group,
a coset or a conjugacy class in a group.

Examples of things that are not objects are
comments which are only lexical constructs,
`while' loops which are only syntactical constructs,
and expressions, such as `1 + 1';
but note that the value of an expression, in this case the integer '2',
is an object.

Objects can be assigned to variables,
and everything that can be assigned to a variable is an object.
Analogously, objects can be used as arguments of functions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Elements}

The equality operation '=' defines an equivalence relation on all {\GAP}
objects.
The equivalence classes are called *elements*.

There are basically three reasons to regard different objects as equal.
Firstly, the same information may be stored in different places.
Secondly, the same information may be stored in different ways;
for example, a polynomial can be stored sparsely or densely.
Thirdly, different information may be equal modulo a mathematical
equivalence relation;
for example, in a finitely presented group with the relation $a^2 = 1$
the different objects $a$ and $a^3$ describe the same element.

As an example for all three aspects, consider the possibility to store
an integer in several places of the memory,
to represent it as a fraction with denominator 1,
or to represent it as a fraction with any denominator, with numerator
a suitable multiple of it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Domains}

A *domain* in {\GAP} is a structured set.
Domains are objects.

For example, every group is a domain, every conjugacy class of elements
in a group is a domain, every coset in a group is a domain.

Domains are the most important objects in {\GAP}.
In a sense, the only reason to introduce objects such as integers and
permutations in {\GAP} is the wish to form domains of them.

Domains have an *operational structure*,
that is, a collection of operations under that the domain is closed.
For example, a group is closed under multiplication,
taking the identity of elements, and taking inverses of elements.

The operations under that a domain is closed are a subset of
the operations that the elements of a domain admit.
It is possible that the elements admit more operations.
For example, matrices can be multiplied and added.
But addition plays no role in a group of matrices,
and multiplication plays no role in a vector space of matrices.
Especially, a matrix group is not closed under addition.

Note that the elements of a domain exist independent of this domain,
usually they existed already before the domain was created.
So it makes sense to say that a domain is *generated* by some elements
with respect to certain operations.

Of course, different sets of operations yield different notions of
generation.
For example, the group generated by some matrices is different from
the ring generated by these matrices, and these two will be in general
different from the vector space generated by the same matrices,
over a suitable field.

Additionally to the operational structure,
a domain can have properties.
For example, the multiplication of a group is associative,
and the multiplication in a field is commutative.

Note that associativity and commutativity depend on the set of
elements for that one considers the multiplication,
i.e., it depends on the domain.
For example, the multiplication in a full matrix ring over a field
is not commutative, whereas its restriction to the set of diagonal
matrices is commutative.

One important difference between the operational structure and the
properties of a domain is that the operational structure is fixed when
the domain is constructed, whereas properties can be found out later.
For example, take a domain whose operational structure is given by
closure under multiplication.
Also if it is found out that by chance also the inverses of all elements
lie in this domain,
being closed under taking inverses is not added to the operational
structure.
But a domain with operational structure multiplication,
taking the identity, and taking inverses
will be treated as a group as soon as the multiplication is found out to
be associative for this domain.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Identical Objects}

Two objects that are equal (as objects and not only w.r.t. the equality
relation `=') are called *identical*.
So identical objects do of course describe the same element.

Usually one may deal with objects but think of elements,
because one is not interested in places in memory, ways of storing,
and information beyond underlying equivalence relations.

But there are cases where it is important to distinguish the relations
identity and equality.
This is best illustrated with an example.
\beginexample
    gap> l1:= [ 1, 2, 3 ];; l2:= [ 1, 2, 3 ];;
    gap> l1 = l2;
    true
    gap> IsIdentical( l1, l2 );
    false
    gap> l1[3]:= 4;; l1; l2;
    [ 1, 2, 4 ]
    [ 1, 2, 3 ]
    gap> l1 = l2;
    false
\endexample
The two lists `l1' and `l2' are equal but not identical.
Thus a change in `l1' does not affect `l2'.
\beginexample
    gap> l1:= [ 1, 2, 3 ];; l2:= l1;;
    gap> l1 = l2;
    true
    gap> IsIdentical( l1, l2 );
    true
    gap> l1[3]:= 4;; l1;; l2;
    [ 1, 2, 4 ]
    [ 1, 2, 4 ]
    gap> l1 = l2;
    true
\endexample
Here, `l1' and `l2' are identical objects,
so changing `l1' means to change also `l2'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Mutability and Copyability}

For many purposes, *mutable* objects are useful.
One example are mutable lists,
they can be changed by assigning values to positions
or by unbinding values at certain positions.
Similarly, one can assign values to components of a mutable record,
or unbind them.

In other situations, however,
one wants to ensure that certain objects are *immutable*,
i. e., that they cannot be changed.
For example, take the identity of a matrix group.
Since this matrix may be referred to as identity of the group in several
places, it would be fatal to modify its entries, or add or unbind rows.

An immutable copy <imm> of an object <obj> is obtained as

\>Immutable( <obj> )

The subobjects of <imm> are immutable copies of the subobjects of <obj>.
If <obj> is immutable then `Immutable' returns <obj> itself.

Conversely, if {\GAP} supports a mutable form <mut> of an object <obj>
then this is obtained as

\>ShallowCopy( <obj> )

The subobjects of <mut> are *identical* to the subobjects of <obj>.
Note that <mut> is not identical with <obj> even if <obj> is mutable.

Objects for that only an immutable form exists in {\GAP}
are called *constants*.
Examples of constants are integers, permutations, and domains.
Called with a constant as argument,
`Immutable' and `ShallowCopy' return this argument.

If both a mutable and an immutable form of an object are available in
{\GAP}, the object is called *copyable*.
Examples of copyable objects are of course lists and records.
Given an immutable matrix <mat>,
`ShallowCopy' returns a mutable matrix whose rows are identical with the
rows of <mat>,
especially the rows are immutable.
To get a matrix whose rows are mutable,
one can use `List( <mat>, ShallowCopy )'.

Another interesting example of mutable objects is provided by
*iterators*, see "Iterators".
Every call of `NextIterator' changes the iterator until it is exhausted,
and this is the only possibility to change an iterator.

Note that it is not possible to turn a mutable object into an immutable
one or vice versa,
only mutable resp. immutable copies can be made.
With this approach,
it is possible to store an immutable identity matrix
or an immutable list of generators,
and to make a mutable copy whenever it is needed.
Compared to the situation without immutable objects,
much unnecessary copying is avoided this way.
Another advantage of immutability is
that lists of immutable objects may store whether they are sorted,
which is not possible for lists of mutable objects.

Many operations return immutable results.
Among them are all arithmetic operations,
such as `Zero', `One', `AdditiveInverse', `Inverse', `Comm',
and the infix operations `+', `-', `*', `/', `^', `mod'.
So the product of two matrices or of a vector and a matrix is immutable,
no matter whether the arguments are mutable or immutable.

In a few situations,
one wants to make a *structural copy* <scp> of an object <obj>.
This is defined as follows.
<scp> and <obj> are identical if <obj> is immutable.
Otherwise, <scp> is a mutable copy of <obj> such that
each subobject of <scp> is a structural copy of the corresponding
subobject of <obj>.
Furthermore, if two subobjects of <obj> are identical then
also the corresponding subobjects of <scp> are identical. 

Here is an example.
\beginexample
    gap> obj:= [ [ 0, 1 ] ];;
    gap> obj[2]:= obj[1];;
    gap> obj[3]:= Immutable( obj[1] );;
    gap> scp:= StructuralCopy( obj );
    gap> scp = obj; IsIdentical( scp, obj );
    true
    false
    gap> IsIdentical( scp[1], obj[1] );
    false
    gap> IsIdentical( scp[3], obj[3] );
    true
    gap> IsIdentical( scp[1], scp[2] );
    true
\endexample

Note that being immutable does not forbid an object to store knowledge.
For example, if it is found out that an immutable list is strictly
sorted then the list may store this information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Types of Objects}

Every {\GAP} object has a *type*.
Types are used to decide whether an operation is admissible or possible,
and if yes, how it is performed.

For example, the types determine whether two objects can be multiplied
and what function is called to compute the product.
Analogously, the type of an object determines whether and how the size
of the object can be computed.

The type of an object consists of the following parts,
which describe different aspects of the object.
It might be useful to identify each type with the set of objects that
have this type, and likewise to regard each part of a type as a set.

The *family* determines the relation of the object to other objects.
For example, all permutations form a family.
Another family consists of all collections of permutations,
this family contains the set of permutation groups as a subset.
A third family consists of all rational functions with coefficients
in a certain family.

The *categories* determine what operations an object admits.
For example, all integers form a category, all rationals form a category,
and all rational functions form a category.

The *representation* determines how an object is actually represented.
For example, a matrix or a polynomial can be stored sparse or dense;
all dense polynomials form a representation.

The *attributes* describe knowledge about an object.
For example, the set of objects corresponding to the attribute `Size'
is formed by all objects for that the value of `Size' is known resp.
can be computed cheaply.

*Properties* are those attributes with possible values `true' and
`false'.
Additionally to the set of objects for that the value of a property is
known, a property defines another important set,
namely the set of all thise objects for that the value is known and
`true'.
For example, all groups for that is known whether they are commutative
belong to the former set, and the groups that are known to be commutative
belong to the latter set of the property `IsCommutative'.

Now we describe these parts of types in more detail.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Families}

The family of an object determines its relation to other objects.

More precisely, the families form a partition of all {\GAP} objects
such that the following two conditions hold.
Objects that are equal w.r.t. ```=''' lie in the same family.
The family of the result of an operation depends only on the families
of its operands.

The first condition means that a family can be regarded as a set of
elements instead of a set of objects.
Note that this does not hold for categories and representations
(see below),
equal objects need not lie in the same categories and representations.
For example, a sparsely represented matrix can be equal to a densely
represented matrix.
Similarly, each domain is equal to the sorted list of its elements,
but a domain is not a list, and a list is not a domain.

The family of the object <obj> is itself an object,
it can be accessed as `FamilyObj( <obj> )'.

It should be emphasized that families are created as soon as they are
needed.
For example, the family of elements of a finitely presented group
can be created only after the presentation has been constructed.
Thus families are the dynamic part of the type system,
that is, the part that is not fixed after the initialisation of {\GAP}.

Families can be parametrized.
For example, the elements of each finitely presented group form a family
of their own.
Here the family of elements and the finitely presented group,
coincide when viewed as sets.
Note that different finitely presented groups belong to different
families, and the elements of these different families cannot be
multiplied.

As a special case, families can be parametrized by other families.
An important example is the family of *collections* that can be formed
for each family.
A collection consists of objects that lie in the same family,
it is either a nonempty dense list of objects from the same family
or a domain.

Note that every domain is a collection, that is,
it is not possible to construct domains whose elements lie in different
families.
For example, a polynomial ring over the rationals cannot contain
the integer `0' because the family that contains the integers
does not contain polynomials.
So one has to distinguish the integer zero from each zero polynomial.

Let us look at this example from a different viewpoint.
A polynomial ring and its coefficients ring lie in different families,
hence the coefficients ring cannot be embedded ``naturally'' into the
polynomial ring in the sense that it is a subset.
But it is possible to allow, e.g., the multiplication of an integer
and a polynomial over the integers.
The relation between the arguments,
namely that one is a coefficient and the other a polynomial,
can be detected from the relation of their families.
Moreover, this analysis is easier than in a situation where the rationals
would lie in one family together with all polynomials over the rationals,
because then the relation of families would not distinguish
the multiplication of two polynomials,
the multiplication of two coefficients,
and the multiplication of a coefficient with a polynomial.

In this sense, the wish for ``natural embeddings'' is just a special case
of the wish to describe relations between elements,
and can be taken as a motivation for the introduction of families.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Categories}

The categories of an object determine what operations it admits.
Turned the other way around, every operation requires its arguments
to lie in certain categories.

An object can lie in several categories.
For example, a row vector lies in the categories `IsList' and `IsVector';
each list lies in the category `IsCopyable',
and depending on whether or not it is mutable, it may lie in the category
`IsMutable'.
Every domain lies in the category `IsDomain'.

If an object is immutable then the set of categories it belongs to is
fixed.

Of course some categories of mutable objects may change.
For example, by assigning values to positions of a mutable list,
one can change the membership of this list in the categories `IsEmpty'
and `IsDenseList'.

All categories are created during initialization,
especially they are not created dynamically at runtime.

The following list gives an overview of important categories of
arithmetic objects.
Indented categories are to be understood as subcategories of the not
indented category listed above it.
\beginexample
    IsObject
        IsExtLElement
        IsExtRElement
            IsMultiplicativeElement
                IsMultiplicativeElementWithOne
                    IsMultiplicativeElementWithInverse
        IsExtAElement
            IsAdditiveElement
                IsAdditiveElementWithZero
                    IsAdditiveElementWithInverse
\endexample
Every object lies in the category `IsObject'.
The categories `IsExtLElement' and `IsExtRElement' contains objects
that can be multiplied with other objects via `*' from the left and
from the right, respectively.
These categories are required for the operands of the operation `*'.

The category `IsMultiplicativeElement' contains objects that can be
multiplied from the left and from the right with objects from the
same family.
`IsMultiplicativeElementWithOne' contains objects <obj> for that a
multiplicatively neutral element can be obtained on taking the
zeroth power `<obj>^0'.
`IsMultiplicativeElementWithInverse' contains objects <obj> for that a
multiplicative inverse can be obtained on forming `<obj>^-1'.

Likewise, the categories `IsExtAElement', `IsAdditiveElement',
`IsAdditiveElementWithZero', and `IsAdditiveElementWithInverse'
contain objects that can be added via `+' with other objects,
objects that can be added with objects of the same family,
objects for that an additively neutral element can be obtained
on multiplication with zero,
and objects for that an additive inverse can be obtained on
multiplication with '-1'.

So a vector lies in `IsExtLElement', `IsExtRElement', and
`IsAdditiveElementWithInverse'.
A ring element must additionally lie in `IsMultiplicativeElement'.

Note that it is not guaranteed from the categories of objects whether
the result of an operation with these objects as arguments is defined.
For example, the category `IsMatrix' is a subcategory of
`IsMultiplicativeElementWithInverse'.
Clearly not every matrix has a multiplicative inverse.
But the category `IsMatrix' makes each matrix an admissible argument of
the operation `Inverse'.
% Likewise, two matrices can be multiplied only if they are of appropriate
% shapes.

Analogously to the categories of arithmetic elements,
there are categories of domains of these elements.
\beginexample
    IsObject
        IsDomain
            IsMagma
                IsMagmaWithOne
                    IsMagmaWithInversesIfNonzero
                        IsMagmaWithInverses
            IsAdditiveMagma
                IsAdditiveMagmaWithZero
                    IsAdditiveMagmaWithInverses
            IsExtLSet
            IsExtRSet
\endexample
Of course `IsDomain' is a subcategory of `IsObject'.
A domain that is closed under multiplication `*' is called a magma,
it lies in the category `IsMagma'.
If a magma is closed under taking the identity,
it lies in `IsMagmaWithOne',
and if it is also closed under taking inverses,
it lies in `IsMagmaWithInverses'.
The category `IsMagmaWithInversesAndZero' denotes closure under
taking inverses only for nonzero elements,
every division ring lies in this category.

% (N.B.: For reasons of aesthetics,
% better define `IsMagmaWithInversesIfNonzero',
% an intermediate category between `IsMagmaWithOne' and `IsMagmaWithInveses';
% note that the existence of a zero element in a division ring is guaranteed
% by the categories concerning addition.)

Note that every set of categories constitutes its own notion of
generation, for example a group may be generated as a magma with inverses
by some elements,
but to generate it as a magma with one it may be necessary to take the
union of these generators and their inverses.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Representation}

The representation of an object determines how it is actually
represented.

{\GAP} distinguishes four essentially different ways to represent
objects.
First there are the representations `IsInternalRep' for internal objects
such as integers and permutations,
and `IsDataObjectRep' for other objects that are created and whose data
are accessible only by kernel functions.

% (N.B.: WHAT exactly to write here?)

All other objects are either in the representation `IsComponentObjectRep'
or in the representation `IsPositionalObjectRep'.
Objects in the former representation are built from subobjects that can
be accessed via `<cobj>!.<name>', similar to components of a record.
Objects in the latter representation are built from subobjects that can
be accessed via `<pobj>![<pos>]', similar to positions in a list.

An object can belong to several representations in the sense that it lies
in subrepresentations of `IsComponentObjectRep' or
`IsPositionalObjectRep'.
The representations to that an object belongs form a chain, 
because either two representations are disjoint or one is contained in
the other.
So the subrepresentations of `IsComponentObjectRep' resp.
`IsPositionalObjectRep' form trees.

Objects may change their representation,
for example a mutable list of characters can be converted into a string.

All representations are created during initialization,
especially they are not created dynamically at runtime.

Examples of subrepresentations of `IsPositionalObjectRep' are
`IsModulusRep',
which is used for residue classes in the ring of integers,
and `IsDenseCoeffVectorRep',
which is used for elements of algebras that are defined by structure
constants.

An important subrepresentation of `IsComponentObjectRep' is
`IsAttributeStoringRep', which is used for many domains.
It provides automatical storing of all attribute values (see below).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes}

The attributes of an object describe knowledge about it.

An attribute is a unary operation without side-effects.

An object may store values of its attributes once they have been
computed, and claim that it knows these values.
Note that ``store'' and ``know'' have to be understood in the sense that 
it is very cheap to get such a value when the attribute is called again.

% (N.B.: a word on the guarantee that each call of an attribute for an
% object yields the same value?)

Thus an attribute can be identified with the set of all objects for that
the attribute value is known.
For example, all groups whose order is known lie in the set of the
attribute `Size'.

Obviously, the set of attributes to that an object belongs can change;
in general, an object belongs to only few attributes when it is created,
and will lie in more and more attributes as their values are computed.

To check whether an object belongs to an attribute <attr>,
the tester

\>Tester( <attr> )

of the attribute is used;
this is a function that returns `true' or `false',
depending on whether or not the value of <attr> for the object is known.
For example, `Tester( Size )( <obj> )' is `true' if the size of the object
<obj> is known.

% Shall the `HasAttr' and `SetAttr' names be mentioned?

To store a value of the attribute <attr> in an object,
the setter

\>Setter( <attr> )

of the attribute is used.
The setter is called automatically when the attribute value has been
computed for the first time.
One can also call the setter explicitly,
for example, `Setter( Size )( <obj>, <val> )' sets <val> as size of the
object <obj> if the size was not yet known.

All attributes are created during initialization,
especially they are not created dynamically at runtime.

Examples of attributes for multiplicative elements are `Inverse', `One',
and `Order'.
`Size' is an attribute for domains, `Centre' is an attribute for a magma,
and `DerivedSubgroup' is an attribute for groups.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Properties}

The properties of an object are those of its attributes whose values are
`true' or `false'.

The only difference between attributes and properties is that a property
defines two sets,
namely the usual set of all objects for that the value is known,
and the set of all objects for that the value is known to be `true'.
If a property value is known for an immutable object then this value is
also stored, as part of the type of the object.
To some extent, also property values of mutable objects can be stored,
for example a mutable list all of whose entries are immutable can store
whether it is strictly sorted.

For a property <prop>, the containment of an object <obj> in the first
set is checked again by applying `Tester( <prop> )' to <obj>,
and <obj> lies in the second set if and only if
`Tester( <prop> )( <obj> ) and <prop>( <obj> )' is `true'.

Note that it makes no sense to consider the set of objects for that the
value of a property is `true', since there may be objects for that the
containment in this set cannot be decided.

Important properties for domains are `IsAssociative', `IsCommutative',
`IsAnticommutative', `IsLDistributive', and `IsRDistributive',
which mean that the multiplication of elements in the domain satisfies
$(a \* b ) \* c = a \* ( b \* c )$, $a \* b = b \* a$,
$a \* b = - ( b \* a )$, $a \* ( b + c ) = a \* b + a \* c$,
and $( a + b ) \* c = a \* c + b \* c$, respectively,
for all $a$, $b$, $c$ in the domain.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Filters}

As introduced above, each category, representation, or attribute tester
can be identified with the set of all objects that lie in the respective
category, representation, or attribute.
For properties, not only the tester but also the property itself is such
a set,
namely the set of all objects for that the property value is known to be
`true'.

{}From this viewpoint, these different concepts can be described
uniformly as *filters*,
which are special {\GAP} functions that return either `true' or `false',
depending on whether or not the argument lies in the set defined by the
filter.

The intersection of two filters <filt1>, <filt2> is again a filter,
it can be formed as `<filt1> and <filt2>'.

For example, `IsList and IsEmpty' is a filter that returns `true'
if its argument is an empty list, and `false' otherwise.
The filter `IsGroup' is defined as the intersection of the category
`IsMagmaWithInverses' and the property `IsAssociative'.

A filter that is not the meet of other filters
is called a *simple filter*.
For example, each attribute tester is a simple filter.

Every filter <filt> has a *rank*, which can be accessed as

\>RankFilter( <filt> )

For simple filters, an *incremental rank* is defined when the filter is
created.
The rank of a filter is given by the sum of incremental ranks of the
involved simple filters,
where also those filters are involved that were explicitly notified as
*implied filters* of <filt> when <filt> was created.
Note that an object in <filt> does not necessarily lie in all
implied filters of <filt>.

For example, `Size' is defined as an attribute for domains,
and `IsDomain' is an implied filter of the filter `Tester( Size )';
But there are also methods for `Size' to compute the size of lists,
which are not domains.

\>NamesFilter( <filt> )

returns a list of names of the implied filters of the filter <filt>.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Types}

For an object <obj>, its *type* is formed by the following data.
The family of <obj>,
the filters in that <obj> lies,
and, optionally, defining data of <obj>.

Two types are equal if and only if the two families are identical,
the filters are equal, and, if present, also the defining data are equal.

The last part of the type, defining data, has not been mentioned before.
It is used, e.g., for residue classes of integers, where the type of each
residue class modulo <n> contains the modulus <n> as defining data.
As a consequence, two residue classes mod <n> and <m> can have the same
type only if `<n> = <m>'.
The defining data of the type <type> can beaccessed as

\>DataType( <type> )

The type of an object is itself an object,
it can be accessed as

\>TypeObj( <obj> )

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Method Selection}

An *operation* is a special {\GAP} function that corresponds to a set of
functions, its *methods*.

All methods of an operation compute the same result.
But each method is installed for specific types of arguments.

If an operation is called with a tuple of arguments,
one of the applicable methods is selected and called.

Special cases of methods are partial methods, immediate methods,
and logical implications.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations and Methods}

Operations are functions in the category `IsOperation'.

So on one hand, *operations* are {\GAP} functions, that is,
they can be applied to arguments and return a result or cause a
side-effect.

On the other hand, operations are more.
Namely, an operation corresponds to a set of {\GAP} functions,
called the *methods* of the operation.

% (N.B.: Is it reasonable to introduce a category `IsOperation'?
% Then it is easier to define what an operation is.)

Each call of an operation causes that a suitable method is selected
and then called.
The decision what method to select is made according to the types
of the arguments,
the underlying mechanism is described in the following sections.

Examples of operations are the binary infix operators `=', `+' etc.,
and `PrintObj' is the operation that is called for each argument of
`Print'.

% (N.B.: IS `=' an operation, or does it only BELONG to the operation `\='?)

Also all attributes and properties are operations.
When an attribute is called then one of its methods is called
also if the attribute value is already stored;
this method should of course simply return this value.

As stated above, the setter of an attribute is called automatically
if an attribute value has been computed.
Attribute setters are operations, too.
They have a default method that ignores the request to store the value.
Depending on the type of the object,
there may be another method to store the value in a suitable way,
and then set the attribute tester for the object to `true'.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Method Installation}

In order to describe what it means to select a method of an operation,
we must describe how the methods are connected to their operations.

A function <method> is installed as a method for the operation <opr> by

\>InstallMethod( <opr>, <text>, <famp>, <args-filts>, <val>, <method> )

where <text> is a short but informative string that describes for what
situation the method is installed,
<famp> is a function to be applied to the families of the arguments,
<args-filts> is a list of requirements for the arguments,
each entry being a filter,
and <val> is an integer that measures the priority of the method.

The exact meaning of the arguments <famp>, <args-filts>, and <val>
is explained below.

<opr> expects its methods to require certain filters for their arguments.
For example, the argument of a method for the operation `Zero' must be
in the category `IsAdditiveElementWithZero'.
It is not possible to install a method with `InstallMethod' for that the
entries of <args-filt> do not imply the respective requirements of the
operation <opr>.
If one wants to override this restriction,
one has to use `InstallOtherMethod' instead.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Applicable Methods and Method Selection}

A method installed as above is *applicable* for an arguments tuple
if the following conditions are satisfied.

The number of arguments equals the length of the list <args-filts>,
the $i$-th argument lies in the filter `<args-filts>[$i$]',
and <famp> returns `true' when applied to the families of the arguments.

So <args-filt> describes conditions for each argument,
and <famp> describes a relation between the arguments.

For unary operations such as attributes and properties,
there is no such relation to postulate,
<famp> is `ReturnTrue' for these operations,
a function that does always return `true'.
For binary operations, a usual value of <famp> is `IsIdentical',
which means that both arguments must lie in the same family.

If no method is applicable,
the error message `no method found' is signaled.

Otherwise, the applicable method with highest *rank* is selected and then
called.
This rank is given by the sum of the ranks of the filters in the list
<args-filt>,
*including implied filters*,
plus the number <val> used in the call of `InstallMethod'.
So the argument <val> can be used to raise the priority of a method
relative to other methods for <opr>.

Note that from the applicable methods,
an efficient one shall be selected.
This is a method that needs only few time and storage for the
computations.

It seems to be impossible that {\GAP} is able to select the optimal
method in all cases.
The present ranking of methods is based on the assumption
that a method installed for a special situation shall be preferred
to a method installed for a more general situation.

For example, a method for computing a Sylow subgroup of a nilpotent
group is expected to be more efficient than a method for arbitrary
groups.
So the more specific method will be selected if the group given as
argument knows to be nilpotent.

Of course there is no obvious way to decide about the efficiency of
incommensurable methods.
For example, take an operation with one method for permutation groups,
another method for nilpotent groups,
but no method for nilpotent permutation groups,
and call this operation with a permutation group that knows to be
nilpotent.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Partial Methods}

After a method has been selected and called,
this method may recognize that it cannot compute the desired result,
and give up by calling `TryNextMethod()'.

In effect, the execution of the method is terminated,
and the method selection calls the next method that is applicable w.r.t.
the original arguments.
In other words, the applicable method is called that is subsequent to the
one that called `TryNextMethod',
according to decreasing rank of the methods.

For example, since every finite group of odd order is solvable,
one may install a method for the property `IsSolvableGroup' that checks
whether the size of the argument is an odd integer,
returns `true' if yes,
and gives up otherwise.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Immediate Methods}

Usually a method is called only if its operation has been called
and if this method has been selected.

For attributes and properties, one can install also *immediate methods*.
An immediate method is called automatically as soon as it is applicable
to an object, provided that the value is not yet known.
Afterwards the attribute setter is called in order to store the value.

Note that in such a case, {\GAP} executes a computation for that
it was not explicitly asked by the user.
So one should install only those methods as immediate methods
that are *extremely cheap*.
To emphasize this, immediate methods are also called *zero cost methods*.
The time for their execution should really be approximately zero.

An immediate method <method> for the attribute or property <attr>
with requirement <req> is installed via

\>InstallImmediateMethod( <attr>, <req>, <val>, <method> )

where <val> is an integer value that measures the priority of <method>
among the immediate methods for <attr>.

Note the difference to `InstallMethod' that no family predicate occurs
because <attr> expects only one argument,
and that <req> is not a list of requirements but the argument requirement
itself.

For example, the size of a permutation group can be computed very cheap
if a stabilizer chain of the group is known.
So it is reasonable to install an immediate method for `Size' with
requirement `IsGroup and Tester( <stab> )',
where <stab> is the attribute corresponding to the stabilizer chain.

Another example would be the implementation of the conclusion that
every finite group of prime power order is nilpotent.
This could be done by installing an immediate method for the attribute
`IsNilpotentGroup' with requirement `IsGroup and Tester( Size )'.
This method would then check whether the size is a finite prime power,
return `true' in this case and otherwise call `TryNextMethod()'.
But this requires factoring of an integer,
which cannot be guaranteed to be very cheap,
so one should not install this method as an immediate method.

Immediate methods are thought of as a possibility for objects to gain
useful knowledge.
They must not be used to force the storing of ``constitutive
information'' in an object.
In other words, {\GAP} should work also if all immediate methods are
invalidated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Logical Implications}

It may happen that a property <prop> is implied by another filter <filt>,
which is usually a meet of other properties,
or the meet of some properties and some categories.
Such a logical implication can be installed as an immediate method for
<prop> that requires <filt> and that returns always `true'.
It should be installed via

\>InstallTrueMethod( <prop>, <filt> )

For example, each cyclic group is abelian,
each finite vector space is finite dimensional,
and each division ring is integral.
The installation of the first of these implications is

\>InstallTrueMethod( IsCommutative, IsGroup and IsCyclic )

Contrary to other immediate methods,
logical implications cannot be switched off.
This means that after the above implication has been installed,
one can rely on the fact that every object in the filter
`IsGroup and IsCyclic' will also be in the filter `IsCommutative'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

