%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  xtndxmpl.tex              GAP manual                    Thomas Breuer
%%
%H  @(#)$Id$
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{An Example: Residue Class Rings}

In this chapter, we give an example how {\GAP} can be extended
by new data structures and new functionality.

Suppose we want to do computations with elements of a ring $\Z/n\Z$,
where $n$ is a positive integer,
for example because we are interested in matrix groups over $\Z/4\Z$.
Furthermore suppose that these rings are not yet available in {\GAP};
in fact they are available, and their implementation is very close to
what is described in the following sections.

The first attempt is straightforward,
see "A First Attempt to Implement Residue Class Rings".
It gives an example how to add a data structure representing elements
that had not been available in {\GAP} before.

In the following section
"Compatibility of Residue Class Rings with Prime Fields",
the question of compatibility of the new objects with known objects is
discussed.

The final section
"Further Improvements in Implementing Residue Class Rings"
gives some hints how to improve the implementation presented before.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{A First Attempt to Implement Residue Class Rings}

Faced with the problem to implement elements of the rings $\Z/n\Z$,
we must determine the *types* of these elements as far as is necessary to
distinguish the elements from other ones.

First of all, we must decide about the *family* of each element.
A natural way to do this is to put the elements of each ring $\Z/n\Z$
into a family of their own.
This means that for example elements of $\Z/3\Z$ and $\Z/9\Z$ lie
in different families,
and that the ring $\Z/n\Z$ contains all elements of its elements family.

Second, we want to describe methods to add or multiply two elements in
$\Z/n\Z$,
and these methods shall be not applicable to other {\GAP} objects.
For that, we must define a new *category* in that all elements of rings
$\Z/n\Z$ lie.

Third, we must decide about a possible *representation* of our objects.
We encode the element $i + n\Z$ by the unique residue in the range
`[ 0 .. $n$-1 ]' that is congruent to $i$ modulo $n$,
and the object itself is chosen to be a positional object with this
residue at the first and only position (see~"Positional Objects").

\begintt
    IsZmodnZObj := NewCategory( "IsZmodnZObj", IsScalar );

    IsModulusRep := NewRepresentation( "IsModulusRep",
        IsPositionalObjectRep,
        [ 1 ] );
\endtt

So all elements in the rings $\Z/n\Z$ will lie in the category
`IsZmodnZObj',
which is a subcategory of `IsScalar'.
The latter means that one can add, subtract, multiply and divide
two such elements that lie in the same family,
with the obvious restriction that the second operand of a division
must be invertible.

After this, we declare two functions
(see~"Declaration and Implementation Part"),
one to create an element when family and residue are given,
and one to return the ring $\Z/n\Z$ when called with the argument $n$.

\begintt
    ZmodnZObj := NewOperationArgs( "ZmodnZObj" );

    ZmodnZ := NewOperationArgs( "ZmodnZ" );
\endtt

Now we have declared what we need,
and we can start to implement the missing methods resp. functions.
The function `ZmodnZ' that returns the ring $\Z/n\Z$ for given $n$
may look as follows.

\begintt
    ZmodnZ := function( n )

        local F, R;

        if not ( IsInt( n ) and IsPosRat( n ) ) then
          Error( "<n> must be a positive integer" );
        fi;

        # Construct the family of element objects of our ring.
        F:= NewFamily( Concatenation( "Zmod", String( n ), "Z" ),
                       IsZmodnZObj );

        # Install the data.
        F!.modulus:= n;

        # Make the domain.
        R:= RingWithOneByGenerators( [ ZmodnZObj( F, 1 ) ] );
        SetIsWholeFamily( R, true );
        SetName( R, Concatenation( "(Integers mod ", String(n), ")" ) );

        # Return the ring.
        return R;
    end;
\endtt

We see that we can use `RingWithOneByGenerators' to construct a ring
with one if we have the appropriate generators.
So the main problem is to create the identity element of the ring,
which in our case suffices to generate the ring.
In order to create this element via `ZmodnZObj',
we have to construct the family first.

Note that the modulus `n' is stored in the family,
thus it is not necessary to store it in each element.
Here we used that families are component objects
(see~"Component Objects").

Also note that we may enter known information about the ring.
Here we store that it contains the whole family of elements;
this is useful for example when we want to check the membership of an
element in the ring, which can be decided from the type of the element
if the ring contains its whole elements family.
Giving a name to the ring causes that it will be printed
via printing the name.

In `ZmodnZ', the function `ZmodnZObj' is called.
Now we define it.

\begintt
    ZmodnZObj := function( Fam, residue )
        return Objectify( NewType( Fam, IsZmodnZObj and IsModulusRep ),
                          [ residue mod Fam!.modulus ] );
    end;
\endtt

If `Fam' is a family as constructed in `ZmodnZ'
and `residue' is an integer,
`ZmodnZObj' returns the corresponding object in the family `Fam',
which lies in the category `IsZmodnZObj' and in the representation
`IsModulusRep'.
Note that we normalize `residue' explicitly,
and that we assume that the modulus is stored as value of the component
`modulus' of the family.

Now we can read the above code into {\GAP},
and the following works already.

\begintt
    gap> R:= ZmodnZ( 4 );
    (Integers mod 4)
    gap> IsRing( R );
    true
    gap> GeneratorsOfRingWithOne( R );
    [ <object> ]
\endtt

Of course we must install some methods for arithmetic and other
operations if the elements shall behave as we want.
We start with a method that allows to print elements nicely.

\begintt
    InstallMethod( ViewObj,
        "method for element in Z/nZ (ModulusRep)",
        true,
        [ IsZmodnZObj and IsModulusRep ], 0,
        function( x )
        Print( "ZmodnZObj( ", x![1], ", ", FamilyObj(x)!.modulus, " )" );
        end );
\endtt

So we installed a method for the operation `ViewObj' (first argument),
and we gave it a suitable information message (second argument),
see~"tut:ApplicableMethod" and~"tut:Tracing Methods" for applications of
this information string.
The third argument, `true', means that no relation between the families
of the arguments is specified, which is obvious for operations with only
one argument.
The fourth argument tells {\GAP} that the method is applicable for
objects that lie in the category `IsZmodnZObj' and in the representation
`IsModulusRep'.
The fifth argument denotes the priority of the method,
and the sixth argument is the method itself.
More details about `InstallMethod' can be found in~"Method Installation".

Note that the requirement `IsModulusRep' for the argument `x' allows us
to access the residue as `x![1]'.
Since the family of `x' has the component `modulus' bound if it is
constructed by `ZmodnZ', we may access this component.
We check whether the method installation has some effect.

\begintt
    gap> gens:= GeneratorsOfRingWithOne( R );
    [ ZmodnZObj( 1, 4 ) ]
\endtt

Next we install methods for the comparison operations.
Note that we can assume that the residues are normalized.

\begintt
    InstallMethod( \=,
        "method for two elements in Z/nZ (ModulusRep)",
        IsIdentical,
        [ IsZmodnZObj and IsModulusRep, IsZmodnZObj and IsModulusRep ],
        0,
        function( x, y ) return x![1] = y![1]; end );

    InstallMethod( \<,
        "method for two elements in Z/nZ (ModulusRep)",
        IsIdentical,
        [ IsZmodnZObj and IsModulusRep, IsZmodnZObj and IsModulusRep ],
        0,
        function( x, y ) return x![1] < y![1]; end );
\endtt

The third argument which describes the relation between the families of
the arguments is `IsIdentical' in the above method installations.
This means that the methods are applicable only if both arguments lie in
the same family.

Next we install methods for the arithmetic operations,
first for the additive structure.

\begintt
    InstallMethod( \+,
        "method for two elements in Z/nZ (ModulusRep)",
        IsIdentical,
        [ IsZmodnZObj and IsModulusRep, IsZmodnZObj and IsModulusRep ],
        0,
        function( x, y )
        return ZmodnZObj( FamilyObj( x ), x![1] + y![1] );
        end );

    InstallMethod( Zero,
        "method for element in Z/nZ (ModulusRep)",
        true,
        [ IsZmodnZObj ], 0,
        x -> ZmodnZObj( FamilyObj( x ), 0 ) );

    InstallMethod( AdditiveInverse,
        "method for element in Z/nZ (ModulusRep)",
        true,
        [ IsZmodnZObj and IsModulusRep ], 0,
        x -> ZmodnZObj( FamilyObj( x ), AdditiveInverse( x![1] ) ) );
\endtt

It is not necessary to install methods for subtraction,
since this is handled via addition of the additive inverse of
the second argument if no other method is installed.

We might want to allow the addition of integers and elements in
rings $\Z/n\Z$, where an integer is interpreted with its residue modulo
$n$.
To achieve this, we install methods to add an integer to an object in
`IsZmodnZObj' from the left and from the right.

\begintt
    InstallMethod( \+,
        "method for element in Z/nZ (ModulusRep) and integer",
        true,
        [ IsZmodnZObj and IsModulusRep, IsInt ], 0,
        function( x, y )
        return ZmodnZObj( FamilyObj( x ), x![1] + y );
        end );

    InstallMethod( \+,
        "method for integer and element in Z/nZ (ModulusRep)",
        true,
        [ IsInt, IsZmodnZObj and IsModulusRep ], 0,
        function( x, y )
        return ZmodnZObj( FamilyObj( y ), x + y![1] );
        end );
\endtt

Similarly we install the methods dealing with the multiplicative
structure.
We need methods to multiply two of our objects,
and to compute identity and inverse.
Note that the method for `Inverse' returns `fail' if the argument
is not invertible.

\begintt
    InstallMethod( \*,
        "method for two elements in Z/nZ (ModulusRep)",
        IsIdentical,
        [ IsZmodnZObj and IsModulusRep, IsZmodnZObj and IsModulusRep ],
        0,
        function( x, y )
        return ZmodnZObj( FamilyObj( x ), x![1] * y![1] );
        end );

    InstallMethod( One,
        "method for element in Z/nZ (ModulusRep)",
        true,
        [ IsZmodnZObj ], 0,
        elm -> ZmodnZObj( FamilyObj( elm ), 1 ) );

    InstallMethod( Inverse,
        "method for element in Z/nZ (ModulusRep)",
        true,
        [ IsZmodnZObj and IsModulusRep ], 0,
        function( elm )
        local residue;
        residue:= QuotientMod( 1, elm![1], FamilyObj( elm )!.modulus );
        if residue <> fail then
          residue:= ZmodnZObj( FamilyObj( elm ), residue );
        fi;
        return residue;
        end );
\endtt

To be able to multiply our objects with integers,
we need not install special methods,
since this multiplication is carried out by successive additions.

Now we have implemented methods for the arithmetic operations for our
elements, and the following calculations work.

\begintt
    gap> x:= gens[1];; y:= 2 * x;
    ZmodnZObj( 2, 4 )
    gap> z:= y + x;
    ZmodnZObj( 3, 4 )
    gap> y^-1;
    fail
    gap> z^-1;
    ZmodnZObj( 3, 4 )
\endtt

There are some other operations in {\GAP} that we may want to accept
our elements as arguments.
An example is the operation `Int' that returns, e.g.,
the integral part of a rational number or the integer corresponding to
an element in a finite prime field.
For our objects, we may define that `Int' returns the normalized residue.
Note that we *define* this behaviour for elements
but we *implement* it for objects.
This means that if someone implements another representation of our
objects then this person must be careful to implement `Int' methods for
this new representation such that the result is independent of the
representation.

\begintt
    InstallMethod( Int,
        "method for element in Z/nZ (ModulusRep)",
        true,
        [ IsZmodnZObj and IsModulusRep ], 0,
        z -> z![1] );
\endtt

Another example of an operation for which we might want to install
a method is `\\mod'.
Since the ring prints itself as `Integers' mod the modulus
it is reasonable to allow a construction this way.

\begintt
    InstallMethod( \mod,
        "method for `Integers', and a positive integer",
        true,
        [ IsIntegers, IsPosRat and IsInt ], 0,
        function( Integers, n ) return ZmodnZ( n ); end );
\endtt

Let us try this.

\begintt
    gap> Int( y );
    2
    gap> Integers mod 1789;
    (Integers mod 1789)
\endtt

Having done enough for the elements,
we must install some methods for the rings.
Many generic methods will work if they are able to compute the
list of elements of the ring,
so we install a method for this.

\begintt
    InstallMethod( Enumerator,
        "method for full collection Z/nZ",
        true,
        [ CategoryCollections( IsZmodnZObj ) and IsWholeFamily ], 0,
        function( R )
        local F;
        F:= ElementsFamily( FamilyObj(R) );
        return List( [ 0 .. Size( R ) - 1 ], x -> ZmodnZObj( F, x ) );
        end );
\endtt

Note that this method is applicable only to full rings $\Z/n\Z$,
for proper subrings it would return a wrong result.
Furthermore, it is not required that the argument is a ring;
in fact this method is applicable also to the additive group
formed by all elements in the family,
provided that is knows to contain the whole family.

Analogously, we install methods to compute the size,
a random element, and the units of full rings $\Z/n\Z$.

\begintt
    InstallMethod( Random,
        "method for full collection Z/nZ",
        true,
        [ CategoryCollections( IsZmodnZObj ) and IsWholeFamily ], 0,
        R -> ZmodnZObj( ElementsFamily( FamilyObj(R) ),
                        Random( [ 0 .. Size( R ) - 1 ] ) ) );

    InstallMethod( Size,
        "method for full ring Z/nZ",
        true,
        [ CategoryCollections( IsZmodnZObj ) and IsWholeFamily ], 0,
        R -> ElementsFamily( FamilyObj(R) )!.modulus );

    InstallMethod( Units,
        "method for full ring Z/nZ",
        true,
        [     CategoryCollections( IsZmodnZObj )
          and IsWholeFamily and IsRing ], 0,
        function( R )
        local F;
        F:= ElementsFamily( FamilyObj( R ) );
        return List( PrimeResidues( Size(R) ), x -> ZmodnZObj( F, x ) );
        end );
\endtt

Each ring $\Z/n\Z$ is finite,
and we could install a method that returns `true' when `IsFinite' is
called with $\Z/n\Z$ as argument.
But we can do this more elegantly via installing a *logical implication*.

\begintt
    InstallTrueMethod( IsFinite,
        CategoryCollections( IsZmodnZObj ) and IsDomain );
\endtt

In effect, every domain that consists of elements in `IsZmodnZObj'
will automatically store that it is finite,
also if `IsFinite' is not called for it.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Compatibility of Residue Class Rings with Prime Fields}

The above implementation of residue class rings has at least two
disadvantages.
First, if $p$ is a prime then the ring $\Z/p\Z$ is in fact a field,
and the return values of `ZmodnZ' are never regarded as fields because
they are not in the category `IsMagmaWithInversesIfNonzero'.
Second, and this makes the example really interesting,
there are already elements of finite prime fields implemented in {\GAP},
and we may want to identify them with elements in $\Z/p\Z$.

To be more precise,
elements of finite fields in {\GAP} lie in the category `IsFFE',
and there is already a representation, `IsInternalRep', of these elements
via discrete logarithms.
The aim of this section is to make `IsModulusRep' an alternative
representation of elements in finite prime fields.

Note that this is only one step towards the desired compatibility.
Namely, after having a second representation of elements in finite
prime fields, we may want that the function `GF' (which is the usual
function to create finite fields in {\GAP}) is able to return
`ZmodnZ( <p> )' when `GF( <p> )' is called for a large prime <p>.
Moreover, then we have to decide about a default representation of
elements in `GF( <p> )' for primes <p> where both representations are
available.
Of course we can force the new representation by explicitly calling
`ZmodnZ' and `ZmodnZObj' whenever we want, but it is not a priory
clear in which situation which representation is preferable.

The same questions will occur when we want to implement a new
representation for large non-prime fields.
The steps of this implementation will be the same as described in this
chapter,
and we will have to achieve compatibility with both the internal
representation of elements in small finite fields and the representation
of elements in arbitrary prime fields.

But let us now turn back to the task of this section.
We first adjust the setup of the previous section,
and then repeat the installations with suitable modifications.

\begintt
    IsZmodnZObj := NewCategory( "IsZmodnZObj", IsScalar );

    IsZmodnZObjNonprime := NewCategory( "IsZmodnZObjNonprime",
        IsZmodnZObj );

    IsZmodpZObj := IsZmodnZObj and IsFFE;

    IsModulusRep := NewRepresentation( "IsModulusRep",
        IsPositionalObjectRep,
        [ 1 ] );

    ZmodnZObj := NewOperationArgs( "ZmodnZObj" );

    ZmodnZ := NewOperationArgs( "ZmodnZ" );
\endtt

As in the previous section,
all elements of rings $\Z/n\Z$ lie in the category `IsZmodnZObj'.
But now we introduce two subcategories, namely `IsZmodnZObjNonprime'
for all elements in rings $\Z/n\Z$ where $n$ is not a prime,
and `IsZmodpZObj' for elements in finite prime fields.

Again let us start with the definitions of `ZmodnZ' and `ZmodnZObj'.

\begintt
    ZmodnZ := function( n )

        local F, R;

        if not ( IsInt( n ) and IsPosRat( n ) ) then
          Error( "<n> must be a positive integer" );

        elif IsPrimeInt( p ) then

          # Construct the family of element objects of our field.
          F:= FFEFamily( p );

          # Make the domain.
          R:= FieldOverItselfByGenerators( [ ZmodnZObj( F, 1 ) ] );
          SetIsPrimeField( R, true );

        else

          # Construct the family of element objects of our ring.
          F:= NewFamily( Concatenation( "Zmod", String( n ), "Z" ),
                         IsZmodnZObjNonprime );
  
          # Install the data.
          F!.modulus:= n;
  
          # Make the domain.
          R:= RingWithOneByGenerators( [ ZmodnZObj( F, 1 ) ] );
          SetIsWholeFamily( R, true );
          SetName( R, Concatenation( "(Integers mod ",String(n),")" ) );

        fi;

        # Return the ring resp. field.
        return R;
    end;


    ZmodnZObj := function( Fam, residue )
    if IsFFEFamily( Fam ) then
      return Objectify( NewType( Fam,     IsZmodpZObj
                                      and IsModulusRep ),
                        [ residue mod Characteristic( Fam ) ] );
    else
      return Objectify( NewType( Fam,     IsZmodnZObjNonprime
                                      and IsModulusRep ),
                        [ residue mod Fam!.modulus ] );
    fi;
    end;
\endtt

Note that the result of `ZmodnZ' with a prime as argument is a field that
does not contain the whole family of its elements, since all finite field
elements of a fixed characteristic lie in the same family.
Further note that we cannot expect a family of finite field elements
to have a component `modulus',
so we use `Characteristic' to get the modulus.
Requiring that `Fam!.modulus' works also if `Fam' is a family of
finite field elements would violate the rule
that an extension of {\GAP} should not force changes in existing code,
in this case code dealing with families of finite field elements.

\begintt
    InstallMethod( PrintObj,
        "method for element in Z/nZ (ModulusRep)",
        true,
        [ IsZmodnZObjNonprime and IsModulusRep ], 0,
        function( x )
        Print( "ZmodnZObj( ", x![1], ", ", FamilyObj(x)!.modulus, " )" );
        end );

    InstallMethod( PrintObj,
        "method for element in Z/pZ (ModulusRep)",
        true,
        [ IsZmodpZObj and IsModulusRep ], 0,
        function( x )
        Print( "ZmodpZObj( ", x![1], ", ", Characteristic(x), " )" );
        end );

    InstallMethod( \=,
        "method for two elements in Z/nZ (ModulusRep)",
        IsIdentical,
        [ IsZmodnZObj and IsModulusRep,
          IsZmodnZObj and IsModulusRep ], 0,
        function( x, y ) return x![1] = y![1]; end );
\endtt

The above method to check equality is independent of whether the
arguments have a prime or nonprime modulus,
so we installed it for arguments in `IsZmodnZObj'.
Now we install also methods to compare objects in `IsZmodpZObj'
with the ``old'' finite field elements.

\begintt
    InstallMethod( \=,
        "method for element in Z/pZ (ModulusRep) and internal FFE",
        IsIdentical,
        [ IsZmodpZObj and IsModulusRep, IsFFE and IsInternalRep ], 0,
        function( x, y )
        return DegreeFFE( y ) = 1 and x![1] = IntFFE( y );
        end );

    InstallMethod( \=,
        "method for internal FFE and element in Z/pZ (ModulusRep)",
        IsIdentical,
        [ IsFFE and IsInternalRep, IsZmodpZObj and IsModulusRep ], 0,
        function( x, y )
        return DegreeFFE( x ) = 1 and IntFFE( x ) = y![1];
        end );
\endtt

The situation with the operation ```\<''' is more difficult.
Of course we are free to define the comparison of objects in
`IsZmodnZObjNonprime',
but for the finite field elements, the comparison must be compatible
with the predefined comparison of the ``old'' finite field elements.

\begintt
    InstallMethod( \<,
        "method for two elements in Z/nZ (ModulusRep, nonprime)",
        IsIdentical,
        [ IsZmodnZObjNonprime and IsModulusRep,
          IsZmodnZObjNonprime and IsModulusRep ], 0,
        function( x, y ) return x![1] < y![1]; end );

    InstallMethod( \<,
        "method for two elements in Z/pZ (ModulusRep)",
        IsIdentical,
        [ IsZmodpZObj and IsModulusRep,
          IsZmodpZObj and IsModulusRep ], 0,
        function( x, y )
        local p, r;      # characteristic and primitive root
        if x![1] = 0 then
          return y![1] <> 0;
        elif y![1] = 0 then
          return false;
        else
          p:= Characteristic( x );
          r:= PrimitiveRootMod( p );
          return LogMod( x![1], r, p ) < LogMod( y![1], r, p );
        fi;
        end );

    InstallMethod( \<,
        "method for element in Z/pZ (ModulusRep) and internal FFE",
        IsIdentical,
        [ IsZmodpZObj and IsModulusRep, IsFFE and IsInternalRep ], 0,
        function( x, y )
        return x![1] * One( y ) < y;
        end );

    InstallMethod( \<,
        "method for internal FFE and element in Z/pZ (ModulusRep)",
        IsIdentical,
        [ IsFFE and IsInternalRep, IsZmodpZObj and IsModulusRep ], 0,
        function( x, y )
        return x < y![1] * One( x );
        end );
\endtt

Now we install the same methods for the arithmetic operations
`\\+', `Zero', `AdditiveInverse', `\\-', `\\\*', and `One'
as in the previous section, without listing them below.
Also the same `Int' method is installed for objects in `IsZmodnZObj'.
Note that it is compatible with the definition of `Int' for finite
field elements.
And of course the same method for `\\mod' is installed.

We have to be careful, however, with the methods for `Inverse', `\\/',
and `\\^'.
These methods and the missing methods for arithmetic operations with
one argument in `IsModulusRep' and the other in `IsInternalRep'
are given below.

\begintt
    InstallMethod( \+,
        "method for element in Z/pZ (ModulusRep) and internal FFE",
        IsIdentical,
        [ IsZmodpZObj and IsModulusRep, IsFFE and IsInternalRep ], 0,
        function( x, y ) return x![1] + y; end );

    InstallMethod( \+,
        "method for internal FFE and element in Z/pZ (ModulusRep)",
        IsIdentical,
        [ IsFFE and IsInternalRep, IsZmodpZObj and IsModulusRep ], 0,
        function( x, y ) return x + y![1]; end );

    InstallMethod( \*,
        "method for element in Z/pZ (ModulusRep) and internal FFE",
        IsIdentical,
        [ IsZmodpZObj and IsModulusRep, IsFFE and IsInternalRep ], 0,
        function( x, y ) return x![1] * y; end );

    InstallMethod( \*,
        "method for internal FFE and element in Z/pZ (ModulusRep)",
        IsIdentical,
        [ IsFFE and IsInternalRep, IsZmodpZObj and IsModulusRep ], 0,
        function( x, y ) return x * y![1]; end );

    InstallMethod( Inverse,
        "method for element in Z/nZ (ModulusRep, nonprime)",
        true,
        [ IsZmodnZObjNonprime and IsModulusRep ], 0,
        function( x )
        local residue;
        residue:= QuotientMod( 1, x![1], FamilyObj(x)!.modulus );
        if residue <> fail then
          residue:= ZmodnZObj( FamilyObj(x), residue );
        fi;
        return residue;
        end );

    InstallMethod( Inverse,
        "method for element in Z/pZ (ModulusRep)",
        true,
        [ IsZmodpZObj and IsModulusRep ], 0,
        function( x )
        local residue;
        residue:= QuotientMod( 1, x![1], Characteristic( FamilyObj(x) ) );
        if residue <> fail then
          residue:= ZmodnZObj( FamilyObj(x), residue );
        fi;
        return residue;
        end );
\endtt

The operation `DegreeFFE' is defined for finite field elements,
we need a method for objects in `IsZmodpZObj'.

\begintt
    InstallMethod( DegreeFFE,
        "method for element in Z/pZ (ModulusRep)",
        true,
        [ IsZmodpZObj and IsModulusRep ], 0,
        z -> 1 );
\endtt

The methods for `Enumerator', `Random', `Size', and `Units',
that we had installed in the previous section had all assumed that
their argument contains the whole family of its elements.
So these methods make sense only for the nonprime case.
For the prime case, there are already methods for these operations
with argument a field.

\begintt
    InstallMethod( Enumerator,
        "method for full ring Z/nZ",
        true,
        [ CategoryCollections( IsZmodnZObjNonprime ) and IsWholeFamily ],
        0,
        function( R )
        local F;
        F:= ElementsFamily( FamilyObj( R ) );
        return List( [ 0 .. Size( R ) - 1 ], x -> ZmodnZObj( F, x ) );
        end );

    InstallMethod( Random,
        "method for full ring Z/nZ",
        true,
        [ CategoryCollections( IsZmodnZObjNonprime ) and IsWholeFamily ],
        0,
        R -> ZmodnZObj( ElementsFamily( FamilyObj( R ) ),
                        Random( [ 0 .. Size( R ) - 1 ] ) ) );

    InstallMethod( Size,
        "method for full ring Z/nZ",
        true,
        [ CategoryCollections( IsZmodnZObjNonprime ) and IsWholeFamily ],
        0,
        R -> ElementsFamily( FamilyObj( R ) )!.modulus );

    InstallMethod( Units,
        "method for full ring Z/nZ",
        true,
        [     CategoryCollections( IsZmodnZObjNonprime )
          and IsWholeFamily and IsRing ],
        0,
        function( R )
        local F;
        F:= ElementsFamily( FamilyObj( R ) );
        return List( PrimeResidues( Size(R) ), x -> ZmodnZObj( F, x ) );
        end );

    InstallTrueMethod( IsFinite,
        CategoryCollections( IsZmodnZObjNonprime ) and IsDomain );
\endtt


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Further Improvements in Implementing Residue Class Rings}

There are of course many possibilities to improve the implementation.

With the setup as described above,
subsequent calls `ZmodnZ( <n> )' with the same <n> yield incompatible
rings in the sense that elements of one ring cannot be added to elements
of another.
The solution for this problem is to keep a global list of all results of
`ZmodnZ' in the current {\GAP} session, and to return the stored values
whenever possible.

To make computations more efficient,
one can install methods for ```\\-''', ```\\/''', and ```\\^''',
for example because this avoids the unnecessary construction of the
additive inverse.

\begintt
    InstallMethod( \-, "two elements in Z/nZ (ModulusRep)", ... );
    InstallMethod( \-, "Z/nZ-obj. (ModulusRep) and integer", ... );
    InstallMethod( \-, "integer and Z/nZ-obj. (ModulusRep)", ... );
    InstallMethod( \-, "Z/pZ-obj. (ModulusRep) and internal FFE", ... );
    InstallMethod( \-, "internal FFE and Z/pZ-obj. (ModulusRep)", ... );
    InstallMethod( \*, "Z/nZ-obj. (ModulusRep) and integer", ... );
    InstallMethod( \*, "integer and Z/nZ-obj. (ModulusRep)", ... );
    InstallMethod( \/, "two Z/nZ-objs. (ModulusRep, nonprime)", ... );
    InstallMethod( \/, "two Z/pZ-objs. (ModulusRep)", ... );
    InstallMethod( \/, "Z/nZ-obj. (ModulusRep) and integer", ... );
    InstallMethod( \/, "integer and Z/nZ-obj. (ModulusRep)", ... );
    InstallMethod( \/, "Z/pZ-obj. (ModulusRep) and internal FFE", ... );
    InstallMethod( \/, "internal FFE and Z/pZ-obj. (ModulusRep)", ... );
    InstallMethod( \^, "Z/nZ-obj. (ModulusRep, nonprime) & int.", ... );
    InstallMethod( \^, "Z/pZ-obj. (ModulusRep), and integer", ... );
\endtt

The call to `NewType' in `ZmodnZObj' can be avoided by storing
the required type, e.g., in the family.
But note that it is *not* admissible to take the type of an object
as first argument of `Objectify'.
For example, suppose two objects in `IsZmodnZObj' shall be added.
Then we must not use the type of one of the arguments in a call of
`Objectify', because the argument may have knowledge that is not
correct for the result of the addition.
One may think of the property `IsOne' that may hold for both
arguments but certainly not for their sum.

For comparing two objects in `IsZmodpZObj' via ```\<''',
we had to install a quite expensive method because of the compatibility
with the comparison of finite field elements that did already exist.
In fact {\GAP} supports finite fields with elements represented via
discrete logarithms only up to a given size.
So in principle we have the freedom to define a cheaper comparison
via ```\<''' for objects in `IsZmodpZObj' if the modulus is large
enough.
This is possible by introducing two categories `IsZmodpZObjSmall'
and `IsZmodpZObjLarge', which are subcategories of `IsZmodpZObj',
and to install different ```\<''' methods for pairs of objects
in these categories.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

