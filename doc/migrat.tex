%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  migrat.tex               GAP manual                  Alexander Hulpke
%%
%H  @(#)$Id$
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Migrating to GAP 4}

This chapter is intended to give users with {\sf GAP}3 experience
information about the things which changed in {\GAP}4.

For explanation of the new features and concepts of {\GAP}4, see chapter
"Welches Kapitel ist das"

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes and record components}

{\GAP}3 stored its more complex objects in records. Information about the
objects thus was stored in record components. This included the stored
values of attributes. {\GAP}4 on the other hand uses its own objects for
this purpose. Access to internal data must be done via functions.

This means that accesses like 'g.generators' or 'g.conjugacyClasses' are no
longer valid, but that they have to be replaced by a call to the
appropriate attributes operation. This operation is usually called 
as the {\GAP}3 record component but starting with a capital letter. 
So 'g.size' becomes 'Size(g)' and 'c.representative' 'Representative(c)'.

There are a few notable exceptions:
\beginitems
'g.generators'&becomes (for groups) 'GeneratorsOfGroup(g)'

\enditems

In {\GAP}3 there usually also was already a function for accessing these
stored attributes, but calling this function was often substantially slower
than accessing the component directly. This has changed in {\GAP}4: Calling
an attribute and obtaining back the stored value takes about the same time
than accessing the component would take.

Similarly, tests for boundness of attribute components in {\GAP}3 become
calls to the tester function for the attribute. This is usually called
'Has'<attribute>. Thus 'IsBound(g.size)' becomes 'HasSize(g)' and so on.

Storing attributes in {\GAP}3 was done by assigning the appropriate record
component. In {\GAP}4 this becomes a call to the attribute\'s setter, usually
called 'Set'<attribute>. So 'g.size:=5' becomes 'SetSize(g,5)'.
(Calling a function explicitly in {\GAP}4 to store information about an 
object additionally permits {\GAP} to deduce dependent information -- like
that nilpotent groups are solvable -- automatically, eliminating the need
for some extra attribute assignments.)

As a side effect, information put in an object by the user for his
private purposes has to be stored differently. While it was possible in
{\GAP}3 to store an additional component 'g.myOwnComponent', this must
become an attribute in {\GAP}4. (Note that the attribute must be declared
''mutable'' if it is planned to change it later.)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations records}

A lot of the functions in {\GAP}3 were dispatcher functions. The task of
these functions was threefold:

1)\quad Check whether the information is already stored in the object.

2)\quad Check for validity of the arguments.

3)\quad Call a function in an operations record to dispatch to a method suitable
for the arguments.

As these features were sometimes unwanted, this lead to situations where
the dispatcher was bypassed and the method 'g.operations.'<name> called
directly.

As these tasks are dealt with in different ways in {\GAP4}, bypassing is
handled differently and sometimes not necessary any longer:

\beginitems
1)&The method selection will automatically select a method to return a
stored attribute if it is known. Thus calling the attribute is now the
''official'' way to access stored information (see "Attributes and record
components").

2)&The method selection itself already takes care of some of the checking
tasks, like ensuring that two multiplicands are indeed of the same type. To
bypass the remaining checking task, namely ensuring that the user passed
valid arguments to the operation', usually {\GAP}4 provides a second
operation, which will not check its arguments.
The two operations are called like 'DoIt' (to check) and 'DoItNC' (no
check). Ususally 'DoIt' will check the arguments and simply return 'DoItNC'
to do the work.

3)&If a specific method is to be called, this method should be available as a
separately declared function (see "NewOperationArgs"). In most cases, however,
'obj.operations.Function' was only called to fall back on a more general
method if it turned out the arguments were not special enough to warrant use
of the method called in the first place. This is now taken care of by
'TryNextMethod()' (see "TryNextMethod").

\enditems

The increase in speed of the method selection compared to a dispatcher
function makes it unnecesssary to call a method in an operations record
to gain speed.

Any further decisions taken within a dispatcher are usually now taken care of
more or less automatically by the method selection mechanism.

Finally, there were a couple of functions in {\GAP}3 (like
'PermGroupOps.MovedPoints') only available within an operations record.
These functions became proper operations in {\GAP}4.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Debugging and the Info Mechanism}

{\GAP} provides the <Info> mechanism to allow the display of information
about an algorithms progress. In {\GAP}3 this was done by calling a function
like 'InfoGroup1' with an argument that should be printed. 
Printing was turned on by assigning 'InfoGroup1:=Print'. By standard all
info functions were assigned to 'Ignore', a function that would ignore all
its arguments without evaluating them. Different levels of information were
provided by further functions like 'InfoGroup2'.

This approach is not possible in {\GAP}4 as the internal evaluation process
has changed. The new info mechanism uses the function 'Info' which takes as
parameters an info class (objects obtained by 'NewInfoClass', the information
level and the information to be printed:
\begintt
Info(InfoGroup,1,"Computed size");
\endtt
For each info class, its information level can be assigned using
'SetInfoLevel(<class>,<level>)'. Only those info commands,
whose information level does not exceed the level set for its class
are evaluated,

If {\GAP}4 runs into an error or is interrupted, it enters the 'brk' loop.
The command 'Where(<number>)' (a replacement for {\GAP}3 'Backtrace')
displays <number> lines of information about the current function call stack.
Access is only possible to the variables on the current level in the
function stack, the function 'DownEnv()' permits to step up in the stack.

When interrupting, the first line printed by 'Where' actually may be already
one level higher, as the following example shows
\begintt
gap> ConjugacyClasses(Group((1,2,3,4,5,6,7,8,9,10),(1,2)));
user interrupt at
[...]
brk> Where();
InducedPcgsByPcSequenceNC( pcgs, u{[ pos .. len ]} ) called from
[...]
brk> pos;
Variable: 'pos' must have a value
brk> DownEnv();
brk> pos;
1
\endtt

For purposes of debugging, it can be helpful sometimes, to see what
information is stored within an object. In {\GAP}3 this was possible using
'RecFields'. {\GAP}4 permits the same for component objects by
'REC_NAMES_ROBJ(<object>)', which will list all components present.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Mutability and Copying}

{\GAP}4 permits to declare objects as ''immutable''. Such objects may not
be changed, attempting to do so issues an error. Typically attributes and
vectors are immutable. Note that operations like '<list>\*<number>'
automatically return a vector.

There is no way to make an object ''mutable'' again, but 'ShallowCopy'
produces a mutable copy of the object.

Note that 'ShallowCopy' now is an operation. Thus one may install methods
that will copy not only the first layer, but all relevant information.
The idea here is that full recursive copying by 'DeepCopy' (which replaces
the old 'Copy') should not be necessary in general.

A typical usage of '<list>\*<number>' was to create a list of zeroes. The
new function 'ListWithIdenticalEntries' can be used here to obtain a mutable
object of this type.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Changed names}

A couple of functions changed their name without changing the
functionality. A -- probably incomplete -- list follows
\beginitems
{\GAP}3&{\GAP}4

'AgGroup'&'PcGroup' (also composita)

'Backtrace'&'Where'

'Copy'&'DeepCopy'

'RecFields'&'RecNames'

\enditems

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Parent and Subgroups}

In {\GAP}3 there was a strict distinction between parent groups and
subgroups. The name ''parent'' (instead of ''supergroup'')
already indicates that the reason for this
was not to store information about embedding properties, but only to provide
a common roof for -- say -- all groups of polycyclic words, belonging to the
same PC-presentation. Is was only possible to create subgroups of
a parent group.
This lead to problems when dealing with groups, whose common parent group
would be too large to represent, like matrix groups over the rationals.

In {\GAP}4 this roof is provided already by the <family>. Therefore
subgroups behave just like groups. It is possible to create a subgroup of
any group, this group then being the parent of the new subgroup. This
permits arbitrary chains of subgroups with respective parents.

This implies, however, that the 'Parent' command may not be used any longer
to test whether two (sub)groups fit together -- this is now strictly a
question of the families. Consequentially, the 2-argument version
'Parent(<G>,<H>)' has been abolished.

As a side effect, some infinite parent objects like the finitary symmetric
group or GL over the integers are now implicitely provided by families and
it is possible to use two finite subgroups of such a group together.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Homomorphisms and factor groups}

In {\GAP}3 there had been a confusion of homomorphisms and general mappings,
as both were created using 'GroupHomomorphismByImages'. This sometimes lead
to very expensive, unnecessary tests.

{\GAP}4 therefore provides two different commands,
'GroupGeneralMappingByImages' and 'GroupHomomorphismByImages', the latter
assuming that the mapping is indeed an homomorphism. Of course the property
'IsHomomorphism' still may be tested for general mappings.

SOLLTE MAN AUCH ETWAS UEBER KERNEL, IMAGE, USW SAGEN?

Factor groups by themselves are not different from groups in any particular
way. They become special, as soon as there is a homomorphism from a larger
group onto them.

Therefore, {\GAP}4 does not use 'FactorGroup(<G>,<N>)' as the basic command,
but 'NaturalHomomorphismByNormalSubgroup(<G>,<N>)'. This command returns an
homomorphism from <G> into another group <H> (whose representation is
determined by the algorithm, trying to be as effective as possible), having
<N> as kernel. This homomorphism is not necessarily surjective. That is
$G/N$ may be a proper subgroup of $H$. This subgroup can be obtained using
'Image'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Changing a groups representation}

Sometimes, it can be helpful to go to an isomorphic representation of an
object. In {\GAP}3 this conversion was done by functions named like the new
representation type, i.e. 'AgGroup', 'PermGroup' et cetera. These functions
returned an object 'A' in the new representation, the record component
'A.bijection' containing an isomorphism from the new object to the old.

{\GAP}4 puts more emphasis on the isomorphism. The new commands are called
like 'IsomorphismPermGroup', returning an isomorphism from the old object to
the new. The new object can be obtained as 'Image(<isom>)'. (The 'Range' may
be larger occasionally. For example for isomorphisms to a permutation group
it may be easier to define it into the full symmetric group.)

Note, however, that the concept of <pcgs> will permit to use algorithms for
solvable groups also for non-pc groups, so a change of reopresentation may
be not really be necessary in many cases.

'IsomorphismFpGroup' in general will define a presentation on generators
which the algorithm chooses. The corresponding group elements can be
obtained by the command
\begintt
gens:=List(isofp!.genimages,i->PreImagesRepresentative(isofp,i));
\endtt
If a presentation in given generators is needed, the command
'IsomorphismFpGroupByGenerators(<G>,<gens>)' will produce one.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Free groups and finitely presented groups}

Finitely presented groups were implemented in {\GAP}3 basically as free
groups with attached relators. Especially, elements were gives by
representatives in th efree group. This lead to the breakdown of any
algorithm which had to test for the equality of elements.

In {\GAP4}, therefore finitely presented groups and there elements are
objects in their own right. Of course they still know the free group, in
which the presentation was given, but for example equality tests among
elements now call the Todd-Coxeter algorithm. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Polycyclic generating systems}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Compatibility mode}

Generelles ueber gap3-mode.

