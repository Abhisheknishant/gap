\Chapter{Operations and Attributes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes}

In the preceding chapters,  we have seen  how to obtain information about
mathematical  objects   in {\GAP}: We   have  to pass  the   object as an
*argument* to  a function, and the   *result* will be  the value  of that
function call. For example, the integer which is  the size of a group <G>
is  the value of the  expression `Size( <G> )'.   Computing the size of a
group generally requires a substantial amount of work, therefore it seems
desirable to store the size somewhere once it has been calculated. If the
size  of <G> is demanded   again later, it can  simply  be looked up. The
natural place  to  store such information  about  <G>  is the object  <G>
itself, and  you should imagine that  {\GAP} puts the size somewhere into
<G> when `Size( <G>   )' is executed  for the  first  time, and   if this
function call is executed  again later, the size is  simply looked up and
returned, without further computation.

\index{getter!of an attribute}\index{setter!of an attribute}%
\index{tester!of an attribute}\index{method}%
This means  that  the behavior of the   function `Size' has  to depend on
whether the argument to the function already knows  its size, and if not,
that the  size   must be  stored  in  the  argument   after it  has  been
calculated. These two extra  tasks are done by  two other  functions that
accompany  `Size( <G> )',  namely the *tester*  `HasSize( <G>  )' and the
*setter*  `SetSize( <G>, <size> )'. The  tester returns `true' or `false'
according to  whether <G>  already knows its  size, and  the  setter puts
<size>  into <G> as the  value of `Size'. The   function `Size' itself is
called the *getter*, and from the preceding discussion  we see that there
must really be two  getters, or rather two *methods*  for the getter: The
first  method is used when  the tester returns  `false'; it is the method
which first does  the real computation and then  executes the setter with
the computed value. The second method is used when the the tester returns
`true'; it simply  returns the stored value.  This method is also  called
the *system getter*.
\beginexample
    gap> G := Group( RandomInvertibleMat(4,GF(4)),
    >                RandomInvertibleMat(4,GF(4)) );; Size( G ); time;
    11612160  # most probably `G' is the general linear group
    3583      # this may of course vary on your machine
    gap> Size( G ); time;
    11612160
    0
\endexample
The convenient thing  for the user  is that  {\GAP} automatically chooses
the right method for the  getter, i.e., it  calls the real-work getter at
most once and  the system getter in  all subsequent occurrences. *At most
once* because the value of a function like  `Size' can also be set before
the getter  is called  at  all; to do  this  you simply call  the  setter
directly.

A triple of a getter,  a setter and a tester  is called an *attribute* in
{\GAP}. When a new attribute is  defined, all three functions are created
together  and the getter contains  references to  the  other two. This is
necessary because when the  getter is called,  it must first consult  the
tester,  and perhaps execute the setter  in the end. Therefore the getter
could be implemented as follows:
\begintt
    getter := function( obj )
    local   value;

        if tester( obj )  then
            value := system_getter( obj );

        else
            value := real_work_getter( obj );
            setter( obj, value );
        fi;

        return value;
    end;
\endtt
The  only  function which depends  on  the   mathematical  nature of  the
attribute  is  the real-work  getter, and  this  is of   course  what the
programmer of an attribute has to install.

\exercise  What  do you think:  Is  the {\GAP} function  `Random' also an
attribute?

\answer Of course  not, because then the  first random element of a group
would be stored by  the setter and returned over  and  over again by  the
system getter every  time `Random' is  called in  the sequel.  Not a very
random behavior.

There is a general important rule about attributes: *Once the value of an
attribute for an object has been set, it cannot be reset, i.e., it cannot
be changed any more.* This is achieved by having two methods not only for
the getter but also for the setter: If an object already has an attribute
value stored, i.e., if the tester returns `true',  the setter simply does
nothing.
\beginexample
    gap> SetSize( G, 0 ); Size( G );
    11612160
\endexample

\exercise Does immutability of an object prevent a  setter from setting a
previously unset value?

\answer No. That  an object like a group  is constant does not mean  that
additional  information  cannot  be  entered. Such additional information
does not  change the mathematical  identity of  the object.
% You can also
% assign values to   record   components like  the `hom!.externalSet'    of
% section~"Operations!of  groups" although `hom'  is  immutable  (you could
% even overwrite the values), but at your own responsibility!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Properties and filters}\null

\atindex{properties}{|indexit}\atindex{filters}{|indexit}%
\index{method!selection}%
Certain attributes, like `IsAbelian', are boolean-valued. Such attributes
are known to {\GAP} as *properties*, because their values are stored in a
slightly different way. A  property  also has a   getter, a setter  and a
tester, but  in this case,  the getter as  well  as the  tester returns a
boolean   value. Therefore {\GAP} stores  both  values  in  the same way,
namely as  a bit in  a boolean list, and  treats property getters and all
testers (of attributes or properties) uniformly, namely as *filters*. You
can imagine a filter of an  object as a bit,  i.e., a switch which is set
either to `true' or to `false'. Since they allow only two values, filters
can be compared very quickly, and the  scheme by which {\GAP} chooses the
method, e.g., for a getter or  a setter (as we  have seen in the previous
section),  is mostly based  on the  examiniation  of filters, not  on the
examiniation   of   other  attribute values.    Details  of this  *method
selection* are described in the reference manual.

We only   present the following rule  of  the thumb here:  Each installed
method for an  attribute, say `Size( <obj>   )', has a certain number  of
``required filters'', i.e., filters that the argument <obj> must have for
this method  to be applicable.  To execute  a  call  of `Size( <obj>  )',
{\GAP}  selects the applicable method  that has the most required filters
because it thinks that the more an algorithm  requires of <obj>, the more
efficient it will be.  For example, if  <obj> is a permutation group that
is not (known to be) solvable, a method with required filter `IsPermGroup
and IsSolvableGroup'  is  not  applicable, hence a  method  with required
filter `IsPermGroup' will be chosen. On other hand, if <obj> was known to
be solvable, the  first method would be selected.   It may happen  that a
method  fails although  the argument  has  all required filters.  In such
cases, the method will  execute the statement `TryNextMethod();' then the
next applicable method will be chosen.

\exercise How  can  `TryNextMethod()' be used   to exploit  the potential
solvability of a permutation group?

\answer Suppose  there is a method for  solvable permutation groups which
is far superior to the general method and which  is able to return `fail'
if the  group is not solvable  (rather than end up  in an infinite loop).
Then one can install a  method with  required filter `IsPermGroup'  which
looks like
\begintt
    function( G )
    local  result;
        result := solvable_method( G );
        if result <> fail  then  return result;
                           else  TryNextMethod();  fi;
    end;
\endtt
This method would then be tried on every permutation group (whether known
to be  solvable or  not),  and it would  include a  mandatory solvability
test.  {\GAP} persues  such  a strategy for   `Size',  using the solvable
method from \cite{Sims90b}.

If no applicable method  (or no next applicable  method) is found, {\GAP}
stops with an error message either like
\begintt
    Error argument for 'Size' must have categories '
    [ "IsListOrCollection" ]' at ...
\endtt
or like
\begintt
    Error no method found for operation 'Size' with 1 argument at ...
\endtt
The  first variant occurs  if  the argument  to  `Size' was  of the wrong
category, e.g.,  if you asked for `Size(  1 )'. The second variant occurs
if the category was    right,  e.g., if   the  argument  was a list    or
collection, but there was no applicable method installed.

\index{operations}%
\danger The method  selection  is not only   used to select  methods  for
attributes but also for arbitrary  *operations*, which can have more than
one   argument.  In this case,   the  filters of  all  the  arguments are
examined, and a  method may also  require a certain  relation between the
families of the arguments. For example,  the methods for `ConjugateGroup(
<grp>, <elm> )'  require that <elm> lies  in the  family of <grp>,  i.e.,
that the family of  <grp> equals the  collections family of the family of
<elm>.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Local Variables:
% mode:               text
% mode:               outline-minor
% outline-regexp:     "\\\\Chapter\\|\\\\Section"
% paragraph-start:    "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% paragraph-separate: "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% fill-column:        73
% End:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
