\Chapter{Domains}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Information maintenance}

At various  places in the library,  {\GAP} defines a relation between two
domains by stating  that one  domain  is a substructure  or a homomorphic
image of another.  This would be  the right place  to pass on information
from the one domain to the other, e.g., because  a subgroup of a solvable
group is itself solvable or  a factor group of  a perfect group is itself
perfect. To  achieve  this, {\GAP}  knows a   special class  of  methods,
so-called *maintained  methods* for properties  like `IsSolvableGroup' or
`IsPerfectGroup', that should be applied whenever two  domains are in the
corresponding relation. We describe this mechanism first for subdomains.

\>InstallSubsetMaintainedMethod( <prop>, <super_req>, <sub_req> )
\>UseSubsetRelation( <super>, <sub> )

Here, <prop> is the property in  question, <super_req> is the conjunction
of  filters/properties that the big domain  must have, and <sub_req> is a
conjunction of  filters/properties that the subdomain  must have in order
to acquire the  value `true' for the  property  <prop>. For example,  the
inheritance of  solvability by  subgroups is  declared by  the  following
command in the {\GAP} library.
\begintt
    InstallSubsetMaintainedMethod( IsSolvableGroup,
        IsGroup and IsSolvableGroup, IsGroup );
\endtt
Now, whenever `UseSubsetRelation(  <super>, <sub> )'  is  executed, it is
tested whether `IsGroup( <super> )'  and `IsSolvableGroup( <super> )' and
`IsGroup( <sub> )',  and if  so, `SetIsSolvableGroup(  <sub>, true )'  is
executed.  Moreover, since in  this  example `<prop> =  IsSolvableGroup',
`<super_req> =  IsGroup and IsSolvableGroup'  and `<sub_req>  = IsGroup',
i.e., since
$$ \hbox{`<super_req> = <sub_req> and <prop>',} $$
the contraposition of the statement is also used:
$$\vbox{\halign{\hfil#\ &#\hfil\quad i.e.,\ &\hfil#\ &#\hfil\cr
if&`<sub_req>( <super> )'&if&`IsGroup( <super> )'\cr
and&`<sub_req>( <sub> )'&and&`IsGroup( <sub> )'\cr
and&`Tester( <prop> )( <sub> ) and not <prop>( <sub> )'&and&
  `not IsSolvableGroup( <sub> )'\cr
then&`Setter( <prop> )( <super>, false )'&then&
  `SetIsSolvableGroup( <super>, false )'.\cr}}$$
Both implications
$$ \eqalignno{\hbox{`IsSolvableGroup( <super> )'}&\Rightarrow
   \hbox{`IsSolvableGroup( <sub> )'}\cr
   \noalign{\line{and}}
   \hbox{`not IsSolvableGroup( <sub> )'}&\Rightarrow
   \hbox{`not IsSolvableGroup( <super> )'}\cr} $$
are declared by  the one call  of `InstallSubsetMaintainedMethod' and are
exploited by the one call of `UseSubsetRelation'.

\>InstallFactorMaintainedMethod( <prop>, <numer_req>, <denom_req>, %
                                 <factor_req> )
\>UseFactorRelation( <numer>, <denom>, <factor> )

\begintt
    InstallFactorMaintainedMethod( IsPerfectGroup,
        IsGroup and IsPerfectGroup, IsGroup, IsGroup );
\endtt
This is the analogue for homomorphic  images. If `<numer_req>( <numer> )'
and `<denom_req>( <denom> )' and `<factor_req>( <factor> )' then `Setter(
<prop> )( <factor>, true )'. The contraposition is valid if
$$ \hbox{`<numer_req> = <factor_req> and <prop>'} $$
and means that
$$\vbox{\halign{\hfil#\ &#\hfil\cr
if&`<factor_req>( <factor> )'\cr
and&`<factor_req>( <denom> )'\cr
and&`Tester( <prop> )( <factor> ) and not <prop>( <factor> )'\cr
then&`Setter( <prop> )( <denom>, false )'.\cr}}$$

Finally, there is a class of maintained methods for the case of isomophic
domains.

\>InstallIsomorphismMaintainedMethod( <prop>, <old_req>, <new_req> )
\>UseIsomorphismRelation( <old>, <new> )

Whenever you install a subset or  factor maintained method for a property
<prop>, it is automatically also  installed as an isomorphism  maintained
method.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subdomains and parents}\null

\>Parent( <D> )
\)\fmark Sub<structure>( <P>, <gens> )

A domain in     {\GAP} may have  a    parent, which is   a  distinguished
superdomain, e.g., a  supergroup of a group. If  <D>  has such a  parent,
`Parent( <D> )' returns it, otherwise it returns <D> itself (i.e., <D> is
its own parent).   A  domain obtains  a  parent  either  by   an explicit
`SetParent( <D>, <P> )' or when it is constructed with a `Sub<structure>'
command, e.g., as `<D>  := Subgroup( <P>,  <gens> )', which would  return
the group generated by <gens> with parent set to <P>. (The parent <P> may
itself have another parent, i.e., a ``grandparent'' of <D>.)

The parent and  subdomain relation reflects  mathematical notions such as
subgroup, but it  also serves algorithmic  purposes,  namely that certain
properties (and also attributes) of a domain <P> are automatically passed
on to  its subdomains, when  this  is mathematically allowed.  Precisely,
``mathematically allowed'' means that  the {\GAP} library must contain  a
call          of                 `InstallSubsetMaintainedMethod'     (see
"InstallSubsetMaintainedMethod") that sets  up the relation, e.g., that a
subgroup of a  solvable group is  itself solvable or  that  the home pcgs
(see "HomePcgs")  of  a  group   is   inherited to its   subgroups.   And
``automatically''  means that this  transfer of properties and attributes
from <P>  to <D> takes  place when  `SetParent( <D>,  <P> )' is executed.
Consequently, this command appears, e.g., in the code for `Subgroup( <P>,
<gens> )'.

Since this information transfer is so useful, many algorithms demand that
it is  performed whenever it  makes  mathematically sense. Hence, certain
operations     which  return subgroups  of   a    given  group <P> (e.g.,
`Stabilizer',  see "Stabilizer") always  return them as subgroups of <P>,
i.e., as groups with parent~<P>. When this is the case, it will always be
stated in this reference manual.

\)<Operation><Domain>( <D>, \dots\ ) {\rm vs.}\ %
  <Operation>Sub<domain>( <D>, \dots\ )
\index{in parent!operations}%

Here <Domain> stands for a category  of domains, e.g., `Group' or `Ring'.
We describe the idea for groups.

Some  group theoretical functions, e.g.,  for  computing the closure of a
group <D>  and a group  element <gen>, have  two variants in  {\GAP}. The
first returns a group without setting a parent in  it, whereas the second
assumes that <D> and <gen> both lie in the parent group of <D>, and hence
return a subgroup of that parent, thereby transfering infomation from the
parent to   the resulting subgroup.  For example,  section "ClosureGroup"
documents the function `ClosureGroup(   <D>, <gen> )' and  mentions  that
there is a  corresponding ``in parent operation'' `ClosureSubgroup'. This
is essentially implemented as
\begintt
    ClosureSubgroup := function( G, gen )
    local   C;

        C := ClosureGroup( G, gen );
        SetParent( C, Parent( G ) );
        return C;
    end;
\endtt

\)<Attribute>InParent( <U> ) {\rm vs.}\ <Attribute>( <D>, <U> )
\index{in parent!attributes}\index{in parent!properties}%

There   is another use    of  parents: Operations   which  depend on  two
arguments, namely two domains of the same  category, can store and lookup
the result in  the case where  the first  argument is  the  parent of the
second. They are  then interpreted  as ``in  parent attributes'' of   the
second argument.  {\GAP}   provides   for each  such    operation,  e.g.,
`Normalizer(  <D>, <U> )',   an attribute, e.g., `NormalizerInParent( <U>
)', whose default  method is to call `Normalizer(  Parent( <U> ), <U> )'.
On  the other hand, the  operation `Normalizer' first  checks whether its
first  argument is  the  parent   of  the second,   and   if  so,   calls
`NormalizerInParent'. (Of course,  it has to be   ensured that when  this
calls  `Normalizer' again, no  deadlock  occurs.) Since all this  happens
behind the scenes,  the user normally need not  care about the in  parent
attributes, but they will always be mentioned in this reference manual.

There is one useful possibility for the user, however, which requires the
knowledge of the in parent attributes: If a value is to be set in advance
with the setter, e.g., `SetNormalizerInParent'. This is perhaps even more
interesting for ``in parent properties'' like `IsNormalInParent'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Local Variables:
% mode:               text
% mode:               outline-minor
% outline-regexp:     "\\\\Chapter\\|\\\\Section\\|\\\\stars"
% paragraph-start:    "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% paragraph-separate: "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% fill-column:        73
% End:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
