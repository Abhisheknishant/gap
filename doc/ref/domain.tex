\Chapter{Domains and Collections}

Since a *set* in {\GAP} is a list with additional properties (homogeneous
and sorted),  {\GAP} can in  this manner  represent only sets  which  are
finite   or at least   readily  enumerable  respecting the ordering   (in
particular, they  must   then  be  well-ordered).  Most   sets  (in   the
mathematical sense) are   therefore represented  in {\GAP}   by  trickier
mechanisms, e.g., groups are (initially) given by generators. The general
name  for a   {\GAP}  object  which   represents a mathematical   set, is
*collection*.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Elements of domains}\null

We   have  seen    in  the   `ProjectiveSpaceTransversal'   example    in
section~"PositionCanonical" that a  collection <T> is  sometimes intended
to represent a mathematical set other than the plain list `AsList( <T> )'
of  its    elements (e.g., a  projective   space  rather than a    set of
left-normed vectors).  The more natural  collections,  however, are those
that have an  algebraic structure and can  be identified with the list of
their elements. They are called *domains* in {\GAP}.

Given  a domain, you can access  a list of its  elements via `AsList' and
`Enumerator',   as described  in   "AsList  and Enumerators". Domain   is
{\GAP}'s name for what was called a ``mathematical set'' in that section.
*To compare  two domains, it  is enough to   compare their element lists*
(or, to  be more precise, their  `AsListSorted's  because the ordering of
elements   plays no  role).  This  imporant rule   shows  why systems  of
representives need not   be domains:  The  list `[   (),  (1,2) ]'   is a
transversal for the  right cosets of the  alternating group of degree~$n$
in the symmetric  group of degree~$n$, for every  $n>1$. Therefore it  is
impossible to  reconstruct the set of right  cosets  (which would include
the alternating group, and hence the degree~$n$) from the transversal.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Property test functions}

There are  numerous functions  in  {\GAP}  that test  a collection  for a
certain property. They  all expect as argument  a collection <D>  (and in
some cases also   an element <elm>  or  another collection <E> as  second
argument)  and return `true'  if <D> has the  property (resp.~if <elm> or
<E> have the property with respect to <D>) and `false' otherwise. For the
sake of uniformity,  such  a function is  always called   `Is\dots' where
\dots\ stands  for an adjective or  noun (with capital first letter) that
describes the property to be tested. For example, the function that tests
a group for   solvability is called   `IsSolvable' and the function  that
tests whether    two elements  are  conjugate   in  a  group   is  called
`IsConjugate'  (*not*  `AreConjugate').  You  should adopt   this  naming
convention if you write your own property testing functions.

As a general principle,  if a test function  requires two arguments, then
the one comes first  that is supposed  to  be ``greater''. So  `IsSubset(
<D>, <E> )' tests whether <E> is a subset of <D> (where ``set'' means the
mathematical set described  by a collection)  and `IsConjugate( $G$, $x$,
$y$ )' tests whether the group elements $x$ and  $y$ are conjugate in the
group $G$.

Some of  these test functions may not  terminate if  the given collection
has an infinite set of elements. A warning may be printed in such cases.

The category test functions  like `IsGroup( <obj>  )' look similar to the
functions just  discussed, but they  do no actual computation:  they just
check whether  the argument <obj> has the   corresponding filter that was
set when <obj> was created.

We will describe property  test  functions for special categories  (e.g.,
for groups)  in the corresponding  chapters. There are  few general tests
that  are applicable to all collections,  you will find them below. Their
names should already demonstrate what they test.

\>IsFinite( <D> )

The default method calls  `Size' and returns  `true' if the size returned
by that function is a finite number (i.e., if `Size( <D> ) \< infinity').
This method will not work for collections where `Size' is not applicable.
In such cases,  the  implementor  of a  new  collection *must*  implement
`IsFinite' for that collection, since  it is, together with `AsList' (see
"AsList"), the most  basic function for collections, used  by most of the
default functions in the collection package.

\>IsSubset( <D>, <E> )!{for domains}

<E> is considered a subset  of <D> if and only  if the set of elements of
<E> is  as  a set   a subset of  the set   of elements  of  <D>. That is,
`IsSubset' behaves as if implemented as `ForAll( AsList( <D>), $d$ -> $d$
in <E> )'  (see "AsList"), except  that  it will also  sometimes, but not
always, work for infinite collections, and that it will usually work much
faster than the above definition.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Set functions!for domains}

The  following  functions  are called  set  functions  because  they  are
applicable to  all collections, i.e.,  to all mathematical  sets (as were
`IsFinite' and `IsSubset'  in  the last  section). Special  categories of
domains, such as groups, often overlay the default methods described here
by  more   efficient  functions.  These  specialized   function  are then
described  in  the appropriate  chapters;   however, if only the  default
method is used, the function will not be mentioned there again.

Whenever possible, the result  of a set  function applied to a domain  is
returned as a domain  again, rather than as a  set. This is to keep  with
the general idea  that  the output of a  computation  should reflect  the
properties of the input.  Examples, where  this leads  to a more  concise
presentation of the result  in the domain case than  in the set case, are
the functions `Intersection' and `Union'.

Functions for structured domains, such  as groups, fields or rings, which
will  be described  in  the following chapters,   behave exactly like set
functions  in these three  aspects. They  are even  more obliged than set
functions to return the result as a domain, since this is the only way to
keep  the     algebraic structure of the     objects  in  the computer's
representation as well as in the mathematical representation.

\>`<elm> in <D>'{membership test}!{for domains}

The `in' operator tests a relation  between elements and domains, whereas
the  comparison  functions  compared objects of  the  same  ``level''. It
returns `true' if the element <elm>, which may  be an object of any type,
lies in the domain <D>, and `false' otherwise.

The default  method computes the  set of elements  of the domain with the
function `AsListSorted' below and tests whether <elm> lies in this set.

\>Size( <D> )!{for domains}

`Size' returns  the size of the  domain  <D>. If <D> is  infinite, `Size'
returns the transfinite  number `infinity'. <D>  may also be a proper set
(see "Sets"), in which case the result is the length of this list. `Size'
will, however, signal an error if <D> is a list that is not a proper set,
i.e., that is not sorted, or has holes, or contains duplicates.

The default methods `DomainOps.Size' computes the  set of elements of the
domain with the function `AsList' and returns the length of this list.

\>Intersection( $D_1$, $D_2$, \dots\ )!{for domains}
\)Intersection( <list> )

In the first form `Intersection'  returns the intersection of the domains
$D_1$, $D_2$, etc.  In the second  form <list> must  be a list of domains
and `Intersection'  returns   the intersection   of those  domains.  Each
argument <D>  or element of <list> respectively  may also be an arbitrary
list, in which case `Intersection' silently applies  `Set' (see "Set") to
it first.

The result of `Intersection' is the set of elements  that lie in every of
the domains  $D_1$, $D_2$, etc.  The methods, however,  are encouraged to
keep as much structure as possible. If $D_1$ and $D_2$  are elements of a
common   category   and if  this    category  is   closed under    taking
intersections, then the result should be  a domain lying in this category
too. So for example the intersection  of permutation groups will again be
a permutation group.

`Intersection' itself is not  an  operation, but  a plain function  which
loops over its  arguments (or the list of  domains or sets) and calls the
operation `Intersection2' repeatedly, passing each time only two domains.
This obviously makes the writing of methods simpler.

The default  method for `Intersection2' checks   whether both domains are
infinite.  If they are  it  signals an error.  Otherwise,  if one of  the
domains is infinite it loops over  the elements of  the other domain, and
tests  for each element whether it  lies in the  infinite domain. If both
domains are finite it  computes the proper  sets of elements of both  and
intersects them.  This  default   method  is overlaid  by   more  special
functions for most other domains. Those  functions usually are faster and
keep the structure of the domains if possible.

\>Union( $D_1$, $D_2$, \dots\ )!{for domains}
\)Union( <list> )

Everything that  was said for `Intersection'  in the last paragraphs goes
similarly  for `Union'. In particular,    there is an operation  `Union2'
which does the real work. Its default method checks whether either domain
is infinite. If one is it signals an error. If both domains are finite it
computes the   proper sets  of   elements of both  and  unites  them (see
"UniteSet").

\>Difference( <D>, <E> )!{for domains}

`Difference'  returns the  set difference  of  the domains  <D> and  <E>.
Either argument may also be an arbitrary list, in which case `Difference'
silently applies `Set' (see "Set") to it first.

The result of `Difference' is the set of elements that lie in <D> but not
in <E>.  Note that <E> need not be a subset of <D>.  The elements of <E>,
however, that are not element of <D> play no role for the result.

The default method checks whether <D> is infinite. If it is it signals an
error. Otherwise, it computes the proper sets of elements  of <D> and <E>
and  returns   the difference of  those   sets  (see "SubtractSet"). This
default method is currently not overlaid for any domain.

\>Representative( <D> )

`Representative' returns a representative of the domain <D>.

The existence of  a representative, and the exact  definition of  what  a
representative  is, depends on the category  of  <D>.  The representative
should be an  element that, within a given context, identifies the domain
<D>.  For example if <D> is a cyclic group, its representative would be a
generator of <D>, or if <D> is  a  coset, its representative  would be an
arbitrary element of the coset.

Note that `Representative' is pretty free in choosing a representative if
there are  several.   It is  not even  guaranteed   that `Representative'
returns the same  representative if it  is  called several times for  one
domain (unless an  ealier  representatives was stored by  the  associated
setter, `SetRepresentative', of course). Thus the main difference between
`Representative' and `Random'  (see "Random") is that `Representative' is
free to choose a value that is cheap to compute, while `Random' must make
an effort to distribute its answers in a well-defined manner.

The default method simply signals an error, since there is no default way
to find a representative.

\>Random( <D> )

`Random' returns a random element of the domain <D>.  The distribution of
elements returned  by `Random'  depends on  the domain  <D>.  For  finite
domains all  elements are usually  equally likely.   For infinite domains
some reasonable  distribution is used.  See the   chapters of the various
domains to find out which distribution is being used.

The  default method for random   selection computes the list of  elements
using   `AsList' and  selects  a   random  element  of   this list  using
`RandomList'  (see "RandomList" for  a  description of the  pseudo random
number generator  used).  This default function  can  of course  only  be
applied to finite domains.

All random functions called this way rely on  the low level random number
generator provided by `RandomList' (see "RandomList").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Information maintenance}

At various  places in the library,  {\GAP} defines a relation between two
domains by stating  that one  domain  is a substructure  or a homomorphic
image of another.  This would be  the right place  to pass on information
from the one domain to the other, e.g., because  a subgroup of a solvable
group is itself solvable or  a factor group of  a perfect group is itself
perfect. To  achieve  this, {\GAP}  knows a   special class  of  methods,
so-called *maintained  methods* for properties  like `IsSolvableGroup' or
`IsPerfectGroup', that should be applied whenever two  domains are in the
corresponding relation. We describe this mechanism first for subdomains.

\>InstallSubsetMaintainedMethod( <prop>, <super_req>, <sub_req> )
\>UseSubsetRelation( <super>, <sub> )

Here, <prop> is the property in  question, <super_req> is the conjunction
of  filters/properties that the big domain  must have, and <sub_req> is a
conjunction of  filters/properties that the subdomain  must have in order
to acquire the  value `true' for the  property  <prop>. For example,  the
inheritance of  solvability by  subgroups is  declared by  the  following
command in the {\GAP} library.
\begintt
    InstallSubsetMaintainedMethod( IsSolvableGroup,
        IsGroup and IsSolvableGroup, IsGroup );
\endtt
Now, whenever `UseSubsetRelation(  <super>, <sub> )'  is  executed, it is
tested whether `IsGroup( <super> )'  and `IsSolvableGroup( <super> )' and
`IsGroup( <sub> )',  and if  so, `SetIsSolvableGroup(  <sub>, true )'  is
executed.  Moreover, since in  this  example `<prop> =  IsSolvableGroup',
`<super_req> =  IsGroup and IsSolvableGroup'  and `<sub_req>  = IsGroup',
i.e., since
$$ \hbox{`<super_req> = <sub_req> and <prop>',} $$
the contraposition of the statement is also used:
$$
\vbox{\halign{\hfil#\ &#\hfil\quad&#\ &\hfil#\ &#\hfil\cr
if& `<sub_req>( <super> )'& i.e.,& if& `IsGroup( <super> )'\cr
and& `<sub_req>( <sub> )'& i.e.,& and& `IsGroup( <sub> )'\cr
and& `Tester( <prop> )( <sub> ) and not <prop>( <sub> )'& i.e.,& and&
  `not IsSolvableGroup( <sub> )'\cr
then& `Setter( <prop> )( <super>, false )'& i.e.,& then&
  `SetIsSolvableGroup( <super>, false )'.\cr}}$$
Both implications
$$
\eqalignno{\hbox
{`IsSolvableGroup( <super> )'}& \Rightarrow
\hbox{`IsSolvableGroup( <sub> )'}\cr
\noalign{\line
{and}}
\hbox{`not IsSolvableGroup( <sub> )'}& \Rightarrow
\hbox{`not IsSolvableGroup( <super> )'}\cr} $$
are declared by  the one call  of `InstallSubsetMaintainedMethod' and are
exploited by the one call of `UseSubsetRelation'.
\beginexample
    gap> G := Group((1,2,3,4),(1,2));; IsSolvableGroup( G );
    true
    gap> U := Subgroup( G, [(1,2,3),(1,2)] );;
    gap> HasIsSolvableGroup( U );  IsSolvableGroup( U );
    true  # this information was passed from `G' to `U'
    true
|_
    gap> HasIsNilpotentGroup( U );  IsNilpotentGroup( U );
    false
    false
    gap> C := NormalClosure( G, U );
    Group( [ (2,3), (1,2,3), (2,3,4) ], ... )
    gap> HasIsNilpotentGroup( C );  IsNilpotentGroup( C );
    true  # this information was passed from `U' to `C'
    false
\endexample

\>InstallFactorMaintainedMethod( <prop>, <numer_req>, <denom_req>, %
                                 <factor_req> )
\>UseFactorRelation( <numer>, <denom>, <factor> )

\begintt
    InstallFactorMaintainedMethod( IsPerfectGroup,
        IsGroup and IsPerfectGroup, IsGroup, IsGroup );
\endtt
This is the analogue for homomorphic  images. If `<numer_req>( <numer> )'
and `<denom_req>( <denom> )' and `<factor_req>( <factor> )' then `Setter(
<prop> )( <factor>, true )'. The contraposition is valid if
$$ \hbox{`<numer_req> = <factor_req> and <prop>'} $$
and means that
$$
\vbox{\halign{\hfil#\ & #\hfil\cr
if& `<factor_req>( <factor> )'\cr
and& `<factor_req>( <denom> )'\cr
and& `Tester( <prop> )( <factor> ) and not <prop>( <factor> )'\cr
then& `Setter( <prop> )( <denom>, false )'.\cr}}$$

Finally, there is a class of maintained methods for the case of isomophic
domains.

\>InstallIsomorphismMaintainedMethod( <prop>, <old_req>, <new_req> )
\>UseIsomorphismRelation( <old>, <new> )

Whenever you install a subset or  factor maintained method for a property
<prop>, it is automatically also  installed as an isomorphism  maintained
method.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subdomains and parents}\null

\>Parent( <D> )
\)\fmark Sub<structure>( <P>, <gens> )

A domain in     {\GAP} may have  a    parent, which is   a  distinguished
superdomain, e.g., a  supergroup of a group. If  <D>  has such a  parent,
`Parent( <D> )' returns it, otherwise it returns <D> itself (i.e., <D> is
its own parent).   A  domain obtains  a  parent  either  by   an explicit
`SetParent( <D>, <P> )' or when it is constructed with a `Sub<structure>'
command, e.g., as `<D>  := Subgroup( <P>,  <gens> )', which would  return
the group generated by <gens> with parent set to <P>. (The parent <P> may
itself have another parent, i.e., a ``grandparent'' of <D>.)

The parent and  subdomain relation reflects  mathematical notions such as
subgroup, but it  also serves algorithmic  purposes,  namely that certain
properties (and also attributes) of a domain <P> are automatically passed
on to  its subdomains, when  this  is mathematically allowed.  Precisely,
``mathematically allowed'' means that  the {\GAP} library must contain  a
call          of                 `InstallSubsetMaintainedMethod'     (see
"InstallSubsetMaintainedMethod") that sets  up the relation, e.g., that a
subgroup of a  solvable group is  itself solvable or  that  the home pcgs
(see "HomePcgs")  of  a  group   is   inherited to its   subgroups.   And
``automatically''  means that this  transfer of properties and attributes
from <P>  to <D> takes  place when  `SetParent( <D>,  <P> )' is executed.
Consequently, this command appears, e.g., in the code for `Subgroup( <P>,
<gens> )'.

Since this information transfer is so useful, many algorithms demand that
it is  performed whenever it  makes  mathematically sense. Hence, certain
operations     which  return subgroups  of   a    given  group <P> (e.g.,
`Stabilizer',  see "Stabilizer") always  return them as subgroups of <P>,
i.e., as groups with parent~<P>. When this is the case, it will always be
stated in this reference manual.

\)\fmark <Operation><Domain>( <D>, \dots\ ) {\rm vs.}\ %
  <Operation>Sub<domain>( <D>, \dots\ )

\index{in parent!operations}%
Here <Domain> stands for a category  of domains, e.g., `Group' or `Ring'.
We describe the idea for groups.

Some  group theoretical functions, e.g.,  for  computing the closure of a
group <D>  and a group  element <gen>, have  two variants in  {\GAP}. The
first returns a group without setting a parent in  it, whereas the second
assumes that <D> and <gen> both lie in the parent group of <D>, and hence
return a subgroup of that parent, thereby transfering infomation from the
parent to   the resulting subgroup.  For example,  section "ClosureGroup"
documents the function `ClosureGroup(   <D>, <gen> )' and  mentions  that
there is a  corresponding ``in parent operation'' `ClosureSubgroup'. This
is essentially implemented as
\begintt
    ClosureSubgroup := function( G, gen )
    local   C;

        C := ClosureGroup( G, gen );
        SetParent( C, Parent( G ) );
        return C;
    end;
\endtt

\)\fmark <Attribute>InParent( <U> ) {\rm vs.}\ <Attribute>( <D>, <U> )

\index{in parent!attributes}\index{in parent!properties}%
There is another use of parents: Functions which depend on two arguments,
namely two domains of the same category, can  store and lookup the result
in the case  where the first argument is  the parent of  the second. They
are then interpreted as ``in parent attributes''  of the second argument.
{\GAP} provides for each  such function, e.g.,  `Normalizer( <D>, <U> )',
an attribute, e.g., `NormalizerInParent( <U> )',  whose default method is
to call `Normalizer( Parent(   <U> ), <U>   )'. On  the other  hand,  the
function  `Normalizer'  first checks whether   its  first argument is the
parent of the  second,   and if  so,  calls `NormalizerInParent'.  \  (Of
course, it has to be ensured that when this  calls `Normalizer' again, no
deadlock  occurs. Actually, there  is  also an operation, `NormalizerOp',
for which all the  methods  are installed that   really do the work.  See
"ext:In  parent attributes" in  the  extension manual.)  \ Since all this
happens behind the scenes, the  user normally need  not care about the in
parent  attributes, but they will  always be mentioned  in this reference
manual.

There is one useful possibility for the user, however, which requires the
knowledge of the in parent attributes: If a value is to be set in advance
with the setter, e.g., `SetNormalizerInParent'. This is perhaps even more
interesting for ``in parent properties'' like `IsNormalInParent'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Local Variables:
% mode:               text
% mode:               outline-minor
% outline-regexp:     "\\\\Chapter\\|\\\\Section\\|\\\\stars"
% paragraph-start:    "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% paragraph-separate: "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% fill-column:        73
% End:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
