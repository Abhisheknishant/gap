%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Speeding up}

This chapter explains a couple of possibilities to increase the performance
of GAP.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The compiler}
\index{gac}

A further possibility to speed up code is to compile it. This can be done
using the {\GAP} compiler {\sf GAC}. It creates C-code from {\GAP} code and
then calls the systems C compiler to produce machine code from it.

The compiler works only on UNIX systems.

The machine code consists of dynamically loadable modules.
To use the compiler to produce such modules, call it with the '-d' option.
\begintt
M193 /home/ahulpke > gap4/bin/i386-ibm-linux-gcc2/gac -d test.g
gap4/bin/i386-ibm-linux-gcc2/gap -C /tmp/5827_test.c test.g Init_Dynamic
gcc -fpic -ansi -Wall -O2 -o /tmp/5827_test.o -I
gap4/bin/i386-ibm-linux-gcc2/../../src -c /tmp/5827_test.c
ld -Bshareable -x -o test.so /tmp/5827_test.o
rm -f /tmp/5827_test.o
rm -f /tmp/5827_test.c
\endtt
This produces a file `<file>.so'.

\>LoadDynamicModule(<filename>)
\)LoadDynamicModule(<filename>,<crc>)

To load a compiled file, the command `LoadDynamicModule' is used. This
command loads <filename> as module. If given, the CRC checksum <crc> must
match the value of the module (see "CRC Numbers").

\begintt
gap> LoadDynamicModule("./test.so");
gap> CrcFile("test.g");
2906458206
gap> LoadDynamicModule("./test.so",1);
Error <crc> mismatch (or no support for dynamic loading) at
Error( "<crc> mismatch (or no support for dynamic loading)" );
Entering break read-eval-print loop, you can 'quit;' to quit to outer loop,
or you can return to continue
brk> quit;
gap> LoadDynamicModule("./test.so",2906458206);
\endtt

If you want to see or modify the intermediate c-code, you can also instruct
the compiler to produce only the c-files by using the option `-C' instead of
`-d'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Compiling library code}

The most tempting code to compile is probably the library. To permit use of
compiled library files whenever possible, the following mechanism is used:

All files that come with {\GAP} are read using the internal function
`READ_GAP_ROOT'. This function then checks, whether a compiled version of the
file exists and if its CRC number matches the file. If it does, the compiled
version is loaded, otherwise the file is read.
You can start {\GAP} with the `-D -N' option to see information printed
about this process.

To make {\GAP} find the compiled versions, they must be
put in the `bin/<systemname>/compiled' directory (<systemname> is the name
you gave for compilation, for example `i386-ibm-linux-gcc2'). They have
to be called according to the following scheme: 
Suppose the file is `humpty/dumpty.gi' in the {\GAP} home
directory. Then the compiled version will be
`bin/<systemname>/compiled/humpty/gi/dumpty.so'. That is, the directory
hierarchy is mirrored under the `compiled' directory. A further directory
level is added for the files suffix and the compiled version of the file
finally gets the suffix replaced to `.so' (as already produced by the
compiler).

For example we show how
to compile the `combinat.gi' file on a Linux machine. We suppose, we are in
the home directory of the gap distribution.

\begintt
bin/i386-ibm-linux-gcc2/gac -d lib/combinat.gi
\endtt

creates a file `combinat.so'. We now put it in the right place, creating
also the necessary directories:

\begintt
mkdir bin/i386-ibm-linux-gcc2/compiled
mkdir bin/i386-ibm-linux-gcc2/compiled/lib
mkdir bin/i386-ibm-linux-gcc2/compiled/lib/gi
mv combinat.so bin/i386-ibm-linux-gcc2/compiled/lib/gi
\endtt

If you now start {\GAP} and look, for example at the function `Binomial',
defined in `combinat.gi', you see it is indeed compiled:
\begintt
gap> Print(Binomial);
function ( <<arg-1>>, <<arg-2>> )
    <<compiled code>>
end
\endtt

The command line option `-M'  disables the loading of compiled modules and
always reads code from the library.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CRC Numbers}
\index{crc}

CRC (cyclic redundancy check) numbers provide a certain method of doing
checksums. They are used by {\GAP} to check whether
files have changed.
Whenever files are ``condensed'' -- for example for completion files
("Completion Files") or when compiling files ("The compiler") -- such a
checksum is computed implicitly and stored within the condensed file.

When reading a condensed version of the file instead of the original one,
the CRC checksum can be used to check whether the original had been changed
in the meantime.

`CrcFile(<filename>)' can be used to compute a CRC checksum for the file
given.

\begintt
gap> CrcFile("lib/morpheus.gi");
2705743645
\endtt

