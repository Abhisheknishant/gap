%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Groups}

Finitely generated groups   and their subgroups   are the most  important
domains in {\GAP}.  They  are represented  as permutation groups,  matrix
groups, pc groups  or even  more  complicated constructs as for  instance
automorphism groups, direct products   or semi-direct products  where the
group elements are composed of group elements in the constituents.

{\GAP}'s    treatment  of groups  reflects  the    mathematical notion of
subgroup, in that it is possible to declare a group a subgroup of another
group. Knowledge  of a group is  generally passed on  to its subgroups if
this is  mathematically allowed (e.g., a  subgroup of a solvable group is
again solvable).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group elements}

By *group elements* we mean objects that can serve as elements of a group
in {\GAP}. In order to construct a group, {\GAP} must be able to multiply
the elements, to   form their zeroth power  (`One(  <obj> )')  and  their
inverse (`Inverse(  <obj>  )'). These operations  are all  predefined for
standard group elements, as are permutations,  pc words and matrices, but
remember that there   are also generic   group elements (e.g.,  in direct
products), and that you can even define your own ones. In these cases the
necessary  binary  operations,   which      are described  in     section
"Multiplicative elements", must be  implemented by the programmer. {\GAP}
must also be able to decide whether two group elements are equal, and for
some applications also which of two given elements is less, i.e., it must
know an ordering of the elements.

Note  that group elements  usually  exist independently of a group, e.g.,
you  can write down two  permutations and  compute  their product without
ever defining a group that contains them.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group constructor functions}

\>Group( <g_1>, ..., <g_n> )
\)Group( <list>, <id> )
\)Group( <U> )

The function `Group' constructs a parent group from one of three types of
arguments.   The first way is  to pass any   number of group elements (as
described in "Group  elements") as arguments,  separated by commas, which
will then be the generators of the group. In this case, the elements must
of course belong to a common domain. The second alternative, perhaps more
useful when called from a program, is to pass a list of group elements as
first argument and  the identity element (which must  the zeroth power of
all the group elements in  the list) as second.   The second argument  is
necessary in   case the list  is  empty,  to  guarantee  that {\GAP}  can
determine   at least  the identity  element  of  the  group.   As a third
alternative, you can also pass a group <U> (parent  group or subgroup) as
argument to `Group'.  In this case, a new  parent group is returned which
is isomorphic to <U>.

In  any case, the  generators of the returned group  need not be the same
elements as the  generators that we   passed as arguments (resp.~not  the
same as  the generators of  <U>  in the third  alternative). The  default
group function uses the same generators, while the  pc group function may
create new generators along with a new collector.

\>AsGroup( <D> )

Let <D> be a domain. `AsGroup' returns a group that has the same elements
as <D>  if this is  possible.  If <D> is a  list of  group elements these
elements must form a group.   Otherwise an error  is signaled.  Note that
this function  returns a  parent group or  a  subgroup of a parent  group
depending on <D>. In order to convert a subgroup into  a parent group you
must use `Group' (see "Group").

Here should go something about

\>SubdirectProduct( ... )

and the like.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroups and parent groups}\null

\>AsSubgroup( <G>, <U> )

Let  <G> be  a  parent group  and <U>  be any group  whose generators are
elements of <G>. Then `AsSubgroup' returns a  new subgroup of <G> that is
generated by the generators  of <U>. This provides  a way to ``change the
parent group''.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Set functions!for groups}

See "Set functions!for domains" for general remarks  on set functions and
also for other set functions that are not overlaid for groups.

\>AsList( <G> )!{for groups}

The  elements of a  group  <G> are constructed  using a Dimino algorithm.
The function starts  with the trivial subgroup of <G>,  for which the set
of elements  is  known and constructs the  successive  closures with  the
generators of <G> using `ClosureGroupDefault' (see "ClosureGroup").

\>IsSubset( <G>, <H> )!{for groups}

If <G> and <H> are groups then `IsSubset' tests whether the generators of
<H> are elements of <G>.

\>Intersection( <G>, <H> )!{for groups}

The intersection of <G> and <H> is returned either  as set of elements or
as a group. If one argument, say <G>, is a set and the other a group, say
<H>, then the subset of elements of <G> which lie in <H> is returned.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group functions}

The following functions are applicable to  groups, regardless of how they
are  represented in   {\GAP}.  Most of  them  compute  subgroups, in  the
mathematical sense as well  as in the  {\GAP} sense. For example,  if you
compute a Sylow subgroup  <S> of a group <U>,  then <S> will have  <U> as
its parent group, and <U> may itself have another parent group.

Some of the  following functions may not  terminate if the given group is
infinite, while other functions may signal an error in such cases.

The basic remarks  made at the beginning   of section "Set  functions!for
domains" about set functions also apply to group functions.

\>AbelianInvariants( <G> )

The default method needs a finite abelian group <G> and it constructs for
every  prime  <p> dividing the  order  of <G>  the series $<G>  > <G>^p >
<G>^{p^2} > \ldots$ and computes the abelian  invariants from the indices
of these groups.

\>DimensionsLoewyFactors( <G> )

This  function returns the dimensions   (as  <F_p>-vector spaces) of  the
factors of the Loewy series of a <p>-group <G> as a list.

The default method computes the Jennings series  of <G> and uses Jennings
theorem  in order to  calculate the dimensions  of  the Loewy factors: If
$d_i$  are the dimensions  of the factors of  the Jennings series of <G>,
then we have for the Jennings polynomial
$$ \sum_{i=0}^l c_i x^i =
   \prod_{k=1}^l (1+x^k+x^{2k}+...+x^{(p-1)k})^{d_k}. $$

\>Exponent( <G> )

The  default method computes  all elements  of  <G> and  the least common
multiple of their orders.

\>Index( <G>, <U> )
\>IndexInParent( <U> )

The default method needs  a finite group <G>.  It returns the quotient of
`Size( <G> )' and `Size( <U> )'.

\>Agemo( <G>, <p> \[, <n> \] )
\>Omega( <G>, <p> \[, <n> \] )

If  <G> is a <p>-group,   `Agemo( <G>, <p>,   <n> )' returns the subgroup
generated by the $p^n$th powers of the  elements of <G>, and `Omega( <G>,
<p>, <n>  )' returns the  subgroup generated by  the $p^n$th roots of the
identity element of~<G>. If <n> is omitted, $<n>=1$ is assumed.

The  default method computes  the subgroup of <G>  generated by the <p>th
powers of the generators of <G> if <G> is abelian. Otherwise the function
computes the normal closure of the <p>th powers of the representatives of
the conjugacy classes of <G>.

\>AutomorphismGroup( <G> )

<G>   must be  finite.    The   automorphism group  is  constructed    by
``Morpheus''.

\>Centralizer( <G>, <x> \| <U> )
\>CentralizerInParent( <U> )
\>Centre( <G> )

`Centralizer' returns the centralizer of an element <x> or a subgroup <U>
of <G> where <x> resp.~<U> must belong to the parent group of <G>.

The  default  method uses  `Stabilizer'  (see  "Stabilizer") in  order to
compute  the  centralizer  of <x>  in  <G> acting  by conjugation.  For a
subgroup <U>,  the stabilizers of  the  generators  of <U>  are  computed
successively.  There is  an obvious extra  method for  `Centre' if <G> is
known to be abelian.

\>ClosureGroup( <U>, <g> \| <S> )
\>ClosureSubgroup( <U>, <g> \| <S> )

The default method returns  <U> if <g> or its  inverse is a generator  of
<U>, or if the set of elements is known and <g> is in this set, or if <g>
is trivial.  Otherwise the function  constructs a new  group <C> which is
generated by the generators of <U> and the element <g>.

\>CommutatorSubgroup( <G>, <H> )
\>DerivedSubgroup( <G> )

Let <G> be generated by $g_1, \ldots, g_n$ and  <H> be generated by $h_1,
\ldots, h_m$. The normal closure of the  subgroup <S> generated by $Comm(
g_i, h_j )$ for $1 \leq i \leq n$ and $1 \leq j \leq m$ under <G> and <H>
is the commutator subgroup  of  <G> and  <H> (see  \cite{Huppert67}). The
default method returns the normal closure of <S> under the closure of <G>
and <H>. The derived subgroup  of <G> is just  the commutator subgroup of
<G> and~<G>.

\>ConjugateGroup( <U>, <g> )
\)<U> ^ <g>
\>ConjugateSubgroup( <U>, <g> )

`ConjugateGroup(  <U>, <g> )' or,  equivalently,  `<U> ^ <g>' returns the
group $U^g$ conjugate to <U> under <g>. The default method returns <U> if
the set of elements of <U> is known and <g> is  an element of this set or
if <g> is a generator  of <U>. Otherwise it  conjugates the generators of
<U> with <g>.

\>Core( <G>, <U> )
\>CoreInParent( <U> )

The default method starts with <U> and replaces <U> with the intersection
of <U> and a conjugate subgroup of <U> under a generator of <G> until the
subgroup is normalized by <G>.

\>FittingSubgroup( <G> )

Let <G> be a finite group. Then the default  method computes the subgroup
of <G> generated by the cores of the Sylow subgroups in <G>.

\>NormalClosure( <G>, <U> )
\>NormalClosureInParent( <U> )

`NormalClosure' returns the normal closure of <U> under <G>.

\>NormalIntersection( <N>, <U> )

Let  <N>  and  <U>  be  two  subgroups   with  a  common   parent  group.
`NormalIntersection' returns the intersection in case <U> normalizes <N>.

Depending on the domain this may be faster  than the general intersection
algorithm    (see  "Intersection").   The  default   method  however uses
`Intersection'.

\>Normalizer( <S>, <U> )
\>NormalizerInParent( <U> )

Let   <S> and <U>  be groups  with  a  common   parent  group  <G>.  Then
`Normalizer' returns the normalizer of <U> in <S>.

The default   method uses  `Stabilizer' (see   "Stabilizer") in  order to
compute  the  stabilizer of <U>   in  <S>   acting  by conjugation   (see
"ConjugateSubgroup").

\>PCore( <G>, <p> )

The  default method computes  the <p>-core  as  the core  of  a Sylow-<p>
subgroup.

\>PermutationCharacter( <G>, <U> )

computes the permutation character of the  operation of <G> on the cosets
of  <U>. The permutation  character is returned  as list of integers such
that the <i>th position  contains the value  of the permutation character
on the <i>th conjugacy class of <G> (see "ConjugacyClasses!for groups").

The value of the *permutation character* of <U>  in <G> on a class <c> of
<G>  is the number of  right  cosets  invariant  under  the action  of an
element of <c>.

For small groups the  default method calculates the permutation character
by inducing the trivial character of <U>. For  large groups it counts the
fixed points by examining double cosets of <U> and the subgroup generated
by a class element.

\>RadicalOfGroup( <G> )

The default method tests if <G> is solvable and signals an error if not.

\>SylowSubgroup( <G>, <p> )

The default method computes the  set of  elements  of <p> power order  of
<G>,  starts   with such an element   of  maximal order  and computes the
closure with normalizing elements of <p> power  order until a Sylow group
is found.

\>TrivialSubgroup( <U> )

This is self-explanatory.

\>CommutatorFactorGroup( <G> )

`CommutatorFactorGroup' returns a  group  isomorphic to  $<G>/<G>'$ where
$<G>'$ is the derived subgroup of <G> (see "DerivedSubgroup").

The default method returns `Image(   NaturalHomomorphismByNormalSubgroup(
<G>,         DerivedSubgroup(       <G>      )       )       )'      (see
"NaturalHomomorphismByNormalSubgroup").

\>Order( <g> )!{for group elements}

The *order* of <g>  is the smallest positive integer  <i> such that $g^i$
is the identity. If no such <i> exists, <g> has infinite order. The order
of the identity is one.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Series of subgroups}

This section describes functions that compute and  return series $<G> \ge
G_0 >  G_1 > \ldots  > G_m \ge \{1\}$ of  subgroups of a given group <G>.
Such a series is returned  as a list `[ $G_0$,  $G_1$, \dots, $G_m$ ]' in
which $G_i$ is either a  subgroup of <G> or  of $G_{i-1}$ (see "Subgroups
and parent groups"). These functions print warnings if the argument is an
infinite group, because they may then run forever.

The functions may  be regarded as a  special kind of group functions, and
the general remarks made at the beginning  of the last section also apply
to them.

\>SubnormalSeries( <G>, <U> )
\>SubnormalSeriesInParent( <U> )

This function returns  a  subnormal series from  <G> to  <U>. If <U>   is
omitted, it is defaulted to the trivial subgroup of~<G>.

The default method constructs  the subnormal series  by setting  $G_0$ to
<G> and $G_i$ to  the normal closure (see  "NormalClosure") of  <U> under
$G_{i-1}$. This  process terminates if   $G_i=G_{i-1}$ for some  value of
$i$, otherwise the function will not stop.

Most  of the  following types  of  series are special  cases of subnormal
series.

\>CompositionSeries( <G> )
\>DisplayCompositionSeries( <G> )

If you want to see  the isomorphism types of  the factors rather than the
subgroups  in  such a series,  `DisplayCompositionSeries'  will provide a
fancy display of the   series.  Note that  although   there may  be  many
composition  series, all of them  have, up to  order and isomorphism, the
same factors.

There is no default method.

\>DerivedSeries( <G> )
\>LowerCentralSeries( <G> )
\>PCentralSeries( <G>, <p> )
\>JenningsSeries( <G>, <p> )
\>UpperCentralSeries( <G> )

The default  methods  for  these operations  construct  the corresponding
series   ``top    down''  by     iterated calls    of   `DerivedSubgroup'
resp.~`CommutatorSubgroup'.  `UpperCentralSeries' is different because it
works ``bottom  up'', repeatedly calculating the  `Centre' of  the factor
group of <G> modulo the topmost member already found.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Property test functions!for groups}

For general  conventions on property  test  functions, see "Property test
functions".   Below  you find a  list    of all  available property  test
functions along with the argument requirements. No further explanation of
what these functions do should be necessary, but we  mention from time to
time how they do it.

\>IsSubgroup( <G>, <U> )

This function  tests the mathematical  subgroup  relation, it is not  the
negation of the {\GAP}  function `IsParent'.  The default function  tests
whether each generator <u>  of <U> is  in <G>,  either by inspecting  the
element list of <G> (if  this is  known),  or by performing a  membership
test `<u> in <G>'.  <G> and <U> must have a common parent group.

\>IsTrivial( <G> )!{for groups}

The default method tests whether `Size( <G> ) = 1'.

\>IsAbelian( <G> )

The default method tests  the property $g*h  = h*g$ as  $g$ and $h$ range
over a set of generators.

\>IsElementaryAbelian( <G> )

If <G>  is abelian, it  is elementary abelian  if its exponent is a prime
<p> or equivalently, if each generator has order <p>.

\>IsCyclic( <G> )

If  <G> is not  abelian, it is  not cyclic either.   The default function
calculates the abelian  invariants (see "AbelianInvariants") for infinite
<G> and returns `true' if this yields `[ 1 ]'.  If <G> is finite of order
$p_1^{e_1}  ... p_n^{e_n}$, where $p_i$  are distinct primes, the default
functions returns `true' if each $G^{p_i}$ has index $p_i$ in <G>.

\>IsCentral( <G>, <U> )
\>IsCentralInParent( <U> )

This function tests the  property $g*u =  u*g$ as $g$  and $u$ range over
generating sets for <G> and <U>, respectively. <U> need not be a subgroup
of <G>.

\>IsNormal( <G>, <U> )
\>IsNormalInParent( <U> )

This function tests the property $u^g\in U$ as <u> ranges over generating
sets for <U>. If <G> is finite, it is also enough to let <g> range over a
generating set  for <G>, in the  infinite case, however, the  inverses of
the generators must also be tried for <g>.

\>IsSubnormal( <G>, <U> )

The default  method constructs  a subnormal series   from <G> to  <U> and
checks whether it reaches <U>.

\>IsSolvable( <G> )
\>IsNilpotent( <G> )

The default method calculates the derived resp.\ lower central series and
checks whether it reaches $\{1\}$.

\>IsPerfect( <G> )

For a  finite   group, the default  method  compares  <G> to its  derived
subgroup `DerivedSubgroup( <G> )'. For an infinite  group it computes the
abelian    invariants   of    the    commutator    factor   group    (see
"AbelianInvariants" and "CommutatorFactorGroup").

\>IsSimple( <G> )

The default method  tests simplicity by  constructing the  normal closure
(see "NormalClosure") of a representative of each conjugacy class.

\>IsConjugate( <G>, <x>, <y> )

This function tests   if  there is an  element    <g> in <G>   such  that
$g^{-1}xg=y$,  using  `Representative'  (see  "Representative")   in  the
default case.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{External sets}\null

\>ExternalSet( <G>, <D> \[, <opr> \] )
\indextt{ExternalSetAttr}%
\>OperationHomomorphism( <xset> )
\indextt{OperationHomomorphismAttr}%
\>UnderlyingExternalSet( <ohom> )
\>OnPoints( <pnt>, <g> )
\>OnRight( <pnt>, <g> )
\>OnLeft( <pnt>, <g> )

Three   things are  necessary  to  specify  an operation:  a group~<G>, a
set~<D>, and a  function  $<opr>\colon <D>\times  <G>\to <D>$.  If  these
things are passed as arguments to the  function `ExternalSet', it returns
a    so-called  *external set*  <xset>,  which   describes the operation.
Mathematically,  the external set  is the set~<D>,  which is endowed with
the group operation <opr>, and for this reason  {\GAP} treats <xset> as a
domain whose  elements are  the  elements  of <D>.  From an  external set
<xset>, the function  call  `OperationHomomorphism( <xset> )'  constructs
the   operation  homomorphism $<G>  \to  S_{|<D>|}$   associated with the
operation (for details, see  "Homomorphisms!for groups").  Conversely, if
<ohom>  is an   operation homomorphism,  you  can  obtain the  underlying
external set as `UnderlyingExternalSet( <ohom>  )'. The mapping functions
for operation homomorphisms  are described in  section "Homomorphisms!for
groups". You can use the shortcut `OperationHomomorphism( <G>, <D>, <opr>
)' for `OperationHomomorphism( ExternalSet( <G>, <D>, <opr> ) )'.

Since {\GAP}   only deals   with  permutations   of finite  degree,   the
domain~<D> must always be finite if these functions  are to work. <D> can
be either a  proper set (see "Sets") or  a domain which is represented as
described in "Domains". <G> can be an arbitrary  group, and <opr> must be
a {\GAP} function   that takes two arguments   (the first  from  <D>, the
second from <G>) and returns the  an element of~<D>,  namely the image of
the first argument under the  second. This last  argument <opr> is always
optional in operation functions, if it is not present, `<opr>( <pnt>, <g>
) =   <pnt>  ^ <g>' is  the  default.  This default function   is  called
`OnPoints'. Other predefined operation functions are `OnRight( <pnt>, <g>
) = <pnt> *  <g>' and `OnLeft( <pnt>, <g>  ) = <g>  ^ -1 * <pnt>'. In the
last function, <g> has to be inverted in order to obtain an operation and
not an anti-operation.

\)ExternalSet( <G>, <D>, <gens>, <oprs> \[, <opr> \] )

There is  an  alternative way of  defining  the operation.  Normally, the
{\GAP} function <opr> takes as second argument an element of <G>, but you
can also specify  a  generating set <gens> of   <G> and a list <oprs>  of
other {\GAP}  objects which operate  on  <D> via `$(d,o)  \mapsto <opr>$(
<d>, <o> )'  (where  $o\in <oprs>$). The elements   in <oprs> must be  in
bijection to <gens> so that really <G> acts  on <D> via `$(d,<gens>$[ $i$
]$) \mapsto <opr>( d, <oprs>$[  $i$ ] )'.  Calculating the image of $d\in
<D>$ under  an arbitrary element  $g\in  G$ would then  of course involve
expressing $g$ as a word in  <gens>. But the  use of <gens> and <oprs> is
more  efficient if only the  action  of generators of   <G> on the points
of~<D> needs to be known. This is the case  during an orbit algorithm, or
even for more advanced computations, if <G> is a polycyclic group; in the
latter case,  `Pcgs(    <G> )'  (see  "Operation  functions!for  solvable
groups") must be given as <gens>. Then only the objects in <oprs> will be
applied to the points of~<D>, and no elements of <G> must be factorized.

\>ActingDomain( <xset> )!{for external sets}
\>Enumerator( <xset> )!{for external sets}
\>FunctionOperation( <xset> )!{for external sets}

`ActingDomain' simply  returns the group  <G> which acts on  the external
set <xset>. `FunctionOperation' returns the  function $<D>\times <G>  \to
<D>$ which describes the operation, as a {\GAP} function. If the external
set was constructed as `ExternalSet( <G>, <D>, <opr> )', this function is
simply <opr>. However, if <gens> and <oprs>  were used to specify <xset>,
the result of `FunctionOperation( <xset>  )' must be constructed with the
help  of the  `OperationHomomorphism(  <xset> )'  which maps  <G>  onto a
permutation group acting on positive integers that enumerate~<D>.

Since  the  range  of  this  associated    operation homomorphism is    a
permutation group acting on $\{1,\ldots,|<D>|\}$, `OperationHomomorphism'
needs a bijection of  <D> onto this  set,  i.e., an *enumerator* of  <D>.
Such a  thing is constructed by `Enumerator(  <D>  )' (see "Enumerator").
You  can  pass  an  enumerator  instead  of  <D>  as  second  argument to
`ExternalSet', but  {\GAP} will choose   one  itself if you  don't.   The
enumerator that was used to construct  the permutation representation can
be retrieved from the  external set <xset> as  `Enumerator( <xset> )'. By
the way, a list <D> is considered to be its own `Enumerator'.

The   operation   functions   always    use   `PositionCanonical'    (see
"PositionCanonical") to   find the number  associated  to  an object, not
`Position'. In the example presented in section "PositionCanonical", this
means that  you  can let a  matrix group  operate on a   projective space
simply via `OnRight': even though the image of a left-normed vector under
a matrix need not be left-normed, it will be given the correct number.

\>SetBase( <xset>, <base> )!{for external sets}

A base  for the operation is a   subset $<base> \subseteq <D>$  such that
only the identity element of <G> fixes <base> pointwise. If you know such
a base for an external set <xset> that you have constructed, you can tell
{\GAP}  your knowledge  by setting the   base with  the command `SetBase(
<xset>, <base> )'.  If do so  before constructing `OperationHomomorphism(
<xset>   )', then {\GAP} will  make   this  operation homomorphism a  bit
smarter,  by making   use   of the  base (see   "ImagesRepresentative!for
operation homomorphisms").

\>ExternalSubset( <G>, <D>, <start> \[, <gens>, <oprs> \] \[, <opr> \] )
\>ExternalOrbit( <G>, <D>, <pnt> \[, <gens>, <oprs> \] \[, <opr> \] )
\>Enumerator( <xset> )!{for external subsets}
\>HomeEnumerator( <xset> )

`ExternalSubset' does not construct the operation  of <G> on <D> but only
on the union of the orbits of the points in <start> under <G>, i.e., on
$$ <start>.<G> = \bigcup_{p \in <start>}
   \{ <opr>(p,g) \mid g\in <G> \}\. $$
<start> must be    a subset of  <D>,   which is stored   in the component
`<xset>!.start'   for   future  reference.  The   corresponding operation
homomorphism  will, however, still have  $S_{|<D>|}$ as  its range, i.e.,
the enumerator of    <D> will be   used to  number  the points,  not  the
enumerator of $<start>.<G>$. Since  there are two enumerators involved in
such an *external subset*, we have  now two different functions to access
them:  `Enumerator' of  an  external  subset   returns  an  enumerator of
$<start>.<G> \subseteq <D>$, whereas  the enumerator used  for <D> can be
retrieved by `HomeEnumerator'  (this  function has the same  meaning also
for general external sets).

If <start> contains  only one  point,   the resulting operation  will  be
transitive. The external  subset is then  called an *external orbit*, and
is  constructed by the  function  `ExternalOrbit',  which is almost  like
`ExternalSubset', except  that it  does not  take a   list <start> but  a
single point  <pnt>.  The  image of  the   operation homomorphism  of  an
external orbit   will  always be   a  subgroup of~$S_{|<D>|}$   which  is
transitive on  its moved points (but  which does not necessarily move all
points).  You could  also  construct the orbit   as a list of points  via
`Orbit' (see below) and  let <G> then operate on  this list, but then the
points  would be  numbered   by their  position in   the orbit (which  is
generally   smaller than  <D>),   whereas  `ExternalOrbit'  (and likewise
`ExternalSubset')   uses the  numbers   of  the  `HomeEnumerator',  which
enumerates the whole~<D>.
\begintt
    gap> G := Group( (1,2,3), (4,5,6) );;  D := [1..6];;
    gap> Operation( ExternalOrbit( G, D, 4 ) );
    Group( [ ( 4, 5, 6) ], ... )
    gap> Operation( G, Orbit( G, D, 4 ) );
    Group( [ (1,2,3) ], ... )
\endtt
This difference becomes   even more peculiar   if you replace  `Orbit' by
`ExternalOrbit' in the last command. This substitution is perfectly valid
because the  operation functions accept  as second argument either a list
(as is   returned  by  `Orbit') or   a   domain (as   is constructed   by
`ExternalOrbit').
\begintt
    gap> Operation( G, ExternalOrbit( G, D, 4 ) );
    Group( [ (1,2,3) ], ... )
\endtt

\>SparseOperationHomomorphism( <G>, \[ <D>, \] <start> \[, <gens>, %
                               <oprs> \] \[, <opr> \] )

`OperationHomomorphism' works as usual  for external subsets and external
orbits, and you can type something like `OperationHomomorphism( <G>, <D>,
<start>, <opr> )'.  In this case, however,  the degree (and therefore the
memory size) of the resulting permutations will be determined by the size
of <D>, which  may be more  than the size  of the external subset. If you
want an  image   group of smaller  degree, you    must use  the  function
`SparseOperationHomomorphism( <G>, <start>, <opr> )', which is equivalent
to `OperationHomomorphism( <G>, ExternalOrbit( <G>, <D>, <start>, <opr> )
)',     but   does     both      steps    in     one.     Observe    that
`SparseOperationHomomorphism' does not require <D>  as an argument. Since
it therefore cannot  distinguish  between  points  and list of    points,
<start> is always  meant to be a  list of points  from <D>. If you want a
`SparseOperationHomomorphism' on  an  external   orbit, you   must  write
`SparseOperationHomomorphism( <G>, [ <pnt> ], <opr> )'.

To continue the previous example:
\begintt
    gap> Image( SparseOperationHomomorphism( G, D, [4] ) );
    Group( [ (1,2,3), () ], ... )
\endtt

\>Representative( <xset> )!{for external sets}
\>StabilizerOfExternalSet( <xset> )
\>CanonicalRepresentativeOfExternalSet( <xset> )
\>OperatorOfExternalSet( <xset> )

The    point <pnt> can be read    off from an   external  orbit <xorb> as
`Representative( <xorb>  )',  whereas the  representative of an  ordinary
external set <xset> is  chosen  as `Enumerator( <xset>   )[ 1 ]'. In  any
case, `StabilizerOfExternalSet( <xset> )' is the  stabilizer of the point
`Representative(         <xset>               )'${}\in              <D>$.
`CanonicalRepresentativeOfExternalSet' returns a representative that does
not depend on how the external set was constructed. For example, the same
external  orbit  can  result for  different  values   for <pnt>, but  the
canonical  representative     will    always   be   the  same.   Finally,
`OperatorOfExternalSet( <xset>   )'    returns an   element  which   maps
`Representative(  <xset> )' to     `CanonicalRepresentativeOfExternalSet(
<xset> )' under the given operation.

\)ExternalSubset( <xset>, <start> )

Similar  to  `OperationHomomorphism',  the function `ExternalSubset' (and
likewise `ExternalOrbit') can be called   either with the arguments  <G>,
<D>,  optionally <opr> and  possibly <gens> and <oprs>   that are used by
`ExternalSet' to  construct  an  <xset>; or   it  can instead  be  called
directly with  the argument <xset>.  The same is   true for the following
functions, which calculate the  image of an operation homomorphism <ohom>
or the image of an element  of <G> under it.  We will, however, no longer
print an extra line like the one above this paragraph.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operation functions!for groups}

We continue the notation and conventions from the last section.

\>Operation( <G>, <D> \[, <start> \] \[, <gens>, <oprs> \] \[, <opr> \] )
\>Orbit( <G>, \[ <D>, \] <pnt> \[, <gens>, <oprs> \] \[, <opr> \] )

`Operation'  returns   the permutation group  which  is  the image of the
operation homomorphism associated with   the specified operation.  If the
third  argument <start> is given, it  returns the permutation group image
for  an external  subset  where  the  action is  on  the  union of orbits
$<start>.<G> \subseteq <D>$. If <start>   is a single point, an  external
orbit is constructed instead, it represents the orbit $<start>.<G>$. This
subset of <D> can be constructed by the function  `Orbit', which can also
be called without the  domain <D>  as  argument. In the latter  case, the
standard orbit algorithm is performed, which puts all points in a list as
they are found and  compares them with  the standard membership test (see
"membership test!for lists").

\>Permutation( <g>, <D> \[, <gens>, <oprs> \] \[, <opr> \] )
\>PermutationCycle( <g>, <D>, <pnt> \[, <gens>, <oprs> \] \[, <opr> \] )
\>Cycle( <g>, \[ <D>, \] <pnt> \[, <gens>, <oprs> \] \[, <opr> \] )

`Permutation' is like   `Operation', but for  a single  group element <g>
rather  than  a  group~<G>. Accordingly,  it does   not return a subgroup
of~$S_{|<D>|}$, but an  element  of~$S_{|<D>|}$. If group elements   were
replaced  by cyclic subgroups, `Permutation'  would really be the same as
`Operation'. Finally, `PermutationCycle(  <g>, <D>,  <pnt>, <opr> )'  and
`Cycle( $\ldots$ )' are the  equivalents to `Operation( <G>, <D>,  <pnt>,
<opr> )'  and `Orbit( $\ldots$ )' for  single group  elements. Note that,
like   `Orbit',   `Cycle'      returns  a  list     of    points, whereas
`PermutationCycle' returns a transitive   permutation (i.e., one  with  a
single orbit), which is often also called  a cycle. Like `Orbit', `Cycle'
can be called without the  argument~<D>. If you want  to use the shortcut
`Permutation( <g>, <xset> )' or `Cycle( <g>, <xset>,  <pnt> )' instead of
passing <D>, <gens>, <oprs> and <opr>, then <g> must be an element of the
domain of definition of `OperationHomomorphism( <xset> )'.

The algorithms used for  these functions must  be able to apply arbitrary
elements of <G> to  points of <D>. Therefore,   if <gens> and <oprs>  are
given, the computations are not done in <G>, but in the permutation group
image  of  the  operation homomorphism   <ohom>, using   the methods  for
`GroupHomomorphismByImages'      (see    "GroupGeneralMappingByImages!for
permutation groups"  for the case where <G>  is  a permutation group, for
example).

\>ExternalOrbits( <G>, <D> \[, <gens>, <oprs> \] \[, <opr> \] )
\indextt{ExternalOrbitsAttr}%
\>Orbits( <G>, <D> \[, <gens>, <oprs> \] \[, <opr> \] )
\indextt{OrbitsAttr}%
\>Cycles( <g>, <D> \[, <gens>, <oprs> \] \[, <opr> \] )

These functions  return  a list  of  all  orbits resp.~cycles  which  the
specified operation has on <D>. In the case of `ExternalOrbits', they are
represented  as  external sets,  to which   you  can apply the  functions
mentioned in this section. Otherwise, they are simply lists.

If <D> is not closed under the operation, it is  silently replaced by its
closure. In  the case of `Cycles', however,  this silent replacement will
not work if the operation is specified via  <gens> and <oprs>, because in
this  case {\GAP} has  to set up  an  operation homomorphism <ohom> first
(like in the last paragraph), and this  already requires the knowledge of
the complete operation domain. If you call `Cycles'  this way in spite of
this warning, you will get the puzzling error message
\begintt
    List Assignment: <position> must be a positive integer (not a boolean) at
    blist[new] := true;
\endtt

\>OrbitLength( <G>, \[ <D>, \] <pnt> \[, <gens>, <oprs> \] \[, <opr> \] )
\>OrbitLengths( <G>, <D> \[, <gens>, <oprs> \] \[, <opr> \] )
\indextt{OrbitLengthsAttr}%
\>CycleLength( <g>, \[ <D>, \] <pnt> \[, <gens>, <oprs> \] \[, <opr> \] )
\>CycleLengths( <g>, <D> \[, <gens>, <oprs> \] \[, <opr> \] )

The functions  for orbits and cycles  have colleagues which take the same
arguments but   determine  not the orbits   themselves  but rather  their
lengths.    These   colleagues   are   named,   e.g.,   `OrbitLength'  or
`CycleLengths'.

\>Blocks( <G>, <D> \[, <seed> \] \[, <gens>, <oprs> \] \[, <opr> \] )
\>MaximalBlocks( <G>, <D> \[, <seed> \] \[, <gens>, <oprs> \] %
                 \[, <opr> \] )

`Blocks'  resp.~`MaximalBlocks'  determine a minimal  resp.~maximal block
system  (i.e., one with blocks  of minimal resp.~maximal cardinality) for
the operation of <G> on <D>. If the optional argument <seed> is given, it
must be a subset of <D> containing at least  two points; then only blocks
containing <seed> will be considered, and the resulting block system will
be minimal resp.~maximal among the ones with this restriction.

In general, `MaximalBlocks' calls `Blocks' for  <G> acting on <D>, and if
the operation of <G> on the resulting  block system <B> is not primitive,
`Blocks'  is called again, this  time for <G> acting   on <B>, and so on,
until <G> acts  primitively  on some system $\tilde   B$ of sets of  sets
\dots\ of sets. The system of ``flattened'' sets of $\tilde B$ then forms
a maximal block system for <G> on~<D>.

\>IsSemiRegular( <G>, <D> \[, <gens>, <oprs> \] \[, <opr> \] )
\indextt{IsSemiRegularProp}%
\>IsRegular( <G>, <D> \[, <gens>, <oprs> \] \[, <opr> \] )
\indextt{IsRegularProp}%
\>IsTransitive( <G>, <D> \[, <gens>, <oprs> \] \[, <opr> \] )
\indextt{IsTransitiveProp}%
\>IsPrimitive( <G>, <D> \[, <gens>, <oprs> \] \[, <opr> \] )
\indextt{IsPrimitiveProp}%
\>IsPrimitiveAffine( <G>, <D> \[, <gens>, <oprs> \] \[, <opr> \] )
\indextt{IsPrimitiveAffineProp}\endgraf\smallskip%
\>Transitivity( <G>, <D> \[, <gens>, <oprs> \] \[, <opr> \] )
\indextt{TransitivityAttr}%
\>Earns( <G>, <D> \[, <gens>, <oprs> \] \[, <opr> \] )
\indextt{EarnsAttr}%

The `Is\dots'  functions from the first group  test certain properties of
operations. If they are alternatively called  with an external set <xset>
as the only  argument, the results are   stored and looked up  in <xset>.
This is possible,  since the result depends  only on the operation (which
is fully  described by the  external set  <xset>),  and not on additional
arguments such as <pnt>   for `Orbit'. These  functions can  therefore be
regarded as properties of  external sets, and  such {\GAP} properties are
accessible as `<Function>Prop( <xset> )'  where <Function> is a name from
the above list. In particular, you can set the value of an property in an
external   set with `Setter( <Function>Prop    )( <xset>,  <val> )'  (the
abbreviations    `Set<Function>Prop'  and `Has<Function>Prop'   are *not*
provided because these properties   should rarely  appear in  the  code).
Results are also  stored and looked up in  a permutation group <G> if the
operation  <opr> is `OnPoints', not  specified via <gens> and <oprs>, and
`MovedPoints( <G> )' is already known and equal to~<D>.

The same mechanism is also used  for non boolean-valued functions such as
`Orbits', `Transitivity' and `Earns', the corresponding {\GAP} attributes
are called `OrbitsAttr' etc. (consult the index for a complete list).

`IsSemiRegular'  always translates the  operation  into  an operation  on
integers and   uses   the special  method  for  permutation  groups  (see
"IsSemiRegular!for permutation groups"). `IsRegular' uses `IsSemiRegular'
in conjunction  with `IsTransitive', which, in  turn, simply compares <D>
with  the result of an   `Orbit' call. `Transitivity'  checks whether the
operation  `IsTransitive'.    If  not, it returns~0     as  the degree of
transitivity, otherwise   it   recursively looks   at  the  `Stabilizer',
adding~1  to its degree of transitivity.  `IsPrimitive' calls `Blocks' to
determine a minimal block system and returns `true'  if this has only one
block.  `IsPrimitiveAffine'  additionally checks whether  `Earns' returns
something different from `fail'.

\>RepresentativeOperation( <G>, \[ <D>, \] <d>, <e> \[, <gens>, <oprs> %
                           \] \[, <opr> \] )
\>Stabilizer( <G>, \[ <D>, \] <d> \[, <gens>, <oprs> \] \[, <opr> \] )

`RepresentativeOperation' determines an element $g\in <G>$ which maps <d>
to <e> under the  given operation. `Stabilizer' calculates the stabilizer
of <d> as a subgroup of <G>. This subgroup relation is important, because
it allows the algorithms in the library to assume that certain properties
of   <G>  are passed  on  to  stabilizers  calculated  in  <G>. For  both
functions, the domain <D> can be omitted.

\>OrbitStabilizer( <G>, \[ <D>, \] <pnt> \[, <gens>, <oprs> \] %
                   \[, <opr> \] )
\>ExternalOrbitsStabilizers( <G>, <D> \[, <gens>, <oprs> \] %
                             \[, <opr> \] )
\indextt{ExternalOrbitsStabilizersAttr}%

These functions combine  the calculations of  orbits and stabilizers  and
where   possible  use    a method which       calculates both  at   once.
`OrbitStabilizer' returns    a  record  with  components   `orbit'    and
`stabilizer'    whereas   `ExternalOrbitsStabilizers'       works    like
`ExternalOrbits',  but ensures that each external  orbit in the resulting
list  will already   have   its   `StabilizerOfExternalSet' by    calling
`OrbitStabilizer' for each new representative.

\>`$<xorb>_{<d>}$ = $<xorb>_{<e>}$'{equality test}!{for external orbits}
\>`<d> in $<xorb>_{<e>}$'{membership test}!{for external orbits}

If  <d> and   <e>  are points   in  the same  external  set <xset> (i.e.,
$<d>,<e>\in   <D>$),  then    the  external    orbits `$<xorb>_{<d>}$  :=
ExternalOrbit(  <xset>,  <d>  )'  and  `$<xorb>_{<e>}$  := ExternalOrbit(
<xset>,   <e>     )'  can       be   compared   by    testing     whether
`RepresentativeOperation( <xset>,  <d>, <e> ) \<>  fail'. hether a common
external set <xset> exists for $<xorb>_{<d>}$  and $<xorb>_{<e>}$ if both
external    orbits   have the   same      `ActingDomain'  and  the   same
`FunctionOperation'.   The  membership test  `<d>   in $<xorb>_{<e>}$' is
decided in the same way.

\>Enumerator( <xorb> )!{for external orbits!by stabilizer}
\>Size( <xorb> )!{for external orbits!by stabilizer}

By the   orbit-stabilizer  theorem,  the  external   orbit <xorb>  is  in
bijection  with  a   right transversal  $T$  of `StabilizerOfExternalSet(
<xorb> )'  in `ActingDomain( <xorb> )' where  $t\in T$ corresponds to the
image of  `<rep> = Representative(  <xorb>   )' under <t> (via  `<opr>  =
FunctionOperation(  <xorb> )'). This fact  allows {\GAP}  to construct an
enumerator <enum> for the external orbit  from an enumerator of the right
transversal     (which    is  calculated     by  `RightTransversal',  see
"RightTransversal"). We then  have  $enum[ pos ]  =  opr( r,  pos )$  and
`Position(    <enum>,     <e>      )    =    PositionCanonical(      $T$,
RepresentativeOperation( <xorb>,  <r>, <e> )  )'.  The bottleneck of this
computation if often  the  call  of `RepresentativeOperation',  which  is
therefore  speeded up in more  special cases, e.g., for conjugacy classes
(see  "Enumerator!for conjugacy  classes").  Of course `Size(  <xorb> ) =
Length( $T$ )  = Index( ActingDomain( <xorb>  ), StabilizerOfExternalSet(
<xorb> ) )'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Conjugacy classes!for groups}\null

\>ConjugacyClass( <G>, <g> )!{for groups}
\>Centralizer( <cl> )!{for conjugacy classes}

This paragraph  serves  as an illustration  of  the  concept  of external
orbits introduced in  the last sections. Namely,  a conjugacy class is an
orbit  of a   group  element $<g>\in  <G>$  under  the action  of <G>  by
conjugation,  and   that  is  how    {\GAP}  stored such    a  thing:  as
`ExternalOrbit(  <G>,  <G>, <g>, OnPoints  )'.  Membership in a conjugacy
class and equality between conjugacy classes can then be decided with the
corresponding   methods for  external  orbits   (see "membership test!for
external orbits").  They trigger   a call  of  `RepresentativeOperation',
which then does the real work.

The  `StabilizerOfExternalSet' of  a   conjugacy class <cl>  can also  be
called `Centralizer( <cl> )' since this is a more imaginative name.

\>Enumerator( <cl> )!{for conjugacy classes}
\>`$<cl>_1$ = $<cl>_2$'{equality test}!{for conjugacy classes}
\>`<h> in <cl>'{membership test}!{for conjugacy classes}
\>AsList( <cl> )!{for conjugacy classes}

The  enumerator  of  a    conjugacy class  is  built  as     described in
"Enumerator!for  external orbits".  There   is  one  improvement  to  the
`Position' function,  however: To speed up `RepresentativeOperation( <G>,
<r>, <e>  )', the stabilizer of  the element <r>, i.e. `Centralizer( <cl>
)' is passed as an additional argument to the function. The same trick is
used to speed up the membership test `<h> in <cl>'. For the comparison of
conjugacy  classes  $<cl>_1$ and   $<cl>_2$,    {\GAP}  uses even    both
stabilizers `Centralizer( $<cl>_1$ )' and `Centralizer( $<cl>_2$ )'.

If   you want to avoid these   elaborate methods and  resort  to the good
old-fashioned orbit  algorithm (which will  probably  be faster for small
groups), you can  use `AsList( <cl>  )', which simply calls `Orbit(  <G>,
<r> )'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Homomorphisms!for groups}

Group homomorphisms    are   mappings  between  groups     that   respect
multiplication (and, consequently, also identity elements and inversion).
This sections  deals more generally  with general mappings between groups
that respect these operations. The reason for this generalization is that
a  group homomorphism can be specified  conveniently  by prescribing only
the     images for  a   generating   set    of  the  source   group  (see
`GroupHomomorphismByImages' below),  but it is  difficult to determine if
such a prescription really defines a single-valued *mapping*. In general,
it     will   only define  a     *general  mapping*, which     we  call a
`GroupGeneralMappingByImages' (see below).

In  the  following  sections  we explain   how  mapping  tasks  for group
homomorphisms are  reduced  to the ``elementary  tasks''  of  finding one
image or one preimage  of an element,  and of determining the kernel  and
the  cokernel. The   corresponding functions  are  `ImagesRepresentative(
<hom>,   <elm> )',  `PreImagesRepresentative(  <hom>,  <elm> )', `Kernel(
<hom> )', and  `CoKernel( <hom>  )'.   These elementary tasks  cannot  be
performed  for generic  group homomorphisms, however,  they are therefore
described   in     the more  specialized      sections  below,  e.g.,  in
"Homomorphisms!for permutation groups".

\>Image( <hom> \[, <elm> \| <H> \] )!{for group homomorphisms}
\>PreImage( <hom> \[, <elm> \| <H> \] )!{for group homomorphisms}
\>IsSurjective( <hom> )!{for group homomorphisms}
\>IsInjective( <hom> )!{for group homomorphisms}
\>IsTotal( <hom> )!{for group homomorphisms}
\>IsSingleValued( <hom> )!{for group homomorphisms}
\>IsMapping( <hom> )!{for group homomorphisms}

The `Image' of  an  element  is only defined  if  <hom>  is single-valued
(i.e.,      if `CoKernel(  <hom>  )' is     trivial,  which is  tested by
`IsSingleValued(     <hom>    )'),   it     is  then      calculated   by
`ImagesRepresentative'. This is the  more general function because it  is
also defined for multi-valued mappings, in which case it just returns one
image. Similarly,  the `PreImage' of  an element is  only defined  for an
injective <hom>, (i.e., for which `Kernel( <hom> )'  is trivial, which is
tested  by  `IsInjective( <hom>   )').  In  this  case, the   preimage is
calculated by `PreImagesRepresentative'.

`Image(  <hom> )' means the image  of `Source( <hom>  )'.  It is equal to
`Range(  <hom> )' if  and only if <hom>  is surjective, so `IsSurjective'
does its job by comparing the sizes or  testing whether the generators of
`Range( <hom>  )' are in  `Image( <hom> )'.  Dually,  `PreImage( <hom> )'
means the preimage of `Range( <hom> )', i.e., the domain of definition of
<hom>. This  is what  `IsTotal(  <hom> )'  looks at  to  test if <hom> is
defined everywhere. `IsMapping( <hom>  )' returns true  if <hom> is total
and its cokernel is trivial.

If <hom> is  total, `Image( <hom> )' can  be calculated as `Image( <hom>,
Source( <hom> )  )' by the  method to  be  described momentarily. Dually,
`PreImage( <hom> )' can be calculated as `PreImage( <hom>, Range( <hom> )
)' if  <hom>  is  surjective.  The image   of  a subgroup under  a  group
homomorphism <hom> is computed as the closure of `CoKernel( <hom> )' with
an   image (found by  `ImagesRepresentative')    for each  of  a set   of
generators  for the  subgroup (intersected with   `PreImage(  <hom> )' if
<hom> is  not total). Dually, the preimage  of a subgroup  is computed as
the closure of `Kernel( <hom> )' with a `PreImagesRepresentative' of each
generator (of  the  intersection with `Image(   <hom> )' if  <hom> is not
surjective).

You  can  avoid possibly time-consuming  calculations  if you tell {\GAP}
what you already  know  about a  homomorphism that you  construct. If you
know   that   <hom> is    <Prop>    where  <Prop>  stands   for  `Total',
`SingleValued', `Surjective',  `Injective'  or `Bijective', then  you can
tell {\GAP}  so by  executing `SetIs<Prop>( <hom>,   true )'. After that,
`Is<Prop>( <hom> )' will return `true' without any further calculation.

\>Images( <hom>, <elm> )!{for group homomorphisms}
\>PreImages( <hom>, <elm> )!{for group homomorphisms}

The set of images of an element under a group homomorphism is constructed
as  the     coset    of  `CoKernel( <hom>     )'      with representative
`ImagesRepresentative( <hom>, <elm> )'. The  set of preimages is computed
analogously using `PreImagesRepresentative' and `Kernel'.

%				 *  *  *
\stars

\>GroupGeneralMappingByImages( <G>, <H>, <gens>, <imgs> )
\>GroupHomomorphismByImages( <G>, <H>, <gens>, <imgs> )

Since a group homomorphism $<G>\to <H>$ respects the group operations, it
is   already determined   if   only the    images of    the  elements  in
`<G>.generators'  are given.    {\GAP}  will  understand  the  expression
`GroupHomomorphismByImages(  <G>, <H>, <gens>,   <imgs> )', which you can
use if  you  want to specify  the homomorphism  that maps  the generators
<gens> to the  images <imgs>, respecting  the  order of these  two lists.
<gens> need not be a generating set for <G>, but if  it is not, then this
homomorphism is not defined on all of <G>.

Such a homomorphism is unique, but it need not  exist, since you may have
prescribed,  e.g., an  image of    order~3  for a generator  of  order~2.
Therefore, in the  general case, we mean by `GroupGeneralMappingByImages(
<G>,   <H>, <gens>,  <imgs>   )' the  relation   consisting of  all pairs
$(w(gens),      w(imgs))$   as   <w>     ranges   over    all    words in
$n=|<gens>|=|<imgs>|$  letters (and  their  inverses). This relation need
not be a single-valued mapping.

\>ImagesSource( <R> )!{for `GroupGeneralMappingByImages'}
\>PreImagesRange( <R> )!{for `GroupGeneralMappingByImages'}

The   image resp.~preimage   of  `GroupGeneralMappingByImages(  <G>, <H>,
<gens>, <imgs> )' is  simply   the subgroup  of <G>  generated  by~<gens>
resp.~the subgroup of <H> generated by~<imgs>.

\>Inverse( <R> )!{for `GroupGeneralMappingByImages'}
\>PreImagesRepresentative( <R>, <elm> )!{for %
                                         `GroupGeneralMappingByImages'}

This  is easy:  `Inverse( GroupGeneralMappingByImages( <G>,  <H>, <gens>,
<imgs> )  )' is simply  constructed as `GroupGeneralMappingByImages( <H>,
<G>,  <imgs>,  <gens> )'.   With   the help   of   the inverse   mapping,
`PreImagesRepresentative(   <R>,  <elm>     )' can    be    calculated as
`ImagesRepresentative( Inverse( <R> ), <elm> )'.

\>CoKernel( <R> )!{for `GroupGeneralMappingByImages'}
\>Kernel( <R> )!{for `GroupGeneralMappingByImages'}

\danger In  order to understand how {\GAP}  can test whether the relation
`<R>   =  GroupGeneralMappingByImages( <G>, <H>,   <gens>,  <imgs>  )' is
single-valued, we need to consider a free group $F$ whose free generating
set is in bijection  to <gens> (this means  that elements occurring twice
or more in <gens> appear  twice or more as  distinct generators of  $F$).
<G>  is the factor  group of $F$  by a  normal ``relation subgroup'' <N>.
Since $F$ is  free,    there is a unique  (single-valued)    homomorphism
$f\colon  F\to H$ mapping  <gens> to <imgs>  as you wished.  If  <R> is a
homomorphism, the composition of the natural projection $F\to G=F/N$ with
<R>   must be $f$,  and so  <N> must be  contained in  the kernel of $f$.
Conversely, if $f(N)=\{1\}$, then  $f$  can be  made into a  homomorphism
$F/N=G\to H$, which is our desired <R>.  Otherwise, the image $f(N)\le H$
is the *cokernel* of <R>, i.e., the subgroup  of images of `<G>.identity'
under <R>. So the test for <R> to  be a single-valued mapping consists of
testing $f(r)=1$ for  every relation $r$ in a  defining  set of relations
for <G>. $f(r)\in H$ can be calculated if  $r$ is given  as a word in the
generators of <gens> because the image must then  be the same word in the
corresponding images in <imgs>.

The cokernel $f(N)$  of~<R> is the  normal closure  in the  image $R(G) =
f(G)$  of  the mapped  relations  $f(r)$.  These are calculated  with the
method used by  `ImagesRepresentative', and  `NormalClosure' is used   to
find the cokernel.

There is  no general  method, however,  to  construct  a defining set  of
relations for <G>,  and so  the test  whether  a mapping  constructed  by
`GroupGeneralMappingByImages'  is  a  single  valued  mapping, is usually
quite expensive. \ (There is a feasible method for  applying this test in
the  case  of  permutation  groups,  see  "Homomorphisms!for  permutation
groups".) \ Note that this test is automatically performed the first time
that you apply a  function  that expects a  single valued  mapping, e.g.,
`Image'  of an element. You can  avoid this test  if you tell {\GAP} that
<R> is a   mapping as  described in the    table above, or you  can  call
`ImagesRepresentative' instead.

The kernel of <R> is the cokernel of the  inverse mapping of <R> and that
is also how it is calculated.

%				 *  *  *
\stars

\>OperationHomomorphism( <G>, <D> \[, <gens>, <oprs> \] \[, <opr> \] %
                         \[, "surjective" \] )!{surjective}
\indextt{SurjectiveOperationHomomorphismAttr}%

This    constructs   an    operation homomorphism     as    described  in
"OperationHomomorphism". Operation homomorphisms are always mappings, and
this information is already entered  into the homomorphism <ohom> when it
is  constructed.  The  other  important  information   is  the  attribute
`UnderlyingExternalSet( <ohom> )' which gives the external set associated
with  the operation. The range  of an  operation homomorphism is normally
the full symmetric group of degree $|D|$,  but if the additional argument
`"surjective"' is given, the  operation homomorphism will  be surjective,
i.e., its  range  will be its   `Image', a  subgroup  of  $S_{|D|}$. This
variant   is  needed   by   functions  like   `IsomorphismPermGroup' (see
"IsomorphismPermGroup")  which use  operations to  construct isomorphisms
from arbitrary groups to permutation groups.

If <G> is a group that allows easy factorization of its elements into its
generators, e.g.,  a permutation  group or a  polycyclic  group, then the
operation homomorphism  is constructed  as  a `GroupHomomorphismByImages'
where  the  image   of  a generator   is  determined    by the   function
`Permutation'. The same method is  also used for  other groups <G> if the
operation    was  specified  via     <gens>   and  <oprs>,    because   a
`GroupHomomorphismByImages' is the  only way  of expressing an  arbitrary
element $g\in G$ as  a word in <gens>, so  that the corresponding word in
<oprs> can  be used to determine  the images of  points  of <D> under <g>
(see   "GroupHomomorphismByImages").   Otherwise,  the homomorphism    is
constructed  as  a new   kind of homomorphism,   for which  the following
functions apply.

\>ImagesRepresentative( <ohom>, <elm> )!{for operation homomorphisms}
\>PreImagesRepresentative( <ohom>, <elm> )!{for operation homomorphisms}
\>Kernel( <ohom> )!{for operation homomorphisms}

Since the  operation  was not    specified  via <gens>   and <oprs>,  the
`ImagesRepresentative'  of an <elm> can  be found as `Permutation( <elm>,
<D>, <opr> )' where  <D>  and <opr> are read   off from the external  set
stored in  `UnderlyingExternalSet( <ohom> )'. If a  base was  set for the
operation  by `SetBase(  <xset>,   <base> )'  (see "SetBase!for  external
sets"),   the operation is   only evaluated on   the base  points and the
resulting  permutation   is   constructed  from  this    information  via
`RepresentativeOperation' (see "RepresentativeOperation").

A     `PreImagesRepresentative'      is   found     by   a       call  of
`RepresentativeOperation', and  the  kernel    similarly by a    call  of
`Stabilizer'.

%				 *  *  *
\stars

\>NaturalHomomorphismByNormalSubgroup( <G>, <N> )

In  {\sf GAP~4}  there  is no  generic  way  to represent factor  groups.
Instead,  there  is   the function  `NaturalHomomorphismByNormalSubgroup'
which,  given  a group   <G>  and a  normal  subgroup <N>,  constructs an
epimorphism $\pi\colon G\to G/N$ with kernel <N>. The  image of this map,
`Image( $\pi$ )', is  then  isomorphic to the  factor  group, but  it  is
represented in a way which makes it convenient to calculate in it, rather
than as a   collection of cosets.  The  following  chapters describe  the
representation {\GAP} chooses for such factor groups.

<N> need  not be    a subgroup   of  <G>,   it  is sufficient   that  <G>
normalizes~<N>. In this  case, the image  of the natural homomorphism  is
isomorphic to $GN/N  \cong G/G\cap N$,  the kernel is  $G\cap N$ and  all
preimages will lie inside~<G>.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Local Variables:
% mode:               text
% mode:               outline-minor
% outline-regexp:     "\\\\Chapter\\|\\\\Section\\|\\\\stars"
% paragraph-start:    "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% paragraph-separate: "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% fill-column:        73
% End:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
