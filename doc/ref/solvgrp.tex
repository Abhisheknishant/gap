%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Solvable Groups}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Polycyclic generating systems}

A  generating  sequence $(g_1,\ldots,g_n)$ for a   group <G> is  called a
*polycyclic generating system* (or *pcgs*)  if the series of subgroups $G
= G_0 > G_1 > \ldots >  G_n = \{1\}$ with  $G_i = \< g_{i+1}, \ldots, g_n
>$ is a  subnormal series for   <G> with cyclic factors $G_i/G_{i+1}$  of
prime order. Such  a pcgs exists for  a finite <G> if  and only if <G> is
solvable.

\>Pcgs( <G> )

This function constructs  and returns a  pcgs for the group  <G> if it is
solvable and returns `fail' otherwise.

\>ExponentsOfPcElement( <pcgs>, <g> )
\>DepthOfPcElement( <pcgs>, <g> )
\>LeadingExponentOfPcElement( <pcgs>, <g> )

These functions ``factorize'' a given  element <g> of `<pcgs>.group' into
the  generators  in  the  list $(g_1,\ldots,g_n)$. `ExponentsOfPcElement'
returns a list <e> such that
$$ g = g_1^{e[1]} \cdot g_2^{e[2]} \cdot \ldots \cdot g_n^{e[n]}. $$
The  default method  performs  a division algorithm,  i.e., it determines
$e[1]$ such that $g_1^{-e[1]}g \in \< g_2, \ldots,  g_n >$, by increasing
$e[1]$  until the membership  test yields  true. Then  <g> is replaced by
$g_1^{-e[1]}g$ and the step is repeated for $e[2]$ and so on.

The functions   `DepthOfPcElement'      and  `LeadingExponentOfPcElement'
determine  the depth  and  the leading  exponent   (as an integer)  of an
element w.r.t.\ a pcgs. Both functions can be  viewed as special versions
of the function `ExponentsOfPcElement'.

\>RelativeOrderOfPcElement( <pcgs>, <g> )

Given an element <g> with  `DepthPcElement( <pcgs>, <g>   ) = <d>',  this
function determines the order of the coset $G_{d-1}g$ in the factor group
$G_{d-1}/G_d$. The default method performs  a division step like the  one
described in `ExponentsOfPcElement' above.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes of polycyclic generating systems}\null

\>GroupOfPcgs( <pcgs> )
\>GroupByPcgs( <pcgs> )

\index{polycyclic generating systems!attributes for}%
These two functions return the group generated by the elements of <pcgs>.
The subtle difference is that  `GroupByPcgs' may  construct a new  group,
e.g., a pc group  with new collector, whose  family is different from the
family of <pcgs>.  By contrast,  `GroupOfPcgs'  is supposed to contain  a
group that was there before  <pcgs> was constructed  (and was put it when
<pcgs> was made).

\>RelativeOrders( <pcgs> )

This is simply a list of the `RelativeOrderOfPcElement's.

\>PcSeries( <pcgs> )
\>NormalPcSeries( <pcgs> )
\>NormalPcFirst( <pcgs> )

This function returns the series of subgroups  of `GroupOfPcgs( <pcgs> )'
generated by the end-pieces of  <pcgs> (i.e., `List( [1..Length(<pcgs>)],
<i> -> GroupByGenerators( <pcgs>{[<i>..Length(<pcgs>)]} ) )'). (This is a
subnormal  series.) If possible,  `NormalPcSeries(  <pcgs>  )' returns  a
subseries of `PcSeries(  <pcgs>  )' which  is  even a normal series  with
abelian factors. This need not be possible for every pcgs, although every
solvable group has a pcgs with this property. `NormalPcFirst' returns the
list of positions where the  generating  subsequences for the members  of
`NormalPcSeries' start.
\beginexample
    gap> s4 := Group((1,2,3,4),(1,2));;  SetName( s4, "S4" );
    gap> p := Pcgs( s4 );  PcSeries( p );
    Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,2)(3,4) ])
    [ S4, Group( [ (2,4,3), (1,4)(2,3), (1,2)(3,4) ], ... ), 
      Group( [ (1,4)(2,3), (1,2)(3,4) ], ... ), 
      Group( [ (1,2)(3,4) ], ... ), Group( [  ], ... ) ]
|_
    gap> NormalPcSeries( p );  NormalPcFirst( p );
    [ Group( [ (3,4), (2,4,3), (1,4)(2,3), (1,2)(3,4) ], ... ), 
      Group( [ (2,4,3), (1,4)(2,3), (1,2)(3,4) ], ... ), 
      Group( [ (1,4)(2,3), (1,2)(3,4) ], ... ), Group( [  ], ... ) ]
    [ 1, 2, 3, 5 ]
\endexample
Note the final `5' in the  `NormalPcFirst( <p> )',  it corresponds to the
trivial subgroup at the end of `NormalPcSeries( <p> )'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Induced polycyclic generating systems}\null

\index{polycyclic generating systems!induced}%
Let $G$ be a solvable group with pcgs $(g_1,\ldots,g_n)$ and let $U$ be a
subgroup  of $G$.   with pcgs  $(u_1,\ldots,u_m)$.  We  then have  unique
factorizations       $u_i=g_1^{e_{i1}}.\ldots.g_n^{e_{in}}$.      Certain
transformations,      like    $u_i     \mapsto     u_i.u_{i+1}^{e_{i+1}}.
\ldots.u_m^{e_m}$, which  transform the given  pcgs  of $U$ into another,
correspond to      manipulations   of   the    rows    of   the    matrix
$(e_{ij})_{i=1,\ldots,m,\,j=1,\ldots,n}$     which    are the  elementary
operations of a  non-commutative variant of Gauss' elimination algorithm.
We  can achieve a  pcgs for  $U$ where   the corresponding matrix  has an
echelon form like
$$ \def\dotfill{\cleaders\hbox{$\mkern1.5mu\.\mkern1.5mu$}\hfill}%
   \left(\vcenter{\halign{&\hbox to1em{\hfil$#$\hfil}\cr%
            \*&\*&\multispan4\dotfill&\*\cr
              &  &\*&\*&\*&\omit\dotfill&\*\cr
              &  &  &  &  &\*&\*\cr
              &  &  &  &  &  &  \cr}}\right) $$
(with zeros in  the lower left  half). Such a  pcgs for $U$ is called  an
*induced pcgs* w.r.t.\ the pcgs of $G$. Working a bit harder, we can also
achieve a pcgs for $U$ for which in addition  the leftmost entry in every
non-zero row in the matrix is~1, and where  the entries in the rows above
such 1's are~0. There is exactly one pcgs for  $U$ with these properties,
it is called the *canonical pcgs* w.r.t.\ the pcgs of $G$.

\>InducedPcgsByGenerators( <pcgs>, <gens> )
\>ParentPcgs( <indpcgs> )

{\GAP} can  calculate induced and  canonical pcgs  and it is particularly
interested in  canonical pcgs of subgroups of  a fixed solvable group <G>
because these pcgs distinguish the subgroups (avoiding membership tests).
The function for induced pcgs  taks two arguments, namely  a pcgs of  the
supergroup <G> and a list of generators for the subgroup.
\beginexample
    gap> G := SymmetricGroup( IsPcGroup, 4 );;  pcgs := Pcgs( G );
    Pcgs([ f1, f2, f3, f4 ])
    gap> u := Subgroup( G, [ G.2^2, G.1*G.2 ] );
    Group( [ f2^2, f1*f2 ], ... )
    gap> InducedPcgsByGenerators( pcgs, GeneratorsOfGroup( u ) );
    Pcgs([ f1*f2, f2^2 ])
\endexample
Here  the   corresponding   matrix  is   $({1\atop}  {1\atop2}  {0\atop0}
{0\atop0})$. The pcgs relative to which an induced pcgs was formed can be
retrived   from  the  induced   pcgs  as  the   value  of  the  attribute
`ParentPcgs'.

\>CanonicalPcgsWrtHomePcgs( <U> )
\>HomePcgs( <U> )

The  canonical pcgs  for  a subgroup  $U$ should really  be an attribute,
because it  must be looked   up  whenever $U$   is  compared to   another
subgroup. But since  the canonical pcgs  is also  defined w.r.t.\ another
pcgs, we   need to  be  more  specific.   There  is  a  {\GAP}  attribute
`CanonicalPcgsWrtHomePcgs' and  another attribute `HomePcgs', which holds
the pcgs with respect  to which the  canonical pcgs will be computed.  Of
course this home pcgs should be  the pcgs of <G>, and  hence the same for
all subgroups of <G>. {\GAP} automatically provides a home pcgs for every
newly-constructed solvable group <G>, in such a way that `HomePcgs( <G> )
= Pcgs( <G> )', and every group constructed as  `Subgroup( <G>, \dots\ )'
will inherit this home pcgs.
\beginexample
    gap> HomePcgs( u );
    Pcgs([ f1, f2, f3, f4 ])
    gap> CanonicalPcgsWrtHomePcgs( u );
    Pcgs([ f1, f2 ])
\endexample
Now    the corresponding   matrix   is  $({1\atop}   {0\atop1}  {0\atop0}
{0\atop0})$.

\>CanonicalPcgsWrtFamilyPcgs( <U> )
\>FamilyPcgs( <U> )

For  pc   groups (but *not*   for permutation  groups)   there is another
mechanism  similar  to  `HomePcgs'.      Since  the  elements      of   a
newly-constructed pc group <G> make up a whole new family, it makes sense
to speak of a family pcgs. If <U> is a subgroup of <G>, then `FamilyPcgs(
<U> )' must always equal `FamilyPcgs( <G> ) = HomePcgs( <G> ) = Pcgs( <G>
)', whereas `HomePcgs( <U> )'  could also be  the pcgs of an intermediate
group between <G> and  <U>, of which we  want to regard <U>  as subgroup.
But even if  we can change  our mind about which  group <U> is a subgroup
of, we cannot change anything about the family  the elments of <U> belong
to.  During one {\GAP}  session, this family  will always  be the same pc
group  <G>,  whose collector is  based on  a fixed  pcgs,  namely the one
returned by `FamilyPcgs( <U> )'.

@ WHAT IS THE REAL DIFFERENCE HERE? I CAN CHANGE  NEITHER FAMILY PCGS NOR
HOME PCGS OF U! @

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Modulo polycyclic generating systems}\null

\>`<pcgs> mod <indpcgs>'{modulo}!{for pcgs}
\>NumeratorOfModuloPcgs( <modpcgs> )
\>DenominatorOfModuloPcgs( <modpcgs> )

\index{polycyclic generating systems!modulo}%
Let $G$ be a  solvable group and $N$ a  normal subgroup. A  *modulo pcgs*
for $G/N$ is a pcgs for the factor group even if  the factor group itself
is unknown.\footnote\*{Migr\accent127ane  sind Kopfschmerzen, auch   wenn
man gar keine hat. (Erich  K\accent127astner, in *P\accent127unktchen und
Anton*)} To construct such a thing,  you need only a  pcgs for $G$ and an
induced pcgs for $N$, but *no* group (isomorphic to) $G/N$. Such a factor
group  is expensive to  obtain,  because it requires   the setup of a new
collector (even if $G$ and $N$  were permutation groups, the factor would
be a pc  group, see "NaturalHomomorphismByNormalSubgroup!for  permutation
groups"), although the  group  operations could as  well be  performed in
$G$.  Comparing  elements in  the factor   group then requires comparison
modulo~$N$, and    this is where  the   modulo pcgs helps:   It makes the
functions  like `ExponentsOfPcElement'  return   exponent lists that  are
valid for~$G/N$.
\beginexample
    gap> N := PCore( G, 2 );
    Group( [ f4, f3, f3*f4 ], ... )
    gap> indpcgs := InducedPcgsByGenerators( pcgs,GeneratorsOfGroup(N) );
    Pcgs([ f3, f4 ])
    gap> modpcgs := pcgs mod indpcgs;
    (Pcgs([ f1, f2, f3, f4 ]) mod Pcgs([ f3, f4 ]))
|_
    gap> RelativeOrders( modpcgs );
    [ 2, 3 ]
    gap> DepthPcElement( modpcgs, G.4 );
    3
    gap> ExponentsOfPcElement( modpcgs, G.1*G.3 );
    [ 1, 0 ]
    gap> PcElementByExponents( modpcgs, last );
    f1
\endexample
Observe that in  the  last two commands,   the group elements   are given
resp.\  returned as elements of $G$  although they are meant to represent
elements of~$G/N$. A modulo pcgs can also be constructed from two induced
pcgs, if   both are induced   w.r.t.\ the  same  parent  pcgs. With  this
generalization, <N> need not be  a subgroup of <G>, as  long as <G> still
normalizes~<N>. In this case, the modulo pcgs will be constructed for the
factor group $GN/N \cong G/G\cap N$,  and the group elements contained in
it  will  lie inside  <G>. The same   generalization was made for natural
homomorphisms, see "NaturalHomomorphismByNormalSubgroup".

In  any case, a  modulo pcgs  has two attributes, `NumeratorOfModuloPcgs'
and `DenominatorOfModuloPcgs', which contain the two  pcgs from which the
modulo pcgs was made.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group functions!for solvable groups}

\>ElementaryAbelianSeries( <G> )

The default  function converts   <G> into an   isomorphic pc   group  and
computes the elementary abelian series in this group.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Affine methods!for solvable groups}

Let <U> and <H> be subgroups of a group <G>  such that <H> normalizes <U>
and consider the   action of <H> on  <U>  by conjugation. If   <U> has an
elementary abelian subgroup <N> (i.e., a vector space)  that is normal in
both  <U> and   <H>, then  affine   methods  can  be employed to   deduce
information   about   <H>-conjugacy    in  <U>  from   information  about
<H>-conjugacy in $U/N$.  In particular, one  can define a set $R_H(U)$ of
_canonical <H>-class    representatives_   for <U>  such  that,  given  a
representative  $hN\in  R_H(U/N)$ in  the  factor group, the intersection
$R_H(U) \cap hN$ (i.e., the set  of canonical representatives in <U> that
map  to <hN>  in  $U/N$) is of   the form <hK>   with <K> a set of  orbit
representatives of the affine action on the vector space <N> given by
$$ C \to {\rm AGL}(N), \qquad c \mapsto ( n \mapsto [h,c] n^c ), $$
where <C> is the preimage  of $C_{H/N}(hN)$ in  <H>. The centralizer of a
representative  $hk  \in  hK$  can also  be   calculated  as described in
\cite{MeckyNeubuser89}.

\>Centralizer( <G>, <U> | <u> )!{for solvable groups}

The centralizer of a  group or an element   is calculated by  the methods
mentioned  above. If only one argument  <U> is given,  the centralizer of
<U> in its parent group is calculated.

\>ConjugacyClasses( [ <H>, ] <U> )!{for solvable groups}

The <H>-conjugacy classes of <U> are calculated by affine methods. If the
first argument <H> is not given, the <U>-classes of <U> are calculated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operation functions!for solvable groups}

\>ExternalSet( <G>, <D>, \[, {Pcgs( <G> )}, <oprs> \] \[, <opr> \] )%
  !{for solvable groups}
\)\it and the other operation functions analogously

For a solvable group <G>, the  operation functions use special algorithms
which make use of  a pcgs for  <G>. To activate  these methods, you  must
supply an external set constructed
\beginlist
\item{$\bullet$}
  either via <gens>    and <oprs>, where `<gens>   =  Pcgs( <G>  )'  (for
  example, as `ExternalSet( <G>, <D>, Pcgs( <G> ), <oprs>, <opr> )'), or
\item{$\bullet$}
  or without   <gens> and  <oprs>, where   `IsPcgsComputable(  <G> )'  is
  `true', e.g. if <G> already has a pcgs.
\endlist

\>Enumerator( <xset> )!{for external orbits!for solvable groups}
\>Stabilizer( <G>, <D>, <p> \[, {Pcgs( <G> )}, <oprs> \] \[, <opr> \] )%
  !{for solvable groups}
\>StabilizerOfExternalSet( <xset> )!{for solvable groups}
\>OrbitStabilizer( <G>, \[ <D>, \] <pnt> \[, {Pcgs( <G> )}, <oprs> \] %
                   \[, <opr> \] )!{for solvable groups}
\>CanonicalRepresentativeOfExternalSet( <xset> )!{for solvable groups}
\>OperatorOfExternalSet( <xset> )!{for solvable groups}

\danger    Since every group permutes   the  orbits of  a normal subgroup
setwise, and since  a solvable group <G> has  a composition series $<G> =
G_0 > \ldots  > G_n=\{1\}$ with cyclic  factors, the <G>-orbit of a point
<pnt> can  be  constructed by iterated  cyclic   extension. The  orbit $p
G_{i-1}$ is   either  equal  to the   orbit   $<p>  G_i$  or it    is the
concatenation  the pairwise   disjoint  mapped orbits   $<p>  G_ig^j$ for
$j=0,\ldots, [G_{i-1}:G_i] - 1$ if  $\langle G_i, g\rangle = G_{i-1}$. In
particular, the orbit of <p> under a  member of the composition series is
always a starting-piece of the entire <G>-orbit.

If the orbit is stable in a cyclic extension step,  i.e., if $p G_{i-1} =
p G_i$, there is an element $h\in G_i$ such that $p.gh^{-1} = p$ with <g>
as above. The  elements $gh^{-1}$ collected over  all steps  in which the
orbit is stable form a (reversed) pcgs for the stabilizer of <p>. In this
way the    stabilizer  can be   computed together    with   the orbit  in
`OrbitStabilizer'. In a similar manner one can construct, given any point
<p> of   the operation domain,  an   element in  <G> mapping <p>   to its
canonical representative.

\>RepresentativeOperation( <G>, <D>, <d>, <e> \[, {Pcgs( <G> )}, <oprs> %
                           \] \[, <opr> \] )!{for solvable groups}

If <d> and <e> are in the same orbit of an operation <xset>, the external
orbits `$xorb_d$    := ExternalOrbit( <xset>,  <d>   )'  and `$xorb_e$ :=
ExternalOrbit(      <xset>,     <e>    )'     will     have    the   same
`CanonicalRepresentativeOfExternalSet',        and    hence             a
`RepresentativeOperation'  from   <d> to <e>   can be  calculated  as the
quotient `OperatorOfExternalSet(  $xorb_d$  )    * OperatorOfExternalSet(
$xorb_e$ ) ^ -1'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Local Variables:
% mode:               text
% mode:               outline-minor
% outline-regexp:     "\\\\Chapter\\|\\\\Section"
% paragraph-start:    "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% paragraph-separate: "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% fill-column:        73
% End:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
