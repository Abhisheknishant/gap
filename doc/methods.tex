\Chapter{Intro}

This chapter describes the new concepts in {\GAP}4.
These new ideas were
motivated by the developent of computational group theory during the last
years:
On the one hand, algorithms become more and more complex. Functions like
'SylowSubgroup' that were originally called just by the user now become
a small part of an intricate algorithm. Therefore {\GAP} may not assume any
longer that the user himself will take an intelligent choice from the
available methods to solve his task. Thus {\GAP} itself has to take decisions
-- at least not too ignorant ones.

On the other hand, algorithms have to solve partial problems in other
algebraic structures more and more frequently. For example an algorithm for
permutation groups may have to deal with modules and the particular problem
is probably best solved in terms of lattices. Thus {\GAP} has to be extendable
to allow the introduction of such new structures.
(andere benutzer wollen auch strukturen?)

So the new concepts try to fulfill two aims:

{\GAP} should be less ''stupid''. It should not ignore knowledge it has about
objects but use this knowledge for further computations. For example if a
group is known to be nilpotent the $p$-Sylow subgroup can be obtained simply
from the $p$-parts of the groups generators.

On the other side it should be possible to add new algebraic structures to
{\GAP}. This requires the ability to add new categories (e.g. modules), new
representations for existing categories and domains (e.g. monomial matrices)
and new methods to {\GAP}.

We pursued these aims already two years ago. (They are mentioned already in
the old application.) But it took us more time than expected to find the
necessary concepts that made it possible to reach these goals.

The problem had been to make the concepts powerful enough to represent the
complex and intricate relations that may exist between mathematical objects
while keeping them simple enough to implement and apply them. In the words
of Albert Einstein: ''Make everything as simple as possible, but not more
simple''.

The wish to keep {\GAP} 4 compatible to {\GAP} 3 as far as possible did not make
this task easier either.

We finally introduced two essentially new concepts:

First, a significantly extended concept of types. It distinguishes what can
be done with an object, how the object is represented and what its relations
to other objects are. Additionally, the type contains information about the
knowledge one has about the object.

Secondly, a vastly extended scheme for the selection of methods.
It permits to select a
method for an operation based on the differnt parts of the types of all the
arguments (or operands).

We have implemented these concepts in {\GAP} 4. In this implementation, each
operation recalls
the argument types that occur most frequently and the method used for
them. (STIMMT DAS NOCH?)  If the operation is called again with arguments of
the same types, the needed method can be found quickly in the ''cache''.
In effect, the method selection in {\GAP} 4 is faster than in {\GAP} 3.

In the sequel we shall first state the aims more explicit (see "Aims").
Afterwards we describe the type concept (see "The Type Concept"). Then
the method selection ("Methods"). Finally we compare the
concepts to related concepts in other programming languages ("andere").

To ease the understanding of the remaining text the most important terms
will be introduced here already:

The objects that {\GAP} deals with (like the number 13, the list $[1,2]$ or a
matrix) are called {\bf objects}. Two objects that are the same (in the
sense of {\GAP} s = operation) represent the same {\bf element}. In other
words, elements are equivalence classes with respect to '='. Those objects
that represent structured sets are called {\bf domains} (for example the
group $S_{12}$ or a conjugacy class therein).

An *operation* behaves like a function, that is it gets called with
arguments and returns a result (like 'Intersection(<arg1>,<arg2>)'
or '<op1>\*<op2>'). In
fact, however it consists of a multitude of functions which are called its
*methods*. Depending on the arguments a method is selected and gets
called.

An unary operation is also called *attribute* (like 'Size(<arg>)'). Objects
may store values of their attributes once thay are computed to use them
later again. A boolean attribute is called a *property*. (like
'IsNilpotent').

The {\bf type} of an object represents the aspects which are important for
the method selection. It consists of several parts which could be imagined
as subsets of the set of all objects. The {\bf family} of an object
determines in which relation an object is to other objects (for example all
sets whose elements are permutations are a family). The {\bf categories} of
an object describe what can be done with an object (for example all monoids
are a category). The {\bf representation} of an object determines how the
object is stored in memory (for example all ''dense'' univariate polynomials
are of the same representation). Finally the type contains which attributes
or properties are known for the object and which values the properties have.

\Section{Aims}

Before describing the implementation of these new concepts in {\GAP} let us
look more closely on the aims:

\){{\rm Knowledge}}

The first aim is to have the possibility of using knowledge for further
computations. Another way of phrasing would be to make {\GAP} less ignorant.

For example there is a method (due to Baum and Clausen) for computing the
character table of a supersoluble group. This method applies to any
supersoluble group and is substantially faster than the standard method (due
to Dixon and Schneider) which is applicable to any group. If {\GAP} knows that
a group is supersoluble it should use this special method and not ignore the
knowledge it has already.

It should be emphasized that this may be {\bf obtained} knowledge. The
objective is to utilize all knowledge currently available about the relevant
objects and not only the knowledge that was known when the objects were
created.

Usually this means to consider properties (like 'IsSolvable'). The
knowledge of attributes (like 'Size') itself however is also a property
that can be useful for certain methods.

Finally, of course, the representation of an object may be utilized. (But 
as it is known when generating the object, this has been possible already in
{\GAP} 3).

Additionally {\GAP} should be able to draw simple conclusions. For example that
every cyclic group is abelian.

Or, to give a more complex example: Suppose we have created a permutation
group and have confirmed that it is nilpotent. Then the group is solvable as
well and so for computing the conjugacy classes a special method for
solvable groups is used.

It has not been our aim, however, to make {\GAP} ''intelligent''. That is, when
being asked for the character table of a group, {\GAP} will not try to check
first, whether it is supersoluble. The reason for this is that we have no
idea how to make the system decide which tests are worthwile and which are
not. It is possible, however, to enforce these tests for special methods
for which the potential gain in speed is that big and the test that cheap
in comparison. There are facilities, however, for a method author to enforce
this behaviour for specific methods if the test is deemed to be always
worthwile.

\){{\rm Extendability}}

The other main aim has been to permit extensions to {\GAP} without the need to
change existing code. Additionally, these extensions should embed nicely in
the existing structure. We list a few aspects:
\beginitems
New Categories&Adding Lie Algebras as a subcategory of non-associative
algebras should permit all operations for non-associative algebras to be
applicable to Lie Algebras as well. Of course we will need to add
representations for the new category as well to be able to define objects at
all.

New Representations&When adding new representations it should be
sufficient to write elementary routines to create objects in the new
representation and to allow basic manipulations. For example, for adding
sparse matrices only the new representation and methods to acess the
matrix components need to be implemented.

&Additionally one can add special operations for sparse matrices (like
''Unsparsify'') or add new methods (like a sparse Gaussian elimination).
These can be added afterwards and don't need to be considered when
creating the new representation.

&It is also possible to specialize an existing representation (for example
monomial matrices as a special case of sparse matrices). Then every method
for sparse matrices is applicable to monomial matrices as well.

New Methods& Besides the methods needed to deal with new
operations, it is possible of course to add methods for existing operations.
For example one could add a new method to compute the character table of a
$p$-group. This method then would be selectable for a group as soon as the
group is known to be a $p$-group.
\enditems

\){{\rm Practicability}}

A main goal in the design finally was practicability. This means:

\beginitems
Usability&
Acessing special methods or new objects should be possible in a similar way
like in {\GAP} 3.

Independence& 
It must be possible to add new code with neither having to change existing
code, nor having to know about existing code. Also it should not be
necessary to basically copy code several times to add new functionality.

Reliability&
Any additions to the system should require no changes in existing code. They
also should affect only those parts of the system they directly interact
with (for example, installing a test for the nilpotence of a matrix group
should not change the behaviour of the Lie algebra routines unless they
require this test implicitely).

Efficency&
The system performance should not be diminuished by the availability of the
new features. This implies that the method selection has to be done quickly.
We are using method caching for the operations here.

There also is the possibility to replace library methods by handwritten C
code. Finally, a compiler that converts {\GAP} code into linkable C-Code is
available.

Implementability&
We had to be able to implement these features in a system. Our
research is in algorithms for group theory and not in the design or
implementation of programming languages.

\enditems

\Chapter{Problems in older versions}

{\GAP} 3 already had some of the features we desired, but there were a
couple of problems with them that led us to designing a new scheme.

\Section{Operation records}
The mechanism used in {\GAP} 3 to permit to select methods depending on
types has been operation records. Every object (which
is represented by a record) contains a component 'operation'. This
component is again a record, whose components are the actual functions which
are to be applied to the object. A dispatcher routine like 'Size' then
just called 'A.operations.Size(A)' to run the applicable method and
returned the result.

Inheritance simply works by copying of operation records. For example
'GroupOps' inherits from 'DomainOps', it overwrites some methods
(like 'Elements' which replaces an error call with a simple orbit
algorithm) and adds some new (like 'Centralizer') which are restricted
to groups.\par
Additionally to calling the routine from the operations record, dispatchers
might perform two additional tasks: The first is checking of the arguments
for applicability (like whether elements really lie in a group). The second
is storing results which are properties of the object in the object and
checking before calling the real routine whether the result is already
stored in the object.

Over the years we have learned about many difficulties with the scheme
described above. The first is the inability to cope well with multiple
arguments for which dispatching should be possible. Typical examples are
arithmetic operations. For these, the dispatcher (in the kernel) usually
dispatched after the first argument. While this works for homogeneous
situations, it becomes difficult if objects of different types are to
operated with: The routine of the left object has to know how to cope with
the right argument, that is it has to know about all possible types of the
right argument.

This becomes increasingly complicated if users implement new objects: If
they want to allow arithmetic operations with existing objects (this came
up for example when
adding algebraic extensions whose elements also should be multipliable with
polynomials), the arithmetic routines for these objects (which are probably
written by someone else, probably in the standard library and in the worst
case in the kernel) have to be changed.

The second disadvantage are problems in using different properties of an
object: The different operations form a pure tree. In some cases (like
homomorphisms from one type of group to another), however, one would like to
join different branches again at a lower point.

This can sometimes be solved by introducing new operation records.
Unfortunately, inheritance is purely linear and no provisions for
merging operation records (and probably even selecting the right routines in
each case) are provided.

A side effect of this (as well as of the first difficulty) are large numbers
of case distinctions in certain routines (like the polynomial multiplication
routines). These case distinctions are difficult to service and have been a
continuous source of nasty problems.

The third problem is mainly of administratorial nature but became almost
insolvable in some situations: The inheritance by copying not only means
that the parent classes operations have to be known to {\GAP} (so reading in
library files has to happen in the right order) but also that additions that
happen after the inheritance do not find their way to the child. This has led
to problems for example with 'SymmetricGroupOps'.

\Section{Sets that may be none}

{\GAP} represents sets by sorted lists. But if the objects in the list can
be changed, the list may suddenly be no set any longer

\beginexample
gap> l:=Set([[1,3],[3,2]]);
[ [ 1, 3 ], [ 3, 2 ] ]
gap> l[2][1]:=1;
1
gap> l=Set(l);  
false
\endexample

Of course, changing an entries entry may happen somewhere else, without the
list ever noting ist. The consequence of this behaviour is, that a list,
that contains composed objects may never store the fact that it is a set.
Each time, it is asked for this property, it has to be tested anew, whether
it is sorted.

If we actually want to keep composed objects in a set, however, to check
for example whether an object is already known, we don't gain anything from
using a ''set'' data type. Even worse: Instead of gaining from a binary
search, whenever we add an element to the set, we additionally test whether
it remained sorted.

In {\GAP} 3 this lead to substantial problems with the orbit algorithm on
vectors. The orbit algorithm keeps a set of all points it has encountered so
far. Vectors however are represented by lists, so they are composed objects.
Consequentially, the ''set'' used for testing is none. (Of course a
user could actually have provided a function for the action that
-- as a side effect -- would change existing vectors entries. So there is no
way around this problem.)

The remedy in {\GAP} 4 for problems of this type is the possibility to
''lock'' objects. By making an composed object *immutable*, one disallows
changes in its components (see "Mutability"). Lists of immutable objects
then may store a flag that they are sorted -- and thus a set -- as no
side-effects may take place.

\Chapter{The Method selection mechanism}

\Section{Objects and Elements}

Before describing the concepts of types we shortly have to explain which
things can have a type.

These ''things'' are called *objects* in {\GAP}. In short, everything that
can be assigned to a variable is an object. Examples are numbers, lists,
matrices, permutations, groups cosets or conjugacy classes. That is,
basically everything in {\GAP} is an object except things like comments (being
just lexical expressions) or {\tt while} loops (which are syntactic units).

Every object can be assigned to a variable and be used as an argument for a
function.

\){\fmark Elements}

While objects are the ''things'' {\GAP} works with, a user typically wants to
deal with mathematical ''things'' we call elements. In short, elements are
equivalence classes of objects under the relation '='.

There are three main reasons for different objects being equal:
\beginitems
-&It can be the same information, just stored in different places
in the memory.

-&It can be the same type of information, but stored in a different way.
For example a polynomial may be stored as ''sparse'' or ''dense''.

-&A special equivalence relation may be in effect. For example in a
finitely presented group with the relation $a^2=1$, the words $a$ and
$a^3$ represent the same element.

\enditems

The user usually will deal with objects but think of elements, as he is not
interested in the place in memory where the information is stored or in the
internal representation.

\danger
There is rarely the case that one actually wants to compare objects
instead of elements. The command 'IsIdentical' will do this.

\){\fmark Domains}

A special case of objects are *Domains*. These are the objects that
represent structured sets.
Examples are a group, a coset or a conjugacy class.

\danger
User of other systems should note that domains
are simply objects and not a part of the typing system as for example in
Axiom.

\Section{The Type Concept}

Like other programming languages, {\GAP} uses types to decide what can be done
with certain objects and how this should be done. That is, a type reflects
those aspects of an object that have to be considered when deciding which
methods to use. (For example the place in memory is not part of the type.)

The {\GAP} lingo of a type is a {\tt kind} (in the sense of ''class of'' rather
than ''gently'').

For example types decide whether two objects can be multiplied, and which
function will do this. Or the type decides whether once can determine the
size of an object (and how this is done).

It is important to remember, however, that while *objects* have types,
variables still are untyped, they are just a ''handle'' for the object.

The type of an object is comprised of different parts. One may cosider these
parts just as sets of objects, the type -- considered as a set -- is just
the intersection of all comprising sets:

\beginitems
The *family*&determines the relations of an object to other objects.

The *category*&determines what can be done with an object.

The *representation*&determines how an object is stored in memory.

*Attributes*&describe knowledge about objects. If they can be only 'true'
or 'false' they are called *Properties*.
\enditems

The kinds of the arguments determine which *method* is used for an
*operation*.

We shall now describe these aspects in greater detail.

As these aspects are interlinked it is unavoidable to use forward references.
It is recommended that you read these sections twice, the first time
skipping the dangerous sections.

\Section{Filter}

*Filter* are used by {\GAP} to indicate features an object may have or not.

To the user, a filter is just a function that returns 'true' or 'false'.
They are used for example to determine whether an object is in a given
category or representation.

The only difference to ''real'' functions is that filter can be combined
using 'and', creating a new filter that is 'true' if and only if all
constituent filters return 'true'. 

\danger
Internally, {\GAP} carries internal bit lists (different to 'Blist's) to
indicate categories, representations and so on. A filter is an interface to
these bit lists.

\Section{Families}

The family of an object determines its relations to other objects. More
formally: The families form a partitioning of the set of all objects, subject
to the following conditions:

Two objects that represent the same element are in the same family. This
permits to regard families also as sets of elements (instead of sets of
objects), in contrast to categories and representations that may be
different for two objects that represent the same element.

Second, the family of the result of an operation (like '\*' or 'Intersection'
is only dependent on the familes of the operations arguments.

Examples of families are the complex numbers (currently represented in
{\GAP}
only by its subset of cyclotomic numbers) or the family of permutations.

Ot is important to distinguish a family of objects from the family of sets
of objects. For example the family of permutations is different from the
family of sets whose elements are permutations. The permutation $(1,2)$ is
in the first family, the group $S_3$ or a coset in the second.

\danger
GAP also contains parametrized families, that is families which are
depending on parameters. For example every finitely presented structure
defines a new family (which as a set is equal with the domain itself).
This implies that every presentation defines a new family and that elements
of these different families are in no relation whatsoever. Especially,
they cannot be combined.

\danger
The parameters of course can be families themselves. For example the family
of all rational functions whose coefficients are complex numbers. 

As mentioned above an object belongs to exactly one family. This family must
be stated when the object is created. An object may never change its family.

The comparison operators '=' and $\<$ just apply to objects within the same
family.

\danger
But you main install special methods for these operations that cross
families.

\danger
Families are created by demand. Some families are created during
initialization (for example the family of permutations). Some other families
may be created just later at runtime (for example the family for a finitely
presented group can only be created once the presentation is given).
Families form the dynamic part of the type system, that is those components
that not necessarily are known during initialization.

Finally it should be mentioned that domains are always subsets of families.
It is not permitted to create domains whose elements lie in different
families.

New families are created by 

\>NewFamily(<name>[,<required-fil>[,<implied-fil>]])

returns an object that represents the new family.

\beginitems
<name>&is a string, giving a name that identifies the family. It is mainly
used in error messages.

<required-fil>&is a filter that gives required categories for each object in
this family. Any attempt to create an object in this family that does not
lie in these categories leads to an error.

<implied-fil>&is a filter that gives implied categories.
Each object in the
family is automatically made an object of these categories, regardless of
whether they were given when generating the object. An example is the
category 'IsPermutationSet' which is given to all sets of permutations
automatically.
If no categories are given, no are implied.
\enditems

\>CollectionsFamily(<family>)

creates a new family whose elements are collections of elements of <family>.
For example the family of $S_3$ is the collections family of the family of
permutations.

\>ElementsFamily(<family>)

returns the family of elements for a collections family. It is the reverse
operation for 'CollectionsFamily'.

\danger
\label{storeinfamily}
Families themselves are component objects. They are usually the place where
to store
information needed for operations on its elements. For example the
presentation of a finitely presented group will be stored in its elements
family to permit access for the equality test.

\danger
As families are objects themselves, they also have a kind and a family.
These are the 'FamilyOfFamilies' and the 'KindOfFamilies'.

\Section{Categories}

A category determines what can be done with its elements. More exact: Each
operation is declared with a tuple of categories that defines to which
categories the arguments of this operation must belong. (Additionally, some
operations may demand that the families of its arguments are in certain
relations, for example equal.)

An object may belong to more than one category. A ring, for example, belongs
to the categories 'IsDomain', 'IsAdditiveMagma' (domains that are closed under
addition) and 'IsMagma' (domains closed under multiplication).

\danger
Whenever an object is created, the categories to which the object belongs
have to be declared. However the family might imply further categories (and
these do not need to be declared explicitely when creating the object).
For example any
group of permutations belongs implicitely to the category 'PermutationSets'.

An object cannot change or enter new categories after it has been created.
That is, all categories to which an object belongs are known ab initio and
will never change.

\danger
Categories are created while the library code is read in. During runtime, no
further categories will be created.

To give you some flavour of what categories are, we list some important
categories. Indented categories are subcategories of the less indented
category above.
Additionally, we list some properties (marked with P) that may be held
by elements form this category but need not.


\begintt
IsObject

  IsMutable

    IsMutableList

  IsElement

    IsAdditiveElement                    ($a + b$)
    IsAdditiveElementWithZero            ($0 \* a$)
    IsAdditiveElementWithInverse         ($-1 \* a$)
    IsMultiplicativeElement              ($a \* b$)
    IsMultiplicativeElementWithOne       ($a^0$)
    IsMultiplicativeElementWithInverse   ($a^{-1}$)

  IsDomain (strukturierte Menge)

    IsAdditiveMagma (closed under $a + b$ for all $a, b \in$ Domain)
      IsAdditiveMagmaWithZero (also closed under $0\*a$)
        IsAdditiveMagmaWithInverses (also closed under $-1\*a$)

    IsMagma (closed under $a \* b$ for all $a, b \in$ Domain)
      IsMagmaWithOne (also closed under $a^0$)
        IsMagmaWithInverses (also closed under $a^{-1}$)
        IsMagmaWithInversesAndZero (closed under $a^{-1}$ for $a\not=0$)

    P IsAssociative     ($(a\*b)\*c = a\*(b\*c)\quad\forall a,b,c$)
    P IsCommutative     ($a\*b = b\*a\quad\forall a,b$)
    P IsAntiCommutative ($a\*b + b\*a = 0\quad\forall a,b$)
    P IsLDistributive   ($a\*(b + c) = a\*b + a\*c\quad\forall a,b,c$)
    P IsRDistributive   ($(a + b)\*c = a\*c + b\*c\quad\forall a,b,c$)
    P IsDistributive    (= IsLDistributive \& IsRDistributive)

    IsExtLSet (closed under $x \* a$ for $a, b \in$ Domain, $x \in$ External)

    P IsAssociativeLOpEProd   ($(x\*y)\*a = x\*(y\*a)\quad\forall x,y,a$)
    P IsAssociativeLOpDProd   ($x\*(a\*b) = (x\*a)\*b\quad\forall x,a,b$)
    P IsDistributiveLOpESum   ($(x + y)\*a = (x\*a) + (y\*a)\quad\forall x,y,a$)
    P IsDistributiveLOpDSum   ($x\*(a + b) = (x\*a) + (x\*b)\quad\forall x,a,b$)
    P IsDistributiveLOpEProd  ($(x\*y)\*a = (x\*a)\*(y\*a)\quad\forall x,y,a$)
    P IsDistributiveLOpDProd  ($x\*(a\*b) = (x\*a)\*(x\*b)\quad\forall x,a,b$)
    P IsTrivialLOpEZero       ($0\*a       = 0\quad\forall a$)
    P IsTrivialLOpEOne        ($1\*a       = a\quad\forall a$)

    IsExtRSet (closed under $a \* x$ for $a, b \in$ Domain, $x \in$ External)

      <as ExtLSet>

    IsExtUSet (closed under $a^x$ for $a, b \in$ Domain, $x \in$ External)

      <as ExtLSet>
\endtt

With these categories and properties, we can declare vector spaces as
follows:

IsFieldNonExtLSet = \\
\ \ AdditiveMagmaWithInverses \& \\
\ \ nMagmaWithInversesAndZero \& IsAssociative \& IsCommutative

VectorSpace = \\
\ \ AdditiveMagmaWithInverses \& \\
\ \ ExtLSet \& IsExtLDistributive \& IsExtLUnital \& IsExtLAssocicative \& \\
\ \ IsExtLField

New categories are created by the function

\> NewCategory(<name>[,<super-cat>]) !{category creation}

This function returns an filter that represents the category. As it is a filter
it can also be used as an function, to test whether an object belongs to this
category and returns 'true' or 'false'. Therefore categories ususally are
called like 'IsPiffle'.

\beginitems
<name>&is a string, giving a name to the category. It is mainly used for
debugging purposes.

<super-cat>&is a filter representing the intersection of all categories this
category is to be a subcategory of. All categories are implicitely
subcategories of 'IsObject'.
\enditems


\Section{Representations}

A representation determines how objects are stored in memory.

There are three classes of objects: Internal objects (like rational numbers,
permutations or words in abstract generators), *positional objects* and
*component objects*. Positional objects behave basically like a list with
the exception that components are accessed by '<lobj>\/![<pos>]'
(with an additional '!'). Component objects behave
like records, except that components get accessed by '<robj>\/!.<component>'.

\danger
The function 'Length' will not work for positional objects. The function
'RecNames' will not work for component objects. There is, however, a
function 'REC_NAMES_ROBJ' that will provide the components of an component
objects for debugging purposes.

The representation of an object determines whether it is an component
object or an positional object. It also determines the component names
present in an component object.
(This is not yet supported).

An object may belong to several representations.

\danger
An object may change its representation during runtime. In general this is
only useful for mutable objects and should be used with great care.

\danger
Representations are created while the library code is read in. During runtime,
no further categories will be created.

New representations are created by 

\>NewRepresentation(<name>,<super-fil>,<components>[,<required-cat>])

This function returns a filter that represents the representation and can be
used to test membership in this representation.
Therefore representations ususally are called like 'IsWoffle'.

\beginitems
<name>&is a string, giving a name to the representation. It is mainly used for
debugging purposes.

<super-fil>&is a filter, used to determine all super-representations and all 
categories implied by this representation. The super-representations
'IsPositionalObjectRep' or 'IsComponentObjectRep' determine, whether it will
be a representation of positional or components objects, so one of them
should be given always (might be implicitely).

<components>&is a list of strings, giving the names of the components an
component objects may have. This field is ignored for positional objects.
If a field ends in '?' this component is facultative for component objects.
If a component name ends in '\*', all components starting this way are
permitted.

<required-cat>&VERLANGTE KATEGORIEN
\enditems

\danger
An interesting representation is the representation 'WhatsItsName' used for
representing most domains. It is a subrepresentation of
'IsComponentObjectRep', having no compulsory components but permitting any.

\danger
If several representations are used to represent objects in one family, it
is often desirable to have some unified way to treat elements of all
representations. The standard way to do this in {\GAP} is via *external
representations*. These external representations are usually defined for a
family and are a list or a record that allows to present all information in
the representation. The operation 
\>ExtRepOfObj(<obj>)

then should be used to obtain the external representation of
an object. Vice versa 
\>ObjByExtRep(<family>,<ext-rep>)

will create an object in the given <family> from the external representation
<ext-rep>. If you introduce new representations you might have to write
methods for these two operations.

\danger
Categories and Representations are both filters and thus cannot be easily
distinguished. They are conceptually different but implemented by the same
means.

At this point we could explain how objects are actually made. It seems
better didactically, however, to explain first how the method selection
works (you will need this more often anyhow.) If you are curious, have a
glance at section "Kinds and Objects".

\Section{Operations}

Operations are {\GAP}s way to decide which algorithm will be called for a
given object to acchieve a certain task. 

For the user, an operation behaves like a function. One can apply it to
arguments and -- depending on the operation -- obtains back a result.

Actually, an operation is a collection of functions. These functions are
called the *methods* of the operation. Depending on the arguments given,
{\GAP} decides which method will be selected to execute the task.
We will explain how methods can be installed and how the method selection
works later ("Methods").

\danger
In {\GAP} 3 something slightly similar was accomplished using dispatcher
functions and operation records. But these functions only allowed to
dispatch on one argument and only on information given when the object was
created.

A new operation is created using
\>NewOperation(<name>,<argfilters>)

This command creates a new operation, whose name (used for debugging
purposes) is the string <name>.

<argfilters> is a list of filters that correspond with the operations
arguments: The operation is defined with as many arguments as <argfilters> has
entries and the arguments with which the operation is called have to fulfill
the conditions prescribed by the appropriate filter, otherwise an error is
raised. Similarly, every method installed for the operation must be at least
as restrictive as the conditions given by <argfilters>, otherwise an error
is raised.

If an operation is called with arguments for which no suitable method
is installed, an error is raised.

\danger
It is not possible to declare an operation several times for a varying
number of arguments or different argument filters. You must use
'InstallOtherMethod' in such cases.

There are some special operations provided by the kernel. These are
$\backslash$'+', $\backslash$'-', $\backslash$'\*', $\backslash$'/',
$\backslash$'^', $\backslash$'mod,
$\backslash$'in', $\backslash$'=', $\backslash\<$ for the usual infix
operations, 'ShallowCopy' for copying and 'PrintObj' for printing one object.
You may install your own methods for these operations to acchieve special
effects.

There are also the operations $\backslash[\backslash]$ and $\backslash\.$ that
may be used to simulate lists or records (see "Simulating Lists and Records")

Usually all operation declarations will be read first and all methods
installed afterwards. This permits an method to call other operations, as
all operations are known when the method is installed. To acchieve something
similar for ordinary functions, there is the command

\>NewOperationArgs(<name>)

This command just creates a pseudo-function that serves as a forward
reference for a function that will be declared elsewhere.

\Section{Attributes and Properties}

Attributes are unary operations that allow to describe knowledge of one
object.

The main difference towards plain operations is that an object may store
attributes computed once and may tell whether it knows an attribute.

\danger
An object may also claim that it knows an attribute if computation of this
attribute would be very easy. A vector space, for example, may claim that
it knows its size once it knows its dimension and the characteristic of the
underlying field. 

Thus attributes can be considerd as sets, comprising all objects that know
this attribute. In general an object will initially not belong to any of
these sets but become a member during runtime.

\danger
Attributes are created while the library code is read in. During runtime, no
further attributes will be created.

New attributes are created by

\>NewAttribute(<name>[,<filter>])

This function returns an operation that will be used to determine the value
of this attribute. It implicitely installs one method for this operation,
namely the operation that just fetches the already known value.

\danger
This is done by implicitely installing a method, called the *system getter*
for the operation with value 'SUM_FLAGS'. This number is some kind on
''infinity'' for method valuations. Thus, once the attribute is known, this
method will be called. If you design situations, however, in
which objects will claim to posess an attribute while actually still having
to compute it (like in the vector space example above), this would lead to
*your* method (which does the computation) not being called and the system
getter complaining about not finding the attributes value. The solution is 
to install your method with the value 'SUM_FLAGS+1' to give it priority
over the system getter.

<name> is again a string, used to identify the attribute.

<filter> determines, for which categories this attribute applies.
\){\fmark Tester(<attribute>)}
\){\fmark Setter(<attribute>)}

Additionally, 'NewAttribute' installs a filter (the *tester*) and another
operation (the *setter*) for this attribute. The
filter determines whether the attribute is known while the operation can be
used to set the attribute to a given value (if its value is obtained
implicitely in an algorithm). A standard use is like
\beginexample
Biffle:=NewAttribute("Biffle");
HasBiffle:=Tester(Biffle);
SetBiffle:=Setter(Biffle);
\endexample

Then 'HasBiffle' will test, whether the biffle of an object is known,
SetBiffle(<obj>,<value>) will set an objects biffle.

\danger
The setter in fact is again an operation which has a standard method
installed at value 'SUM_FLAGS' which just stores the attribute. You can
install another method that may, for example, immediately store
dependent information. WIE BEKOMMT MAN DAS ATTRIBUT DANN GESPEICHERT?

As each attribute defines an operation, methods can be installed to compute 
the value of this attribute for certain types of objects. Any value returned
by the function will be assigned automatically to the attribute, you don't
need to call the setter.

\danger
Storing all computed attributes for an object may take substantial space. On
the other hand there might be objects that are that unimportant that you
do not want to store attributes for them. Therefore attributes will be
stored only, if the representation of the object is a subrepresentation of
'IsAttributeStoringRep'. KANN DAS POSITIONAL SEIN ?

\danger
Attributes are by standard immutable. In some situations an attribute will
be used, however, to store partial information about an object that may be
completed later. A special case of this are parametrized attributes, where
we don't want to create a new attribute for each value of the parameter.
Sylow subgroups are a good example: We cannot create an atttribute for each
prime number. Instead there is an attribute 'ComputedSylowSubgroups' that is
a list, containing in its $i$-th component the $i$-Sylow subgroup (provided
$i$ is a prime). The function 'SylowSubgroup' then will access this list and
compute further sylow subgroups if neccessary using the operation
'SylowSubgroupOp'. storing the result again in the list
'ComputedSylowSubgroups'.

\danger
To obtain a mutable attribute for such purposes, simply add the string 
'' 'mutable' '' to the parameter list when defining the attribute with
'NewAttribute'

\danger
Another aspect of the immutability of attributes is that you usually cannot
change an attribute. Calling the setter later with a different value just
will be ignored.

\>NewProperty(<name>[,<filter>])

Properties are attributes whose value may only be 'true' or 'false'.
What makes properties special is that the operation defined by the property
is implicitely a filter. This allows to install methods based on the *value*
of a property.

Thus it is possible to install a method for solvable groups that will be
called whenever a group is known to be solvable, even if this information
was not known when the group was created.

\Section{Methods}

A method is an ordinary function that is used to implement an operation for
particular types of arguments. The connection with the operation is obtained
by *installing* the function for the operation and a particular set of
types. This installation works by 

\>InstallMethod(<opr>[,<ident>],<fampred>,<argflags>,<value>,<method>)

This installs the function <method> for the operation <opr>. If given,
<ident> is a string to identify the specific method (like ''cyclic extension
algorithm for subgroup lattice'') installed. It can be used for debugging.

<fampred> is a function that will be applied to the families of the
arguments given to test whether they fit together. (For example two
polynomials should be defined in the same characteristic.)
With these families as arguments, <fampred> must return
true for this method to be applicable. A typical usage is for example
'IsIdentical' to ensure that the families of two factors to be multiplied
are the same. If no family relation is to be tested, simply 'true' may be
given here. Section "Family Predicates" below lists some common predefined
family predicates.

<argflags> is a list of filters, corresponding to the arguments.
Each filter
must be true for the corresponding argument for this method to be
applicable. The number of filters must correspond to the number of arguments
in the declaration of the operation <opr> and each filter must be a refinement
of the corresponding filter given in the declaration of <opr>, otherwise an
error is raised.

Remember that the filters may determine categories, representations,
knowledge of attributes and values of properties.

\danger
It must be pointed out, however, that for the purposes of method selection
the filters that return the value of a property are only fulfilled if the
value of the property is known. In other words, the method selection will
not compute the value of an property just to see whether a method is
applicable. (Such a behaviour would otherwise lead to potentially disastrous
runtime effects.) Doing such things sensibly would require a level of
intelligence which is beyond the scope of a computer program. 

\danger
If you have cases where a certain property is that beneficial that
it is actually worth to force determination of this property, you will have
to install the method without requiring this property, first test in your
function for the value of the property and if this is 'false' call
'TryNextMethod()' to retreat gently.

\danger
A variation of this theme is if you have classes of objects for which
a certain attribute can be computed very cheaply. In this case you would not
require 'HasPiffle' when installing the method, but add a new property
'IsPiffleObtainable'. All objects in the special class should get this
property implicitly when creating them (either directly in the 'Objectify'
command or by a true or immediate method), while an implication would imply
that each object for which 'HasPiffle' returns 'true' actually would be
'IsPiffleObtainable' as well.

<value> is an integer value given to this function. This value determines
''how well'' the method performs. Unless you want to acchieve a special
effect this will be 0.

How do all these arguments interlink with each other:

If an operation gets called, {\GAP} first selects all methods that are
*applicable*. That are those methods, for which the family predicate
returns 'true' when applied to the families of the arguments and for which
all filters for all arguments return 'true'. These methods then are sorted
according to an ''implicit value'': For each filter involved in one of the
<argflags> one point is given. That is, if we define 'IsC' as 'IsA and
IsB', then 'IsC and IsD' gets 3 points (or even more if 'IsA', 'IsB' or
'IsD' are composite themselves).
To this number the installed <value> is
added.
(Actually this sorting can take place already when installing the method, so
there is no time loss for this during execution.)
Then the method with the highest value is executed and any result it returns
returned as the result of the operation.

This ''value business' allows for three aims: First, usually (nobody should
install such a method otherwise) a special method will be better than a
general one. This special method then however would have more filters in its 
<argflags>, thus get a higher implicit value and is favoured if applicable.

Second, there may be the case of concurrent methods whose specifications are
not subsets of each other. Suppose, for example we have two (simple) filters,
'IsBourbakian' and 'IsLowerRegularQ' which have no relation whatsoever.
Suppose for an operation we have one method each installed for both filters.
If we now call this operation with an argument that is bourbakian and
fulfills the lower regular Q property, the method whose <value> is larger
gets selected. This allows to tell {\GAP} which filters will  lead to
especially cheap methods for certain operations.

Thirdly, giving a high value to a method permits to override decisions taken
before. If for example for test purposes a more general method should be
used, it is sufficient to install this method with a higher value than the
special one.

\danger
To speed up the process of method selection, each method caches the last 3
tuples of kinds with which it got called and the method selected for these.
This allows the selection process to proceed very swiftly in cases (like
multiplications) where the same method is called very frequently.

\danger
The list of (applicable) methods for an operation is always sorted in a way
to have newer methods coming first. Thus a method installed with the same
parameters as an existing method will supersede this. This allows to
re-install a corrected method (beware of problems here if the corrected
method calls 'TryNextMethod'!).

\>TryNextMethod()

There are situations where a method may be a bit pert in that it claims to be
applicable but actually is not. A typical situation for this is if the
method actually has to do tests which cannot be dealt with by putting
suitable filters in the method installation or if the author deems it worth
to test for a property even if it is not yet known.

In these cases a method can call 'TryNextMethod()'. This will return to the
method selection mechanism, which will then proceed and call the next
applicable method to compute the result.

\>InstallOtherMethod(<opr>[,<ident>],<fampred>,<argflags>,<value>,<method>)

There are situations, when methods also should be installed for cases that
do not confirm for the operations declaration. (This also covers different
methods to allow for a variable number of arguments.) This is done by
'InstallOtherMethod'
which does the same as 'InstallMethod', except that it does not demand for the
<argflags> to comply with the operations declaration.

\Section{Implications}

Usually a method is only executed if the corresponding operation is called.
For attributes, however it is also possible to install methods that will be
called immedicately, if their prerequesits are fulfilled.

Such methods can be used to install implications and to ensure that certain
deduced information will always be present. This is important to make
good use of the method selection. For example, we want a method that
requires the size of a group to be applicable if the stabilizer chain for a
permutation group is known (as the groups size can be deduced from it very
easily). However we don't want to install all these methods twice, once for
'HasSize', a second time for permutation groups whose stabilizer chain is
known.

Needless to say, such methods must take only $\varepsilon$ time, as they
might be called automatically over and over. 

{\GAP} provides essentially two ways for such implications. The first is

\>InstallImplication(<property>,<argflags>)

WAS IST MIT INSTALLTRUEMETHOD?
If an implication is installed, the <property> will be set to true for an
object, whenever the filter <argflags> is fulfilled for this object.
For example

\beginexample
gap> InstallImplication(IsSolvable,IsNilpotent);
gap> InstallImplication(IsPcgsComputable,IsSolvable);
gap> InstallImplication(IsPcgsComputable,HasPcgs);
\endexample

For more difficult implications, there is

\>InstallImmediateMethod(<opr>,<argflags>,<value>,<method>)

This installs the function <method> to be called to compute the attribute
<opr> for an object as soon as the filter <argflags> is fulfilled for this
object. <value> permits to determine a sequence, in which the applicable
immediate methods are called for an object.

A immediate method will only be called if the attribute <opr> is not yet
known. Its return value will be assigned to the attribute. It may return via
'TryNextMethod()', in this situation the attribute (obviously) will not be
set. This permits, for example, an immediate method to apply further tests,
whether an attribute can be computed cheaply.

An example would be the following immediate method for the implication that
groups of size $p^aq^b$ are solvable:

\beginexample
InstallImmediateMethod(IsSolvable,IsGroup and HasSize,0,
function(G)
  if Length(Set(Factors(Size(G))))>2 then
    TryNextMethod();
  fi;
  return true;
end);
\endexample

In the light of the fact, that the complexity of factorizing integers is
still unknown, however, it is debatable whether such a method is really of
$\varepsilon$ runtime.

Immediate methods can lead to substantial losses in runtime if a
method gets called too often or if the function installed actually *takes*
time. They should be used with care!

\danger
For calling immediate methods, {\GAP} actually does the following: 
Whenever a filter is set for an object, all installed immediate methods,
that need this filter to be applicable are run if the attribute is not yet
known and if they are applicable.

\danger
If you are creating objects and setting attributes in them you might want to
avoid immediate methods to be run, as you will set the immediately obtainable
attributes yourself. This can be acchieved using the variable

\){\fmark IGNORE_IMMEDIATE_METHODS}

While this variable is set to 'true' (it is set to 'false' by default) no
immediate methods will be called.

\Section{Tracing and profiling methods}

The implicit choices made by {\GAP} when calling a method can make it quite
difficult to find out which method is actually called. This is necessary
however, partially for debugging purposes and partially to learn which
algorithm is actually used. 

\>TraceMethods(<opr>,<opr>,...)
\>UntraceMethods(<opr>,<opr>,...)

induced {\GAP} to print information whenever one of the operations given to
trace is called. This information consists of the name of the operation
(given as the string <name>) and -- if present -- the name of the method
(given as the string <ident>)
Tracing is turned off again by 'UntraceMethods'.

\beginexample
gap> TraceMethods(Size);
gap> g:=Group((1,2,3,4),(1,2));
Group( [ (1,2,3,4), (1,2) ], ... )
gap> Size(g);
#I  Size
#I  Setter(Size): system setter
#I  Size: system getter
#I  Size: system getter
24
gap> UntraceMethods(Size);
\endexample

\>MethodXArgs(<opr>,<arglist>[,<printlevel>[,<skip>]])

calls the method selection mechanism for the operation <opr>, applied to the
arguments given in <arglist> without actually applying the method, but
returning the *method* itself instead.

If <printlevel> is given, information about
the decisions of the method selection mechanism is printed:

\beginitems
1&Prints information about the selected method

2&Prints information about each method encountered on the way there (but not
chosen)

3&Prints for each of these methods the first reason why it has not been
applicable

4&Prints all reasons, why the methods not selected were not applicable.
\enditems

If <skip> is given as a positive integer, that many applicable  methods will
be skipped. This can be used to examine cases that call 'TryNextMethod'.

If <skip> is a negative integer, a list of all applicable methods (sorted by
value) is returned instead.

\>ProfileOperations()
\>ProfileMethods()

UND SO WEITER.


\Section{Kinds and Objects}

Finally, we have to explain, how new objects are really made.

This section explains what a kind actually is and how the method selection
works internally. It also tells you how to make objects.
If you are not creating your own objects, you will not need to know this
for installing own methods, but it might be helpful for understanding the
innards of {\GAP} anyhow.

The type of an object is composed from its family and the filters set for
it. It can be created by

\>NewKind(<family>,<filter>)

Here <family> is the family for the kind and <filter> determines categories
and representations. Each object of this kind will belong to <family> and
all the categories and representations of <filter>.

\danger
To save memory,
{\GAP} internally keeps a list of all known kinds. NewKind actually will
only create a new kind if it is not in this list and otherwise return a
kind from
this list, if it fulfills exactly the requirements. A cache for the most
recent kinds is used to avoid long searches over the list of all kinds.

Whenever new filters are set for an object, its kind changes, if necessary
creating a new kind implicitely.

The method selection mechanism actually only looks at the kinds of the
arguments and fetches the necessary informations from them.

\danger
As kind are objects themselves, they also have a kind and a family.
These are the 'FamilyOfKinds' and the 'KindOfKinds'.

Usually, kinds are created just as intermediate steps to construct *objects*:

\>Objectify(<kind>,<rlobj>)

makes a new object. This object will have family, categories and
representations as prescribed by <kind>.
<rlobj> is either a record or a list (depending whether the representation
is a subclass of 'IsComponentObjectRep' or 'IsPositionalObjectRep') that
will be converted to a positional object or a list object to actually form
the object.

\danger
Despite the caching of kinds, if you expect to create a lot of
new objects (as, for example, when implementing new arithmetical objects,
where each infix opertion will create a new object), it can be helpful to
store the *default kinds* (the kinds with which objects will be
created) in the family to avoid calls to 'NewKind' (see "storeinfamily").

\Section{Mutability}

Changing list entries may affect other lists, something similar holds for
records:

\beginexample
gap> l:=[[1,2]];;
gap> m:=[l[1]];
[ 1, 2 ]
gap> m[1][1]:=2;;
gap> l;
[ 2, 2 ];
\endexample

But information stored in objects may be implicitely used in some other place.
Therefore it is not a good idea to change this information. If an algorithm
returns an object, it is not known, however, whether some other object
stores this object as information somewhere. The only remedy would
be to actually *copy* the stored information before returning it to a user
or another routine. Needless to say, this would be a bad idea both on
runtime and memory usage.

The remedy for this used in {\GAP} is that you can make objects
*immutable*
(Some, like integers or permutations always were):

\>Immutable(<obj>)

returns a copy of <obj> that is immutable. That is, you cannot assign
anything to parts of <obj>. (If you try to, {\GAP} complains with an error.)

This allows objects to return its *master* copy of a related object without
the fear of having this object inadvertedly destroyed.

\danger
A side effect is that immutable objects allow to make ''real'' sets from 
objects that otherwise would be lists. The section "Sets that may be none"
tells more about this problem.

Some objects are made immutable by creation. These are

\beginitems
Kernel Objects&like integers, permutations, words in free generators. 

Objects obtained by 'Objectify'&These are basically any ''mathematical
objects'' you will encounter in {\GAP}, but implicitely storing attributes in
them is still permitted.

Attributes&unless they are explicitely declared to be ''mutable''.

Vectors&and Matrices (when obtained as a result of a binary operation). The
reason for this has been the desire to increase the speed of orbit
operations (which now can use binary search).
\enditems

\>IsMutable(<obj>)

is a filter that tests whether an object is mutable.

If you got an immutable object which you want to modify, you can get an
mutable copy by using 'ShallowCopy' ("ShallowCopy").

\Section{Simulating Lists and Records}

{\GAP} permits objects to behave as if they were lists or records. In these
cases, components can be accessed in the usual way, while actually a
function computes the result returned. Enumerators ("Enumerators") for
example behave that way. This permits to have something like a list of
elements even for infinite objects like the integers.

This simulation for lists works via four special operations:

\){\fmark $\backslash[\backslash]$(<obj>,<pos>)}
\index{$\backslash[\backslash]$}
\){\fmark
$\backslash[\backslash]\backslash:\backslash=$(<obj>,<pos>,<arg>)}
\){\fmark 'IsBound'$\backslash[\backslash]$(<obj>,<pos>)}
\){\fmark 'Unbind'$\backslash[\backslash]$(<obj>,<pos>)}

These operations are defined for the category tuple
('IsList', 'IsInt and IsPosRat') (respectively <IsObject> added for
$\backslash[\backslash]\backslash:\backslash=$).
<obj> is the object simulating a list, <pos> is a positive integer, giving
the list position.

They allow to simulate list access, assignments, test for boundness and
removal of list elements by the installed method. The installed methods will
respecively
return the simulated list value, assign the value, remove it or test for
boundness.

The simulation for records works via the following four special operations:

\){\fmark $\backslash\.$(<obj>,<rnam>)}
\index{$\backslash\.$}
\){\fmark $\backslash\.\backslash:\backslash=$(<obj>,<rnam>,<arg>)}
\){\fmark 'IsBound'$\backslash\.$(<obj>,<rnam>)}
\){\fmark 'Unbind'$\backslash\.$(<obj>,<rnam>)}

These operations are defined for the category tuple
('IsObject', 'IsInt and IsPosRat') (espectively <IsObject> added for
$\backslash\.\backslash:\backslash=$).
<obj> is the object simulating a list, <rnam> is a component
identifier (see below).

The operations allow to simulate record access, assignments, test for
boundness and removal of list elements by the installed method. The 
installed methods will respectively
return the simulated record component, assign the value, remove it or test for
boundness.

\>RNamObj(<string>)
\>NameRNam(<int>)

When a record components is accessed, the components name is parsed and
replaced by a number, the <rnam>, which identifies it. This permits among
other things to
save storage space, as each record components name is stored only once in
memory. Thus, for example, it is unimportant whether a long components name
occurs frequently. 

The functions to simulate record access use this <rnam>. The function
'RNamObj' returns the <rnam> of a <string>, the function 'NamRNam' returns
the string for a <rnam> number.

As the <rnam> identifiers are allocated while reading in the library,
reference should never be to absolute numbers, but using these tranlation
function. For example, the following method could be used to allow access to
a groups generators via the '<G>.generators' as has been possible in {\GAP}
3:

\beginexample
ID_NUMBER_GENERATORS:=RNamObj("generators");
InstallMethod(\.,"access to .generators",true,[IsGroup,IsPosRat and IsInt],0,
function(g,n)
  g:=GeneratorsOfGroup(g);
  if n<>ID_NUMBER_GENERATORS then
    TryNextMethod();
  fi;
  return GeneratorsOfGroup(g)l
end);
\endexample


\Section{Family Predicates}

In this section we list some common family predicates used throughout the
library.

\beginitems
'IsElmsColls(<A>,<B>)'&

'IsNotElmsColls(<A>,<B>)'&

'IsElmsCollColls(<A>,<B>,<C>)'&

'IsCollsElms(<A>,<B>)'&

'IsCollCollsElms(<A>,<B>,<C>)'&

'IsCollsElmsElms(<A>,<B>,<C>)'&

'IsCollsElmsElmsElms(<A>,<B>,<C>,<D>)'&

'IsCollsElmsElmsX(<A>,<B>,<C>,<D>)'&

'IsCollCollsElmsElms(<A>,<B>,<C>,<D>)'&

'IsCollsCollsElms(<A>,<B>,<C>)'&

'IsCollsXElms(<A>,<B>,<C>)'&

'IsFamFamXY(<A>,<B>,<C>,<D>)'&

'IsLieFamFam(<A>,<B>,<C>)'&

'IsFamLieFam(<A>,<B>,<C>)'&

'IsElmsLieColls(<A>,<B>,<C>)'&

'IsElmsCollLieColls(<A>,<B>,<C>,<D>)'&

'IsCollLieCollsElms(<A>,<B>,<C>,<D>)'&

'IsCoeffsElms(<A>,<B>)'&

'IsElmsCoeffs(<A>,<B>)'&

'FamRangeEqFamElm(<A>,<B>)'&

'FamSourceEqFamElm(<A>,<B>)'&

'CollFamRangeEqFamElms(<A>,<B>)'&

'CollFamSourceEqFamElms(<A>,<B>)'&

'FamElmEqFamRange(<A>,<B>)'&

'FamElmEqFamSource(<A>,<B>)'&

'FamSource2EqFamRange1(<A>,<B>)'&

'FamSource1EqFamRange2(<A>,<B>)'&

'FamRange1EqFamRange2(<A>,<B>)'&

'FamMapFamSourceFamRange(<A>,<B>)'&

'FamSourceRgtEqFamsLft(<A>,<B>)'&

'FamSourceNotEqFamElm(<A>,<B>)'&

'FamRangeNotEqFamElm(<A>,<B>)'&

'IsMagmaRingsRings(<A>,<B>)'&

'IsRingsMagmaRings(<A>,<B>)'&

'IsMagmasMagmaRings(<A>,<B>)'&

\enditems

