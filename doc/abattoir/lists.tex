%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Lists and Sets}

Modern mathematics, especially algebra, is based on set theory. When sets
are represented in a computer, they inadvertently turn into lists. That's
why we start our  survey of the various  objects {\GAP} can handle with a
description of  lists  and their  manipulation. {\GAP}  regards sets as a
special kind of lists, namely  as lists without  holes or duplicates, and
whose entries are ordered with respect to the precedence relation~`\<'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Basic list operations}

\>Length( <list> )
\>IsBound( <list>[ <pos> ] )
\>`<list>[ <pos> ]'{list element!access}

What is a *list* in  {\GAP} may mathematically be  regarded as a function
<list> defined on  a subset of the  natural numbers which takes as values
{\GAP} objects. The highest number for which this  function is defined is
called the `Length' of the list. More  generally, `IsBound( <list>[ <pos>
] )' returns `true' if <list> is defined on the number  <pos>, and if so,
`<list>[ <pos> ]'  returns its value on this  number. These are the three
basic operations that must be implemented for any list. They allow access
to the entries of a list, but they do not allow changes to the list.

A list  in {\GAP} is  any object that allows   these basic operations, no
matter how it is internally represented. It is  not necessary to have all
the  list entries present in  memory simultaneously, they can for example
be constructed one at a time, if they are enumerated one by one and after
use  thrown away  again. Such  lists  which  do not  store their  entries
explicitly, but which know  how to construct  the <pos>th entry for every
value of <pos> will be called *enumerators*, see "AsList and Enumerators"
below.

Although a  call of the `IsBound'  operation is written `IsBound( <list>[
<pos> ]  )', this is merely a  syntactic equivalent to the more customary
two-argument function call `IsBound\\[\\](  <list>, <pos> )' (like `<a> +
<b>' is equivalent to `SUM( <a>,  <b> )'). The identifier `IsBound\\[\\]'
must,  e.g.,   be used  when methods  are  installed for  that operation.
Similarly, the operation called by the syntactic construct `<list>[ <pos>
]' is~`\\[\\]'.

\>`<elm> in <list>'{membership test}!{for lists}
\>Position( <list>, <elm> \[, <after> \] )
\>`<list>\{ <poss> \}'{sublist!access}

`<elm> in <list>' returns `true' if <elm> is equal to  one of the entries
of  <list>, and `false'  otherwise. `Position( <list>,  <elm>, <after> )'
returns the first position $pos  > after$  such  that `<list>[ <pos> ]  =
<elm>', and `false' if  there is no  such  position. If a third  argument
<after> is  not given, it is  set to 0, i.e.  the whole list is searched.
Finally, in  the construct `<list>\{  <poss> \}',  <poss> must  be a list
without holes, this makes a  list as long as <poss>  whose <i>th entry is
`<list>[ <poss>[ <i> ] ]'.

These functions are   automatically   manufactured from the  basic   list
operations  above. The  operation   called  by the   syntactic  construct
`<list>\{ <poss> \}' is~`\\\{\\\}'.

\>Unbind( <list>[ <pos> ] )
\>`<list>[ <pos> ] := <elm>'{list element!assignment}
\>`<list>\{ <poss> \} := <sublist>'{sublist!assignment}

These   operations modify a  given  list.  `Unbind'  removes an entry and
decreases  the `Length' of the list  if it was  the  last entry. `<list>[
<pos> ]  := <elm>' sets an  entry  and `<list>\{ <poss> \}  := <sublist>'
sets a whole sublist  (of course <poss> and <sublist>  must have the same
length). This latter operation is automatically manufactured from the one
before  which sets a  single entry.  If  you  perform such an  assignment
operation and type  the left hand side of  the assignment afterwards, you
will get the right hand side as result.

The  corresponding  operations are  called `Unbind\\[\\]', `\\[\\]\\:\\='
and~`\\\{\\\}\\:\\='.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{AsList and Enumerators}\null

\>AsList( <D> )

`AsList( <D> )' constructs a {\GAP} object that represents a mathematical
set as if it were an immutable list of its elements. Note that we say ``a
list'', not   ``the list'' because there  are  many ways  of ordering the
elements and,  indeed,  {\GAP}  does  not  guarantee anything  about  the
ordering it   chooses. If you  say   `$list_1$ := AsList(   $D_1$ );' and
`$list_2$ := AsList( $D_2$    );' then even   if  `$D_1$ =   $D_2$',  the
orderings of $list_1$ and $list_2$ may be different, and consequently you
may have  `$list_1$ \<> $list_2$'. After   all, $D_1$ may  be represented
differently  than $D_2$ and the `AsList'  may be constructed depending on
the representation. (Even if you say `$list_3$ := AsList( $D_1$ );' again
later, you may have `$list_3$ \<> $list_1$'.)

Objects constructed  by  `AsList'  behave like  immutable  lists,  so you
cannot modify them, neither by assigning to elements  or sublists, nor by
`Unbind'ing. But you  can use the three  basic  list operations `Length',
`IsBound' and `[ ]' with them.  The sublist operator `<list>\{ <poss> \}'
is  also  available, it  is  normally  just  manufactured from  the `[ ]'
operator. The  time needed by  these operations should  not depend on the
length of  the list, but the  memory needed should grow proportionally to
the length, as should  the time needed by `Position'.  This is just as it
is with ordinary lists, but it is not always what you want. To make these
operations  space  efficient  rather  than time  efficient,   and to make
`Position' more time  efficient, it is necessary  to  overlay the generic
methods by   more  special algorithms, which   will  generally  require a
different internal representation of the object <list>. To emphasize this
distinction,  such space   efficient    objects are not  constructed   by
`AsList', but instead by the `Enumerator'.

\>Enumerator( <D> )

An *enumerator* is a {\GAP} object that  represents a mathematical set as
if  it  were an  immutable   list of its elements;  just   like an object
constructed by   `AsList'.  The remarks   made at  the beginning  of that
section also  apply  to enumerators,  and the  only  difference is   that
enumerators are space efficient rather than time efficient. Again you can
use  the list operations like `<enum>[  <pos>  ]' and `Position', but you
cannot assign to single positions or to sublists  of enumerators, nor can
you `Unbind' elements.

\>PositionCanonical( <enum>, <elm> )

\indextt{OneDimSubspacesTransversal}%
`PositionCanonical(  <enum>,  <elm> )'  works  basically  like `Position(
<enum>,  <elm> )', but there  can be a   difference in the behaviour when
<enum> is not a  plain list but  a specially-constructed enumerator. Such
enumerators   are often used   to    enumerate sets  whose elements   are
mathematically defined as equivalence  classes  of other elements.  As an
example,  take the function   `OneDimSubspacesTransversal'. It returns an
enumerator whose  elements  form a  *system  of representatives* for  the
one-dimensional subspaces in a  vector space or, in   other words, for  a
projective space. The following example constructs this enumerator in the
case of the three-dimensional space over the field with three elements.
\beginexample
    gap> enum := OneDimSubspacesTransversal( GF(3)^3 );
    P( 3^3 )
\endexample
Each of  the representatives in   `enum' represents two  non-zero vectors
from  `GF(3)^3', and  it is always  a canonical  (i.e. here, left-normed)
representative.  This is what  the  enumerator returns  when you  ask for
`enum[ <pos> ]'.
\beginexample
    gap> enum[3];  enum[4];
    [ 0*Z(3), 0*Z(3), Z(3)^0, Z(3)^0 ]
    [ 0*Z(3), 0*Z(3), Z(3)^0, Z(3) ]
\endexample
On the  other hand, if you  want  to specify  a one-dimensional subspace,
i.e., an equivalence  class of two  vectors, you can  give either of  its
elements;  and if you ask for  the `PositionCanonical'  in the enumerator
`enum',  {\GAP} will  silently replace   the   element by  the  canonical
representative.  This does, however,  no longer work,  if you ask for the
`Position' because in  this case {\GAP}  replaces `pro' by the plain list
of its elements and does  then no longer know  that these elements form a
system of representatives.
\beginexample
    gap> v := [2,1,1,1]*Z(3)^0;;  PositionCanonical( enum, v );
    40
    gap> enum[40];
    [ Z(3)^0, Z(3), Z(3), Z(3) ]
    gap> Position( enum, v );
    fail
\endexample

To   summarize: The  enumerator in   the  above  example   is a  list  of
representatives  for the  equivalence  classes, and these representatives
are ---  mathematically  viewed ---  not the  elements  of the projective
space.    Such enumerators   are  convenient  because     they avoid  the
introduction   of  new types  of  elements    (here: the introduction  of
projective points or one-dimensional  subspaces). There are, however, two
caveats about them:
\beginlist
  \item{$\bullet$} They cannot be obtained as `Enumerator( <pro_space> )'
    where  <pro_space> is a projective  space in  the proper mathematical
    sense.   In general, they   are   never enumerators  of domains  (see
    chapter~"Domains and Collections").
  \item{$\bullet$} The function `Position( enum,  <rep> )' cannot be used
    to  find  the position   of  the mathematical  element represented by
    <rep>. The function `PositionCanonical' does that.
\endlist
Suppose  you  have   a   {\GAP} object  <T>  which  is   either  a proper
mathematical set or merely a set of representatives for the elements in a
proper  mathematical set. Now if  you want to enumerate that mathematical
set,   you  can in  both  cases  use  `<enum> :=  Enumerator(  <T>  )' in
conjunction with `PositionCanonical( <enum>, <elm> )', where <elm> stands
a {\GAP} object of  the same type as  <enum> produces. Reason: If <T>  is
equal to `AsList( <enum> )', then `PositionCanonical' simply behaves like
`Position'. And if <T> is merely a list of representatives, you will have
`<enum> = <T>' and `PositionCanonical'  will really give the position  of
the mathematical element represented by <elm>. (An  example of this usage
is  given by the operation  functions,  see  "External sets".) For  every
enumerator, this manual  mentions explicitly if  it allows such a  use of
representatives.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Sets}

A  list may  have holes or  contain elements  more  than once. Also,  the
elements of a list <list> are in  general not sorted,  i.e., `<i> \< <j>'
(for    two natural numbers) does  in   general not imply `<list>[<i>] \<
<list>[<j>]'. The  two list entries need  not even  be comparable at all,
because the  `\<' relation is  defined only between elements belonging to
the same family (see~"Families").

Mathematically, the only defining property of  a *set* is that membership
in it  can be decided  for every element. In {\GAP},  a set is  a special
kind of list, and since the ordering plays not role for a set, {\GAP} can
impose restrictions on the  ordering of the list  representing the set. A
list representing a  set must not have holes  nor contain elements twice.
Additionally,  {\GAP} requires the    elements to be sorted   w.r.t.\ the
relation  `\<',  which  implies that  they  must  all belong  to the same
family.

\index{lists!properties of}\index{multisets}%
\indextt{IsDenseList}\indextt{IsHomogeneousList}%
\indextt{IsDuplicateFreeList}\indextt{IsSSortedList}%
A non-empty *dense* list (i.e., one without holes)  all of whose elements
belong to the same family is called *homogeneous*. Hence  a set is either
empty  or a  strictly sorted  collection  (where the adverb  ``strictly''
implies  that there   are no duplicates).   If  we drop  the condition of
duplicate-freeness  but keep the requirement  that the list be sorted (in
the  sense that `<i> \<  <j> $\Rightarrow$ <list>[<i>] \<= <list>[<j>]'),
we arrive  at *multisets*, which are  empty or homogeneous  sorted lists.
All  the  list properties mentioned  here  can be  tested with the {\GAP}
functions  `IsDenseList',  `IsHomogeneousList',    `IsDuplicateFreeList',
`IsSSortedList'.

\>Set( <list> )

`Set' returns a  new proper  set, which  is represented as  a sorted list
without holes or duplicates, containing the elements of the list <list>.

`Set' returns a new list even if the list <list> is already a proper set,
in this  case  it is   equivalent to  `ShallowCopy' (see  "ShallowCopy").
Thus the result is  a new list  that is not  identical to any other list.
The elements of  the result are however identical  to elements of <list>.
If <list> contains equal elements, it is  not specified to which of those
the element of the result is identical (see "Identical Lists").

\>AddSet( <set>, <elm> )
\>RemoveSet( <set>, <elm> )

`AddSet' adds <elm>, which may be an elment of an  arbitrary type, to the
set   <set>, which must  be  a proper  set,  otherwise an  error  will be
signalled.  If <elm> is already an element of the  set <set>, the  set is
not  changed.  Otherwise <elm> is inserted  at the  correct position such
that <set> is again a set afterwards.

`RemoveSet' removes   the  element  <elm>,  which  may be   an  object of
arbitrary  type, from the set <set>,  which must be  a  set, otherwise an
error will be signalled.  If  <elm>  is  not an  element of <set> nothing
happens.  If <elm>  is  an element it is removed   and  all the following
elements in the list are moved one position forward.

\>IntersectSet( <set1>, <set2> )

`IntersectSet' intersects  the set <set1> with the  set <set2>.  This  is
equivalent  to removing all  the elements  that are not  in  <set2>  from
<set1> (see  "RemoveSet").  <set1> must be a  set, otherwise  an error is
signalled.  <set2> may be a list that is not a proper  set, in which case
`IntersectSet'   silently  applies  `Set' to      it first  (see  "Set").
`IntersectSet' returns nothing, it is only called to change <set1>.

The function `IntersectionSet'  (see  "Set functions!for sets")  is  the
nondestructive counterpart to the destructive procedure `IntersectSet'.

\>UniteSet( <set1>, <set2> )

`UniteSet' unites the set <set1> with the set <set2>.  This is equivalent
to adding all the elements  in <set2>  to <set1> (see "AddSet").   <set1>
must be a proper set, otherwise an  error is  signalled.  <set2> may also
be  list that  is  not a  proper set,  in  which case `UniteSet' silently
applies `Set' to it first (see "Set").  'UniteSet' returns nothing, it is
only called to change <set1>.

The  function   `UnionSet'   (see  "Set   functions!for sets")  is    the
nondestructive counterpart to the destructive procedure `UniteSet'.

\>SubtractSet( <set1>, <set2> )

`SubtractSet'  subtracts  the set  <set2>  from the set  <set1>.  This is
equivalent to  removing  all the elements in   <set2>  from  <set1>  (see
"RemoveSet").   <set1> must  be  a  proper  set, otherwise   an  error is
signalled.  <set2> may be a list that is not a proper  set, in which case
`SubtractSet' applies  `Set'   to it   first  (see "Set").  `SubtractSet'
returns nothing, it is only called to change <set1>.

The   function `Difference'    (see   "Difference!for  domains") is   the
nondestructive counterpart to destructive the procedure `SubtractSet'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Set functions!for sets}

Set  functions  are applicable not  only  to sets,  but more generally to
collections, where a  collection  is either a  set of  a  domain  with an
algebraic  structure.  In this  section we mention  only the  methods for
plain sets, the methods for domains, such as groups, will be described in
section "Set functions!for domains".

\>IsSubset( <set1>, <set2> )

This is implemented by `IsSubsetSet', which you can call directly to save
a little  bit of  time.  Either argument to  `IsSubsetSet' may also  be a
list that is not a proper set, in which  case `IsSubset' silently applies
`Set' (see "Set") to it first.

\>Union( <set1>, <set2> )

This is implemented by `UnionSet', which you can call  directly to save a
little bit of time.  Note that  `UnionSet' only accepts two  sets, unlike
`Union',  which accepts several sets or  a list of  sets.  The  result of
`UnionSet' is a new set,  represented as  a sorted list  without holes or
duplicates.  Each argument to `UnionSet' may also be a list that is not a
proper set, in which case `UnionSet'  silently  applies `Set' (see "Set")
to this argument.  `UnionSet' is implemented in terms of its  destructive
counterpart `UniteSet' (see "UniteSet").

\>Intersection( <set1>, <set2> )

This is implemented by `IntersectionSet', which you can call  directly to
save a little bit of time.  Note that `IntersectionSet'  only accepts two
sets, unlike `Intersection',  which  accepts several sets  or  a list  of
sets.  The  result of `IntersectionSet' is  a new  set,  represented as a
sorted  list     without  holes   or  duplicates.   Each   argument    to
`IntersectionSet' may also be a list  that is not  a proper set, in which
case  `IntersectionSet'  silently  applies  `Set' (see  "Set")    to this
argument.  `IntersectionSet' is implemented in  terms of its  destructive
counterpart `IntersectSet' (see "IntersectSet").

The result of `IntersectionSet' and `UnionSet' is always a new list, that
is not  identical to any other list.   The elements of that  list however
are identical to the corresponding elements of <set1>.   If <set1> is not
a proper list it is not specified to which of a number  of equal elements
in <set1> the element in the result is identical (see "Identical Lists").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Knowledge of the set property}\null

In the previous section we defined a proper  set as a sorted list without
holes or duplicates.  This representation is not  only nice to use, it is
also a good internal representation supporting efficient algorithms.  For
example the `in' operator can use binary instead of a linear search since
a set is sorted.  For another example `Union' only has to merge the sets.

However, all  those set functions  also allow lists that are  not  proper
sets,  silently making  a copy  of it and  converting this copy to a set.
Suppose all the functions would have to test  their arguments every time,
comparing  each element  with its  successor, to see if  they  are proper
sets.  This would chew up most  of  the performance advantage again.  For
example suppose `in' would have to run  over the whole list, to see if it
is  a  proper set, so  it could  use the  binary search.   That  would be
ridiculous.

To avoid this a  list that is  a proper set  may, but need  not, have  an
internal flag set that tells  those functions that  this list is indeed a
proper set.  Those functions do not have to check this argument then, and
can use the more  efficient algorithms.  This  section tells  you  when a
proper set obtains this flag,  so you can write your  functions in such a
way that you make best use of the algorithms.

The results of `Set', `Difference', `Intersection'  and `Union' are known
to be sets by construction, and thus have the flag set upon creation.

If an argument to `IsSet', `IsEqualSet', `IsSubset', `Set', `Difference',
`Intersection' or  `Union' is a proper  set, that does  not  yet have the
flag set, those functions will notice that and set the flag for this set.
Note that `in' will use linear search if the  right operand does not have
the flag set, will therefore not detect  if it is  a proper set and will,
unlike the functions above, never set the flag.

If you change a proper set, that does have this  flag set, by assignment,
`Add'   or `Append' the  set  will generally lose  it  flag,  even if the
change is such that the resulting list is still a proper set.  However if
the set has more than 100 elements and the value assigned or added is not
a list and not a record and the resulting list is still a proper set than
it will keep  the flag.  Note that  changing a list  that is not a proper
set will never set the flag, even if the resulting list  is a proper set.
Such a set will obtain the flag only if it is passed to a set function.

Suppose you have built a proper set  in such a way that  it does not have
the flag set, and that you now want  to perform lots of membership tests.
Then you  should call `IsSet'  with that set   as an argument.   If it is
indeed  a proper set  `IsSet' will set the flag,  and the subsequent `in'
operations will use  the more efficient binary  search.  You can think of
the call to `IsSet' as a hint to {\GAP} that this list is a proper set.

There is no way you can set the flag for an ordinary  list  without going
through the checking in `IsSet'.  The  internal  functions depend so much
on the fact that a list with  this flag set  is indeed sorted and without
holes and duplicates that the risk would be too high to allow setting the
flag without such a check.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{AsListSorted and EnumeratorSorted}\null

\>AsListSorted( <D> )
\>EnumeratorSorted( <D> )

These   functions return  sorted versions  of  what `AsList(   <D> )' and
`Enumerator( <D> )' would return.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Local Variables:
% mode:               text
% mode:               outline-minor
% outline-regexp:     "\\\\Chapter\\|\\\\Section\\|\\\\stars"
% paragraph-start:    "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% paragraph-separate: "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% fill-column:        73
% End:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

