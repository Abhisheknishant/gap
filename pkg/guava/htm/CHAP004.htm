<html><head><title>[GUAVA] 4 Generating Codes</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP003.htm">Previous</a>] [<a href ="CHAP005.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>4 Generating Codes</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP004.htm#SECT001">Generating Unrestricted Codes</a>
<li> <A HREF="CHAP004.htm#SECT002">Generating Linear Codes</a>
<li> <A HREF="CHAP004.htm#SECT003">Golay Codes</a>
<li> <A HREF="CHAP004.htm#SECT004">Generating Cyclic Codes</a>
<li> <A HREF="CHAP004.htm#SECT005">Toric codes</a>
</ol><p>
<p>
In this chapter we describe functions for generating codes.
<p>
Section&nbsp;<a href="CHAP004.htm#SECT001">Generating Unrestricted Codes</a> describes function for generating
unrestricted codes.
<p>
Section&nbsp;<a href="CHAP004.htm#SECT002">Generating  Linear  Codes</a> describes function for generating linear
codes.
<p>
Finally,  Section&nbsp;<a href="CHAP004.htm#SECT004">Generating  Cyclic  Codes</a>  describes  functions   for
generating cyclic codes.
<p>
<p>
<h2><a name="SECT001">4.1 Generating Unrestricted Codes</a></h2>
<p><p>
In this section we start with functions  that  creating  code  from  user
defined matrices or special matrices (see <a href="CHAP004.htm#SSEC001.1">ElementsCode</a>, <a href="CHAP004.htm#SSEC001.3">HadamardCode</a>,
<a href="CHAP004.htm#SSEC001.4">ConferenceCode!from  a  matrix</a>  and  <a href="CHAP004.htm#SSEC001.6">MOLSCode</a>).   These   codes   are
unrestricted codes; they may later be discovered to be linear or cyclic.
<p>
The next functions generate  random  codes  (see  <a href="CHAP004.htm#SSEC001.7">RandomCode</a>)  and  the
Nordstrom-Robinson code (see <a href="CHAP004.htm#SSEC001.8">NordstromRobinsonCode</a>), respectively.
<p>
Finally, we describe two functions for generating Greedy codes. These are
codes  that  contructed  by  gathering  codewords  from  a   space   (see
<a href="CHAP004.htm#SSEC001.9">GreedyCode</a> and <a href="CHAP004.htm#SSEC001.10">LexiCode</a>).
<p>
<a name = "SSEC001.1"></a>
<li><code>ElementsCode( </code><var>L</var><code> [, </code><var>Name</var><code> ], </code><var>F</var><code> )</code>
<p>
<code>ElementsCode</code> creates an unrestricted code of the  list of elements <var>L</var>,
in the field <var>F</var>.  <var>L</var> must be a list of vectors, strings, polynomials or
codewords. <var>Name</var> can contain a short description of the code.
<p>
If <var>L</var>  contains a codeword more than  once, it is  removed from the list
and a <font face="Gill Sans,Helvetica,Arial">GAP</font> set is returned.
<p>
<pre>
gap&gt; M := Z(3)^0 * [ [1, 0, 1, 1], [2, 2, 0, 0], [0, 1, 2, 2] ];;
gap&gt; C := ElementsCode( M, "example code", GF(3) );
a (4,3,1..4)2 example code over GF(3)
gap&gt; MinimumDistance( C );
4
gap&gt; AsSSortedList( C );
[ [ 0 1 2 2 ], [ 1 0 1 1 ], [ 2 2 0 0 ] ]
</pre>
<p>
<a name = "SSEC001.3"></a>
<li><code>HadamardCode( </code><var>H</var><code>, </code><var>t</var><code> )</code>
<li><code>HadamardCode( </code><var>H</var><code> )</code>
<p>
In the   first form <code>HadamardCode</code>  returns   a  Hadamard code  from  the
Hadamard matrix <var>H</var>, of the  <i>t</i> <sup><i>th</i></sup> kind. In the  second form, <i>t</i>  = 3 is used.
<p>
A Hadamard  matrix is a  square  matrix <var>H</var>  with <i>H</i> *<i>H</i> <sup><i>T</i></sup> = <font face="symbol">-</font><i>n</i>*<i>I</i><sub><i>n</i></sub>,
where <i>n</i> is the size of <var>H</var>. The entries of <var>H</var> are either 1 or -1.
<p>
The matrix <var>H</var>  is first   transformed into a   binary  matrix <i>A</i><sub><i>n</i></sub>  (by
replacing the 1s by 0s and the -1s by 1s).
<p>
The first kind (<i>t</i>=1) is created by using the rows of <i>A</i><sub><i>n</i></sub> as elements,
after deleting the first column. This is a (<i>n</i><font face="symbol">-</font>1, <i>n</i>, <i>n</i>/2) code.  We use
this code for creating the  Hadamard code of the  second kind (<i>t</i>=2), by
adding   all the  complements of   the already  existing  codewords. This
results in a (<i>n</i><font face="symbol">-</font>1, 2<i>n</i>, <i>n</i>/2 <font face="symbol">-</font>1) code.  The third code (<i>t</i>=3) is created
by  using   the  rows of <i>A</i><sub><i>n</i></sub>   (without  cutting  a  column)  and their
complements as elements.  This way, we have an  (<i>n</i>, 2<i>n</i>, <i>n</i>/2) code.  The
returned code is generally  an unrestricted code,  but for <i>n</i> = 2<sup><i>r</i></sup>, the
code is linear.
<p>
<pre>
gap&gt; H4 := [[1,1,1,1],[1,-1,1,-1],[1,1,-1,-1],[1,-1,-1,1]];;
gap&gt; HadamardCode( H4, 1 );
a (3,4,2)1 Hadamard code of order 4 over GF(2)
gap&gt; HadamardCode( H4, 2 );
a (3,8,1)0 Hadamard code of order 4 over GF(2)
gap&gt; HadamardCode( H4 );
a (4,8,2)1 Hadamard code of order 4 over GF(2) 
</pre>
<p>
<li><code>HadamardCode( </code><var>n</var><code>, </code><var>t</var><code> )</code>
<li><code>HadamardCode( </code><var>n</var><code> )</code>
<p>
In  the first form <code>HadamardCode</code>  returns a Hadamard code with parameter
<var>n</var> of the <i>t</i> <sup><i>th</i></sup> kind. In the second form, <i>t</i> =3 is used.
<p>
When called   in these  forms,  <code>HadamardCode</code> first  creates a  Hadamard
matrix (see  <a href="CHAP006.htm#SSEC002.4">HadamardMat</a>),   of size  <var>n</var>  and  then follows  the  same
procedure as   described above.  Therefore  the  same  restrictions  with
respect to <var>n</var> as for Hadamard matrices hold.
<p>
<pre>
gap&gt; C1 := HadamardCode( 4 );
a (4,8,2)1 Hadamard code of order 4 over GF(2)
gap&gt; C1 = HadamardCode( H4 );
true 
</pre>
<p>
<a name = "SSEC001.4"></a>
<li><code>ConferenceCode( </code><var>H</var><code> )</code>
<p>
<code>ConferenceCode</code>   returns a code  of length  <i>n</i> <font face="symbol">-</font>1  constructed from a
symmetric <strong>conference matrix</strong>  <var>H</var>.  <var>H</var> must be   a symmetric matrix  of
order <i>n</i>, which satisfies <i>H</i>*<i>H</i><sup><i>T</i></sup> = ((<i>n</i><font face="symbol">-</font>1)*<i>I</i>. <i>n</i> = 2 (mod 4). The
rows  of 1/2(<i>H</i>+<i>I</i>+<i>J</i>), 1/2(<font face="symbol">-</font><i>H</i>+<i>I</i>+<i>J</i>),  plus  the zero  and all-ones vectors
form  the elements of   a binary non-linear (<i>n</i><font face="symbol">-</font>1, 2*<i>n</i>, 1/2 * (<i>n</i><font face="symbol">-</font>2))
code.
<p>
<pre>
gap&gt; H6 := [[0,1,1,1,1,1],[1,0,1,-1,-1,1],[1,1,0,1,-1,-1],
&gt; [1,-1,1,0,1,-1],[1,-1,-1,1,0,1],[1,1,-1,-1,1,0]];;
gap&gt; C1 := ConferenceCode( H6 );
a (5,12,2)1..4 conference code over GF(2)
gap&gt; IsLinearCode( C1 );
false 
</pre>
<p>
<a name = "SSEC001.5"></a>
<li><code>ConferenceCode( </code><var>n</var><code> )</code>
<p>
<font face="Gill Sans,Helvetica,Arial">GUAVA</font> constructs a symmetric conference  matrix of order <i>n</i> +1 (<i>n</i>  = 1 (mod  4)) and uses  the rows of that matrix,   plus the zero  and
all-ones vectors, to construct a binary  non-linear (<i>n</i>, 2*(<i>n</i>+1), 1/2 * (<i>n</i><font face="symbol">-</font>1)) code.
<p>
<pre>
gap&gt; C2 := ConferenceCode( 5 );
a (5,12,2)1..4 conference code over GF(2)
gap&gt; AsSSortedList( C2 );
[ [ 0 0 0 0 0 ], [ 0 0 1 1 1 ], [ 0 1 0 1 1 ], [ 0 1 1 0 1 ], [ 0 1 1 1 0 ], 
  [ 1 0 0 1 1 ], [ 1 0 1 0 1 ], [ 1 0 1 1 0 ], [ 1 1 0 0 1 ], [ 1 1 0 1 0 ], 
  [ 1 1 1 0 0 ], [ 1 1 1 1 1 ] ]
</pre>
<p>
<a name = "SSEC001.6"></a>
<li><code>MOLSCode( </code><var>n</var><code>, </code><var>q</var><code> )</code>
<li><code>MOLSCode( </code><var>q</var><code> )</code>
<p>
<code>MOLSCode</code> returns an  (<i>n</i>, <i>q</i><sup>2</sup>, <i>n</i><font face="symbol">-</font>1) code over  <code>GF(</code><var>q</var><code>)</code>.  The code is
created from <i>n</i><font face="symbol">-</font>2 <strong>Mutually Orthogonal  Latin Squares</strong> (MOLS) of size <i>q</i> * <i>q</i>. The default for <var>n</var> is  4. <font face="Gill Sans,Helvetica,Arial">GUAVA</font> can  construct a MOLS code for
<i>n</i> <font face="symbol">-</font>2  <font face="symbol">£</font> <i>q</i> ; <var>q</var> must be a prime power, <i>q</i> &gt;    2.  If there are no
<i>n</i> <font face="symbol">-</font>2 MOLS, an error is signalled.
<p>
Since each of the <i>n</i> <font face="symbol">-</font>2 MOLS  is a <i>q</i>*<i>q</i>  matrix, we can create a code
of size <i>q</i><sup>2</sup> by listing in each code element the entries that are in the
same position in  each of the MOLS.  We precede each  of these lists with
the two  coordinates that specify this  position,  making the word length
become <i>n</i>.
<p>
The MOLS codes are MDS codes (see <a href="CHAP003.htm#SSEC003.5">IsMDSCode</a>).
<p>
<pre>
gap&gt; C1 := MOLSCode( 6, 5 );
a (6,25,5)3..4 code generated by 4 MOLS of order 5 over GF(5)
gap&gt; mols := List( [1 .. WordLength(C1) - 2 ], function( nr )
&gt;       local ls, el;
&gt;       ls := NullMat( Size(LeftActingDomain(C1)), Size(LeftActingDomain(C1)) );
&gt;       for el in VectorCodeword( AsSSortedList( C1 ) ) do
&gt;          ls[IntFFE(el[1])+1][IntFFE(el[2])+1] := el[nr + 2];
&gt;       od;
&gt;       return ls;
&gt;    end );;
gap&gt; AreMOLS( mols );
true
gap&gt; C2 := MOLSCode( 11 );
a (4,121,3)2 code generated by 2 MOLS of order 11 over GF(11) 
</pre>
<p>
<a name = "SSEC001.7"></a>
<li><code>RandomCode( </code><var>n</var><code>, </code><var>M</var><code>, </code><var>F</var><code> )</code>
<p>
<code>RandomCode</code> returns  a random unrestricted  code of  size <var>M</var> with  word
length <var>n</var>  over <var>F</var>. <var>M</var> must  be less than  or equal  to the  number of
elements in the space <i>GF</i>(<i>q</i>)<sup><i>n</i></sup>.
<p>
The   function  <code>RandomLinearCode</code> returns  a    random linear code  (see
<a href="CHAP004.htm#SSEC002.11">RandomLinearCode</a>).
<p>
<pre>
gap&gt; C1 := RandomCode( 6, 10, GF(8) );
a (6,10,1..6)4..6 random unrestricted code over GF(8)
gap&gt; MinimumDistance(C1);
3
gap&gt; C2 := RandomCode( 6, 10, GF(8) );
a (6,10,1..6)4..6 random unrestricted code over GF(8)
gap&gt; C1 = C2;
false 
</pre>
<p>
<a name = "SSEC001.8"></a>
<li><code>NordstromRobinsonCode()</code>
<p>
<code>NordstromRobinsonCode</code> returns a  Nordstrom-Robinson code, the best code
with word length <i>n</i>=16 and minimum distance  <i>d</i>=6 over <code>GF(2)</code>. This is
a non-linear (16, 256, 6) code.
<p>
<pre>
gap&gt; C := NordstromRobinsonCode();
a (16,256,6)4 Nordstrom-Robinson code over GF(2)
gap&gt; OptimalityCode( C );
0 
</pre>
<p>
<a name = "SSEC001.9"></a>
<li><code>GreedyCode( </code><var>L</var><code>, </code><var>d</var><code>, </code><var>F</var><code> )</code>
<p>
<code>GreedyCode</code> returns a Greedy code with design distance <var>d</var> over <var>F</var>. The
code is  constructed using the  Greedy algorithm  on the  list of vectors
<var>L</var>. This algorithm checks each vector in <var>L</var> and  adds it to the code if
its distance to the current  code is greater than  or equal to <var>d</var>. It is
obvious that the resulting code has a minimum distance of at least <var>d</var>.
<p>
Note that Greedy codes are often linear codes.
<p>
The function <code>LexiCode</code> creates a Greedy code  from a basis instead of an
enumerated list (see <a href="CHAP004.htm#SSEC001.10">LexiCode</a>).
<p>
<pre>
gap&gt; C1 := GreedyCode( Tuples( AsSSortedList( GF(2) ), 5 ), 3, GF(2) );
a (5,4,3..5)2 Greedy code, user defined basis over GF(2)
gap&gt; C2 := GreedyCode( Permuted( Tuples( AsSSortedList( GF(2) ), 5 ),
&gt;                         (1,4) ), 3, GF(2) );
a (5,4,3..5)2 Greedy code, user defined basis over GF(2)
gap&gt; C1 = C2;
false 
</pre>
<p>
<a name = "SSEC001.10"></a>
<li><code>LexiCode( </code><var>n</var><code>, </code><var>d</var><code>, </code><var>F</var><code> )</code>
<p>
In this format, <code>Lexicode</code>  returns  a Lexicode   with word length   <var>n</var>,
design distance <var>d</var>  over <var>F</var>. The code is  constructed using  the Greedy
algorithm on the lexicographically ordered  list of all vectors of length
<var>n</var> over <var>F</var>.   Every time a vector  is found that has  a distance to the
current code  of  at least <var>d</var>,  it is  added to the  code. This results,
obviously, in a code with minimum distance greater than or equal to <var>d</var>.
<p>
<pre>
gap&gt; C := LexiCode( 4, 3, GF(5) );
a (4,17,3..4)2..4 lexicode over GF(5) 
</pre>
<p>
<a name = "SSEC001.11"></a>
<li><code>LexiCode( </code><var>B</var><code>, </code><var>d</var><code>, </code><var>F</var><code> )</code>
<p>
When called in this format, <code>LexiCode</code> uses the  basis <var>B</var> instead of the
standard basis. <var>B</var>  is  a  matrix of vectors    over <var>F</var>.  The  code  is
constructed using the Greedy algorithm on the  list of vectors spanned by
<var>B</var>, ordered lexicographically with respect to <var>B</var>.
<p>
<pre>
gap&gt; B := [ [Z(2)^0, 0*Z(2), 0*Z(2)], [Z(2)^0, Z(2)^0, 0*Z(2)] ];;
gap&gt; C := LexiCode( B, 2, GF(2) );
a linear [3,1,2]1..2 lexicode over GF(2) 
</pre>
<p>
Note that binary Lexicodes are always linear.
<p>
The function <code>GreedyCode</code> creates a Greedy code that is not restricted to
a lexicographical order (see <a href="CHAP004.htm#SSEC001.9">GreedyCode</a>).
<p>
<p>
<h2><a name="SECT002">4.2 Generating Linear Codes</a></h2>
<p><p>
In this section we describe functions for constructing  linear  codes.  A
linear code always has a generator or check matrix.
<p>
The first two functions generate linear codes from the  generator  matrix
(<a href="CHAP004.htm#SSEC002.1">GeneratorMatCode</a>) or check matrix (<a href="CHAP004.htm#SSEC002.2">CheckMatCode</a>). All  linear  codes
can be constructed with these functions.
<p>
The next functions we describe  generate  some  well  known  codes,  like
Hamming codes (<a href="CHAP004.htm#SSEC002.3">HammingCode</a>), Reed-Muller codes  (<a href="CHAP004.htm#SSEC002.4">ReedMullerCode</a>)  and
the    extended    Golay     codes     (<a href="CHAP004.htm#SSEC003.2">ExtendedBinaryGolayCode</a>     and
<a href="CHAP004.htm#SSEC003.4">ExtendedTernaryGolayCode</a>).
<p>
A large and powerful family  of  codes  are  alternant  codes.  They  are
obtained by a small modification of the parity check matrix of a BCH code
(see <a href="CHAP004.htm#SSEC002.5">AlternantCode</a>, <a href="CHAP004.htm#SSEC002.6">GoppaCode!with list of field elements  parameter</a>,
<a href="CHAP004.htm#SSEC002.8">GeneralizedSrivastavaCode</a> and <a href="CHAP004.htm#SSEC002.9">SrivastavaCode</a>).
<p>
Finally, we describe a function for generating random linear  codes  (see
<a href="CHAP004.htm#SSEC002.11">RandomLinearCode</a>).
<p>
<a name = "SSEC002.1"></a>
<li><code>GeneratorMatCode( </code><var>G</var><code> [, </code><var>Name</var><code> ], </code><var>F</var><code> )</code>
<p>
<code>GeneratorMatCode</code>  returns a linear  code with generator matrix <var>G</var>. <var>G</var>
must be  a matrix  over Galois  field   <var>F</var>. <var>Name</var> can  contain  a short
description of  the  code.  The  generator matrix  is  the basis  of  the
elements of the  code. The resulting code  has word length <i>n</i>, dimension
<i>k</i> if <var>G</var> is a <i>k</i> * <i>n</i>-matrix. If <i>GF</i>(<i>q</i>) is the field of the code, the
size of the code will be <i>q</i><sup><i>k</i></sup>.
<p>
If the   generator  matrix does  not  have  full row   rank, the linearly
dependent rows  are removed. This is  done by the function <code>BaseMat</code> (see
<a href="../../../doc/htm/ref/CHAP024.htm#SSEC010.1">BaseMat</a>)  and results  in an equal  code. The  generator  matrix can be
retrieved with the function <code>GeneratorMat</code> (see <a href="CHAP003.htm#SSEC007.1">GeneratorMat</a>).
<p>
<pre>
gap&gt; G := Z(3)^0 * [[1,0,1,2,0],[0,1,2,1,1],[0,0,1,2,1]];;
gap&gt; C1 := GeneratorMatCode( G, GF(3) );
a linear [5,3,1..2]1..2 code defined by generator matrix over GF(3)
gap&gt; C2 := GeneratorMatCode( IdentityMat( 5, GF(2) ), GF(2) );
a linear [5,5,1]0 code defined by generator matrix over GF(2)
gap&gt; GeneratorMatCode( List( AsSSortedList( NordstromRobinsonCode() ),
&gt; x -&gt; VectorCodeword( x ) ), GF( 2 ) );
a linear [16,11,1..4]2 code defined by generator matrix over GF(2)
# This is the smallest linear code that contains the N-R code 
</pre>
<p>
<a name = "SSEC002.2"></a>
<li><code>CheckMatCode( </code><var>H</var><code> [, </code><var>Name</var><code> ], </code><var>F</var><code> )</code>
<p>
<code>CheckMatCode</code> returns a linear code with check matrix <var>H</var>. <var>H</var> must be a
matrix over  Galois field <var>F</var>. <var>Name</var> can  contain a short description of
the code. The parity check matrix is  the transposed of the nullmatrix of
the generator matrix of the code. Therefore, <i>c</i>*<i>H</i> <sup><i>T</i></sup> = 0 where <i>c</i> is
an  element of the code.  If <var>H</var>  is a <i>r</i>*<i>n</i>-matrix,   the code has word
length <i>n</i>, redundancy <i>r</i> and dimension <i>n</i><font face="symbol">-</font><i>r</i>.
<p>
If the  check matrix does not have  full row rank, the linearly dependent
rows are removed. This is done  by the function <code>BaseMat</code> (see <a href="../../../doc/htm/ref/CHAP024.htm#SSEC010.1">BaseMat</a>)
and results in an equal code. The check matrix  can be retrieved with the
function <code>CheckMat</code> (see <a href="CHAP003.htm#SSEC007.2">CheckMat</a>).
<p>
<pre>
gap&gt; G := Z(3)^0 * [[1,0,1,2,0],[0,1,2,1,1],[0,0,1,2,1]];;
gap&gt; C1 := CheckMatCode( G, GF(3) );
a linear [5,2,1..2]2..3 code defined by check matrix over GF(3)
gap&gt; CheckMat(C1);
[ [ Z(3)^0, 0*Z(3), Z(3)^0, Z(3), 0*Z(3) ],
  [ 0*Z(3), Z(3)^0, Z(3), Z(3)^0, Z(3)^0 ],
  [ 0*Z(3), 0*Z(3), Z(3)^0, Z(3), Z(3)^0 ] ]
gap&gt; C2 := CheckMatCode( IdentityMat( 5, GF(2) ), GF(2) );
a cyclic [5,0,5]5 code defined by check matrix over GF(2)
</pre>
<p>
<a name = "SSEC002.3"></a>
<li><code>HammingCode( </code><var>r</var><code>, </code><var>F</var><code> )</code>
<p>
<code>HammingCode</code>  returns a Hamming  code with  redundancy <var>r</var>  over <var>F</var>.  A
Hamming code is a single-error-correcting  code. The parity check  matrix
of a Hamming code  has all nonzero vectors  of length <var>r</var> in its columns,
except for a multiplication factor. The decoding algorithm of the Hamming
code (see <a href="CHAP003.htm#SSEC010.1">Decode</a>) makes use of this property.
<p>
If  <i>q</i> is the  size  of its field  <var>F</var>,  the returned  Hamming code is a
linear [(<i>q</i><sup><i>r</i> </sup><font face="symbol">-</font>1)/(<i>q</i><font face="symbol">-</font>1), (<i>q</i><sup><i>r</i> </sup><font face="symbol">-</font>1)/(<i>q</i><font face="symbol">-</font>1) <font face="symbol">-</font> <i>r</i> , 3] code.
<p>
<pre>
gap&gt; C1 := HammingCode( 4, GF(2) );
a linear [15,11,3]1 Hamming (4,2) code over GF(2)
gap&gt; C2 := HammingCode( 3, GF(9) );
a linear [91,88,3]1 Hamming (3,9) code over GF(9) 
</pre>
<p>
<a name = "SSEC002.4"></a>
<li><code>ReedMullerCode( </code><var>r</var><code>, </code><var>k</var><code> )</code>
<p>
<code>ReedMullerCode</code> returns a binary  <strong>Reed-Muller code</strong> <i>R</i>(<i>r</i> , <i>k</i> )  with
dimension <var>k</var>  and  order <var>r</var>.  This  is a code  with  length 2<sup><i>k</i> </sup> and
minimum  distance  2<sup><i>k</i> <font face="symbol">-</font><i>r</i> </sup>. By   definition, the  <i>r</i> <sup><i>th</i></sup>  order
binary Reed-Muller  code of length <i>n</i>=2<sup><i>m</i> </sup>, for  0  <font face="symbol">£</font> <i>r</i>   <font face="symbol">£</font> <i>m</i> ,
is the set of all vectors <i>f</i>, where <i>f</i> is a Boolean function which is a
polynomial of degree at most <var>r</var>.
<p>
<pre>
gap&gt; ReedMullerCode( 1, 3 );
a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2) 
</pre>
<p>
<a name = "SSEC002.5"></a>
<li><code>AlternantCode( </code><var>r</var><code>, </code><var>Y</var><code>, </code><var>F</var><code> )</code>
<li><code>AlternantCode( </code><var>r</var><code>, </code><var>Y</var><code>, </code><var>alpha</var><code>, </code><var>F</var><code> )</code>
<p>
<code>AlternantCode</code> returns an <strong>alternant code</strong>, with parameters <var>r</var>, <var>Y</var> and
<var>alpha</var> (optional).  <var>r</var> is the  design redundancy of   the code. <var>Y</var> and
<var>alpha</var> are both vectors of length <var>n</var> from which the parity check matrix
is constructed. The check matrix has entries of the form <i>a</i><sub><i>i</i></sub><sup><i>j</i></sup> <i>y</i><sub><i>i</i></sub>.  If
no <var>alpha</var> is specified, the  vector [1, <i>a</i>, <i>a</i><sup>2</sup>, &#183;., <i>a</i><sup><i>n</i><font face="symbol">-</font>1</sup>] is used,
where <i>a</i> is a primitive element of a Galois field <var>F</var>.
<p>
<pre>
gap&gt; Y := [ 1, 1, 1, 1, 1, 1, 1];; a := PrimitiveUnityRoot( 2, 7 );;
gap&gt; alpha := List( [0..6], i -&gt; a^i );;
gap&gt; C := AlternantCode( 2, Y, alpha, GF(8) );
a linear [7,3,3..4]3..4 alternant code over GF(8) 
</pre>
<p>
<a name = "SSEC002.6"></a>
<li><code>GoppaCode( </code><var>G</var><code>, </code><var>L</var><code> )</code>
<p>
<code>GoppaCode</code>   returns a  Goppa  code  from  Goppa  polynomial <var>G</var>, having
coefficients in a Galois Field <i>GF</i>(<i>q</i><sup><i>m</i></sup>). <var>L</var> must  be a list of elements
in <i>GF</i>(<i>q</i><sup><i>m</i></sup>), that are not roots of <var>G</var>.  The word length  of the code is
equal to the length of  <var>L</var>. The parity check  matrix contains entries of
the       form   <i>a</i><sub><i>i</i></sub><sup><i>j</i></sup> <i>G</i>(<i>a</i><sub><i>i</i></sub>), <i>a</i><sub><i>i</i></sub>      in  <i>L</i>.   The   function
<code>VerticalConversionFieldMat</code> converts   this  matrix  to  a  matrix  with
entries in <i>GF</i>(<i>q</i>) (see <a href="CHAP006.htm#SSEC002.9">VerticalConversionFieldMat</a>).
<p>
<pre>
gap&gt; x := Indeterminate( GF(2), "x" );; 
gap&gt; G := x^2 + x + 1;; L := AsSSortedList( GF(8) );;
gap&gt; C := GoppaCode( G, L );
a linear [8,2,5]3 Goppa code over GF(2) 
</pre>
<p>
<a name = "SSEC002.7"></a>
<li><code>GoppaCode( </code><var>G</var><code>, </code><var>n</var><code> )</code>
<p>
When called with parameter <var>n</var>, <font face="Gill Sans,Helvetica,Arial">GUAVA</font>  constructs a list <i>L</i> of length
<var>n</var>, such that no element of <i>L</i> is a root of <var>G</var>.
<p>
<pre>
gap&gt; x := Indeterminate( GF(2), "x" );; 
gap&gt; G := x^2 + x + 1;;
gap&gt; C := GoppaCode( G, 8 );
a linear [8,2,5]3 Goppa code over GF(2) 
</pre>
<p>
<a name = "SSEC002.8"></a>
<li><code>GeneralizedSrivastavaCode( </code><var>a</var><code>, </code><var>w</var><code>, </code><var>z</var><code>, </code><var>F</var><code> )</code>
<li><code>GeneralizedSrivastavaCode( </code><var>a</var><code>, </code><var>w</var><code>, </code><var>z</var><code>, </code><var>t</var><code>, </code><var>F</var><code> )</code>
<p>
<code>GeneralizedSrivastavaCode</code> returns   a generalized Srivastava  code with
parameters <var>a</var>, <var>w</var>, <var>z</var>, <var>t</var>. <i>a</i>  = <i>a</i><sub>1</sub>, &#183;.&#183;, <i>a</i><sub><i>n</i></sub> and <i>w</i>  = <i>w</i><sub>1</sub>, &#183;.&#183;, <i>w</i><sub><i>s</i></sub> are lists of <i>n</i>+<i>s</i> distinct elements of <i>F</i> =<i>GF</i>(<i>q</i><sup><i>m</i></sup>), <var>z</var> is a list
of length <i>n</i>  of   nonzero elements  of  <i>GF</i>(<i>q</i><sup><i>m</i></sup>). The   parameter  <var>t</var>
determines the designed  distance: <i>d</i>  <font face="symbol">³</font> <i>st</i> + 1.  The parity check
matrix of this code has entries  of the form <br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"></td><td nowrap="nowrap" align="center"><i>z</i><sub><i>i</i></sub><div class="hrcomp"><hr noshade="noshade" size="1"/></div>(<i>a</i><sub><i>i</i></sub> <font face="symbol">-</font> <i>w</i><sub><i>l</i></sub>)<sup><i>k</i></sup> <br /></td><td nowrap="nowrap" align="center"></td></tr></table></td></tr></table>  <code>VerticalConversionFieldMat</code>  converts this matrix  to  a matrix with
entries in  <i>GF</i>(<i>q</i>)  (see <a href="CHAP006.htm#SSEC002.9">VerticalConversionFieldMat</a>).  The default for
<var>t</var> is  1.  The original Srivastava codes  (see  <a href="CHAP004.htm#SSEC002.9">SrivastavaCode</a>) are  a
special case <i>t</i>=1, <i>z</i><sub><i>i</i></sub>=<i>a</i><sub><i>i</i></sub><sup><font face="symbol">m</font></sup> for some <font face="symbol">m</font>.
<p>
<pre>
gap&gt; a := Filtered( AsSSortedList( GF(2^6) ), e -&gt; e in GF(2^3) );;
gap&gt; w := [ Z(2^6) ];; z := List( [1..8], e -&gt; 1 );;
gap&gt; C := GeneralizedSrivastavaCode( a, w, z, 1, GF(64) );
a linear [8,2,2..5]3..4 generalized Srivastava code over GF(2) 
</pre>
<p>
<a name = "SSEC002.9"></a>
<li><code>SrivastavaCode( </code><var>a</var><code>, </code><var>w</var><code>, </code><var>F</var><code> )</code>
<li><code>SrivastavaCode( </code><var>a</var><code>, </code><var>w</var><code>, </code><var>mu</var><code>, </code><var>F</var><code> )</code>
<p>
<code>SrivastavaCode</code> returns a    Srivastava code with parameters  <var>a</var>,  <var>w</var>,
<var>mu</var>. <i>a</i>  = <i>a</i><sub>1</sub>, &#183;.&#183;, <i>a</i><sub><i>n</i></sub> and <i>w</i>  = <i>w</i><sub>1</sub>, &#183;.&#183;, <i>w</i><sub><i>s</i></sub> are lists of <i>n</i>+<i>s</i>
distinct elements   of  <i>F</i> =<i>GF</i>(<i>q</i><sup><i>m</i></sup>). The default  for  <var>mu</var>   is 1. The
Srivastava  code      is      a generalized    Srivastava     code   (see
<a href="CHAP004.htm#SSEC002.8">GeneralizedSrivastavaCode</a>), in which <i>z</i><sub><i>i</i></sub>  = <i>a</i><sub><i>i</i></sub><sup><i>mu</i> </sup> for some <var>mu</var>
and <i>t</i>=1.
<p>
<pre>
gap&gt; a := AsSSortedList( GF(11) ){[2..8]};;
gap&gt; w := AsSSortedList( GF(11) ){[9..10]};;
gap&gt; C := SrivastavaCode( a, w, 2, GF(11) );
a linear [7,5,3]2 Srivastava code over GF(11)
gap&gt; IsMDSCode( C );
true    # Always true if F is a prime field 
</pre>
<p>
<a name = "SSEC002.10"></a>
<li><code>CordaroWagnerCode( </code><var>n</var><code> )</code>
<p>
<code>CordaroWagnerCode</code> returns a binary Cordaro-Wagner code.  This is a code
of length <var>n</var> and dimension 2 having the best possible minimum distance
<var>d</var>.  This code is  just a little  bit less trivial than <code>RepetitionCode</code>
(see <a href="CHAP004.htm#SSEC004.11">RepetitionCode</a>).
<p>
<pre>
gap&gt; C := CordaroWagnerCode( 11 );
a linear [11,2,7]5 Cordaro-Wagner code over GF(2)
gap&gt; AsSSortedList(C);                 
[ [ 0 0 0 0 0 0 0 0 0 0 0 ], [ 0 0 0 0 1 1 1 1 1 1 1 ], 
  [ 1 1 1 1 0 0 0 1 1 1 1 ], [ 1 1 1 1 1 1 1 0 0 0 0 ] ]
</pre>
<p>
<a name = "SSEC002.11"></a>
<li><code>RandomLinearCode( </code><var>n</var><code>, </code><var>k</var><code> , </code><var>F</var><code> )</code>
<p>
<code>RandomLinearCode</code>  returns  a random linear  code  with word length <var>n</var>,
dimension <var>k</var> over field <var>F</var>.
<p>
To   create a    random  unrestricted   code,   use <code>RandomCode</code>     (see
<a href="CHAP004.htm#SSEC001.7">RandomCode</a>).
<p>
<pre>
gap&gt; C := RandomLinearCode( 15, 4, GF(3) );
a linear [15,4,1..6]6..10 random linear code over GF(3)
</pre>
<p>
<a name = "SSEC002.12"></a>
<li><code>BestKnownLinearCode( </code><var>n</var><code>, </code><var>k</var><code> , </code><var>F</var><code> )</code>
<p>
<code>BestKnownLinearCode</code> returns the best  known linear code of  length <var>n</var>,
dimension <var>k</var> over field  <var>F</var>. The function uses  the tables described in
section <a href="CHAP006.htm#SSEC001.12">BoundsMinimumDistance</a> to construct this code.
<p>
<pre>
gap&gt; C1 := BestKnownLinearCode( 23, 12, GF(2) );
a cyclic [23,12,7]3 binary Golay code over GF(2)
gap&gt; C1 = BinaryGolayCode();
true
gap&gt; Display( BestKnownLinearCode( 8, 4, GF(4) ) );
a linear [8,4,4]2..3 U U+V construction code of
U: a cyclic [4,3,2]1 dual code of
   a cyclic [4,1,4]3 repetition code over GF(4)
V: a cyclic [4,1,4]3 repetition code over GF(4)
gap&gt; C := BestKnownLinearCode(131,47);
a linear [131,47,28..32]23..68 shortened code 
</pre>
<p>
<a name = "SSEC002.13"></a>
<li><code>BestKnownLinearCode( </code><var>rec</var><code> )</code>
<p>
In this form, <var>rec</var> must be a record  containing the fields <code>lowerBound</code>,
<code>upperBound</code> and <code>construction</code>. It uses the information in this field to
construct a code.   This form is   meant to  be  used together  with  the
function <code>BoundsMinimumDistance</code>    (see <a href="CHAP006.htm#SSEC001.12">BoundsMinimumDistance</a>), if the
bounds are already calculated.
<p>
<pre>
gap&gt; bounds := BoundsMinimumDistance( 20, 17, GF(4) );
rec( n := 20, k := 17, q := 4, 
  references := rec( HM := [ "%T this reference is unknown, for more info", 
          "%T contact A.E. Brouwer (aeb@cwi.nl)" ] ), 
  construction := [ &lt;Operation "ShortenedCode"&gt;, 
      [ [ &lt;Operation "HammingCode"&gt;, [ 3, 4 ] ], [ 1 ] ] ], lowerBound := 3, 
  lowerBoundExplanation := [ "Lb(20,17)=3, by shortening of:", 
      "Lb(21,18)=3, reference: HM" ], upperBound := 3, 
  upperBoundExplanation := 
    [ "Ub(20,17)=3, otherwise construction B would contradict:", 
      "Ub(3,1)=3, repetition code" ] )
gap&gt; C := BestKnownLinearCode( bounds );
a linear [20,17,3]2 shortened code
gap&gt; C = BestKnownLinearCode( 20, 17, GF(4) );
true 
</pre>
<p>
<p>
<h2><a name="SECT003">4.3 Golay Codes</a></h2>
<p><p>
<a name = "SSEC003.1"></a>
<li><code>BinaryGolayCode()</code>
<p>
<code>BinaryGolayCode</code>  returns   a binary  Golay   code. This  is   a perfect
[23,12,7]  code. It  is  also    cyclic,  and has  generator   polynomial
<i>g</i>(<i>x</i>)=1+<i>x</i><sup>2</sup>+<i>x</i><sup>4</sup>+<i>x</i><sup>5</sup>+<i>x</i><sup>6</sup>+<i>x</i><sup>10</sup>+<i>x</i><sup>11</sup>.  Extending  it    results   in an
extended Golay code (see  <a href="CHAP004.htm#SSEC003.2">ExtendedBinaryGolayCode</a>).  There's  also  the
ternary Golay code (see <a href="CHAP004.htm#SSEC003.3">TernaryGolayCode</a>).
<p>
<pre>
gap&gt; BinaryGolayCode();
a cyclic [23,12,7]3 binary Golay code over GF(2)
gap&gt; ExtendedBinaryGolayCode() = ExtendedCode(BinaryGolayCode());
true
gap&gt; IsPerfectCode(BinaryGolayCode());
true 
</pre>
<p>
<a name = "SSEC003.2"></a>
<li><code>ExtendedBinaryGolayCode( )</code>
<p>
<code>ExtendedBinaryGolayCode</code> returns an extended binary  Golay code. This is
a [24,12,8] code. Puncturing in the last  position results in a perfect
binary Golay  code (see <a href="CHAP004.htm#SSEC003.1">BinaryGolayCode</a>).  The  code is  self-dual (see
<a href="CHAP003.htm#SSEC003.6">IsSelfDualCode</a>).
<p>
<pre>
gap&gt; C := ExtendedBinaryGolayCode();
a linear [24,12,8]4 extended binary Golay code over GF(2)
gap&gt; P := PuncturedCode(C);
a linear [23,12,7]3 punctured code
gap&gt; P = BinaryGolayCode();
true 
</pre>
<p>
<a name = "SSEC003.3"></a>
<li><code>TernaryGolayCode()</code>
<p>
<code>TernaryGolayCode</code>  returns  a ternary Golay  code.  This  is  a  perfect
[11,6,5] code.  It   is   also cyclic,   and  has  generator   polynomial
<i>g</i>(<i>x</i>)=2+<i>x</i><sup>2</sup>+2<i>x</i><sup>3</sup>+<i>x</i><sup>4</sup>+<i>x</i><sup>5</sup>. Extending it results in an extended Golay code
(see <a href="CHAP004.htm#SSEC003.4">ExtendedTernaryGolayCode</a>). There's also the binary Golay code (see
<a href="CHAP004.htm#SSEC003.1">BinaryGolayCode</a>).
<p>
<pre>
gap&gt; TernaryGolayCode();
a cyclic [11,6,5]2 ternary Golay code over GF(3)
gap&gt; ExtendedTernaryGolayCode() = ExtendedCode(TernaryGolayCode());
true 
</pre>
<p>
<a name = "SSEC003.4"></a>
<li><code>ExtendedTernaryGolayCode( )</code>
<p>
<code>ExtendedTernaryGolayCode</code> returns an  extended ternary Golay  code. This
is a [12,6,6] code. Puncturing  this code results  in a perfect ternary
Golay   code (see  <a href="CHAP004.htm#SSEC003.3">TernaryGolayCode</a>).  The     code is self-dual   (see
<a href="CHAP003.htm#SSEC003.6">IsSelfDualCode</a>).
<p>
<pre>
gap&gt; C := ExtendedTernaryGolayCode();
a linear [12,6,6]3 extended ternary Golay code over GF(3)
gap&gt; P := PuncturedCode(C);
a linear [11,6,5]2 punctured code
gap&gt; P = TernaryGolayCode();
true 
</pre>
<p>
<p>
<h2><a name="SECT004">4.4 Generating Cyclic Codes</a></h2>
<p><p>
The  elements of  a cyclic  code <i>C</i> are   all multiples of  a polynomial
<i>g</i>(<i>x</i>), where calculations are carried out modulo <i>x</i><sup><i>n</i></sup><font face="symbol">-</font>1. Therefore, the
elements always have a degree less than <i>n</i>. A cyclic code is an ideal in
the ring  of polynomials  modulo <i>x</i><sup><i>n</i> </sup> <font face="symbol">-</font> 1. The  polynomial <i>g</i>(<i>x</i>)  is
called the  <strong>generator polynomial</strong>  of  <i>C</i>. This   is the  unique  monic
polynomial  of least degree that generates  <i>C</i>. It is  a  divisor of the
polynomial <i>x</i><sup><i>n</i> </sup><font face="symbol">-</font>1.
<p>
<a name = "I0"></a>

The  <strong>check polynomial</strong>  is   the  polynomial  <i>h</i>(<i>x</i>) with   <i>g</i>(<i>x</i>)*<i>h</i>(<i>x</i>) = <i>x</i><sup><i>n</i></sup><font face="symbol">-</font>1. Therefore it is  also a divisor of  <i>x</i><sup><i>n</i></sup><font face="symbol">-</font>1. The check polynomial
has  the property that   <i>c</i>(<i>x</i>)*<i>h</i>(<i>x</i>) = 0 (mod   (<i>x</i><sup><i>n</i></sup><font face="symbol">-</font>1)) for  every
codeword <i>c</i>(<i>x</i>).
<p>
The first two functions described generate  cyclic  codes  from  a  given
generator or check polynomial. All cyclic codes can be constructed  using
these functions.
<p>
Next are described the two cyclic Golay codes (see <a href="CHAP004.htm#SSEC003.1">BinaryGolayCode</a>  and
<a href="CHAP004.htm#SSEC003.3">TernaryGolayCode</a>).
<p>
Then functions that generate cyclic codes from a prescribed set of  roots
of the generator polynomial are described, including the BCH  codes  (see
<a href="CHAP004.htm#SSEC004.3">RootsCode</a>, <a href="CHAP004.htm#SSEC004.5">BCHCode</a>, <a href="CHAP004.htm#SSEC004.6">ReedSolomonCode</a> and <a href="CHAP004.htm#SSEC004.7">QRCode</a>).
<p>
Finally we describe the trivial codes (see <a href="CHAP004.htm#SSEC004.9">WholeSpaceCode</a>,  <a href="CHAP004.htm#SSEC004.10">NullCode</a>,
<a href="CHAP004.htm#SSEC004.11">RepetitionCode</a>), and <code>CyclicCodes</code> (<a href="CHAP004.htm#SSEC004.12">CyclicCodes</a>).
<p>
<a name = "SSEC004.1"></a>
<li><code>GeneratorPolCode( </code><var>g</var><code>, </code><var>n</var><code> [, </code><var>Name</var><code> ], </code><var>F</var><code> )</code>
<p>
<code>GeneratorPolCode</code> creates a cyclic code with a generator polynomial <var>g</var>,
word length <var>n</var>,  over <var>F</var>.  <var>Name</var> can contain  a short
description of the code.
<p>
If  <var>g</var>   is not   a divisor   of <i>x</i><sup><i>n</i> </sup><font face="symbol">-</font>1,   it cannot  be  a generator
polynomial. In  that case,  a code  is created  with generator polynomial
<i>gcd</i>( <i>g</i> , <i>x</i><sup><i>n</i> </sup><font face="symbol">-</font>1 ), i.e.   the  greatest common divisor  of  <var>g</var> and
<i>x</i><sup><i>n</i> </sup><font face="symbol">-</font>1. This is a valid  generator polynomial that generates the ideal
(<i>g</i>). See <a href="CHAP004.htm#SECT004">Generating Cyclic Codes</a>.
<p>
<pre>
gap&gt; x:= Indeterminate( GF(2) );; P:= x^2+1;
Z(2)^0+x^2
gap&gt; G := GeneratorPolCode(P, 7, GF(2));
a cyclic [7,6,1..2]1 code defined by generator polynomial over GF(2)
gap&gt; GeneratorPol( G );
Z(2)^0+x
gap&gt; G2 := GeneratorPolCode( x+1, 7, GF(2)); 
a cyclic [7,6,1..2]1 code defined by generator polynomial over GF(2)
gap&gt; GeneratorPol( G2 );
Z(2)^0+x
</pre>
<p>
<a name = "SSEC004.2"></a>
<li><code>CheckPolCode( </code><var>h</var><code>, </code><var>n</var><code> [, </code><var>Name</var><code> ], </code><var>F</var><code> )</code>
<p>
<code>CheckPolCode</code> creates  a cyclic code  with a  check polynomial <var>h</var>, word
length <var>n</var>, over <var>F</var>. <var>Name</var> can contain  a short
description of the code.
<p>
If <var>h</var> is not a divisor of <i>x</i><sup><i>n</i> </sup><font face="symbol">-</font>1, it cannot be a check polynomial. In
that case, a code is created with check polynomial <i>gcd</i>( <i>h</i> , <i>x</i><sup><i>n</i> </sup><font face="symbol">-</font>1 ),
i.e. the greatest common divisor  of <var>h</var> and  <i>x</i><sup><i>n</i> </sup><font face="symbol">-</font>1. This is a  valid
check polynomial that yields the same  elements as the ideal (<i>h</i>). See
<a href="CHAP004.htm#SECT004">Generating Cyclic Codes</a>.
<p>
<pre>
gap&gt;  x:= Indeterminate( GF(3) );; P:= x^2+2;
-Z(3)^0+x_1^2
gap&gt; H := CheckPolCode(P, 7, GF(3));
a cyclic [7,1,7]4 code defined by check polynomial over GF(3)
gap&gt; CheckPol(H);
-Z(3)^0+x_1
gap&gt; Gcd(P, X(GF(3))^7-1);
-Z(3)^0+x_1
</pre>
<p>
<a name = "SSEC004.3"></a>
<li><code>RootsCode( </code><var>n</var><code>, </code><var>list</var><code> )</code>
<p>
This is the generalization of the BCH, Reed-Solomon and quadratic residue
codes (see <a href="CHAP004.htm#SSEC004.5">BCHCode</a>, <a href="CHAP004.htm#SSEC004.6">ReedSolomonCode</a> and  <a href="CHAP004.htm#SSEC004.7">QRCode</a>). The user can give
a length of  the code <var>n</var>  and a  prescribed  set of zeros. The  argument
<var>list</var> must be a valid  list of primitive <i>n</i> <sup><i>th</i></sup>  roots of unity in a
splitting field <i>GF</i>(<i>q</i><sup><i>m</i></sup>).  The resulting  code  will be over  the  field
<i>GF</i>(<i>q</i>). The function  will return the  largest possible cyclic  code for
which  the list <var>list</var> is  a subset of the  roots  of the code. From this
list, <font face="Gill Sans,Helvetica,Arial">GUAVA</font> calculates the entire set of roots.
<p>
<pre>
gap&gt; a := PrimitiveUnityRoot( 3, 14 );
Z(3^6)^52
gap&gt; C1 := RootsCode( 14, [ a^0, a, a^3 ] );
a cyclic [14,7,3..6]3..7 code defined by roots over GF(3)
gap&gt; MinimumDistance( C1 );
4
gap&gt; b := PrimitiveUnityRoot( 2, 15 );
Z(2^4)
gap&gt; C2 := RootsCode( 15, [ b, b^2, b^3, b^4 ] );
a cyclic [15,7,5]3..5 code defined by roots over GF(2)
gap&gt; C2 = BCHCode( 15, 5, GF(2) );
true 
</pre>
<p>
<a name = "SSEC004.4"></a>
<li><code>RootsCode( </code><var>n</var><code>, </code><var>list</var><code>, </code><var>F</var><code> )</code>
<p>
In this second form,  the second argument is a  list of integers, ranging
from 0  to <var>n</var>-1. The  resulting code will  be over a field <var>F</var>. <font face="Gill Sans,Helvetica,Arial">GUAVA</font>
calculates  a   primitive <i>n</i> <sup><i>th</i></sup>   root  of unity,  <font face="symbol">a</font>,  in the
extension field of <var>F</var>. It uses the set of  the powers of <font face="symbol">a</font> in the
list as a prescribed set of zeros.
<p>
<pre>
gap&gt; C := RootsCode( 4, [ 1, 2 ], GF(5) );
a cyclic [4,2,3]2 code defined by roots over GF(5)
gap&gt; RootsOfCode( C );
[ Z(5), Z(5)^2 ]
gap&gt; C = ReedSolomonCode( 4, 3 );
true 
</pre>
<p>
<a name = "SSEC004.5"></a>
<li><code>BCHCode( </code><var>n</var><code>, </code><var>d</var><code> , </code><var>F</var><code> )</code>
<li><code>BCHCode( </code><var>n</var><code>, </code><var>b</var><code>, </code><var>d</var><code>, </code><var>F</var><code> )</code>
<p>
The function <code>BCHCode</code> returns a <strong>Bose-Chaudhuri-Hockenghem code</strong> (or BCH
code for short).  This is the largest  possible cyclic code of length <var>n</var>
over field <var>F</var>, whose generator polynomial has zeros <br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"><i>a</i><sup><i>b</i> </sup>,<i>a</i><sup><i>b</i> +1</sup>, &#183;.&#183;, <i>a</i><sup><i>b</i> +<i>d</i> <font face="symbol">-</font>2</sup>,</td></tr></table></td></tr></table> where <i>a</i> is a primitive  <i>n</i><sup><i>th</i></sup> root of unity in
the splitting  field <i>GF</i>(<i>q</i><sup><i>m</i></sup>), <var>b</var>  is an integer  &gt;  1  and  <i>m</i> is the
multiplicative  order of  <i>q</i>  modulo  <var>n</var>.  Default  value  for  <var>b</var>  is
1. The  length <var>n</var> of  the code and the size  <i>q</i> of  the field must be
relatively prime. The generator polynomial is equal to the product of the
minimal polynomials of <i>X</i><sup><i>b</i> </sup>, <i>X</i><sup><i>b</i> +1</sup>, &#183;.&#183;, <i>X</i><sup><i>b</i> +<i>d</i> <font face="symbol">-</font>2</sup>.
<p>
Special cases are <i>b</i> =1 (resulting codes  are called <strong>narrow-sense</strong> BCH
codes), and  <i>n</i> =<i>q</i><sup><i>m</i></sup><font face="symbol">-</font>1 (known  as  <strong>primitive</strong>  BCH  codes).   <font face="Gill Sans,Helvetica,Arial">GUAVA</font>
calculates the largest value  of  <var>d</var>&facute;or  which  the  BCH  code  with
designed distance  <var>d</var>&cacute;oincides  with  the  BCH  code  with  designed
distance <var>d</var>. This distance is called the <strong>Bose distance</strong>  of  the  code.
The true minimum distance of the code is greater than  or  equal  to  the
Bose distance.
<p>
Printed are  the designed distance  (to be  precise,  the Bose  distance)
<code>delta</code>, and the starting power <code>b</code>.
<p>
<pre>
gap&gt; C1 := BCHCode( 15, 3, 5, GF(2) );
a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
gap&gt; DesignedDistance( C1 );
7
gap&gt; C2 := BCHCode( 23, 2, GF(2) );
a cyclic [23,12,5..7]3 BCH code, delta=5, b=1 over GF(2)
gap&gt; DesignedDistance( C2 );       
5
gap&gt; MinimumDistance(C2);
7 
</pre>
<p>
<a name = "SSEC004.6"></a>
<li><code>ReedSolomonCode( </code><var>n</var><code>, </code><var>d</var><code> )</code>
<p>
<code>ReedSolomonCode</code> returns a  <strong>Reed-Solomon code</strong> of length  <var>n</var>, designed
distance <var>d</var>. This  code  is a primitive  narrow-sense BCH  code over the
field <i>GF</i>(<i>q</i>),  where  <i>q</i>=<i>n</i> +1.  The  dimension   of  an   RS code   is
<i>n</i> <font face="symbol">-</font><i>d</i> +1. According to the Singleton bound (see <a href="CHAP006.htm#SSEC001.1">UpperBoundSingleton</a>)
the dimension cannot  be greater than this, so  the true minimum distance
of an RS code is equal to <var>d</var> and the code  is maximum distance separable
(see <a href="CHAP003.htm#SSEC003.5">IsMDSCode</a>).
<p>
<pre>
gap&gt; C1 := ReedSolomonCode( 3, 2 );
a cyclic [3,2,2]1 Reed-Solomon code over GF(4)
gap&gt; C2 := ReedSolomonCode( 4, 3 );
a cyclic [4,2,3]2 Reed-Solomon code over GF(5)
gap&gt; RootsOfCode( C2 );
[ Z(5), Z(5)^2 ]
gap&gt; IsMDSCode(C2);
true 
</pre>
<p>
<a name = "SSEC004.7"></a>
<li><code>QRCode( </code><var>n</var><code>, </code><var>F</var><code> )</code>
<p>
<code>QRCode</code> returns a  quadratic residue code. If  <var>F</var>  is a field  <i>GF</i>(<i>q</i>),
then <i>q</i> must be a  quadratic residue modulo  <var>n</var>. That is, an <i>x</i> exists
with <i>x</i><sup>2</sup>=<i>q</i>  (mod  <i>n</i> ). Both  <var>n</var> and <i>q</i>   must  be primes.   Its
generator polynomial is the product of the  polynomials <i>x</i><font face="symbol">-</font><i>a</i><sup><i>i</i></sup>. <i>a</i> is a
primitive <i>n</i> <sup><i>th</i></sup> root of unity, and  <i>i</i> is an  integer in the set of
quadratic residues modulo <var>n</var>.
<p>
<pre>
gap&gt; C1 := QRCode( 7, GF(2) );
a cyclic [7,4,3]1 quadratic residue code over GF(2)
gap&gt; IsEquivalent( C1, HammingCode( 3, GF(2) ) );
true
gap&gt; C2 := QRCode( 11, GF(3) );
a cyclic [11,6,4..5]2 quadratic residue code over GF(3)
gap&gt; C2 = TernaryGolayCode();
true 
</pre>
<p>
<a name = "SSEC004.8"></a>
<li><code>FireCode( </code><var>G</var><code>, </code><var>b</var><code> )</code>
<p>
<code>FireCode</code> constructs a (binary) Fire code. <var>G</var> is a primitive polynomial
of degree <i>m</i>, factor of <i>x</i><sup><i>r</i></sup><font face="symbol">-</font>1. <var>b</var> an integer 0  <font face="symbol">£</font> <i>b</i>   <font face="symbol">£</font> <i>m</i> not
divisible by <i>r</i>,  that  determines the  burst length  of a  single error
burst  that can be  corrected. The argument <var>G</var> can  be a polynomial with
base ring  <i>GF</i>(2), or a list of  coefficients in <i>GF</i>(2).  The generator
polynomial is defined as the product of <var>G</var> and <i>x</i><sup>2<i>b</i><font face="symbol">-</font>1</sup>+1.
<p>
<pre>
gap&gt; x:= Indeterminate( GF(2) );; G:= x^3+x^2+1;
Z(2)^0+x^2+x^3
gap&gt; Factors( G );
[ Z(2)^0+x^2+x^3 ]
gap&gt; C := FireCode( G, 3 );
a cyclic [35,27,1..4]2..6 3 burst error correcting fire code over GF(2)
gap&gt; MinimumDistance( C );
4     # Still it can correct bursts of length 3 
</pre>
<p>
<a name = "SSEC004.9"></a>
<li><code>WholeSpaceCode( </code><var>n</var><code>, </code><var>F</var><code> )</code>
<p>
<code>WholeSpaceCode</code> returns  the cyclic whole space code  of length <var>n</var> over
<var>F</var>. This code consists  of all polynomials of  degree less than <var>n</var>  and
coefficients in <var>F</var>.
<p>
<pre>
gap&gt; C := WholeSpaceCode( 5, GF(3) );
a cyclic [5,5,1]0 whole space code over GF(3)
</pre>
<p>
<a name = "SSEC004.10"></a>
<li><code>NullCode( </code><var>n</var><code>, </code><var>F</var><code> )</code>
<p>
<code>NullCode</code> returns  the  zero-dimensional nullcode with  length  <var>n</var> over
<var>F</var>. This code  has only  one word: the  all zero  word. It is   cyclic
though!
<p>
<pre>
gap&gt; C := NullCode( 5, GF(3) );
a cyclic [5,0,5]5 nullcode over GF(3)
gap&gt; AsSSortedList( C );
[ [ 0 0 0 0 0 ] ]
</pre>
<p>
<a name = "SSEC004.11"></a>
<li><code>RepetitionCode( </code><var>n</var><code>, </code><var>F</var><code> )</code>
<p>
<code>RepetitionCode</code> returns the  cyclic repetition code  of length  <var>n</var> over
<var>F</var>. The code has as many elements as <var>F</var>, because each codeword consists
of a repetition of one of these elements.
<p>
<pre>
gap&gt; C := RepetitionCode( 3, GF(5) );
a cyclic [3,1,3]2 repetition code over GF(5)
gap&gt; AsSSortedList( C );
[ [ 0 0 0 ], [ 1 1 1 ], [ 2 2 2 ], [ 4 4 4 ], [ 3 3 3 ] ]
gap&gt; IsPerfectCode( C );
false
gap&gt; IsMDSCode( C );
true 
</pre>
<p>
<a name = "SSEC004.12"></a>
<li><code>CyclicCodes( </code><var>n</var><code>, </code><var>F</var><code> )</code>
<p>
<code>CyclicCodes</code> returns  a list  of all  cyclic  codes of  length  <var>n</var> over
<var>F</var>. It constructs all possible generator polynomials from the factors of
<i>x</i><sup><i>n</i></sup><font face="symbol">-</font>1. Each combination of these  factors yields a generator polynomial
after multiplication.
<p>
<a name = "SSEC004.13"></a>
<li><code>NrCyclicCodes( </code><var>n</var><code>, </code><var>F</var><code> )</code>
<p>
The function  <code>NrCyclicCodes</code> calculates the  number  of cyclic  codes of
length <var>n</var> over field <var>F</var>.
<p>
<pre>
gap&gt; NrCyclicCodes( 23, GF(2) );
8
gap&gt; codelist := CyclicCodes( 23, GF(2) );
[ a cyclic [23,23,1]0 enumerated code over GF(2), 
  a cyclic [23,22,1..2]1 enumerated code over GF(2), 
  a cyclic [23,11,1..8]4..7 enumerated code over GF(2), 
  a cyclic [23,0,23]23 enumerated code over GF(2), 
  a cyclic [23,11,1..8]4..7 enumerated code over GF(2), 
  a cyclic [23,12,1..7]3 enumerated code over GF(2), 
  a cyclic [23,1,23]11 enumerated code over GF(2), 
  a cyclic [23,12,1..7]3 enumerated code over GF(2) ]
gap&gt; BinaryGolayCode() in codelist;
true
gap&gt; RepetitionCode( 23, GF(2) ) in codelist;
true
gap&gt; CordaroWagnerCode( 23 ) in codelist;
false    # This code is not cyclic 
</pre>
<p>
<p>
<h2><a name="SECT005">4.5 Toric codes</a></h2>
<p><a name = "I1"></a>

<p>
<a name = "SSEC005.1"></a>
<li><code>ToricCode(</code><var>L</var><code>,</code><var>F</var><code>)</code>
<p>
This function returns the same toric code as in J. P. Hansen
<a href="biblio.htm#Han99"><cite>Han99</cite></a>, except that the polytope can be
more general This is a truncated RS code. <var>L</var> is a list of integral
vectors (in Hansen's case, <var>L</var> is the list of integral vectors in a
polytope) and <var>F</var> is the finite field. The characteristic of <var>F</var> must
be different from 2.
<p>
<a name = "SSEC005.2"></a>
<li><code>ToricPoints(</code><var>n</var><code>,</code><var>F</var><code>)</code>
<p>
returns the points in (<i>F</i><sup>*</sup>)<sup><i>n</i></sup>.
<p>
<pre>
gap&gt; ToricPoints(2,GF(5));
[ [ Z(5)^0, Z(5)^0 ], [ Z(5)^0, Z(5) ], [ Z(5)^0, Z(5)^2 ], 
  [ Z(5)^0, Z(5)^3 ], [ Z(5), Z(5)^0 ], [ Z(5), Z(5) ], [ Z(5), Z(5)^2 ], 
  [ Z(5), Z(5)^3 ], [ Z(5)^2, Z(5)^0 ], [ Z(5)^2, Z(5) ], [ Z(5)^2, Z(5)^2 ], 
  [ Z(5)^2, Z(5)^3 ], [ Z(5)^3, Z(5)^0 ], [ Z(5)^3, Z(5) ], 
  [ Z(5)^3, Z(5)^2 ], [ Z(5)^3, Z(5)^3 ] ]
gap&gt; C:=ToricCode([[1,0],[3,4]],GF(3));
a linear [4,1,4]2 code defined by generator matrix over GF(3)
gap&gt; Display(GeneratorMat(C));
 1 1 2 2
gap&gt; Elements(C);
[ [ 0 0 0 0 ], [ 1 1 2 2 ], [ 2 2 1 1 ] ]
</pre>
<p>
<p>
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP003.htm">Previous</a>] [<a href ="CHAP005.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>GUAVA manual<br>April 2004
</address></body></html>