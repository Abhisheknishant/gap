<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (guava) - Chapter 7: 
Bounds on codes, special matrices and miscellaneous functions
</title>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body>


<div class="pcenter"><table class="chlink"><tr><td class="chlink1">Goto Chapter: </td><td><a href="chap0.html">Top</a></td><td><a href="chap1.html">1</a></td><td><a href="chap2.html">2</a></td><td><a href="chap3.html">3</a></td><td><a href="chap4.html">4</a></td><td><a href="chap5.html">5</a></td><td><a href="chap6.html">6</a></td><td><a href="chap7.html">7</a></td><td><a href="chapBib.html">Bib</a></td><td><a href="chapInd.html">Ind</a></td></tr></table><br /></div>
<p><a id="s0ss0" name="s0ss0"></a></p>

<h3>7. 
Bounds on codes, special matrices and miscellaneous functions
</h3>

<p>In this chapter we describe functions that determine bounds on the size and minimum distance of codes (Section <a href="chap7.html#s1ss0"><b>7.1</b></a>), functions that determine bounds on the size and covering radius of codes (Section <a href="chap7.html#s2ss0"><b>7.2</b></a>), functions that work with special matrices <strong class="pkg">GUAVA</strong> needs for several codes (see Section <a href="chap7.html#s3ss0"><b>7.3</b></a>), and constructing codes or performing calculations with codes (see Section <a href="chap7.html#s5ss0"><b>7.5</b></a>).</p>

<p><a id="s1ss0" name="s1ss0"></a></p>

<h4>7.1 
Distance bounds on codes
</h4>

<p>This section describes the functions that calculate estimates for upper bounds on the size and minimum distance of codes. Several algorithms are known to compute a largest number of words a code can have with given length and minimum distance. It is important however to understand that in some cases the true upper bound is unknown. A code which has a size equalto the calculated upper bound may not have been found. However, codes that have a larger size do not exist.</p>

<p>A second way to obtain bounds is a table. In <strong class="pkg">GUAVA</strong>, an extensive table is implemented for linear codes over GF(2), GF(3) and GF(4). It contains bounds on the minimum distance for given word length and dimension. For binary codes, it contains entries for word length less than or equal to 257. For codes over GF(3) and GF(4), it contains entries for word length less than or equal to 130.</p>

<p>Firstly, we describe functions that compute specific upper bounds on the code size (see <code class="func">UpperBoundSingleton</code> (<a href="chap7.html#s1ss1"><b>7.1-1</b></a>), <code class="func">UpperBoundHamming</code> (<a href="chap7.html#s1ss2"><b>7.1-2</b></a>), <code class="func">UpperBoundJohnson</code> (<a href="chap7.html#s1ss3"><b>7.1-3</b></a>), <code class="func">UpperBoundPlotkin</code> (<a href="chap7.html#s1ss4"><b>7.1-4</b></a>), <code class="func">UpperBoundElias</code> (<a href="chap7.html#s1ss5"><b>7.1-5</b></a>) and <code class="func">UpperBoundGriesmer</code> (<a href="chap7.html#s1ss6"><b>7.1-6</b></a>)).</p>

<p>Next we describe a function that computes <strong class="pkg">GUAVA</strong>'s best upper bound on the code size (see <code class="func">UpperBound</code> (<a href="chap7.html#s1ss7"><b>7.1-7</b></a>)).</p>

<p>Then we describe two functions that compute a lower and upper bound on the minimum distance of a code (see <code class="func">LowerBoundMinimumDistance</code> (<a href="chap7.html#s1ss8"><b>7.1-8</b></a>) and <code class="func">UpperBoundMinimumDistance</code> (<a href="chap7.html#s1ss11"><b>7.1-11</b></a>)).</p>

<p>Finally, we describe a function that returns a lower and upper bound on the minimum distance with given parameters and a description of how the bounds were obtained (see <code class="func">BoundsMinimumDistance</code> (<a href="chap7.html#s1ss12"><b>7.1-12</b></a>)).</p>

<p><a id="s1ss1" name="s1ss1"></a></p>

<h5>7.1-1 UpperBoundSingleton</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UpperBoundSingleton</code>( <var>n, d, q</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">UpperBoundSingleton</code> returns the Singleton bound for a code of length <var>n</var>, minimum distance <var>d</var> over a field of size <var>q</var>. This bound is based on the shortening of codes. By shortening an (n, M, d) code d-1 times, an (n-d+1,M,1) code results, with M &lt;= q^n-d+1 (see <code class="func">ShortenedCode</code> (<a href="chap6.html#s1ss9"><b>6.1-9</b></a>)). Thus</p>

<p class="pcenter">\[
M \leq q^{n-d+1}.
 \]</p>

<p>Codes that meet this bound are called <em>maximum distance separable</em> (see <code class="func">IsMDSCode</code> (<a href="chap3.html#s3ss7"><b>3.3-7</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; UpperBoundSingleton(4, 3, 5);
25
gap&gt; C := ReedSolomonCode(4,3);; Size(C);
25
gap&gt; IsMDSCode(C);
true 

</pre></td></tr></table>

<p><a id="s1ss2" name="s1ss2"></a></p>

<h5>7.1-2 UpperBoundHamming</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UpperBoundHamming</code>( <var>n, d, q</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The Hamming bound (also known as the <em>sphere packing bound</em>) returns an upper bound on the size of a code of length <var>n</var>, minimum distance <var>d</var>, over a field of size <var>q</var>. The Hamming bound is obtained by dividing the contents of the entire space GF(q)^n by the contents of a ball with radius lfloor(d-1) / 2rfloor. As all these balls are disjoint, they can never contain more than the whole vector space.</p>

<p class="pcenter">\[
M \leq {q^n \over V(n,e)},
 \]</p>

<p>where M is the maxmimum number of codewords and V(n,e) is equal to the contents of a ball of radius e (see <code class="func">SphereContent</code> (<a href="chap7.html#s5ss9"><b>7.5-9</b></a>)). This bound is useful for small values of <var>d</var>. Codes for which equality holds are called <em>perfect</em> (see <code class="func">IsPerfectCode</code> (<a href="chap3.html#s3ss6"><b>3.3-6</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; UpperBoundHamming( 15, 3, 2 );
2048
gap&gt; C := HammingCode( 4, GF(2) );
a linear [15,11,3]1 Hamming (4,2) code over GF(2)
gap&gt; Size( C );
2048 

</pre></td></tr></table>

<p><a id="s1ss3" name="s1ss3"></a></p>

<h5>7.1-3 UpperBoundJohnson</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UpperBoundJohnson</code>( <var>n, d</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The Johnson bound is an improved version of the Hamming bound (see <code class="func">UpperBoundHamming</code> (<a href="chap7.html#s1ss2"><b>7.1-2</b></a>)). In addition to the Hamming bound, it takes into account the elements of the space outside the balls of radius e around the elements of the code. The Johnson bound only works for binary codes.</p>


<table class="example">
<tr><td><pre>

gap&gt; UpperBoundJohnson( 13, 5 );
77
gap&gt; UpperBoundHamming( 13, 5, 2);
89   # in this case the Johnson bound is better 

</pre></td></tr></table>

<p><a id="s1ss4" name="s1ss4"></a></p>

<h5>7.1-4 UpperBoundPlotkin</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UpperBoundPlotkin</code>( <var>n, d, q</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The function <code class="code">UpperBoundPlotkin</code> calculates the sum of the distances of all ordered pairs of different codewords. It is based on the fact that the minimum distance is at most equal to the average distance. It is a good bound if the weights of the codewords do not differ much. It results in:</p>

<p class="pcenter">\[
M \leq {d \over {d-(1-1/q)n}},
 \]</p>

<p>where M is the maximum number of codewords. In this case, <var>d</var> must be larger than (1-1/q)n, but by shortening the code, the case d &lt; (1-1/q)n is covered.</p>


<table class="example">
<tr><td><pre>

gap&gt; UpperBoundPlotkin( 15, 7, 2 );
32
gap&gt; C := BCHCode( 15, 7, GF(2) );
a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
gap&gt; Size(C);
32
gap&gt; WeightDistribution(C);
[ 1, 0, 0, 0, 0, 0, 0, 15, 15, 0, 0, 0, 0, 0, 0, 1 ] 

</pre></td></tr></table>

<p><a id="s1ss5" name="s1ss5"></a></p>

<h5>7.1-5 UpperBoundElias</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UpperBoundElias</code>( <var>n, d, q</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The Elias bound is an improvement of the Plotkin bound (see <code class="func">UpperBoundPlotkin</code> (<a href="chap7.html#s1ss4"><b>7.1-4</b></a>)) for large codes. Subcodes are used to decrease the size of the code, in this case the subcode of all codewords within a certain ball. This bound is useful for large codes with relatively small minimum distances.</p>


<table class="example">
<tr><td><pre>

gap&gt; UpperBoundPlotkin( 16, 3, 2 );
12288
gap&gt; UpperBoundElias( 16, 3, 2 );
10280 
gap&gt; UpperBoundElias( 20, 10, 3 );
16255

</pre></td></tr></table>

<p><a id="s1ss6" name="s1ss6"></a></p>

<h5>7.1-6 UpperBoundGriesmer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UpperBoundGriesmer</code>( <var>n, d, q</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The Griesmer bound is valid only for linear codes. It is obtained by counting the number of equal symbols in each row of the generator matrix of the code. By omitting the coordinates in which all rows have a zero, a smaller code results. The Griesmer bound is obtained by repeating this proces until a trivial code is left in the end.</p>


<table class="example">
<tr><td><pre>

gap&gt; UpperBoundGriesmer( 13, 5, 2 );
64
gap&gt; UpperBoundGriesmer( 18, 9, 2 );
8        # the maximum number of words for a linear code is 8
gap&gt; Size( PuncturedCode( HadamardCode( 20, 1 ) ) );
20       # this non-linear code has 20 elements 

</pre></td></tr></table>

<p><a id="s1ss7" name="s1ss7"></a></p>

<h5>7.1-7 UpperBound</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UpperBound</code>( <var>n, d, q</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">UpperBound</code> returns the best known upper bound A(n,d) for the size of a code of length <var>n</var>, minimum distance <var>d</var> over a field of size <var>q</var>. The function <code class="code">UpperBound</code> first checks for trivial cases (like d=1 or n=d), and if the value is in the built-in table. Then it calculates the minimum value of the upper bound using the methods of Singleton (see <code class="func">UpperBoundSingleton</code> (<a href="chap7.html#s1ss1"><b>7.1-1</b></a>)), Hamming (see <code class="func">UpperBoundHamming</code> (<a href="chap7.html#s1ss2"><b>7.1-2</b></a>)), Johnson (see <code class="func">UpperBoundJohnson</code> (<a href="chap7.html#s1ss3"><b>7.1-3</b></a>)), Plotkin (see <code class="func">UpperBoundPlotkin</code> (<a href="chap7.html#s1ss4"><b>7.1-4</b></a>)) and Elias (see <code class="func">UpperBoundElias</code> (<a href="chap7.html#s1ss5"><b>7.1-5</b></a>)). If the code is binary, A(n, 2* ell-1) = A(n+1,2* ell), so the <code class="code">UpperBound</code> takes the minimum of the values obtained from all methods for the parameters (n, 2*ell-1) and (n+1, 2* ell).</p>


<table class="example">
<tr><td><pre>

gap&gt; UpperBound( 10, 3, 2 );
85
gap&gt; UpperBound( 25, 9, 8 );
1211778792827540 

</pre></td></tr></table>

<p><a id="s1ss8" name="s1ss8"></a></p>

<h5>7.1-8 LowerBoundMinimumDistance</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LowerBoundMinimumDistance</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>In this form, <code class="code">LowerBoundMinimumDistance</code> returns a lower bound for the minimum distance of code <var>C</var>.</p>

<p>This command can also be called using the syntax <code class="code">LowerBoundMinimumDistance( n, k, F )</code>. In this form, <code class="code">LowerBoundMinimumDistance</code> returns a lower bound for the minimum distance of the best known linear code of length <var>n</var>, dimension <var>k</var> over field <var>F</var>. It uses the mechanism explained in section <a href="chap7.html#s1ss12"><b>7.1-12</b></a>.</p>


<table class="example">
<tr><td><pre>

gap&gt; C := BCHCode( 45, 7 );
a cyclic [45,23,7..9]6..16 BCH code, delta=7, b=1 over GF(2)
gap&gt; LowerBoundMinimumDistance( C );
7     # designed distance is lower bound for minimum distance 
gap&gt; LowerBoundMinimumDistance( 45, 23, GF(2) );
10 

</pre></td></tr></table>

<p><a id="s1ss9" name="s1ss9"></a></p>

<h5>7.1-9 LowerBoundGilbertVarshamov</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LowerBoundGilbertVarshamov</code>( <var>n, d, q</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This is the lower bound due (independently) to Gilbert and Varshamov. It says that for each <var>n</var> and <var>d</var>, there exists a linear code having length n and minimum distance d at least of size q^n-1/ SphereContent(n-1,d-2,GF(q)).</p>


<table class="example">
<tr><td><pre>

gap&gt; LowerBoundGilbertVarshamov(3,2,2);
4
gap&gt; LowerBoundGilbertVarshamov(3,3,2);
1
gap&gt; LowerBoundMinimumDistance(3,3,2);
1
gap&gt; LowerBoundMinimumDistance(3,2,2);
2

</pre></td></tr></table>

<p><a id="s1ss10" name="s1ss10"></a></p>

<h5>7.1-10 LowerBoundSpherePacking</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LowerBoundSpherePacking</code>( <var>n, d, q</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This is the lower bound due (independently) to Gilbert and Varshamov. It says that for each <var>n</var> and <var>r</var>, there exists an unrestricted code at least of size q^n/ SphereContent(n,d,GF(q)) minimum distance d.</p>


<table class="example">
<tr><td><pre>

gap&gt; LowerBoundSpherePacking(3,2,2);
2
gap&gt; LowerBoundSpherePacking(3,3,2);
1

</pre></td></tr></table>

<p><a id="s1ss11" name="s1ss11"></a></p>

<h5>7.1-11 UpperBoundMinimumDistance</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UpperBoundMinimumDistance</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>In this form, <code class="code">UpperBoundMinimumDistance</code> returns an upper bound for the minimum distance of code <var>C</var>. For unrestricted codes, it just returns the word length. For linear codes, it takes the minimum of the possibly known value from the method of construction, the weight of the generators, and the value from the table (see <a href="chap7.html#s1ss12"><b>7.1-12</b></a>).</p>

<p>This command can also be called using the syntax <code class="code">UpperBoundMinimumDistance( n, k, F )</code>. In this form, <code class="code">UpperBoundMinimumDistance</code> returns an upper bound for the minimum distance of the best known linear code of length <var>n</var>, dimension <var>k</var> over field <var>F</var>. It uses the mechanism explained in section <a href="chap7.html#s1ss12"><b>7.1-12</b></a>.</p>


<table class="example">
<tr><td><pre>

gap&gt; C := BCHCode( 45, 7 );;
gap&gt; UpperBoundMinimumDistance( C );
9 
gap&gt; UpperBoundMinimumDistance( 45, 23, GF(2) );
11 

</pre></td></tr></table>

<p><a id="s1ss12" name="s1ss12"></a></p>

<h5>7.1-12 BoundsMinimumDistance</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BoundsMinimumDistance</code>( <var>n, k, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The function <code class="code">BoundsMinimumDistance</code> calculates a lower and upper bound for the minimum distance of an optimal linear code with word length <var>n</var>, dimension <var>k</var> over field <var>F</var>. The function returns a record with the two bounds and an explenation for each bound. The function <code class="code">Display</code> can be used to show the explanations.</p>

<p>The values for the lower and upper bound are obtained from a table. <strong class="pkg">GUAVA</strong> has tables containing lower and upper bounds for q=2 (n &lt;= 257), 3, 4 (n &lt;= 130). (Current as of 1998.) These tables were derived from the table of Brouwer and Verhoeff. (See <a href="http://www.win.tue.nl/~aeb/voorlincod.html">http://www.win.tue.nl/~aeb/voorlincod.html</a>.) For codes over other fields and for larger word lengths, trivial bounds are used.</p>

<p>The resulting record can be used in the function <code class="code">BestKnownLinearCode</code> (see <code class="func">BestKnownLinearCode</code> (<a href="chap5.html#s2ss12"><b>5.2-12</b></a>)) to construct a code with minimum distance equal to the lower bound.</p>


<table class="example">
<tr><td><pre>

gap&gt; bounds := BoundsMinimumDistance( 7, 3 );; DisplayBoundsInfo( bounds );
an optimal linear [7,3,d] code over GF(2) has d=4
------------------------------------------------------------------------------
Lb(7,3)=4, by shortening of:
Lb(8,4)=4, u u+v construction of C1 and C2:
Lb(4,3)=2, dual of the repetition code
Lb(4,1)=4, repetition code
------------------------------------------------------------------------------
Ub(7,3)=4, Griesmer bound
# The lower bound is equal to the upper bound, so a code with
# these parameters is optimal.
gap&gt; C := BestKnownLinearCode( bounds );; Display( C );
a linear [7,3,4]2..3 shortened code of
a linear [8,4,4]2 U U+V construction code of
U: a cyclic [4,3,2]1 dual code of
   a cyclic [4,1,4]2 repetition code over GF(2)
V: a cyclic [4,1,4]2 repetition code over GF(2)

</pre></td></tr></table>

<p><a id="s2ss0" name="s2ss0"></a></p>

<h4>7.2 
Covering radius bounds on codes
</h4>

<p><a id="s2ss1" name="s2ss1"></a></p>

<h5>7.2-1 BoundsCoveringRadius</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BoundsCoveringRadius</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">BoundsCoveringRadius</code> returns a list of integers. The first entry of this list is the maximum of some lower bounds for the covering radius of <var>C</var>, the last entry the minimum of some upper bounds of <var>C</var>.</p>

<p>If the covering radius of <var>C</var> is known, a list of length 1 is returned. <code class="code">BoundsCoveringRadius</code> makes use of the functions <code class="code">GeneralLowerBoundCoveringRadius</code> and <code class="code">GeneralUpperBoundCoveringRadius</code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; BoundsCoveringRadius( BCHCode( 17, 3, GF(2) ) );
[ 3 .. 4 ]
gap&gt; BoundsCoveringRadius( HammingCode( 5, GF(2) ) );
[ 1 ] 

</pre></td></tr></table>

<p><a id="s2ss2" name="s2ss2"></a></p>

<h5>7.2-2 IncreaseCoveringRadiusLowerBound</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IncreaseCoveringRadiusLowerBound</code>( <var>C[, stopdist][,][startword]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">IncreaseCoveringRadiusLowerBound</code> tries to increase the lower bound of the covering radius of <var>C</var>. It does this by means of a probabilistic algorithm. This algorithm takes a random word in GF(q)^n (or <var>startword</var> if it is specified), and, by changing random coordinates, tries to get as far from <var>C</var> as possible. If changing a coordinate finds a word that has a larger distance to the code than the previous one, the change is made permanent, and the algorithm starts all over again. If changing a coordinate does not find a coset leader that is further away from the code, then the change is made permanent with a chance of 1 in 100, if it gets the word closer to the code, or with a chance of 1 in 10, if the word stays at the same distance. Otherwise, the algorithm starts again with the same word as before.</p>

<p>If the algorithm did not allow changes that decrease the distance to the code, it might get stuck in a sub-optimal situation (the coset leader corresponding to such a situation - i.e. no coordinate of this coset leader can be changed in such a way that we get at a larger distance from the code - is called an <em>orphan</em>).</p>

<p>If the algorithm finds a word that has distance <var>stopdist</var> to the code, it ends and returns that word, which can be used for further investigations.</p>

<p>The variable <var>InfoCoveringRadius</var> can be set to <var>Print</var> to print the maximum distance reached so far every 1000 runs. The algorithm can be interrupted with <strong class="button">ctrl-C</strong>, allowing the user to look at the word that is currently being examined (called `current'), or to change the chances that the new word is made permanent (these are called `staychance' and `downchance'). If one of these variables is i, then it corresponds with a i in 100 chance.</p>

<p>At the moment, the algorithm is only useful for codes with small dimension, where small means that the elements of the code fit in the memory. It works with larger codes, however, but when you use it for codes with large dimension, you should be <em>very</em> patient. If running the algorithm quits <strong class="pkg">GAP</strong> (due to memory problems), you can change the global variable <var>CRMemSize</var> to a lower value. This might cause the algorithm to run slower, but without quitting <strong class="pkg">GAP</strong>. The only way to find out the best value of <var>CRMemSize</var> is by experimenting.</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(10,5,GF(2));
a  [10,5,?] randomly generated code over GF(2)
gap&gt; IncreaseCoveringRadiusLowerBound(C,10);
Number of runs: 1000  best distance so far: 3
Number of runs: 2000  best distance so far: 3
Number of changes: 100
Number of runs: 3000  best distance so far: 3
Number of runs: 4000  best distance so far: 3
Number of runs: 5000  best distance so far: 3
Number of runs: 6000  best distance so far: 3
Number of runs: 7000  best distance so far: 3
Number of changes: 200
Number of runs: 8000  best distance so far: 3
Number of runs: 9000  best distance so far: 3
Number of runs: 10000  best distance so far: 3
Number of changes: 300
Number of runs: 11000  best distance so far: 3
Number of runs: 12000  best distance so far: 3
Number of runs: 13000  best distance so far: 3
Number of changes: 400
Number of runs: 14000  best distance so far: 3
user interrupt at... 
#
# used ctrl-c to break out of execution
#
... called from 
IncreaseCoveringRadiusLowerBound( code, -1, current ) called from
 function( arguments ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk&gt; current;
[ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ]
brk&gt;
gap&gt; CoveringRadius(C);
3


</pre></td></tr></table>

<p><a id="s2ss3" name="s2ss3"></a></p>

<h5>7.2-3 ExhaustiveSearchCoveringRadius</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ExhaustiveSearchCoveringRadius</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ExhaustiveSearchCoveringRadius</code> does an exhaustive search to find the covering radius of <var>C</var>. Every time a coset leader of a coset with weight w is found, the function tries to find a coset leader of a coset with weight w+1. It does this by enumerating all words of weight w+1, and checking whether a word is a coset leader. The start weight is the current known lower bound on the covering radius.</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(10,5,GF(2));
a  [10,5,?] randomly generated code over GF(2)
gap&gt; ExhaustiveSearchCoveringRadius(C);
Trying 3 ...
[ 3 .. 5 ]
gap&gt; CoveringRadius(C);
3


</pre></td></tr></table>

<p><a id="s2ss4" name="s2ss4"></a></p>

<h5>7.2-4 GeneralLowerBoundCoveringRadius</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GeneralLowerBoundCoveringRadius</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">GeneralLowerBoundCoveringRadius</code> returns a lower bound on the covering radius of <var>C</var>. It uses as many functions which names start with <code class="code">LowerBoundCoveringRadius</code> as possible to find the best known lower bound (at least that <strong class="pkg">GUAVA</strong> knows of) together with tables for the covering radius of binary linear codes with length not greater than $64$.</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(10,5,GF(2));
a  [10,5,?] randomly generated code over GF(2)
gap&gt; GeneralLowerBoundCoveringRadius(C);
2
gap&gt; CoveringRadius(C);
3


</pre></td></tr></table>

<p><a id="s2ss5" name="s2ss5"></a></p>

<h5>7.2-5 GeneralUpperBoundCoveringRadius</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GeneralUpperBoundCoveringRadius</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">GeneralUpperBoundCoveringRadius</code> returns an upper bound on the covering radius of <var>C</var>. It uses as many functions which names start with <code class="code">UpperBoundCoveringRadius</code> as possible to find the best known upper bound (at least that <strong class="pkg">GUAVA</strong> knows of).</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(10,5,GF(2));
a  [10,5,?] randomly generated code over GF(2)
gap&gt; GeneralUpperBoundCoveringRadius(C);
4
gap&gt; CoveringRadius(C);
3


</pre></td></tr></table>

<p><a id="s2ss6" name="s2ss6"></a></p>

<h5>7.2-6 LowerBoundCoveringRadiusSphereCovering</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LowerBoundCoveringRadiusSphereCovering</code>( <var>n, M[, F,] false</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This command can also be called using the syntax <code class="code">LowerBoundCoveringRadiusSphereCovering( n, r, [F,] true )</code>. If the last argument of <code class="code">LowerBoundCoveringRadiusSphereCovering</code> is <var>false</var>, then it returns a lower bound for the covering radius of a code of size <var>M</var> and length <var>n</var>. Otherwise, it returns a lower bound for the size of a code of length <var>n</var> and covering radius <var>r</var>.</p>

<p><var>F</var> is the field over which the code is defined. If <var>F</var> is omitted, it is assumed that the code is over GF(2). The bound is computed according to the sphere covering bound:</p>

<p class="pcenter">\[
M \cdot V_q(n,r) \geq q^n
 \]</p>

<p>where V_q(n,r) is the size of a sphere of radius r in GF(q)^n.</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(10,5,GF(2));
a  [10,5,?] randomly generated code over GF(2)
gap&gt; Size(C);
32
gap&gt; CoveringRadius(C);
3
gap&gt; LowerBoundCoveringRadiusSphereCovering(10,32,GF(2),false);
2
gap&gt; LowerBoundCoveringRadiusSphereCovering(10,3,GF(2),true);
6


</pre></td></tr></table>

<p><a id="s2ss7" name="s2ss7"></a></p>

<h5>7.2-7 LowerBoundCoveringRadiusVanWee1</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LowerBoundCoveringRadiusVanWee1</code>( <var>n, M[, F,] false</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This command can also be called using the syntax <code class="code">LowerBoundCoveringRadiusVanWee1( n, r, [F,] true )</code>. If the last argument of <code class="code">LowerBoundCoveringRadiusVanWee1</code> is <var>false</var>, then it returns a lower bound for the covering radius of a code of size <var>M</var> and length <var>n</var>. Otherwise, it returns a lower bound for the size of a code of length <var>n</var> and covering radius <var>r</var>.</p>

<p><var>F</var> is the field over which the code is defined. If <var>F</var> is omitted, it is assumed that the code is over GF(2).</p>

<p>The Van Wee bound is an improvement of the sphere covering bound:</p>

<p class="pcenter">\[
M \cdot \left\{ V_q(n,r) -
\frac{{n \choose r}}{\lceil\frac{n-r}{r+1}\rceil}
\left(\left\lceil\frac{n+1}{r+1}\right\rceil - \frac{n+1}{r+1}\right)
\right\} \geq q^n
 \]</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(10,5,GF(2));
a  [10,5,?] randomly generated code over GF(2)
gap&gt; Size(C);
32
gap&gt; CoveringRadius(C);
3
gap&gt; LowerBoundCoveringRadiusVanWee1(10,32,GF(2),false);
2
gap&gt; LowerBoundCoveringRadiusVanWee1(10,3,GF(2),true);
6


</pre></td></tr></table>

<p><a id="s2ss8" name="s2ss8"></a></p>

<h5>7.2-8 LowerBoundCoveringRadiusVanWee2</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LowerBoundCoveringRadiusVanWee2</code>( <var>n, M, false</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This command can also be called using the syntax <code class="code">LowerBoundCoveringRadiusVanWee2( n, r [,true] )</code>. If the last argument of <code class="code">LowerBoundCoveringRadiusVanWee2</code> is <var>false</var>, then it returns a lower bound for the covering radius of a code of size <var>M</var> and length <var>n</var>. Otherwise, it returns a lower bound for the size of a code of length <var>n</var> and covering radius <var>r</var>.</p>

<p>This bound only works for binary codes. It is based on the following inequality:</p>

<p class="pcenter">\[
M \cdot \frac{\left( \left( V_2(n,2) - \frac{1}{2}(r+2)(r-1) \right)
V_2(n,r) + \varepsilon
V_2(n,r-2) \right)}
{(V_2(n,2) - \frac{1}{2}(r+2)(r-1) + \varepsilon)}
\geq 2^n,
 \]</p>

<p>where</p>

<p class="pcenter">\[
\varepsilon = {r+2 \choose 2} \left\lceil
{n-r+1 \choose 2} / {r+2 \choose 2} \right\rceil
- {n-r+1 \choose 2}.
 \]</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(10,5,GF(2));
a  [10,5,?] randomly generated code over GF(2)
gap&gt; Size(C);
32
gap&gt; CoveringRadius(C);
3
gap&gt; LowerBoundCoveringRadiusVanWee2(10,32,false);
2
gap&gt; LowerBoundCoveringRadiusVanWee2(10,3,true);
7


</pre></td></tr></table>

<p><a id="s2ss9" name="s2ss9"></a></p>

<h5>7.2-9 LowerBoundCoveringRadiusCountingExcess</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LowerBoundCoveringRadiusCountingExcess</code>( <var>n, M, false</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This command can also be called with <code class="code">LowerBoundCoveringRadiusCountingExcess( n, r [,true] )</code>. If the last argument of <code class="code">LowerBoundCoveringRadiusCountingExcess</code> is <var>false</var>, then it returns a lower bound for the covering radius of a code of size <var>M</var> and length <var>n</var>. Otherwise, it returns a lower bound for the size of a code of length <var>n</var> and covering radius <var>r</var>.</p>

<p>This bound only works for binary codes. It is based on the following inequality:</p>

<p class="pcenter">\[
M \cdot \left( \rho V_2(n,r) + \varepsilon V_2(n,r-1) \right) \geq
(\rho + \varepsilon) 2^n,
 \]</p>

<p>where</p>

<p class="pcenter">\[
\varepsilon = (r+1) \left\lceil\frac{n+1}{r+1}\right\rceil - (n+1)
 \]</p>

<p>and</p>

<p class="pcenter">\[
\rho = \left\{
\begin{array}{l}
n-3+\frac{2}{n}, \ \ \  \ \ \  {\rm if}\   r = 2\\
n-r-1  ,        \ \ \  \ \ \   {\rm if}\   r \geq 3 .
\end{array}
\right.
 \]</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(10,5,GF(2));
a  [10,5,?] randomly generated code over GF(2)
gap&gt; Size(C);
32
gap&gt; CoveringRadius(C);
3
gap&gt; LowerBoundCoveringRadiusCountingExcess(10,32,false);
0
gap&gt; LowerBoundCoveringRadiusCountingExcess(10,3,true);
7


</pre></td></tr></table>

<p><a id="s2ss10" name="s2ss10"></a></p>

<h5>7.2-10 LowerBoundCoveringRadiusEmbedded1</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LowerBoundCoveringRadiusEmbedded1</code>( <var>n, M, false</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This command can also be called with <code class="code">LowerBoundCoveringRadiusEmbedded1( n, r [,true] )</code>. If the last argument of <code class="code">LowerBoundCoveringRadiusEmbedded1</code> is 'false', then it returns a lower bound for the covering radius of a code of size <var>M</var> and length <var>n</var>. Otherwise, it returns a lower bound for the size of a code of length <var>n</var> and covering radius <var>r</var>.</p>

<p>This bound only works for binary codes. It is based on the following inequality:</p>

<p class="pcenter">\[
M \cdot \left( V_2(n,r) - {2r \choose r} \right) \geq
2^n - A( n, 2r+1 ) {2r \choose r},
 \]</p>

<p>where A(n,d) denotes the maximal cardinality of a (binary) code of length n and minimum distance d. The function <code class="code">UpperBound</code> is used to compute this value.</p>

<p>Sometimes <code class="code">LowerBoundCoveringRadiusEmbedded1</code> is better than <code class="code">LowerBoundCoveringRadiusEmbedded2</code>, sometimes it is the other way around.</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(10,5,GF(2));
a  [10,5,?] randomly generated code over GF(2)
gap&gt; Size(C);
32
gap&gt; CoveringRadius(C);
3
gap&gt; LowerBoundCoveringRadiusEmbedded1(10,32,false);
2
gap&gt; LowerBoundCoveringRadiusEmbedded1(10,3,true);
7


</pre></td></tr></table>

<p><a id="s2ss11" name="s2ss11"></a></p>

<h5>7.2-11 LowerBoundCoveringRadiusEmbedded2</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LowerBoundCoveringRadiusEmbedded2</code>( <var>n, M, false</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This command can also be called with <code class="code">LowerBoundCoveringRadiusEmbedded2( n, r [,true] )</code>. If the last argument of <code class="code">LowerBoundCoveringRadiusEmbedded2</code> is 'false', then it returns a lower bound for the covering radius of a code of size <var>M</var> and length <var>n</var>. Otherwise, it returns a lower bound for the size of a code of length <var>n</var> and covering radius <var>r</var>.</p>

<p>This bound only works for binary codes. It is based on the following inequality:</p>

<p class="pcenter">\[
M \cdot \left( V_2(n,r) - \frac{3}{2} {2r \choose r} \right) \geq
2^n - 2A( n, 2r+1 ) {2r \choose r},
 \]</p>

<p>where A(n,d) denotes the maximal cardinality of a (binary) code of length n and minimum distance d. The function <code class="code">UpperBound</code> is used to compute this value.</p>

<p>Sometimes <code class="code">LowerBoundCoveringRadiusEmbedded1</code> is better than <code class="code">LowerBoundCoveringRadiusEmbedded2</code>, sometimes it is the other way around.</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(15,5,GF(2));
a  [15,5,?] randomly generated code over GF(2)
gap&gt; Size(C);
32
gap&gt; CoveringRadius(C);
6
gap&gt; LowerBoundCoveringRadiusEmbedded2(10,32,false);
2
gap&gt; LowerBoundCoveringRadiusEmbedded2(10,3,true);
7


</pre></td></tr></table>

<p><a id="s2ss12" name="s2ss12"></a></p>

<h5>7.2-12 LowerBoundCoveringRadiusInduction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LowerBoundCoveringRadiusInduction</code>( <var>n, r</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">LowerBoundCoveringRadiusInduction</code> returns a lower bound for the size of a code with length <var>n</var> and covering radius <var>r</var>.</p>

<p>If n = 2r+2 and r &gt;= 1, the returned value is 4.</p>

<p>If n = 2r+3 and r &gt;= 1, the returned value is 7.</p>

<p>If n = 2r+4 and r &gt;= 4, the returned value is 8.</p>

<p>Otherwise, 0 is returned.</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(15,5,GF(2));
a  [15,5,?] randomly generated code over GF(2)
gap&gt; CoveringRadius(C);
5
gap&gt; LowerBoundCoveringRadiusInduction(15,6);
7


</pre></td></tr></table>

<p><a id="s2ss13" name="s2ss13"></a></p>

<h5>7.2-13 UpperBoundCoveringRadiusRedundancy</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UpperBoundCoveringRadiusRedundancy</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">UpperBoundCoveringRadiusRedundancy</code> returns the redundancy of <var>C</var> as an upper bound for the covering radius of <var>C</var>. <var>C</var> must be a linear code.</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(15,5,GF(2));
a  [15,5,?] randomly generated code over GF(2)
gap&gt; CoveringRadius(C);
5
gap&gt; UpperBoundCoveringRadiusRedundancy(C);
10


</pre></td></tr></table>

<p><a id="s2ss14" name="s2ss14"></a></p>

<h5>7.2-14 UpperBoundCoveringRadiusDelsarte</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UpperBoundCoveringRadiusDelsarte</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">UpperBoundCoveringRadiusDelsarte</code> returns an upper bound for the covering radius of <var>C</var>. This upper bound is equal to the external distance of <var>C</var>, this is the minimum distance of the dual code, if <var>C</var> is a linear code.</p>

<p>This is described in Theorem 11.3.3 of <a href="chapBib.html#biBHP03">[HP03]</a>.</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(15,5,GF(2));
a  [15,5,?] randomly generated code over GF(2)
gap&gt; CoveringRadius(C);
5
gap&gt; UpperBoundCoveringRadiusDelsarte(C);
13

</pre></td></tr></table>

<p><a id="s2ss15" name="s2ss15"></a></p>

<h5>7.2-15 UpperBoundCoveringRadiusStrength</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UpperBoundCoveringRadiusStrength</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">UpperBoundCoveringRadiusStrength</code> returns an upper bound for the covering radius of <var>C</var>.</p>

<p>First the code is punctured at the zero coordinates (i.e. the coordinates where all codewords have a zero). If the remaining code has <em>strength</em> 1 (i.e. each coordinate contains each element of the field an equal number of times), then it returns fracq-1qm + (n-m) (where q is the size of the field and m is the length of punctured code), otherwise it returns n. This bound works for all codes.</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(15,5,GF(2));
a  [15,5,?] randomly generated code over GF(2)
gap&gt; CoveringRadius(C);
5
gap&gt; UpperBoundCoveringRadiusStrength(C);
7

</pre></td></tr></table>

<p><a id="s2ss16" name="s2ss16"></a></p>

<h5>7.2-16 UpperBoundCoveringRadiusGriesmerLike</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UpperBoundCoveringRadiusGriesmerLike</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This function returns an upper bound for the covering radius of <var>C</var>, which must be linear, in a Griesmer-like fashion. It returns</p>

<p class="pcenter">\[
n - \sum_{i=1}^k \left\lceil \frac{d}{q^i} \right\rceil
 \]</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(15,5,GF(2));
a  [15,5,?] randomly generated code over GF(2)
gap&gt; CoveringRadius(C);
5
gap&gt; UpperBoundCoveringRadiusGriesmerLike(C);
9


</pre></td></tr></table>

<p><a id="s2ss17" name="s2ss17"></a></p>

<h5>7.2-17 UpperBoundCoveringRadiusCyclicCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UpperBoundCoveringRadiusCyclicCode</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This function returns an upper bound for the covering radius of <var>C</var>, which must be a cyclic code. It returns</p>

<p class="pcenter">\[
n - k + 1 - \left\lceil \frac{w(g(x))}{2} \right\rceil,
 \]</p>

<p>where g(x) is the generator polynomial of <var>C</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=CyclicCodes(15,GF(2))[3];
a cyclic [15,12,1..2]1..3 enumerated code over GF(2)
gap&gt; CoveringRadius(C);
3
gap&gt; UpperBoundCoveringRadiusCyclicCode(C);
3


</pre></td></tr></table>

<p><a id="s3ss0" name="s3ss0"></a></p>

<h4>7.3 
Special matrices in <strong class="pkg">GUAVA</strong>
</h4>

<p>This section explains functions that work with special matrices <strong class="pkg">GUAVA</strong> needs for several codes.</p>

<p>Firstly, we describe some matrix generating functions (see <code class="func">KrawtchoukMat</code> (<a href="chap7.html#s3ss1"><b>7.3-1</b></a>), <code class="func">GrayMat</code> (<a href="chap7.html#s3ss2"><b>7.3-2</b></a>), <code class="func">SylvesterMat</code> (<a href="chap7.html#s3ss3"><b>7.3-3</b></a>), <code class="func">HadamardMat</code> (<a href="chap7.html#s3ss4"><b>7.3-4</b></a>) and <code class="func">MOLS</code> (<a href="chap7.html#s3ss11"><b>7.3-11</b></a>)).</p>

<p>Next we describe two functions regarding a standard form of matrices (see <code class="func">PutStandardForm</code> (<a href="chap7.html#s3ss6"><b>7.3-6</b></a>) and <code class="func">IsInStandardForm</code> (<a href="chap7.html#s3ss7"><b>7.3-7</b></a>)).</p>

<p>Then we describe functions that return a matrix after a manipulation (see <code class="func">PermutedCols</code> (<a href="chap7.html#s3ss8"><b>7.3-8</b></a>), <code class="func">VerticalConversionFieldMat</code> (<a href="chap7.html#s3ss9"><b>7.3-9</b></a>) and <code class="func">HorizontalConversionFieldMat</code> (<a href="chap7.html#s3ss10"><b>7.3-10</b></a>)).</p>

<p>Finally, we describe functions that do some tests on matrices (see <code class="func">IsLatinSquare</code> (<a href="chap7.html#s3ss12"><b>7.3-12</b></a>) and <code class="func">AreMOLS</code> (<a href="chap7.html#s3ss13"><b>7.3-13</b></a>)).</p>

<p><a id="s3ss1" name="s3ss1"></a></p>

<h5>7.3-1 KrawtchoukMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; KrawtchoukMat</code>( <var>n, q</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">KrawtchoukMat</code> returns the n+1 by n+1 matrix K=(k_ij) defined by k_ij=K_i(j) for i,j=0,...,n. K_i(j) is the Krawtchouk number (see <code class="func">Krawtchouk</code> (<a href="chap7.html#s5ss10"><b>7.5-10</b></a>)). <var>n</var> must be a positive integer and <var>q</var> a prime power. The Krawtchouk matrix is used in the <em>MacWilliams identities</em>, defining the relation between the weight distribution of a code of length <var>n</var> over a field of size <var>q</var>, and its dual code. Each call to <code class="code">KrawtchoukMat</code> returns a new matrix, so it is safe to modify the result.</p>


<table class="example">
<tr><td><pre>

gap&gt; PrintArray( KrawtchoukMat( 3, 2 ) );
[ [   1,   1,   1,   1 ],
  [   3,   1,  -1,  -3 ],
  [   3,  -1,  -1,   3 ],
  [   1,  -1,   1,  -1 ] ]
gap&gt; C := HammingCode( 3 );; a := WeightDistribution( C );
[ 1, 0, 0, 7, 7, 0, 0, 1 ]
gap&gt; n := WordLength( C );; q := Size( LeftActingDomain( C ) );;
gap&gt; k := Dimension( C );;
gap&gt; q^( -k ) * KrawtchoukMat( n, q ) * a;
[ 1, 0, 0, 0, 7, 0, 0, 0 ]
gap&gt; WeightDistribution( DualCode( C ) );
[ 1, 0, 0, 0, 7, 0, 0, 0 ] 

</pre></td></tr></table>

<p><a id="s3ss2" name="s3ss2"></a></p>

<h5>7.3-2 GrayMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GrayMat</code>( <var>n, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">GrayMat</code> returns a list of all different vectors (see <strong class="pkg">GAP</strong>'s <code class="code">Vectors</code> command) of length <var>n</var> over the field <var>F</var>, using Gray ordering. <var>n</var> must be a positive integer. This order has the property that subsequent vectors differ in exactly one coordinate. The first vector is always the null vector. Each call to <code class="code">GrayMat</code> returns a new matrix, so it is safe to modify the result.</p>


<table class="example">
<tr><td><pre>

gap&gt; GrayMat(3);
[ [ 0*Z(2), 0*Z(2), 0*Z(2) ], [ 0*Z(2), 0*Z(2), Z(2)^0 ],
  [ 0*Z(2), Z(2)^0, Z(2)^0 ], [ 0*Z(2), Z(2)^0, 0*Z(2) ],
  [ Z(2)^0, Z(2)^0, 0*Z(2) ], [ Z(2)^0, Z(2)^0, Z(2)^0 ],
  [ Z(2)^0, 0*Z(2), Z(2)^0 ], [ Z(2)^0, 0*Z(2), 0*Z(2) ] ]
gap&gt; G := GrayMat( 4, GF(4) );; Length(G);
256          # the length of a GrayMat is always $q^n$
gap&gt; G[101] - G[100];
[ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] 

</pre></td></tr></table>

<p><a id="s3ss3" name="s3ss3"></a></p>

<h5>7.3-3 SylvesterMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SylvesterMat</code>( <var>n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">SylvesterMat</code> returns the ntimes n Sylvester matrix of order <var>n</var>. This is a special case of the Hadamard matrices (see <code class="func">HadamardMat</code> (<a href="chap7.html#s3ss4"><b>7.3-4</b></a>)). For this construction, <var>n</var> must be a power of 2. Each call to <code class="code">SylvesterMat</code> returns a new matrix, so it is safe to modify the result.</p>


<table class="example">
<tr><td><pre>

gap&gt; PrintArray(SylvesterMat(2));
[ [   1,   1 ],
  [   1,  -1 ] ]
gap&gt; PrintArray( SylvesterMat(4) );
[ [   1,   1,   1,   1 ],
  [   1,  -1,   1,  -1 ],
  [   1,   1,  -1,  -1 ],
  [   1,  -1,  -1,   1 ] ] 

</pre></td></tr></table>

<p><a id="s3ss4" name="s3ss4"></a></p>

<h5>7.3-4 HadamardMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; HadamardMat</code>( <var>n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">HadamardMat</code> returns a Hadamard matrix of order <var>n</var>. This is an ntimes n matrix with the property that the matrix multiplied by its transpose returns <var>n</var> times the identity matrix. This is only possible for n=1, n=2 or in cases where <var>n</var> is a multiple of 4. If the matrix does not exist or is not known (as of 1998), <code class="code">HadamardMat</code> returns an error. A large number of construction methods is known to create these matrices for different orders. <code class="code">HadamardMat</code> makes use of two construction methods (among which the Sylvester construction -- see <code class="func">SylvesterMat</code> (<a href="chap7.html#s3ss3"><b>7.3-3</b></a>)). These methods cover most of the possible Hadamard matrices, although some special algorithms have not been implemented yet. The following orders less than 100 do not yet have an implementation for a Hadamard matrix in <strong class="pkg">GUAVA</strong>: 28, 36, 52, 76, 92.</p>


<table class="example">
<tr><td><pre>

gap&gt; C := HadamardMat(8);; PrintArray(C);
[ [   1,   1,   1,   1,   1,   1,   1,   1 ],
  [   1,  -1,   1,  -1,   1,  -1,   1,  -1 ],
  [   1,   1,  -1,  -1,   1,   1,  -1,  -1 ],
  [   1,  -1,  -1,   1,   1,  -1,  -1,   1 ],
  [   1,   1,   1,   1,  -1,  -1,  -1,  -1 ],
  [   1,  -1,   1,  -1,  -1,   1,  -1,   1 ],
  [   1,   1,  -1,  -1,  -1,  -1,   1,   1 ],
  [   1,  -1,  -1,   1,  -1,   1,   1,  -1 ] ]
gap&gt; C * TransposedMat(C) = 8 * IdentityMat( 8, 8 );
true 

</pre></td></tr></table>

<p><a id="s3ss5" name="s3ss5"></a></p>

<h5>7.3-5 VandermondeMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; VandermondeMat</code>( <var>X, a</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The function <code class="code">VandermondeMat</code> returns the (a+1)times n matrix of powers x_i^j where <var>X</var> is a list of elements of a field, X= x_1,...,x_n, and <var>a</var> is a non-negative integer.</p>


<table class="example">
<tr><td><pre>

gap&gt; M:=VandermondeMat([Z(5),Z(5)^2,Z(5)^0,Z(5)^3],2);
[ [ Z(5)^0, Z(5), Z(5)^2 ], [ Z(5)^0, Z(5)^2, Z(5)^0 ],
  [ Z(5)^0, Z(5)^0, Z(5)^0 ], [ Z(5)^0, Z(5)^3, Z(5)^2 ] ]
gap&gt; Display(M);
 1 2 4
 1 4 1
 1 1 1
 1 3 4

</pre></td></tr></table>

<p><a id="s3ss6" name="s3ss6"></a></p>

<h5>7.3-6 PutStandardForm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PutStandardForm</code>( <var>M[, idleft]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>We say that a ktimes n matrix is in <em>standard form</em> if it is equal to the block matrix (I | A), for some ktimes (n-k) matrix A and where I is the ktimes k identity matrix. It follows from a basis result in linear algebra that, after a possible permutation of the columns, using elementary row operations, every matrix can be reduced to standard form. <code class="code">PutStandardForm</code> puts a matrix <var>M</var> in standard form, and returns the permutation needed to do so. <var>idleft</var> is a boolean that sets the position of the identity matrix in <var>M</var>. (The default for <var>idleft</var> is `true'.) If <var>idleft</var> is set to `true', the identity matrix is put on the left side of <var>M</var>. Otherwise, it is put at the right side. (This option is useful when putting a check matrix of a code into standard form.) The function <code class="code">BaseMat</code> also returns a similar standard form, but does not apply column permutations. The rows of the matrix still span the same vector space after <code class="code">BaseMat</code>, but after calling <code class="code">PutStandardForm</code>, this is not necessarily true.</p>


<table class="example">
<tr><td><pre>

gap&gt; M := Z(2)*[[1,0,0,1],[0,0,1,1]];; PrintArray(M);
[ [    Z(2),  0*Z(2),  0*Z(2),    Z(2) ],
  [  0*Z(2),  0*Z(2),    Z(2),    Z(2) ] ]
gap&gt; PutStandardForm(M);                   # identity at the left side
(2,3)
gap&gt; PrintArray(M);
[ [    Z(2),  0*Z(2),  0*Z(2),    Z(2) ],
  [  0*Z(2),    Z(2),  0*Z(2),    Z(2) ] ]
gap&gt; PutStandardForm(M, false);            # identity at the right side
(1,4,3)
gap&gt; PrintArray(M);
[ [  0*Z(2),    Z(2),    Z(2),  0*Z(2) ],
  [  0*Z(2),    Z(2),  0*Z(2),    Z(2) ] ]

</pre></td></tr></table>

<p><a id="s3ss7" name="s3ss7"></a></p>

<h5>7.3-7 IsInStandardForm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsInStandardForm</code>( <var>M[, idleft]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">IsInStandardForm</code> determines if <var>M</var> is in standard form. <var>idleft</var> is a boolean that indicates the position of the identity matrix in <var>M</var>, as in <code class="code">PutStandardForm</code> (see <code class="func">PutStandardForm</code> (<a href="chap7.html#s3ss6"><b>7.3-6</b></a>)). <code class="code">IsInStandardForm</code> checks if the identity matrix is at the left side of <var>M</var>, otherwise if it is at the right side. The elements of <var>M</var> may be elements of any field.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsInStandardForm(IdentityMat(7, GF(2)));
true
gap&gt; IsInStandardForm([[1, 1, 0], [1, 0, 1]], false);
true
gap&gt; IsInStandardForm([[1, 3, 2, 7]]);
true
gap&gt; IsInStandardForm(HadamardMat(4));
false 

</pre></td></tr></table>

<p><a id="s3ss8" name="s3ss8"></a></p>

<h5>7.3-8 PermutedCols</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PermutedCols</code>( <var>M, P</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">PermutedCols</code> returns a matrix <var>M</var> with a permutation <var>P</var> applied to its columns.</p>


<table class="example">
<tr><td><pre>

gap&gt; M := [[1,2,3,4],[1,2,3,4]];; PrintArray(M);
[ [  1,  2,  3,  4 ],
  [  1,  2,  3,  4 ] ]
gap&gt; PrintArray(PermutedCols(M, (1,2,3)));
[ [  3,  1,  2,  4 ],
  [  3,  1,  2,  4 ] ] 

</pre></td></tr></table>

<p><a id="s3ss9" name="s3ss9"></a></p>

<h5>7.3-9 VerticalConversionFieldMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; VerticalConversionFieldMat</code>( <var>M, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">VerticalConversionFieldMat</code> returns the matrix <var>M</var> with its elements converted from a field F=GF(q^m), q prime, to a field GF(q). Each element is replaced by its representation over the latter field, placed vertically in the matrix, using the GF(p)-vector space isomorphism</p>

<p class="pcenter">\[

[...] : GF(q)\rightarrow GF(p)^m,
 \]</p>

<p>with q=p^m.</p>

<p>If <var>M</var> is a k by n matrix, the result is a k* m times n matrix, since each element of GF(q^m) can be represented in GF(q) using m elements.</p>


<table class="example">
<tr><td><pre>

gap&gt; M := Z(9)*[[1,2],[2,1]];; PrintArray(M);
[ [    Z(3^2),  Z(3^2)^5 ],
  [  Z(3^2)^5,    Z(3^2) ] ]
gap&gt; DefaultField( Flat(M) );
GF(3^2)
gap&gt; VCFM := VerticalConversionFieldMat( M, GF(9) );; PrintArray(VCFM);
[ [  0*Z(3),  0*Z(3) ],
  [  Z(3)^0,    Z(3) ],
  [  0*Z(3),  0*Z(3) ],
  [    Z(3),  Z(3)^0 ] ]
gap&gt; DefaultField( Flat(VCFM) );
GF(3) 

</pre></td></tr></table>

<p>A similar function is <code class="code">HorizontalConversionFieldMat</code> (see <code class="func">HorizontalConversionFieldMat</code> (<a href="chap7.html#s3ss10"><b>7.3-10</b></a>)).</p>

<p><a id="s3ss10" name="s3ss10"></a></p>

<h5>7.3-10 HorizontalConversionFieldMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; HorizontalConversionFieldMat</code>( <var>M, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">HorizontalConversionFieldMat</code> returns the matrix <var>M</var> with its elements converted from a field F=GF(q^m), q prime, to a field GF(q). Each element is replaced by its representation over the latter field, placed horizontally in the matrix.</p>

<p>If <var>M</var> is a k times n matrix, the result is a ktimes mtimes n* m matrix. The new word length of the resulting code is equal to n* m, because each element of GF(q^m) can be represented in GF(q) using m elements. The new dimension is equal to ktimes m because the new matrix should be a basis for the same number of vectors as the old one.</p>

<p><code class="code">ConversionFieldCode</code> uses horizontal conversion to convert a code (see <code class="func">ConversionFieldCode</code> (<a href="chap6.html#s1ss14"><b>6.1-14</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; M := Z(9)*[[1,2],[2,1]];; PrintArray(M);
[ [    Z(3^2),  Z(3^2)^5 ],
  [  Z(3^2)^5,    Z(3^2) ] ]
gap&gt; DefaultField( Flat(M) );
GF(3^2)
gap&gt; HCFM := HorizontalConversionFieldMat(M, GF(9));; PrintArray(HCFM);
[ [  0*Z(3),  Z(3)^0,  0*Z(3),    Z(3) ],
  [  Z(3)^0,  Z(3)^0,    Z(3),    Z(3) ],
  [  0*Z(3),    Z(3),  0*Z(3),  Z(3)^0 ],
  [    Z(3),    Z(3),  Z(3)^0,  Z(3)^0 ] ]
gap&gt; DefaultField( Flat(HCFM) );
GF(3) 

</pre></td></tr></table>

<p>A similar function is <code class="code">VerticalConversionFieldMat</code> (see <code class="func">VerticalConversionFieldMat</code> (<a href="chap7.html#s3ss9"><b>7.3-9</b></a>)).</p>

<p><a id="s3ss11" name="s3ss11"></a></p>

<h5>7.3-11 MOLS</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MOLS</code>( <var>q[, n]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">MOLS</code> returns a list of <var>n</var> <em>Mutually Orthogonal Latin Squares</em> (MOLS). A <em>Latin square</em> of order <var>q</var> is a qtimes q matrix whose entries are from a set F_q of <var>q</var> distinct symbols (<strong class="pkg">GUAVA</strong> uses the integers from 0 to <var>q</var>) such that each row and each column of the matrix contains each symbol exactly once.</p>

<p>A set of Latin squares is a set of MOLS if and only if for each pair of Latin squares in this set, every ordered pair of elements that are in the same position in these matrices occurs exactly once.</p>

<p><var>n</var> must be less than <var>q</var>. If <var>n</var> is omitted, two MOLS are returned. If <var>q</var> is not a prime power, at most 2 MOLS can be created. For all values of <var>q</var> with q &gt; 2 and q &lt;&gt; 6, a list of MOLS can be constructed. However, <strong class="pkg">GUAVA</strong> does not yet construct MOLS for q= 2 mod 4. If it is not possible to construct <var>n</var> MOLS, the function returns `false'.</p>

<p>MOLS are used to create <var>q</var>-ary codes (see <code class="func">MOLSCode</code> (<a href="chap5.html#s1ss4"><b>5.1-4</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; M := MOLS( 4, 3 );;PrintArray( M[1] );
[ [  0,  1,  2,  3 ],
  [  1,  0,  3,  2 ],
  [  2,  3,  0,  1 ],
  [  3,  2,  1,  0 ] ]
gap&gt; PrintArray( M[2] );
[ [  0,  2,  3,  1 ],
  [  1,  3,  2,  0 ],
  [  2,  0,  1,  3 ],
  [  3,  1,  0,  2 ] ]
gap&gt; PrintArray( M[3] );
[ [  0,  3,  1,  2 ],
  [  1,  2,  0,  3 ],
  [  2,  1,  3,  0 ],
  [  3,  0,  2,  1 ] ]
gap&gt; MOLS( 12, 3 );
false 

</pre></td></tr></table>

<p><a id="s3ss12" name="s3ss12"></a></p>

<h5>7.3-12 IsLatinSquare</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsLatinSquare</code>( <var>M</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">IsLatinSquare</code> determines if a matrix <var>M</var> is a Latin square. For a Latin square of size ntimes n, each row and each column contains all the integers 1,dots,n exactly once.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsLatinSquare([[1,2],[2,1]]);
true
gap&gt; IsLatinSquare([[1,2,3],[2,3,1],[1,3,2]]);
false 

</pre></td></tr></table>

<p><a id="s3ss13" name="s3ss13"></a></p>

<h5>7.3-13 AreMOLS</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AreMOLS</code>( <var>L</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">AreMOLS</code> determines if <var>L</var> is a list of mutually orthogonal Latin squares (MOLS). For each pair of Latin squares in this list, the function checks if each ordered pair of elements that are in the same position in these matrices occurs exactly once. The function <code class="code">MOLS</code> creates MOLS (see <code class="func">MOLS</code> (<a href="chap7.html#s3ss11"><b>7.3-11</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; M := MOLS(4,2);
[ [ [ 0, 1, 2, 3 ], [ 1, 0, 3, 2 ], [ 2, 3, 0, 1 ], [ 3, 2, 1, 0 ] ],
  [ [ 0, 2, 3, 1 ], [ 1, 3, 2, 0 ], [ 2, 0, 1, 3 ], [ 3, 1, 0, 2 ] ] ]
gap&gt; AreMOLS(M);
true 

</pre></td></tr></table>

<p><a id="s4ss0" name="s4ss0"></a></p>

<h4>7.4 
Some functions related to the norm of a code
</h4>

<p>In this section, some functions that can be used to compute the norm of a code and to decide upon its normality are discussed. Typically, these are applied to binary linear codes. The definitions of this section were introduced in Graham and Sloane <a href="chapBib.html#biBGS85">[GS85]</a>.</p>

<p><a id="s4ss1" name="s4ss1"></a></p>

<h5>7.4-1 CoordinateNorm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CoordinateNorm</code>( <var>C, coord</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">CoordinateNorm</code> returns the norm of <var>C</var> with respect to coordinate <var>coord</var>. If C_a = c in C | c_coord = a, then the norm of <var>C</var> with respect to <var>coord</var> is defined as</p>

<p class="pcenter">\[
\max_{v \in GF(q)^n} \sum_{a=1}^q d(x,C_a),
 \]</p>

<p>with the convention that d(x,C_a) = n if C_a is empty.</p>


<table class="example">
<tr><td><pre>

gap&gt; CoordinateNorm( HammingCode( 3, GF(2) ), 3 );
3 

</pre></td></tr></table>

<p><a id="s4ss2" name="s4ss2"></a></p>

<h5>7.4-2 CodeNorm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CodeNorm</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">CodeNorm</code> returns the norm of <var>C</var>. The <em>norm</em> of a code is defined as the minimum of the norms for the respective coordinates of the code. In effect, for each coordinate <code class="code">CoordinateNorm</code> is called, and the minimum of the calculated numbers is returned.</p>


<table class="example">
<tr><td><pre>

gap&gt; CodeNorm( HammingCode( 3, GF(2) ) );
3 

</pre></td></tr></table>

<p><a id="s4ss3" name="s4ss3"></a></p>

<h5>7.4-3 IsCoordinateAcceptable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsCoordinateAcceptable</code>( <var>C, coord</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">IsCoordinateAcceptable</code> returns `true' if coordinate <var>coord</var> of <var>C</var> is acceptable. A coordinate is called <em>acceptable</em> if the norm of the code with respect to that coordinate is not more than two times the covering radius of the code plus one.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsCoordinateAcceptable( HammingCode( 3, GF(2) ), 3 );
true 

</pre></td></tr></table>

<p><a id="s4ss4" name="s4ss4"></a></p>

<h5>7.4-4 GeneralizedCodeNorm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GeneralizedCodeNorm</code>( <var>C, subcode1, subscode2, ..., subcodek</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">GeneralizedCodeNorm</code> returns the <var>k</var>-norm of <var>C</var> with respect to <var>k</var> subcodes.</p>


<table class="example">
<tr><td><pre>

gap&gt; c := RepetitionCode( 7, GF(2) );;
gap&gt; ham := HammingCode( 3, GF(2) );;
gap&gt; d := EvenWeightSubcode( ham );;
gap&gt; e := ConstantWeightSubcode( ham, 3 );;
gap&gt; GeneralizedCodeNorm( ham, c, d, e );
4 

</pre></td></tr></table>

<p><a id="s4ss5" name="s4ss5"></a></p>

<h5>7.4-5 IsNormalCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsNormalCode</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">IsNormalCode</code> returns `true' if <var>C</var> is normal. A code is called <em>normal</em> if the norm of the code is not more than two times the covering radius of the code plus one. Almost all codes are normal, however some (non-linear) abnormal codes have been found.</p>

<p>Often, it is difficult to find out whether a code is normal, because it involves computing the covering radius. However, <code class="code">IsNormalCode</code> uses much information from the literature (in particular, <a href="chapBib.html#biBGS85">[GS85]</a>) about normality for certain code parameters.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsNormalCode( HammingCode( 3, GF(2) ) );
true 

</pre></td></tr></table>

<p><a id="s5ss0" name="s5ss0"></a></p>

<h4>7.5 
Miscellaneous functions
</h4>

<p>In this section we describe several functions <strong class="pkg">GUAVA</strong> uses for constructing codes or performing calculations with codes.</p>

<p>In this section, some new miscellaneous functions are described, including weight enumerators, the MacWilliams-transform and affinity and almost affinity of codes.</p>

<p><a id="s5ss1" name="s5ss1"></a></p>

<h5>7.5-1 CodeWeightEnumerator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CodeWeightEnumerator</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">CodeWeightEnumerator</code> returns a polynomial of the following form:</p>

<p class="pcenter">\[
f(x) = \sum_{i=0}^{n} A_i x^i,
 \]</p>

<p>where A_i is the number of codewords in <var>C</var> with weight i.</p>


<table class="example">
<tr><td><pre>

gap&gt; CodeWeightEnumerator( ElementsCode( [ [ 0,0,0 ], [ 0,0,1 ],
&gt; [ 0,1,1 ], [ 1,1,1 ] ], GF(2) ) );
x^3 + x^2 + x + 1
gap&gt; CodeWeightEnumerator( HammingCode( 3, GF(2) ) );
x^7 + 7*x^4 + 7*x^3 + 1 

</pre></td></tr></table>

<p><a id="s5ss2" name="s5ss2"></a></p>

<h5>7.5-2 CodeDistanceEnumerator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CodeDistanceEnumerator</code>( <var>C, w</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">CodeDistanceEnumerator</code> returns a polynomial of the following form:</p>

<p class="pcenter">\[
f(x) = \sum_{i=0}^{n} B_i x^i,
 \]</p>

<p>where B_i is the number of codewords with distance i to <var>w</var>.</p>

<p>If <var>w</var> is a codeword, then <code class="code">CodeDistanceEnumerator</code> returns the same polynomial as <code class="code">CodeWeightEnumerator</code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; CodeDistanceEnumerator( HammingCode( 3, GF(2) ),[0,0,0,0,0,0,1] );
x^6 + 3*x^5 + 4*x^4 + 4*x^3 + 3*x^2 + x
gap&gt; CodeDistanceEnumerator( HammingCode( 3, GF(2) ),[1,1,1,1,1,1,1] );
x^7 + 7*x^4 + 7*x^3 + 1 # `[1,1,1,1,1,1,1]' $\in$ `HammingCode( 3, GF(2 ) )'

</pre></td></tr></table>

<p><a id="s5ss3" name="s5ss3"></a></p>

<h5>7.5-3 CodeMacWilliamsTransform</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CodeMacWilliamsTransform</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">CodeMacWilliamsTransform</code> returns a polynomial of the following form:</p>

<p class="pcenter">\[
f(x) = \sum_{i=0}^{n} C_i x^i,
 \]</p>

<p>where C_i is the number of codewords with weight i in the <em>dual</em> code of <var>C</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; CodeMacWilliamsTransform( HammingCode( 3, GF(2) ) );
7*x^4 + 1 

</pre></td></tr></table>

<p><a id="s5ss4" name="s5ss4"></a></p>

<h5>7.5-4 IsSelfComplementaryCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsSelfComplementaryCode</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">IsSelfComplementaryCode</code> returns `true' if</p>

<p class="pcenter">\[
v \in code \Rightarrow 1 - v \in code,
 \]</p>

<p>where 1 is the all-one word of length n.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsSelfComplementaryCode( HammingCode( 3, GF(2) ) );
true
gap&gt; IsSelfComplementaryCode( EvenWeightSubcode(
&gt; HammingCode( 3, GF(2) ) ) );
false 

</pre></td></tr></table>

<p><a id="s5ss5" name="s5ss5"></a></p>

<h5>7.5-5 IsAffineCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsAffineCode</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">IsAffineCode</code> returns `true' if <var>C</var> is an affine code. A code is called <em>affine</em> if it is an affine space. In other words, a code is affine if it is a coset of a linear code.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsAffineCode( HammingCode( 3, GF(2) ) );
true
gap&gt; IsAffineCode( CosetCode( HammingCode( 3, GF(2) ),
&gt; [ 1, 0, 0, 0, 0, 0, 0 ] ) );
true
gap&gt; IsAffineCode( NordstromRobinsonCode() );
false 

</pre></td></tr></table>

<p><a id="s5ss6" name="s5ss6"></a></p>

<h5>7.5-6 IsAlmostAffineCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsAlmostAffineCode</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">IsAlmostAffineCode</code> returns `true' if <var>C</var> is an almost affine code. A code is called <em>almost affine</em> if the size of any punctured code of <var>C</var> is q^r for some r, where q is the size of the alphabet of the code. Every affine code is also almost affine, and every code over GF(2) and GF(3) that is almost affine is also affine.</p>


<table class="example">
<tr><td><pre>

gap&gt; code := ElementsCode( [ [0,0,0], [0,1,1], [0,2,2], [0,3,3],
&gt;                             [1,0,1], [1,1,0], [1,2,3], [1,3,2],
&gt;                             [2,0,2], [2,1,3], [2,2,0], [2,3,1],
&gt;                             [3,0,3], [3,1,2], [3,2,1], [3,3,0] ],
&gt;                             GF(4) );;
gap&gt; IsAlmostAffineCode( code );
true
gap&gt; IsAlmostAffineCode( NordstromRobinsonCode() );
false 

</pre></td></tr></table>

<p><a id="s5ss7" name="s5ss7"></a></p>

<h5>7.5-7 IsGriesmerCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsGriesmerCode</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">IsGriesmerCode</code> returns `true' if <var>C</var>, which must be a linear code, is Griesmer code, and `false' otherwise. A code is called <em>Griesmer</em> if its length satisfies</p>

<p class="pcenter">\[
n = g[k,d] = \sum_{i=0}^{k-1} \lceil \frac{d}{q^i} \rceil.
 \]</p>


<table class="example">
<tr><td><pre>

gap&gt; IsGriesmerCode( HammingCode( 3, GF(2) ) );
true
gap&gt; IsGriesmerCode( BCHCode( 17, 2, GF(2) ) );
false 

</pre></td></tr></table>

<p><a id="s5ss8" name="s5ss8"></a></p>

<h5>7.5-8 CodeDensity</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CodeDensity</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">CodeDensity</code> returns the <em>density</em> of <var>C</var>. The density of a code is defined as</p>

<p class="pcenter">\[
\frac{M \cdot V_q(n,t)}{q^n},
 \]</p>

<p>where M is the size of the code, V_q(n,t) is the size of a sphere of radius t in GF(q^n) (which may be computed using <code class="code">SphereContent</code>), t is the covering radius of the code and n is the length of the code.</p>


<table class="example">
<tr><td><pre>

gap&gt; CodeDensity( HammingCode( 3, GF(2) ) );
1
gap&gt; CodeDensity( ReedMullerCode( 1, 4 ) );
14893/2048 

</pre></td></tr></table>

<p><a id="s5ss9" name="s5ss9"></a></p>

<h5>7.5-9 SphereContent</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SphereContent</code>( <var>n, t, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">SphereContent</code> returns the content of a ball of radius <var>t</var> around an arbitrary element of the vectorspace F^n. This is the cardinality of the set of all elements of F^n that are at distance (see <code class="func">DistanceCodeword</code> (<a href="chap2.html#s6ss2"><b>2.6-2</b></a>) less than or equal to <var>t</var> from an element of F^n.</p>

<p>In the context of codes, the function is used to determine if a code is perfect. A code is <em>perfect</em> if spheres of radius t around all codewords contain exactly the whole vectorspace, where <em>t</em> is the number of errors the code can correct.</p>


<table class="example">
<tr><td><pre>

gap&gt; SphereContent( 15, 0, GF(2) );
1    # Only one word with distance 0, which is the word itself
gap&gt; SphereContent( 11, 3, GF(4) );
4984
gap&gt; C := HammingCode(5);
a linear [31,26,3]1 Hamming (5,2) code over GF(2)
#the minimum distance is 3, so the code can correct one error
gap&gt; ( SphereContent( 31, 1, GF(2) ) * Size(C) ) = 2 ^ 31;
true 

</pre></td></tr></table>

<p><a id="s5ss10" name="s5ss10"></a></p>

<h5>7.5-10 Krawtchouk</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Krawtchouk</code>( <var>k, i, n, q</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">Krawtchouk</code> returns the Krawtchouk number K_k(i). <var>q</var> must be a prime power, <var>n</var> must be a positive integer, <var>k</var> must be a non-negative integer less then or equal to <var>n</var> and <var>i</var> can be any integer. (See <code class="func">KrawtchoukMat</code> (<a href="chap7.html#s3ss1"><b>7.3-1</b></a>)). This number is the value at x=i of the polynomial</p>

<p class="pcenter">\[
K_k^{n,q}(x)
=\sum_{j=0}^n (-1)^j(q-1)^{k-j}b(x,j)b(n-x,k-j),
 \]</p>

<p>where $b(v,u)=u!/(v!(v-u)!)$ is the binomial coefficient if $u,v$ are integers. For more properties of these polynomials, see <a href="chapBib.html#biBMS83">[MS83]</a>.</p>


<table class="example">
<tr><td><pre>

gap&gt; Krawtchouk( 2, 0, 3, 2);
3 

</pre></td></tr></table>

<p><a id="s5ss11" name="s5ss11"></a></p>

<h5>7.5-11 PrimitiveUnityRoot</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PrimitiveUnityRoot</code>( <var>F, n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">PrimitiveUnityRoot</code> returns a primitive <var>n</var>-th root of unity in an extension field of <var>F</var>. This is a finite field element a with the property a^n=1 in <var>F</var>, and <var>n</var> is the smallest integer such that this equality holds.</p>


<table class="example">
<tr><td><pre>

gap&gt; PrimitiveUnityRoot( GF(2), 15 );
Z(2^4)
gap&gt; last^15;
Z(2)^0
gap&gt; PrimitiveUnityRoot( GF(8), 21 );
Z(2^6)^3 

</pre></td></tr></table>

<p><a id="s5ss12" name="s5ss12"></a></p>

<h5>7.5-12 ReciprocalPolynomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ReciprocalPolynomial</code>( <var>P</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ReciprocalPolynomial</code> returns the <em>reciprocal</em> of polynomial <var>P</var>. This is a polynomial with coefficients of <var>P</var> in the reverse order. So if P=a_0 + a_1 X + ... + a_n X^n, the reciprocal polynomial is P'=a_n + a_n-1 X + ... + a_0 X^n.</p>

<p>This command can also be called using the syntax <code class="code">ReciprocalPolynomial( P , n )</code>. In this form, the number of coefficients of <var>P</var> is assumed to be less than or equal to n+1 (with zero coefficients added in the highest degrees, if necessary). Therefore, the reciprocal polynomial also has degree n+1.</p>


<table class="example">
<tr><td><pre>

gap&gt; P := UnivariatePolynomial( GF(3), Z(3)^0 * [1,0,1,2] );
Z(3)^0+x_1^2-x_1^3
gap&gt; RecP := ReciprocalPolynomial( P );
-Z(3)^0+x_1+x_1^3
gap&gt; ReciprocalPolynomial( RecP ) = P;
true 
gap&gt; P := UnivariatePolynomial( GF(3), Z(3)^0 * [1,0,1,2] );
Z(3)^0+x_1^2-x_1^3
gap&gt; ReciprocalPolynomial( P, 6 );
-x_1^3+x_1^4+x_1^6

</pre></td></tr></table>

<p><a id="s5ss13" name="s5ss13"></a></p>

<h5>7.5-13 CyclotomicCosets</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CyclotomicCosets</code>( <var>q, n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">CyclotomicCosets</code> returns the cyclotomic cosets of q mod n. <var>q</var> and <var>n</var> must be relatively prime. Each of the elements of the returned list is a list of integers that belong to one cyclotomic coset. A q-cyclotomic coset of s mod n is a set of the form s,sq,sq^2,...,sq^r-1, where r is the smallest positive integer such that sq^r-s is 0 mod n. In other words, each coset contains all multiplications of the coset representative by q mod n. The coset representative is the smallest integer that isn't in the previous cosets.</p>


<table class="example">
<tr><td><pre>

gap&gt; CyclotomicCosets( 2, 15 );
[ [ 0 ], [ 1, 2, 4, 8 ], [ 3, 6, 12, 9 ], [ 5, 10 ],
  [ 7, 14, 13, 11 ] ]
gap&gt; CyclotomicCosets( 7, 6 );
[ [ 0 ], [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ] ] 

</pre></td></tr></table>

<p><a id="s5ss14" name="s5ss14"></a></p>

<h5>7.5-14 WeightHistogram</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; WeightHistogram</code>( <var>C[, h]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The function <code class="code">WeightHistogram</code> plots a histogram of weights in code <var>C</var>. The maximum length of a column is <var>h</var>. Default value for <var>h</var> is 1/3 of the size of the screen. The number that appears at the top of the histogram is the maximum value of the list of weights.</p>


<table class="example">
<tr><td><pre>

gap&gt; H := HammingCode(2, GF(5));
a linear [6,4,3]1 Hamming (2,5) code over GF(5)
gap&gt; WeightDistribution(H);
[ 1, 0, 0, 80, 120, 264, 160 ]
gap&gt; WeightHistogram(H);
264----------------
               *
               *
               *
               *
               *  *
            *  *  *
         *  *  *  *
         *  *  *  *
+--------+--+--+--+--
0  1  2  3  4  5  6 

</pre></td></tr></table>

<p><a id="s5ss15" name="s5ss15"></a></p>

<h5>7.5-15 CoefficientToPolynomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CoefficientToPolynomial</code>( <var>coeffs, R</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The function <code class="code">CoefficientToPolynomial</code> returns the degree d-1 polynomial c_0+c_1x+...+c_d-1x^d-1, where <var>coeffs</var> is a list of elements of a field, coeffs= c_0,...,c_d-1, and <var>R</var> is a univariate polynomial ring.</p>


<table class="example">
<tr><td><pre>

gap&gt; F:=GF(11);
GF(11)
gap&gt; R1:=PolynomialRing(F,["a"]);;
gap&gt; var1:=IndeterminatesOfPolynomialRing(R1);; a:=var1[1];;
gap&gt; coeffs:=Z(11)^0*[1,2,3,4];
[ Z(11)^0, Z(11), Z(11)^8, Z(11)^2 ]
gap&gt; CoefficientToPolynomial(coeffs,R1);
Z(11)^2*a^3+Z(11)^8*a^2+Z(11)*a+Z(11)^0

</pre></td></tr></table>

<p><a id="s5ss16" name="s5ss16"></a></p>

<h5>7.5-16 DegreesMonomialTerm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DegreesMonomialTerm</code>( <var>m, R</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The function <code class="code">DegreesMonomialTerm</code> returns the list of degrees to which each variable in the multivariate polynomial ring <var>R</var> occurs in the monomial <var>m</var>, where <var>coeffs</var> is a list of elements of a field.</p>


<table class="example">
<tr><td><pre>

gap&gt; F:=GF(11);
GF(11)
gap&gt; R1:=PolynomialRing(F,["a"]);;
gap&gt; var1:=IndeterminatesOfPolynomialRing(R1);; a:=var1[1];;
gap&gt; b:=X(F,"b",var1);
b
gap&gt; var2:=Concatenation(var1,[b]);
[ a, b ]
gap&gt; R2:=PolynomialRing(F,var2);
PolynomialRing(..., [ a, b ])
gap&gt; c:=X(F,"c",var2);
c
gap&gt; var3:=Concatenation(var2,[c]);
[ a, b, c ]
gap&gt; R3:=PolynomialRing(F,var3);
PolynomialRing(..., [ a, b, c ])
gap&gt; m:=b^3*c^7;
b^3*c^7
gap&gt; DegreesMonomialTerm(m,R3);
[ 0, 3, 7 ]

</pre></td></tr></table>

<p><a id="s5ss17" name="s5ss17"></a></p>

<h5>7.5-17 DivisorsMultivariatePolynomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DivisorsMultivariatePolynomial</code>( <var>f, R</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The function <code class="code">DivisorsMultivariatePolynomial</code> returns the list of polynomial divisors of <var>f</var> in the multivariate polynomial ring <var>R</var> with coefficients in a field. This program uses a simple but slow algorithm (see Joachim von zur Gathen, J\"urgen Gerhard, <a href="chapBib.html#biBGG03">[GJ03]</a>, exercise 16.10) which first converts the multivariate polynomial <var>f</var> to an associated univariate polynomial f^*, then <code class="code">Factors</code> f^*, and finally converts these univariate factors back into the multivariate polynomial factors of <var>f</var>. Since <code class="code">Factors</code> is non-deterministic, <code class="code">DivisorsMultivariatePolynomial</code> is non-deterministic as well.</p>


<table class="example">
<tr><td><pre>

gap&gt; R2:=PolynomialRing(GF(3),["x1","x2"]);
PolynomialRing(..., [ x1, x2 ])
gap&gt; vars:=IndeterminatesOfPolynomialRing(R2);
[ x1, x2 ]
gap&gt; x2:=vars[2];
x2
gap&gt; x1:=vars[1];
x1
gap&gt; f:=x1^3+x2^3;;
gap&gt; DivisorsMultivariatePolynomial(f,R2);
[ x1+x2, x1+x2, x1+x2 ]

</pre></td></tr></table>


<div class="pcenter">
<table class="chlink"><tr><td><a href="chap0.html">Top of Book</a></td><td><a href="chap6.html">Previous Chapter</a></td><td><a href="chapBib.html">Next Chapter</a></td></tr></table>
<br />


<div class="pcenter"><table class="chlink"><tr><td class="chlink1">Goto Chapter: </td><td><a href="chap0.html">Top</a></td><td><a href="chap1.html">1</a></td><td><a href="chap2.html">2</a></td><td><a href="chap3.html">3</a></td><td><a href="chap4.html">4</a></td><td><a href="chap5.html">5</a></td><td><a href="chap6.html">6</a></td><td><a href="chap7.html">7</a></td><td><a href="chapBib.html">Bib</a></td><td><a href="chapInd.html">Ind</a></td></tr></table><br /></div>

</div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
