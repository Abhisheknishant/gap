<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (guava) - Chapter 2: Codewords</title>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body>


<div class="pcenter"><table class="chlink"><tr><td class="chlink1">Goto Chapter: </td><td><a href="chap0.html">Top</a></td><td><a href="chap1.html">1</a></td><td><a href="chap2.html">2</a></td><td><a href="chap3.html">3</a></td><td><a href="chap4.html">4</a></td><td><a href="chap5.html">5</a></td><td><a href="chap6.html">6</a></td><td><a href="chap7.html">7</a></td><td><a href="chapBib.html">Bib</a></td><td><a href="chapInd.html">Ind</a></td></tr></table><br /></div>
<p><a id="s0ss0" name="s0ss0"></a></p>

<h3>2. Codewords</h3>

<p>Let GF(q) denote a finite field with q (a prime power) elements. A <em>code</em> is a subset C of some finite-dimensional vector space V over GF(q). The <em>length</em> of C is the dimension of V. Usually, V=GF(q)^n and the length is the number of coordinate entries. When C is itself a vector space over GF(q) then it is called a <em>linear code</em> and the <em>dimension</em> of C is its dimension as a vector space over GF(q).</p>

<p>In <strong class="pkg">GUAVA</strong>, a `codeword' is a <strong class="pkg">GAP</strong> record, with one of its components being an element in V. Likewise, a `code' is a <strong class="pkg">GAP</strong> record, with one of its components being a subset (or subspace with given basis, if C is linear) of V.</p>


<table class="example">
<tr><td><pre>

  gap&gt; C:=RandomLinearCode(20,10,GF(4));
  a  [20,10,?] randomly generated code over GF(4)
  gap&gt; c:=Random(C);
  [ 1 a 0 0 0 1 1 a^2 0 0 a 1 1 1 a 1 1 a a 0 ]
  gap&gt; NamesOfComponents(C);
  [ "LeftActingDomain", "GeneratorsOfLeftOperatorAdditiveGroup", "WordLength",
    "GeneratorMat", "name", "Basis", "NiceFreeLeftModule", "Dimension", 
     "Representative", "ZeroImmutable" ]
  gap&gt; NamesOfComponents(c);
  [ "VectorCodeword", "WordLength", "treatAsPoly" ]
  gap&gt; c!.VectorCodeword;
  [ immutable compressed vector length 20 over GF(4) ] 
  gap&gt; Display(last);
  [ Z(2^2), Z(2^2), Z(2^2), Z(2)^0, Z(2^2), Z(2^2)^2, 0*Z(2), Z(2^2), Z(2^2),
    Z(2)^0, Z(2^2)^2, 0*Z(2), 0*Z(2), Z(2^2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2^2)^2,
    Z(2)^0, 0*Z(2) ]
  gap&gt; C!.Dimension;
  10

</pre></td></tr></table>

<p>Mathematically, a `codeword' is an element of a code C, but in <strong class="pkg">GUAVA</strong> the <code class="code">Codeword</code> and <code class="code">VectorCodeword</code> commands have implementations which do not check if the codeword belongs to C (i.e., are independent of the code itself). They exist primarily to make it easier for the user to construct a the associated <strong class="pkg">GAP</strong> record. Using these commands, one can enter into a <strong class="pkg">GAP</strong> both a codeword c (belonging to C) and a received word r (not belonging to C) using the same command. The user can input codewords in different formats (as strings, vectors, and polynomials), and output information is formatted in a readable way.</p>

<p>A codeword c in a linear code C arises in practice by an initial encoding of a 'block' message m, adding enough redundancy to recover m after c is transmitted via a 'noisy' communication medium. In <strong class="pkg">GUAVA</strong>, for linear codes, the map mlongmapsto c is computed using the command <code class="code">c:=m*C</code> and recovering m from c is obtained by the command <code class="code">InformationWord(c,C)</code>. These commands are explained more below.</p>

<p>Many operations are available on codewords themselves, although codewords also work together with codes (see chapter <a href="chap3.html#s0ss0"><b>3.</b></a> on Codes).</p>

<p>The first section describes how codewords are constructed (see <code class="func">Codeword</code> (<a href="chap2.html#s1ss1"><b>2.1-1</b></a>) and <code class="func">IsCodeword</code> (<a href="chap2.html#s1ss3"><b>2.1-3</b></a>)). Sections <a href="chap2.html#s2ss0"><b>2.2</b></a> and <a href="chap2.html#s3ss0"><b>2.3</b></a> describe the arithmetic operations applicable to codewords. Section <a href="chap2.html#s4ss0"><b>2.4</b></a> describe functions that convert codewords back to vectors or polynomials (see <code class="func">VectorCodeword</code> (<a href="chap2.html#s4ss1"><b>2.4-1</b></a>) and <code class="func">PolyCodeword</code> (<a href="chap2.html#s4ss2"><b>2.4-2</b></a>)). Section <b>???</b> describe functions that change the way a codeword is displayed (see <code class="func">TreatAsVector</code> (<a href="chap2.html#s5ss1"><b>2.5-1</b></a>) and <code class="func">TreatAsPoly</code> (<a href="chap2.html#s5ss2"><b>2.5-2</b></a>)). Finally, Section <a href="chap2.html#s6ss0"><b>2.6</b></a> describes a function to generate a null word (see <code class="func">NullWord</code> (<a href="chap2.html#s6ss1"><b>2.6-1</b></a>)) and some functions for extracting properties of codewords (see <code class="func">DistanceCodeword</code> (<a href="chap2.html#s6ss2"><b>2.6-2</b></a>), <code class="func">Support</code> (<a href="chap2.html#s6ss3"><b>2.6-3</b></a>) and <code class="func">WeightCodeword</code> (<a href="chap2.html#s6ss4"><b>2.6-4</b></a>)).</p>

<p><a id="s1ss0" name="s1ss0"></a></p>

<h4>2.1 Construction of Codewords</h4>

<p><a id="s1ss1" name="s1ss1"></a></p>

<h5>2.1-1 Codeword</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Codeword</code>( <var>obj[, n][,][F]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">Codeword</code> returns a codeword or a list of codewords constructed from <var>obj</var>. The object <var>obj</var> can be a vector, a string, a polynomial or a codeword. It may also be a list of those (even a mixed list).</p>

<p>If a number <var>n</var> is specified, all constructed codewords have length <var>n</var>. This is the only way to make sure that all elements of <var>obj</var> are converted to codewords of the same length. Elements of <var>obj</var> that are longer than <var>n</var> are reduced in length by cutting of the last positions. Elements of <var>obj</var> that are shorter than <var>n</var> are lengthened by adding zeros at the end. If no <var>n</var> is specified, each constructed codeword is handled individually.</p>

<p>If a Galois field <var>F</var> is specified, all codewords are constructed over this field. This is the only way to make sure that all elements of <var>obj</var> are converted to the same field <var>F</var> (otherwise they are converted one by one). Note that all elements of <var>obj</var> must have elements over <var>F</var> or over `Integers'. Converting from one Galois field to another is not allowed. If no <var>F</var> is specified, vectors or strings with integer elements will be converted to the smallest Galois field possible.</p>

<p>Note that a significant speed increase is achieved if <var>F</var> is specified, even when all elements of <var>obj</var> already have elements over <var>F</var>.</p>

<p>Every vector in <var>obj</var> can be a finite field vector over <var>F</var> or a vector over `Integers'. In the last case, it is converted to <var>F</var> or, if omitted, to the smallest Galois field possible.</p>

<p>Every string in <var>obj</var> must be a string of numbers, without spaces, commas or any other characters. These numbers must be from 0 to 9. The string is converted to a codeword over <var>F</var> or, if <var>F</var> is omitted, over the smallest Galois field possible. Note that since all numbers in the string are interpreted as one-digit numbers, Galois fields of size larger than 10 are not properly represented when using strings. In fact, no finite field of size larger than 11 arises in this fashion at all.</p>

<p>Every polynomial in <var>obj</var> is converted to a codeword of length <var>n</var> or, if omitted, of a length dictated by the degree of the polynomial. If <var>F</var> is specified, a polynomial in <var>obj</var> must be over <var>F</var>.</p>

<p>Every element of <var>obj</var> that is already a codeword is changed to a codeword of length <var>n</var>. If no <var>n</var> was specified, the codeword doesn't change. If <var>F</var> is specified, the codeword must have base field <var>F</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; c := Codeword([0,1,1,1,0]);
[ 0 1 1 1 0 ]
gap&gt; VectorCodeword( c ); 
[ 0*Z(2), Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2) ]
gap&gt; c2 := Codeword([0,1,1,1,0], GF(3));
[ 0 1 1 1 0 ]
gap&gt; VectorCodeword( c2 );
[ 0*Z(3), Z(3)^0, Z(3)^0, Z(3)^0, 0*Z(3) ]
gap&gt; Codeword([c, c2, "0110"]);
[ [ 0 1 1 1 0 ], [ 0 1 1 1 0 ], [ 0 1 1 0 ] ]
gap&gt; p := UnivariatePolynomial(GF(2), [Z(2)^0, 0*Z(2), Z(2)^0]);
Z(2)^0+x_1^2
gap&gt; Codeword(p);
x^2 + 1 

</pre></td></tr></table>

<p>This command can also be called using the syntax <code class="code">Codeword(obj,C)</code>. In this format, the elements of <var>obj</var> are converted to elements of the same ambient vector space as the elements of a code <var>C</var>. The command <code class="code">Codeword(c,C)</code> is the same as calling <code class="code">Codeword(c,n,F)</code>, where <var>n</var> is the word length of <var>C</var> and the <var>F</var> is the ground field of <var>C</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; C := WholeSpaceCode(7,GF(5));
a cyclic [7,7,1]0 whole space code over GF(5)
gap&gt; Codeword(["0220110", [1,1,1]], C);
[ [ 0 2 2 0 1 1 0 ], [ 1 1 1 0 0 0 0 ] ]
gap&gt; Codeword(["0220110", [1,1,1]], 7, GF(5));
[ [ 0 2 2 0 1 1 0 ], [ 1 1 1 0 0 0 0 ] ] 
gap&gt; C:=RandomLinearCode(10,5,GF(3));
a linear [10,5,1..3]3..5 random linear code over GF(3)
gap&gt; Codeword("1000000000",C);
[ 1 0 0 0 0 0 0 0 0 0 ]
gap&gt; Codeword("1000000000",10,GF(3));
[ 1 0 0 0 0 0 0 0 0 0 ]

</pre></td></tr></table>

<p><a id="s1ss2" name="s1ss2"></a></p>

<h5>2.1-2 CodewordNr</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CodewordNr</code>( <var>C, list</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">CodewordNr</code> returns a list of codewords of <var>C</var>. <var>list</var> may be a list of integers or a single integer. For each integer of <var>list</var>, the corresponding codeword of <var>C</var> is returned. The correspondence of a number i with a codeword is determined as follows: if a list of elements of <var>C</var> is available, the i^th element is taken. Otherwise, it is calculated by multiplication of the i^th information vector by the generator matrix or generator polynomial, where the information vectors are ordered lexicographically. In particular, the returned codeword(s) could be a vector or a polynomial. So <code class="code">CodewordNr(C, i)</code> is equal to <code class="code">AsSSortedList(C)[i]</code>, described in the next chapter. The latter function first calculates the set of all the elements of C and then returns the i^th element of that set, whereas the former only calculates the i^th codeword.</p>


<table class="example">
<tr><td><pre>

gap&gt; B := BinaryGolayCode();
a cyclic [23,12,7]3 binary Golay code over GF(2)
gap&gt; c := CodewordNr(B, 4);
x^22 + x^20 + x^17 + x^14 + x^13 + x^12 + x^11 + x^10
gap&gt; R := ReedSolomonCode(2,2);
a cyclic [2,1,2]1 Reed-Solomon code over GF(3)
gap&gt; AsSSortedList(R);
[ [ 0 0 ], [ 1 1 ], [ 2 2 ] ]
gap&gt; CodewordNr(R, [1,3]);
[ [ 0 0 ], [ 2 2 ] ]

</pre></td></tr></table>

<p><a id="s1ss3" name="s1ss3"></a></p>

<h5>2.1-3 IsCodeword</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsCodeword</code>( <var>obj</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">IsCodeword</code> returns `true' if <var>obj</var>, which can be an object of arbitrary type, is of the codeword type and `false' otherwise. The function will signal an error if <var>obj</var> is an unbound variable.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsCodeword(1);
false
gap&gt; IsCodeword(ReedMullerCode(2,3));
false
gap&gt; IsCodeword("11111");
false
gap&gt; IsCodeword(Codeword("11111"));
true 

</pre></td></tr></table>

<p><a id="s2ss0" name="s2ss0"></a></p>

<h4>2.2 Comparisons of Codewords</h4>

<p><a id="s2ss1" name="s2ss1"></a></p>

<h5>2.2-1 =</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; =</code>( <var>c1, c2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The equality operator <code class="code">c1 = c2</code> evaluates to `true' if the codewords <var>c1</var> and <var>c2</var> are equal, and to `false' otherwise. Note that codewords are equal if and only if their base vectors are equal. Whether they are represented as a vector or polynomial has nothing to do with the comparison.</p>

<p>Comparing codewords with objects of other types is not recommended, although it is possible. If <var>c2</var> is the codeword, the other object <var>c1</var> is first converted to a codeword, after which comparison is possible. This way, a codeword can be compared with a vector, polynomial, or string. If <var>c1</var> is the codeword, then problems may arise if <var>c2</var> is a polynomial. In that case, the comparison always yields a `false', because the polynomial comparison is called.</p>

<p>The equality operator is also denoted <code class="code">EQ</code>, and <code class="code">EQ(c1,c2)</code> is the same as <code class="code">c1 = c2</code>. There is also an inequality operator, &lt; &gt;, or <code class="code">not EQ</code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; P := UnivariatePolynomial(GF(2), Z(2)*[1,0,0,1]);
Z(2)^0+x_1^3
gap&gt; c := Codeword(P, GF(2));
x^3 + 1
gap&gt; P = c;        # codeword operation
true
gap&gt; c2 := Codeword("1001", GF(2));
[ 1 0 0 1 ]
gap&gt; c = c2;
true 
gap&gt; C:=HammingCode(3);
a linear [7,4,3]1 Hamming (3,2) code over GF(2)
gap&gt; c1:=Random(C);
[ 1 0 0 1 1 0 0 ]
gap&gt; c2:=Random(C);
[ 0 1 0 0 1 0 1 ]
gap&gt; EQ(c1,c2);
false
gap&gt; not EQ(c1,c2);
true

</pre></td></tr></table>

<p><a id="s3ss0" name="s3ss0"></a></p>

<h4>2.3 Arithmetic Operations for Codewords</h4>

<p><a id="s3ss1" name="s3ss1"></a></p>

<h5>2.3-1 +</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; +</code>( <var>c1, c2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The following operations are always available for codewords. The operands must have a common base field, and must have the same length. No implicit conversions are performed.</p>

<p>The operator <code class="code">+</code> evaluates to the sum of the codewords <var>c1</var> and <var>c2</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(10,5,GF(3));
a linear [10,5,1..3]3..5 random linear code over GF(3)
gap&gt; c:=Random(C);
[ 1 0 2 2 2 2 1 0 2 0 ]
gap&gt; Codeword(c+"2000000000");
[ 0 0 2 2 2 2 1 0 2 0 ]
gap&gt; Codeword(c+"1000000000");

</pre></td></tr></table>

<p>The last command return a <strong class="pkg">GAP</strong> ERROR since the `codeword' which <strong class="pkg">GUAVA</strong> associates to "1000000000" belongs to GF(2) and not GF(3).</p>

<p><a id="s3ss2" name="s3ss2"></a></p>

<h5>2.3-2 -</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; -</code>( <var>c1, c2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Similar to addition: the operator <code class="code">-</code> evaluates to the difference of the codewords <var>c1</var> and <var>c2</var>.</p>

<p><a id="s3ss3" name="s3ss3"></a></p>

<h5>2.3-3 +</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; +</code>( <var>v, C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The operator <code class="code">v+C</code> evaluates to the coset code of code <var>C</var> after adding a `codeword' <var>v</var> to all codewords in <var>C</var>. Note that if c in C then mathematically c+C=C but <strong class="pkg">GUAVA</strong> only sees them equal as <em>sets</em>. See <code class="func">CosetCode</code> (<a href="chap6.html#s1ss15"><b>6.1-15</b></a>).</p>

<p>Note that the command <code class="code">C+v</code> returns the same output as the command <code class="code">v+C</code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=RandomLinearCode(10,5);
a  [10,5,?] randomly generated code over GF(2)
gap&gt; c:=Random(C);
[ 0 0 0 0 0 0 0 0 0 0 ]
gap&gt; c+C;
[ add. coset of a  [10,5,?] randomly generated code over GF(2) ]
gap&gt; c+C=C;
true
gap&gt; IsLinearCode(c+C);
false
gap&gt; v:=Codeword("100000000");
[ 1 0 0 0 0 0 0 0 0 ]
gap&gt; v+C;
[ add. coset of a  [10,5,?] randomly generated code over GF(2) ]
gap&gt; C=v+C;
false
gap&gt; C := GeneratorMatCode( [ [1, 0,0,0], [0, 1,0,0] ], GF(2) );
a linear [4,2,1]1 code defined by generator matrix over GF(2)
gap&gt; Elements(C);
[ [ 0 0 0 0 ], [ 0 1 0 0 ], [ 1 0 0 0 ], [ 1 1 0 0 ] ]
gap&gt; v:=Codeword("0011");
[ 0 0 1 1 ]
gap&gt; C+v;
[ add. coset of a linear [4,2,4]1 code defined by generator matrix over GF(2) ]
gap&gt; Elements(C+v);
[ [ 0 0 1 1 ], [ 0 1 1 1 ], [ 1 0 1 1 ], [ 1 1 1 1 ] ]

</pre></td></tr></table>

<p>In general, the operations just described can also be performed on codewords expressed as vectors, strings or polynomials, although this is not recommended. The vector, string or polynomial is first converted to a codeword, after which the normal operation is performed. For this to go right, make sure that at least one of the operands is a codeword. Further more, it will not work when the right operand is a polynomial. In that case, the polynomial operations (<code class="code">FiniteFieldPolynomialOps</code>) are called, instead of the codeword operations (<code class="code">CodewordOps</code>).</p>

<p>Some other code-oriented operations with codewords are described in <a href="chap3.html#s2ss0"><b>3.2</b></a>.</p>

<p><a id="s4ss0" name="s4ss0"></a></p>

<h4>2.4 
Functions that Convert Codewords to Vectors or Polynomials
</h4>

<p><a id="s4ss1" name="s4ss1"></a></p>

<h5>2.4-1 VectorCodeword</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; VectorCodeword</code>( <var>obj</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Here <var>obj</var> can be a code word or a list of code words. This function returns the corresponding vectors over a finite field.</p>


<table class="example">
<tr><td><pre>

gap&gt; a := Codeword("011011");; 
gap&gt; VectorCodeword(a);
[ 0*Z(2), Z(2)^0, Z(2)^0, 0*Z(2), Z(2)^0, Z(2)^0 ]

</pre></td></tr></table>

<p><a id="s4ss2" name="s4ss2"></a></p>

<h5>2.4-2 PolyCodeword</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PolyCodeword</code>( <var>obj</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">PolyCodeword</code> returns a polynomial or a list of polynomials over a Galois field, converted from <var>obj</var>. The object <var>obj</var> can be a codeword, or a list of codewords.</p>


<table class="example">
<tr><td><pre>

gap&gt; a := Codeword("011011");; 
gap&gt; PolyCodeword(a);
x_1+x_1^2+x_1^4+x_1^5

</pre></td></tr></table>

<p><a id="s5ss0" name="s5ss0"></a></p>

<h4>2.5 
Functions that Change the Display Form of a Codeword
</h4>

<p><a id="s5ss1" name="s5ss1"></a></p>

<h5>2.5-1 TreatAsVector</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TreatAsVector</code>( <var>obj</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">TreatAsVector</code> adapts the codewords in <var>obj</var> to make sure they are printed as vectors. <var>obj</var> may be a codeword or a list of codewords. Elements of <var>obj</var> that are not codewords are ignored. After this function is called, the codewords will be treated as vectors. The vector representation is obtained by using the coefficient list of the polynomial.</p>

<p>Note that this <em>only</em> changes the way a codeword is <em>printed</em>. <code class="code">TreatAsVector</code> returns nothing, it is called only for its side effect. The function <code class="code">VectorCodeword</code> converts codewords to vectors (see <code class="func">VectorCodeword</code> (<a href="chap2.html#s4ss1"><b>2.4-1</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; B := BinaryGolayCode();
a cyclic [23,12,7]3 binary Golay code over GF(2)
gap&gt; c := CodewordNr(B, 4);
x^22 + x^20 + x^17 + x^14 + x^13 + x^12 + x^11 + x^10
gap&gt; TreatAsVector(c);
gap&gt; c;
[ 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 1 0 0 1 0 1 ] 

</pre></td></tr></table>

<p><a id="s5ss2" name="s5ss2"></a></p>

<h5>2.5-2 TreatAsPoly</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TreatAsPoly</code>( <var>obj</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">TreatAsPoly</code> adapts the codewords in <var>obj</var> to make sure they are printed as polynomials. <var>obj</var> may be a codeword or a list of codewords. Elements of <var>obj</var> that are not codewords are ignored. After this function is called, the codewords will be treated as polynomials. The finite field vector that defines the codeword is used as a coefficient list of the polynomial representation, where the first element of the vector is the coefficient of degree zero, the second element is the coefficient of degree one, etc, until the last element, which is the coefficient of highest degree.</p>

<p>Note that this <em>only</em> changes the way a codeword is <em>printed</em>. <code class="code">TreatAsPoly</code> returns nothing, it is called only for its side effect. The function <code class="code">PolyCodeword</code> converts codewords to polynomials (see <code class="func">PolyCodeword</code> (<a href="chap2.html#s4ss2"><b>2.4-2</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; a := Codeword("00001",GF(2));
[ 0 0 0 0 1 ]
gap&gt; TreatAsPoly(a); a;
x^4
gap&gt; b := NullWord(6,GF(4));
[ 0 0 0 0 0 0 ]
gap&gt; TreatAsPoly(b); b;
0 

</pre></td></tr></table>

<p><a id="s6ss0" name="s6ss0"></a></p>

<h4>2.6 
Other Codeword Functions
</h4>

<p><a id="s6ss1" name="s6ss1"></a></p>

<h5>2.6-1 NullWord</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; NullWord</code>( <var>n, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Other uses: <code class="code">NullWord( n )</code> (default F=GF(2)) and <code class="code">NullWord( C )</code>. <code class="code">NullWord</code> returns a codeword of length <var>n</var> over the field <var>F</var> of only zeros. The integer <var>n</var> must be greater then zero. If only a code <var>C</var> is specified, <code class="code">NullWord</code> will return a null word with both the word length and the Galois field of <var>C</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; NullWord(8);
[ 0 0 0 0 0 0 0 0 ]
gap&gt; Codeword("0000") = NullWord(4);
true
gap&gt; NullWord(5,GF(16));
[ 0 0 0 0 0 ]
gap&gt; NullWord(ExtendedTernaryGolayCode());
[ 0 0 0 0 0 0 0 0 0 0 0 0 ] 

</pre></td></tr></table>

<p><a id="s6ss2" name="s6ss2"></a></p>

<h5>2.6-2 DistanceCodeword</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DistanceCodeword</code>( <var>c1, c2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">DistanceCodeword</code> returns the Hamming distance from <var>c1</var> to <var>c2</var>. Both variables must be codewords with equal word length over the same Galois field. The Hamming distance between two words is the number of places in which they differ. As a result, <code class="code">DistanceCodeword</code> always returns an integer between zero and the word length of the codewords.</p>


<table class="example">
<tr><td><pre>

gap&gt; a := Codeword([0, 1, 2, 0, 1, 2]);; b := NullWord(6, GF(3));;
gap&gt; DistanceCodeword(a, b);
4
gap&gt; DistanceCodeword(b, a);
4
gap&gt; DistanceCodeword(a, a);
0 

</pre></td></tr></table>

<p><a id="s6ss3" name="s6ss3"></a></p>

<h5>2.6-3 Support</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Support</code>( <var>c</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">Support</code> returns a set of integers indicating the positions of the non-zero entries in a codeword <var>c</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; a := Codeword("012320023002");; Support(a);
[ 2, 3, 4, 5, 8, 9, 12 ]
gap&gt; Support(NullWord(7));
[  ] 

</pre></td></tr></table>

<p>The support of a list with codewords can be calculated by taking the union of the individual supports. The weight of the support is the length of the set.</p>


<table class="example">
<tr><td><pre>

gap&gt; L := Codeword(["000000", "101010", "222000"], GF(3));;
gap&gt; S := Union(List(L, i -&gt; Support(i)));
[ 1, 2, 3, 5 ]
gap&gt; Length(S);
4 

</pre></td></tr></table>

<p><a id="s6ss4" name="s6ss4"></a></p>

<h5>2.6-4 WeightCodeword</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; WeightCodeword</code>( <var>c</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">WeightCodeword</code> returns the weight of a codeword c, the number of non-zero entries in <var>c</var>. As a result, <code class="code">WeightCodeword</code> always returns an integer between zero and the word length of the codeword.</p>


<table class="example">
<tr><td><pre>

gap&gt; WeightCodeword(Codeword("22222"));
5
gap&gt; WeightCodeword(NullWord(3));
0
gap&gt; C := HammingCode(3);
a linear [7,4,3]1 Hamming (3,2) code over GF(2)
gap&gt; Minimum(List(AsSSortedList(C){[2..Size(C)]}, WeightCodeword ) );
3 

</pre></td></tr></table>


<div class="pcenter">
<table class="chlink"><tr><td><a href="chap0.html">Top of Book</a></td><td><a href="chap1.html">Previous Chapter</a></td><td><a href="chap3.html">Next Chapter</a></td></tr></table>
<br />


<div class="pcenter"><table class="chlink"><tr><td class="chlink1">Goto Chapter: </td><td><a href="chap0.html">Top</a></td><td><a href="chap1.html">1</a></td><td><a href="chap2.html">2</a></td><td><a href="chap3.html">3</a></td><td><a href="chap4.html">4</a></td><td><a href="chap5.html">5</a></td><td><a href="chap6.html">6</a></td><td><a href="chap7.html">7</a></td><td><a href="chapBib.html">Bib</a></td><td><a href="chapInd.html">Ind</a></td></tr></table><br /></div>

</div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
