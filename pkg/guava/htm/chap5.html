<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (guava) - Chapter 5: Generating Codes</title>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body>


<div class="pcenter"><table class="chlink"><tr><td class="chlink1">Goto Chapter: </td><td><a href="chap0.html">Top</a></td><td><a href="chap1.html">1</a></td><td><a href="chap2.html">2</a></td><td><a href="chap3.html">3</a></td><td><a href="chap4.html">4</a></td><td><a href="chap5.html">5</a></td><td><a href="chap6.html">6</a></td><td><a href="chap7.html">7</a></td><td><a href="chapBib.html">Bib</a></td><td><a href="chapInd.html">Ind</a></td></tr></table><br /></div>
<p><a id="s0ss0" name="s0ss0"></a></p>

<h3>5. Generating Codes</h3>

<p>In this chapter we describe functions for generating codes.</p>

<p>Section <a href="chap5.html#s1ss0"><b>5.1</b></a> describes functions for generating unrestricted codes.</p>

<p>Section <a href="chap5.html#s2ss0"><b>5.2</b></a> describes functions for generating linear codes.</p>

<p>Section <a href="chap5.html#s3ss0"><b>5.3</b></a> describes functions for constructing certain covering codes, such as the Gabidulin codes.</p>

<p>Section <a href="chap5.html#s4ss0"><b>5.4</b></a> describes functions for constructing the Golay codes.</p>

<p>Section <a href="chap5.html#s5ss0"><b>5.5</b></a> describes functions for generating cyclic codes.</p>

<p>Section <a href="chap5.html#s6ss0"><b>5.6</b></a> describes functions for generating codes as the image of an evaluation map applied to a space of functions. For example, generalized Reed-Solomon codes and toric codes are described there.</p>

<p><a id="s1ss0" name="s1ss0"></a></p>

<h4>5.1 
Generating Unrestricted Codes
</h4>

<p>In this section we start with functions that creating code from user defined matrices or special matrices (see <code class="func">ElementsCode</code> (<a href="chap5.html#s1ss1"><b>5.1-1</b></a>), <code class="func">HadamardCode</code> (<a href="chap5.html#s1ss2"><b>5.1-2</b></a>), <code class="func">ConferenceCode</code> (<a href="chap5.html#s1ss3"><b>5.1-3</b></a>) and <code class="func">MOLSCode</code> (<a href="chap5.html#s1ss4"><b>5.1-4</b></a>)). These codes are unrestricted codes; they may later be discovered to be linear or cyclic.</p>

<p>The next functions generate random codes (see <code class="func">RandomCode</code> (<a href="chap5.html#s1ss5"><b>5.1-5</b></a>)) and the Nordstrom-Robinson code (see <code class="func">NordstromRobinsonCode</code> (<a href="chap5.html#s1ss6"><b>5.1-6</b></a>)), respectively.</p>

<p>Finally, we describe two functions for generating Greedy codes. These are codes that contructed by gathering codewords from a space (see <code class="func">GreedyCode</code> (<a href="chap5.html#s1ss7"><b>5.1-7</b></a>) and <code class="func">LexiCode</code> (<a href="chap5.html#s1ss8"><b>5.1-8</b></a>)).</p>

<p><a id="s1ss1" name="s1ss1"></a></p>

<h5>5.1-1 ElementsCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ElementsCode</code>( <var>L[, name,] F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ElementsCode</code> creates an unrestricted code of the list of elements <var>L</var>, in the field <var>F</var>. <var>L</var> must be a list of vectors, strings, polynomials or codewords. <var>name</var> can contain a short description of the code.</p>

<p>If <var>L</var> contains a codeword more than once, it is removed from the list and a <strong class="pkg">GAP</strong> set is returned.</p>


<table class="example">
<tr><td><pre>

gap&gt; M := Z(3)^0 * [ [1, 0, 1, 1], [2, 2, 0, 0], [0, 1, 2, 2] ];;
gap&gt; C := ElementsCode( M, "example code", GF(3) );
a (4,3,1..4)2 example code over GF(3)
gap&gt; MinimumDistance( C );
4
gap&gt; AsSSortedList( C );
[ [ 0 1 2 2 ], [ 1 0 1 1 ], [ 2 2 0 0 ] ]

</pre></td></tr></table>

<p><a id="s1ss2" name="s1ss2"></a></p>

<h5>5.1-2 HadamardCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; HadamardCode</code>( <var>H[, t]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The four forms this command can take are <code class="code">HadamardCode(H,t)</code>, <code class="code">HadamardCode(H)</code>, <code class="code">HadamardCode(n,t)</code>, and <code class="code">HadamardCode(n)</code>.</p>

<p>In the case when the arguments <var>H</var> and <var>t</var> are both given, <code class="code">HadamardCode</code> returns a Hadamard code of the t^th kind from the Hadamard matrix <var>H</var> In case only <var>H</var> is given, t = 3 is used.</p>

<p>By definition, a Hadamard matrix is a square matrix <var>H</var> with H* H^T = -n* I_n, where n is the size of <var>H</var>. The entries of <var>H</var> are either 1 or -1.</p>

<p>The matrix <var>H</var> is first transformed into a binary matrix A_n by replacing the 1's by 0's and the -1's by 1s).</p>

<p>The Hadamard matrix of the <em>first kind</em> (t=1) is created by using the rows of A_n as elements, after deleting the first column. This is a (n-1, n, n/2) code. We use this code for creating the Hadamard code of the <em>second kind</em> (t=2), by adding all the complements of the already existing codewords. This results in a (n-1, 2n, n/2 -1) code. The <em>third kind</em> (t=3) is created by using the rows of A_n (without cutting a column) and their complements as elements. This way, we have an (n, 2n, n/2)-code. The returned code is generally an unrestricted code, but for n = 2^r, the code is linear.</p>

<p>The command <code class="code">HadamardCode(n,t)</code> returns a Hadamard code with parameter <var>n</var> of the t^th kind. For the command <code class="code">HadamardCode(n)</code>, t=3 is used.</p>

<p>When called in these forms, <code class="code">HadamardCode</code> first creates a Hadamard matrix (see <code class="func">HadamardMat</code> (<a href="chap7.html#s3ss4"><b>7.3-4</b></a>)), of size <var>n</var> and then follows the same procedure as described above. Therefore the same restrictions with respect to <var>n</var> as for Hadamard matrices hold.</p>


<table class="example">
<tr><td><pre>

gap&gt; H4 := [[1,1,1,1],[1,-1,1,-1],[1,1,-1,-1],[1,-1,-1,1]];;
gap&gt; HadamardCode( H4, 1 );
a (3,4,2)1 Hadamard code of order 4 over GF(2)
gap&gt; HadamardCode( H4, 2 );
a (3,8,1)0 Hadamard code of order 4 over GF(2)
gap&gt; HadamardCode( H4 );
a (4,8,2)1 Hadamard code of order 4 over GF(2) 
gap&gt; H4 := [[1,1,1,1],[1,-1,1,-1],[1,1,-1,-1],[1,-1,-1,1]];;
gap&gt; C := HadamardCode( 4 );
a (4,8,2)1 Hadamard code of order 4 over GF(2)
gap&gt; C = HadamardCode( H4 );
true 

</pre></td></tr></table>

<p><a id="s1ss3" name="s1ss3"></a></p>

<h5>5.1-3 ConferenceCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ConferenceCode</code>( <var>H</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ConferenceCode</code> returns a code of length n-1 constructed from a symmetric 'conference matrix' <var>H</var>. A <em>conference matrix</em> <var>H</var> is a symmetric matrix of order n, which satisfies H* H^T = ((n-1)* I, with n = 2 mod 4. The rows of frac12(H+I+J), frac12(-H+I+J), plus the zero and all-ones vectors form the elements of a binary non-linear (n-1, 2n, (n-2)/2) code.</p>

<p><strong class="pkg">GUAVA</strong> constructs a symmetric conference matrix of order n+1 (n= 1 mod 4) and uses the rows of that matrix, plus the zero and all-ones vectors, to construct a binary non-linear (n, 2(n+1), (n-1)/2)-code.</p>


<table class="example">
<tr><td><pre>

gap&gt; H6 := [[0,1,1,1,1,1],[1,0,1,-1,-1,1],[1,1,0,1,-1,-1],
&gt; [1,-1,1,0,1,-1],[1,-1,-1,1,0,1],[1,1,-1,-1,1,0]];;
gap&gt; C1 := ConferenceCode( H6 );
a (5,12,2)1..4 conference code over GF(2)
gap&gt; IsLinearCode( C1 );
false 
gap&gt; C2 := ConferenceCode( 5 );
a (5,12,2)1..4 conference code over GF(2)
gap&gt; AsSSortedList( C2 );
[ [ 0 0 0 0 0 ], [ 0 0 1 1 1 ], [ 0 1 0 1 1 ], [ 0 1 1 0 1 ], [ 0 1 1 1 0 ], 
  [ 1 0 0 1 1 ], [ 1 0 1 0 1 ], [ 1 0 1 1 0 ], [ 1 1 0 0 1 ], [ 1 1 0 1 0 ], 
  [ 1 1 1 0 0 ], [ 1 1 1 1 1 ] ]

</pre></td></tr></table>

<p><a id="s1ss4" name="s1ss4"></a></p>

<h5>5.1-4 MOLSCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MOLSCode</code>( <var>[n,] q</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">MOLSCode</code> returns an (n, q^2, n-1) code over GF(q). The code is created from n-2 'Mutually Orthogonal Latin Squares' (MOLS) of size q times q. The default for <var>n</var> is 4. <strong class="pkg">GUAVA</strong> can construct a MOLS code for n-2 &lt;= q. Here <var>q</var> must be a prime power, q &gt; 2. If there are no n-2 MOLS, an error is signalled.</p>

<p>Since each of the n-2 MOLS is a qtimes q matrix, we can create a code of size q^2 by listing in each code element the entries that are in the same position in each of the MOLS. We precede each of these lists with the two coordinates that specify this position, making the word length become n.</p>

<p>The MOLS codes are MDS codes (see <code class="func">IsMDSCode</code> (<a href="chap3.html#s3ss7"><b>3.3-7</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := MOLSCode( 6, 5 );
a (6,25,5)3..4 code generated by 4 MOLS of order 5 over GF(5)
gap&gt; mols := List( [1 .. WordLength(C1) - 2 ], function( nr )
&gt;       local ls, el;
&gt;       ls := NullMat( Size(LeftActingDomain(C1)), Size(LeftActingDomain(C1)) );
&gt;       for el in VectorCodeword( AsSSortedList( C1 ) ) do
&gt;          ls[IntFFE(el[1])+1][IntFFE(el[2])+1] := el[nr + 2];
&gt;       od;
&gt;       return ls;
&gt;    end );;
gap&gt; AreMOLS( mols );
true
gap&gt; C2 := MOLSCode( 11 );
a (4,121,3)2 code generated by 2 MOLS of order 11 over GF(11) 

</pre></td></tr></table>

<p><a id="s1ss5" name="s1ss5"></a></p>

<h5>5.1-5 RandomCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RandomCode</code>( <var>n, M, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">RandomCode</code> returns a random unrestricted code of size <var>M</var> with word length <var>n</var> over <var>F</var>. <var>M</var> must be less than or equal to the number of elements in the space GF(q)^n.</p>

<p>The function <code class="code">RandomLinearCode</code> returns a random linear code (see <code class="func">RandomLinearCode</code> (<a href="chap5.html#s2ss10"><b>5.2-10</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := RandomCode( 6, 10, GF(8) );
a (6,10,1..6)4..6 random unrestricted code over GF(8)
gap&gt; MinimumDistance(C1);
3
gap&gt; C2 := RandomCode( 6, 10, GF(8) );
a (6,10,1..6)4..6 random unrestricted code over GF(8)
gap&gt; C1 = C2;
false 

</pre></td></tr></table>

<p><a id="s1ss6" name="s1ss6"></a></p>

<h5>5.1-6 NordstromRobinsonCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; NordstromRobinsonCode</code>( <var></var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">NordstromRobinsonCode</code> returns a Nordstrom-Robinson code, the best code with word length n=16 and minimum distance d=6 over GF(2). This is a non-linear (16, 256, 6) code.</p>


<table class="example">
<tr><td><pre>

gap&gt; C := NordstromRobinsonCode();
a (16,256,6)4 Nordstrom-Robinson code over GF(2)
gap&gt; OptimalityCode( C );
0 

</pre></td></tr></table>

<p><a id="s1ss7" name="s1ss7"></a></p>

<h5>5.1-7 GreedyCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GreedyCode</code>( <var>L, d, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">GreedyCode</code> returns a Greedy code with design distance <var>d</var> over the finite field <var>F</var>. The code is constructed using the greedy algorithm on the list of vectors <var>L</var>. (The greedy algorithm checks each vector in <var>L</var> and adds it to the code if its distance to the current code is greater than or equal to <var>d</var>. It is obvious that the resulting code has a minimum distance of at least <var>d</var>.</p>

<p>Greedy codes are often linear codes.</p>

<p>The function <code class="code">LexiCode</code> creates a greedy code from a basis instead of an enumerated list (see <code class="func">LexiCode</code> (<a href="chap5.html#s1ss8"><b>5.1-8</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := GreedyCode( Tuples( AsSSortedList( GF(2) ), 5 ), 3, GF(2) );
a (5,4,3..5)2 Greedy code, user defined basis over GF(2)
gap&gt; C2 := GreedyCode( Permuted( Tuples( AsSSortedList( GF(2) ), 5 ),
&gt;                         (1,4) ), 3, GF(2) );
a (5,4,3..5)2 Greedy code, user defined basis over GF(2)
gap&gt; C1 = C2;
false 

</pre></td></tr></table>

<p><a id="s1ss8" name="s1ss8"></a></p>

<h5>5.1-8 LexiCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LexiCode</code>( <var>n, d, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>In this format, <code class="code">Lexicode</code> returns a lexicode with word length <var>n</var>, design distance <var>d</var> over <var>F</var>. The code is constructed using the greedy algorithm on the lexicographically ordered list of all vectors of length <var>n</var> over <var>F</var>. Every time a vector is found that has a distance to the current code of at least <var>d</var>, it is added to the code. This results, obviously, in a code with minimum distance greater than or equal to <var>d</var>.</p>

<p>Another syntax which one can use is <code class="code">LexiCode( B, d, F )</code>. When called in this format, <code class="code">LexiCode</code> uses the basis <var>B</var> instead of the standard basis. <var>B</var> is a matrix of vectors over <var>F</var>. The code is constructed using the greedy algorithm on the list of vectors spanned by <var>B</var>, ordered lexicographically with respect to <var>B</var>.</p>

<p>Note that binary lexicodes are always linear.</p>


<table class="example">
<tr><td><pre>

gap&gt; C := LexiCode( 4, 3, GF(5) );
a (4,17,3..4)2..4 lexicode over GF(5) 
gap&gt; B := [ [Z(2)^0, 0*Z(2), 0*Z(2)], [Z(2)^0, Z(2)^0, 0*Z(2)] ];;
gap&gt; C := LexiCode( B, 2, GF(2) );
a linear [3,1,2]1..2 lexicode over GF(2) 

</pre></td></tr></table>

<p>The function <code class="code">GreedyCode</code> creates a greedy code that is not restricted to a lexicographical order (see <code class="func">GreedyCode</code> (<a href="chap5.html#s1ss7"><b>5.1-7</b></a>)).</p>

<p><a id="s2ss0" name="s2ss0"></a></p>

<h4>5.2 
Generating Linear Codes
</h4>

<p>In this section we describe functions for constructing linear codes. A linear code always has a generator or check matrix.</p>

<p>The first two functions generate linear codes from the generator matrix (<code class="func">GeneratorMatCode</code> (<a href="chap5.html#s2ss1"><b>5.2-1</b></a>)) or check matrix (<code class="func">CheckMatCode</code> (<a href="chap5.html#s2ss2"><b>5.2-2</b></a>)). All linear codes can be constructed with these functions.</p>

<p>The next functions we describe generate some well-known codes, like Hamming codes (<code class="func">HammingCode</code> (<a href="chap5.html#s2ss3"><b>5.2-3</b></a>)), Reed-Muller codes (<code class="func">ReedMullerCode</code> (<a href="chap5.html#s2ss4"><b>5.2-4</b></a>)) and the extended Golay codes (<code class="func">ExtendedBinaryGolayCode</code> (<a href="chap5.html#s4ss2"><b>5.4-2</b></a>) and <code class="func">ExtendedTernaryGolayCode</code> (<a href="chap5.html#s4ss4"><b>5.4-4</b></a>)).</p>

<p>A large and powerful family of codes are alternant codes. They are obtained by a small modification of the parity check matrix of a BCH code (see <code class="func">AlternantCode</code> (<a href="chap5.html#s2ss5"><b>5.2-5</b></a>), <code class="func">GoppaCode</code> (<a href="chap5.html#s2ss6"><b>5.2-6</b></a>), <code class="func">GeneralizedSrivastavaCode</code> (<a href="chap5.html#s2ss7"><b>5.2-7</b></a>) and <code class="func">SrivastavaCode</code> (<a href="chap5.html#s2ss8"><b>5.2-8</b></a>)).</p>

<p>Finally, we describe a function for generating random linear codes (see <code class="func">RandomLinearCode</code> (<a href="chap5.html#s2ss10"><b>5.2-10</b></a>)).</p>

<p><a id="s2ss1" name="s2ss1"></a></p>

<h5>5.2-1 GeneratorMatCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GeneratorMatCode</code>( <var>G[, name,] F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">GeneratorMatCode</code> returns a linear code with generator matrix <var>G</var>. <var>G</var> must be a matrix over finite field <var>F</var>. <var>name</var> can contain a short description of the code. The generator matrix is the basis of the elements of the code. The resulting code has word length n, dimension k if <var>G</var> is a k times n-matrix. If GF(q) is the field of the code, the size of the code will be q^k.</p>

<p>If the generator matrix does not have full row rank, the linearly dependent rows are removed. This is done by the <strong class="pkg">GAP</strong> function <code class="code">BaseMat</code> and results in an equal code. The generator matrix can be retrieved with the function <code class="code">GeneratorMat</code> (see <code class="func">GeneratorMat</code> (<a href="chap3.html#s7ss1"><b>3.7-1</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; G := Z(3)^0 * [[1,0,1,2,0],[0,1,2,1,1],[0,0,1,2,1]];;
gap&gt; C1 := GeneratorMatCode( G, GF(3) );
a linear [5,3,1..2]1..2 code defined by generator matrix over GF(3)
gap&gt; C2 := GeneratorMatCode( IdentityMat( 5, GF(2) ), GF(2) );
a linear [5,5,1]0 code defined by generator matrix over GF(2)
gap&gt; GeneratorMatCode( List( AsSSortedList( NordstromRobinsonCode() ),
&gt; x -&gt; VectorCodeword( x ) ), GF( 2 ) );
a linear [16,11,1..4]2 code defined by generator matrix over GF(2)
# This is the smallest linear code that contains the N-R code 

</pre></td></tr></table>

<p><a id="s2ss2" name="s2ss2"></a></p>

<h5>5.2-2 CheckMatCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CheckMatCode</code>( <var>H[, name,] F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">CheckMatCode</code> returns a linear code with check matrix <var>H</var>. <var>H</var> must be a matrix over Galois field <var>F</var>. <var>[name.</var> can contain a short description of the code. The parity check matrix is the transposed of the nullmatrix of the generator matrix of the code. Therefore, c* H^T = 0 where c is an element of the code. If <var>H</var> is a rtimes n-matrix, the code has word length n, redundancy r and dimension n-r.</p>

<p>If the check matrix does not have full row rank, the linearly dependent rows are removed. This is done by the <strong class="pkg">GAP</strong> function <code class="code">BaseMat</code>. and results in an equal code. The check matrix can be retrieved with the function <code class="code">CheckMat</code> (see <code class="func">CheckMat</code> (<a href="chap3.html#s7ss2"><b>3.7-2</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; G := Z(3)^0 * [[1,0,1,2,0],[0,1,2,1,1],[0,0,1,2,1]];;
gap&gt; C1 := CheckMatCode( G, GF(3) );
a linear [5,2,1..2]2..3 code defined by check matrix over GF(3)
gap&gt; CheckMat(C1);
[ [ Z(3)^0, 0*Z(3), Z(3)^0, Z(3), 0*Z(3) ],
  [ 0*Z(3), Z(3)^0, Z(3), Z(3)^0, Z(3)^0 ],
  [ 0*Z(3), 0*Z(3), Z(3)^0, Z(3), Z(3)^0 ] ]
gap&gt; C2 := CheckMatCode( IdentityMat( 5, GF(2) ), GF(2) );
a cyclic [5,0,5]5 code defined by check matrix over GF(2)

</pre></td></tr></table>

<p><a id="s2ss3" name="s2ss3"></a></p>

<h5>5.2-3 HammingCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; HammingCode</code>( <var>r, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">HammingCode</code> returns a Hamming code with redundancy <var>r</var> over <var>F</var>. A Hamming code is a single-error-correcting code. The parity check matrix of a Hamming code has all nonzero vectors of length <var>r</var> in its columns, except for a multiplication factor. The decoding algorithm of the Hamming code (see <code class="func">Decode</code> (<a href="chap3.html#s10ss1"><b>3.10-1</b></a>)) makes use of this property.</p>

<p>If q is the size of its field <var>F</var>, the returned Hamming code is a linear [(q^r-1)/(q-1), (q^r-1)/(q-1) - r, 3] code.</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := HammingCode( 4, GF(2) );
a linear [15,11,3]1 Hamming (4,2) code over GF(2)
gap&gt; C2 := HammingCode( 3, GF(9) );
a linear [91,88,3]1 Hamming (3,9) code over GF(9) 

</pre></td></tr></table>

<p><a id="s2ss4" name="s2ss4"></a></p>

<h5>5.2-4 ReedMullerCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ReedMullerCode</code>( <var>r, k</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ReedMullerCode</code> returns a binary 'Reed-Muller code' <var>R(r, k)</var> with dimension <var>k</var> and order <var>r</var>. This is a code with length 2^k and minimum distance 2^k-r (see for example, section 1.10 in <a href="chapBib.html#biBHP03">[HP03]</a>). By definition, the r^th order binary Reed-Muller code of length n=2^m, for 0 &lt;= r &lt;= m, is the set of all vectors f, where f is a Boolean function which is a polynomial of degree at most r.</p>


<table class="example">
<tr><td><pre>

gap&gt; ReedMullerCode( 1, 3 );
a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2) 

</pre></td></tr></table>

<p>See <code class="func">GeneralizedReedMuller</code> (<b>???</b>) for a more general construction.</p>

<p><a id="s2ss5" name="s2ss5"></a></p>

<h5>5.2-5 AlternantCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AlternantCode</code>( <var>r, Y[, alpha,] F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">AlternantCode</code> returns an 'alternant code', with parameters <var>r</var>, <var>Y</var> and <var>alpha</var> (optional). <var>F</var> denotes the (finite) base field. Here, <var>r</var> is the design redundancy of the code. <var>Y</var> and <var>alpha</var> are both vectors of length <var>n</var> from which the parity check matrix is constructed. The check matrix has the form H=([a_i^j y_i]), where 0 &lt;= j&lt;= r-1, 1 &lt;= i&lt;= n, and where [...] is as in <code class="func">VerticalConversionFieldMat</code> (<a href="chap7.html#s3ss9"><b>7.3-9</b></a>)). If no <var>alpha</var> is specified, the vector [1, a, a^2, .., a^n-1] is used, where a is a primitive element of a Galois field <var>F</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; Y := [ 1, 1, 1, 1, 1, 1, 1];; a := PrimitiveUnityRoot( 2, 7 );;
gap&gt; alpha := List( [0..6], i -&gt; a^i );;
gap&gt; C := AlternantCode( 2, Y, alpha, GF(8) );
a linear [7,3,3..4]3..4 alternant code over GF(8) 

</pre></td></tr></table>

<p><a id="s2ss6" name="s2ss6"></a></p>

<h5>5.2-6 GoppaCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GoppaCode</code>( <var>G, L</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">GoppaCode</code> returns a Goppa code <var>C</var> from Goppa polynomial <var>g</var>, having coefficients in a Galois Field GF(q). <var>L</var> must be a list of elements in GF(q), that are not roots of <var>g</var>. The word length of the code is equal to the length of <var>L</var>. The parity check matrix has the form H=([a_i^j / G(a_i)])_0 &lt;= j &lt;= deg(g)-1, a_i in L, where a_iin L and [...] is as in <code class="func">VerticalConversionFieldMat</code> (<a href="chap7.html#s3ss9"><b>7.3-9</b></a>), so H has entries in GF(q), q=p^m. It is known that d(C)&gt;= deg(g)+1, with a better bound in the binary case provided g has no multiple roots. See Huffman and Pless <a href="chapBib.html#biBHP03">[HP03]</a> section 13.2.2, and MacWilliams and Sloane <a href="chapBib.html#biBMS83">[MS83]</a> section 12.3, for more details.</p>

<p>One can also call <code class="code">GoppaCode</code> using the syntax <code class="code">GoppaCode(g,n)</code>. When called with parameter <var>n</var>, <strong class="pkg">GUAVA</strong> constructs a list L of length <var>n</var>, such that no element of <var>L</var> is a root of <var>g</var>.</p>

<p>This is a special case of an alternant code.</p>


<table class="example">
<tr><td><pre>

gap&gt; x:=Indeterminate(GF(8),"x");
x
gap&gt; L:=Elements(GF(8));
[ 0*Z(2), Z(2)^0, Z(2^3), Z(2^3)^2, Z(2^3)^3, Z(2^3)^4, Z(2^3)^5, Z(2^3)^6 ]
gap&gt; g:=x^2+x+1;
x^2+x+Z(2)^0
gap&gt; C:=GoppaCode(g,L);
a linear [8,2,5]3 Goppa code over GF(2)
gap&gt; xx := Indeterminate( GF(2), "xx" );; 
gap&gt; gg := xx^2 + xx + 1;; L := AsSSortedList( GF(8) );;
gap&gt; C1 := GoppaCode( gg, L );
a linear [8,2,5]3 Goppa code over GF(2) 
gap&gt; y := Indeterminate( GF(2), "y" );; 
gap&gt; h := y^2 + y + 1;;
gap&gt; C2 := GoppaCode( h, 8 );
a linear [8,2,5]3 Goppa code over GF(2) 
gap&gt; C1=C2;
true
gap&gt; C=C1;
true

</pre></td></tr></table>

<p><a id="s2ss7" name="s2ss7"></a></p>

<h5>5.2-7 GeneralizedSrivastavaCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GeneralizedSrivastavaCode</code>( <var>a, w, z[, t,] F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">GeneralizedSrivastavaCode</code> returns a generalized Srivastava code with parameters <var>a</var>, <var>w</var>, <var>z</var>, <var>t</var>. a = a_1, ..., a_n and w = w_1, ..., w_s are lists of n+s distinct elements of F=GF(q^m), z is a list of length n of nonzero elements of GF(q^m). The parameter <var>t</var> determines the designed distance: d &gt;= st + 1. The check matrix of this code is the form</p>

<p class="pcenter">\[
H=([\frac{z_i}{(a_i - w_j)^k}]),
 \]</p>

<p>1&lt;= k&lt;= t, where [...] is as in <code class="func">VerticalConversionFieldMat</code> (<a href="chap7.html#s3ss9"><b>7.3-9</b></a>). We use this definition of H to define the code. The default for <var>t</var> is 1. The original Srivastava codes (see <code class="func">SrivastavaCode</code> (<a href="chap5.html#s2ss8"><b>5.2-8</b></a>)) are a special case t=1, z_i=a_i^mu, for some mu.</p>


<table class="example">
<tr><td><pre>

gap&gt; a := Filtered( AsSSortedList( GF(2^6) ), e -&gt; e in GF(2^3) );;
gap&gt; w := [ Z(2^6) ];; z := List( [1..8], e -&gt; 1 );;
gap&gt; C := GeneralizedSrivastavaCode( a, w, z, 1, GF(64) );
a linear [8,2,2..5]3..4 generalized Srivastava code over GF(2) 

</pre></td></tr></table>

<p><a id="s2ss8" name="s2ss8"></a></p>

<h5>5.2-8 SrivastavaCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SrivastavaCode</code>( <var>a, w[, mu,] F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>SrivastavaCode returns a Srivastava code with parameters <var>a</var>, <var>w</var> (and optionally <var>mu</var>). a = a_1, ..., a_n and w = w_1, ..., w_s are lists of n+s distinct elements of F=GF(q^m). The default for <var>mu</var> is 1. The Srivastava code is a generalized Srivastava code, in which z_i = a_i^mu for some <var>mu</var> and t=1.</p>

<p>J. N. Srivastava introduced this code in 1967, though his work was not published. See Helgert <a href="chapBib.html#biBHe72">[H72]</a> for more details on the properties of this code. Related reference: G. Roelofsen, <strong class="button">On Goppa and Generalized Srivastava Codes</strong> PhD thesis, Dept. Math. and Comp. Sci., Eindhoven Univ. of Technology, the Netherlands, 1982.</p>


<table class="example">
<tr><td><pre>

gap&gt; a := AsSSortedList( GF(11) ){[2..8]};;
gap&gt; w := AsSSortedList( GF(11) ){[9..10]};;
gap&gt; C := SrivastavaCode( a, w, 2, GF(11) );
a linear [7,5,3]2 Srivastava code over GF(11)
gap&gt; IsMDSCode( C );
true    # Always true if F is a prime field 

</pre></td></tr></table>

<p><a id="s2ss9" name="s2ss9"></a></p>

<h5>5.2-9 CordaroWagnerCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CordaroWagnerCode</code>( <var>n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">CordaroWagnerCode</code> returns a binary Cordaro-Wagner code. This is a code of length <var>n</var> and dimension 2 having the best possible minimum distance d. This code is just a little bit less trivial than <code class="code">RepetitionCode</code> (see <code class="func">RepetitionCode</code> (<a href="chap5.html#s5ss10"><b>5.5-10</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; C := CordaroWagnerCode( 11 );
a linear [11,2,7]5 Cordaro-Wagner code over GF(2)
gap&gt; AsSSortedList(C);                 
[ [ 0 0 0 0 0 0 0 0 0 0 0 ], [ 0 0 0 0 1 1 1 1 1 1 1 ], 
  [ 1 1 1 1 0 0 0 1 1 1 1 ], [ 1 1 1 1 1 1 1 0 0 0 0 ] ]

</pre></td></tr></table>

<p><a id="s2ss10" name="s2ss10"></a></p>

<h5>5.2-10 RandomLinearCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RandomLinearCode</code>( <var>n, k, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">RandomLinearCode</code> returns a random linear code with word length <var>n</var>, dimension <var>k</var> over field <var>F</var>. The method used is to first construct a ktimes n matrix of the block form (I,A), where I is a ktimes k identity matrix and A is a ktimes (n-k) matrix constructed using <code class="code">Random(F)</code> repeatedly. Then the columns are permuted using a randomly selected element of <code class="code">SymmetricGroup(n)</code>.</p>

<p>To create a random unrestricted code, use <code class="code">RandomCode</code> (see <code class="func">RandomCode</code> (<a href="chap5.html#s1ss5"><b>5.1-5</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; C := RandomLinearCode( 15, 4, GF(3) );
a  [15,4,?] randomly generated code over GF(3)
gap&gt; Display(C);
a linear [15,4,1..6]6..10 random linear code over GF(3)

</pre></td></tr></table>

<p>The method <strong class="pkg">GUAVA</strong> chooses to output the result of a <code class="code">RandomLinearCode</code> command is different than other codes. For example, the bounds on the minimum distance is not displayed. Howeer, you can use the <code class="code">Display</code> command to print this information. This new display method was added in version 1.9 to speed up the command (if n is about 80 and k about 40, for example, the time it took to look up and/or calculate the bounds on the minimum distance was too long).</p>

<p><a id="s2ss11" name="s2ss11"></a></p>

<h5>5.2-11 OptimalityCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; OptimalityCode</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>In general this command is no longer accurate, since the tables have not been updated since 1998. See the web site <a href="http://www.win.tue.nl/~aeb/voorlincod.html">http://www.win.tue.nl/~aeb/voorlincod.html</a> for more recent data.</p>

<p><code class="code">OptimalityCode</code> returns the difference between the smallest known upper bound and the actual size of the code. Note that the value of the function <code class="code">UpperBound</code> is not always equal to the actual upper bound A(n,d) thus the result may not be equal to 0 even if the code is optimal!</p>

<p><code class="code">OptimalityLinearCode</code> is similar but applies only to linear codes.</p>

<p><a id="s2ss12" name="s2ss12"></a></p>

<h5>5.2-12 BestKnownLinearCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BestKnownLinearCode</code>( <var>n, k, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>In general this command is no longer accurate, since the tables have not been updated since 1998. See the web site <a href="http://www.win.tue.nl/~aeb/voorlincod.html">http://www.win.tue.nl/~aeb/voorlincod.html</a> for more recent data.</p>

<p><code class="code">BestKnownLinearCode</code> returns the best known (as of 1998) linear code of length <var>n</var>, dimension <var>k</var> over field <var>F</var>. The function uses the tables described in section <code class="func">BoundsMinimumDistance</code> (<a href="chap7.html#s1ss12"><b>7.1-12</b></a>) to construct this code.</p>

<p>This command can also be called using the syntax <code class="code">BestKnownLinearCode( rec )</code>, where <var>rec</var> must be a record containing the fields `lowerBound', `upperBound' and `construction'. It uses the information in this field to construct a code. This form is meant to be used together with the function <code class="code">BoundsMinimumDistance</code> (see <code class="func">BoundsMinimumDistance</code> (<a href="chap7.html#s1ss12"><b>7.1-12</b></a>)), if the bounds are already calculated.</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := BestKnownLinearCode( 23, 12, GF(2) );
a cyclic [23,12,7]3 binary Golay code over GF(2)
gap&gt; C1 = BinaryGolayCode();
true
gap&gt; Display( BestKnownLinearCode( 8, 4, GF(4) ) );
a linear [8,4,4]2..3 U U+V construction code of
U: a cyclic [4,3,2]1 dual code of
   a cyclic [4,1,4]3 repetition code over GF(4)
V: a cyclic [4,1,4]3 repetition code over GF(4)
gap&gt; C := BestKnownLinearCode(131,47);
a linear [131,47,28..32]23..68 shortened code 
gap&gt; bounds := BoundsMinimumDistance( 20, 17, GF(4) );
rec( n := 20, k := 17, q := 4, 
  references := rec( HM := [ "%T this reference is unknown, for more info", 
          "%T contact A.E. Brouwer (aeb@cwi.nl)" ] ), 
  construction := [ [Operation "ShortenedCode"], 
      [ [ [Operation "HammingCode"], [ 3, 4 ] ], [ 1 ] ] ], lowerBound := 3, 
  lowerBoundExplanation := [ "Lb(20,17)=3, by shortening of:", 
      "Lb(21,18)=3, reference: HM" ], upperBound := 3, 
  upperBoundExplanation := 
    [ "Ub(20,17)=3, otherwise construction B would contradict:", 
      "Ub(3,1)=3, repetition code" ] )
gap&gt; C := BestKnownLinearCode( bounds );
a linear [20,17,3]2 shortened code
gap&gt; C = BestKnownLinearCode( 20, 17, GF(4) );
true 

</pre></td></tr></table>

<p><a id="s3ss0" name="s3ss0"></a></p>

<h4>5.3 
Gabidulin Codes
</h4>

<p>These five binary, linear codes are derived from an article by Gabidulin, Davydov and Tombak <a href="chapBib.html#biBGDT91">[GDT91]</a>. All these codes are defined by check matrices. Exact definitions can be found in the article. The Gabidulin code, the enlarged Gabidulin code, the Davydov code, the Tombak code, and the enlarged Tombak code, correspond with theorem 1, 2, 3, 4, and 5, respectively in the article.</p>

<p>Like the Hamming codes, these codes have fixed minimum distance and covering radius, but can be arbitrarily long.</p>

<p><a id="s3ss1" name="s3ss1"></a></p>

<h5>5.3-1 GabidulinCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GabidulinCode</code>( <var>m, w1, w2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">GabidulinCode</code> yields a code of length 5 . 2^m-2-1, redundancy 2m-1, minimum distance 3 and covering radius 2. <var>w1</var> and <var>w2</var> should be elements of GF(2^m-2).</p>

<p><a id="s3ss2" name="s3ss2"></a></p>

<h5>5.3-2 EnlargedGabidulinCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; EnlargedGabidulinCode</code>( <var>m, w1, w2, e</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">EnlargedGabidulinCode</code> yields a code of length 7. 2^m-2-2, redundancy 2m, minimum distance 3 and covering radius 2. <var>w1</var> and <var>w2</var> are elements of GF(2^m-2). <var>e</var> is an element of GF(2^m).</p>

<p><a id="s3ss3" name="s3ss3"></a></p>

<h5>5.3-3 DavydovCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DavydovCode</code>( <var>r, v, ei, ej</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">DavydovCode</code> yields a code of length 2^v + 2^r-v - 3, redundancy <var>r</var>, minimum distance 4 and covering radius 2. <var>v</var> is an integer between 2 and r-2. <var>ei</var> and <var>ej</var> are elements of GF(2^v) and GF(2^r-v), respectively.</p>

<p><a id="s3ss4" name="s3ss4"></a></p>

<h5>5.3-4 TombakCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TombakCode</code>( <var>m, e, beta, gamma, w1, w2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">TombakCode</code> yields a code of length 15 * 2^m-3 - 3, redundancy 2m, minimum distance 4 and covering radius 2. <var>e</var> is an element of GF(2^m). <var>beta</var> and <var>gamma</var> are elements of GF(2^m-1). <var>w1</var> and <var>w2</var> are elements of GF(2^m-3).</p>

<p><a id="s3ss5" name="s3ss5"></a></p>

<h5>5.3-5 EnlargedTombakCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; EnlargedTombakCode</code>( <var>m, e, beta, gamma, w1, w2, u</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">EnlargedTombakCode</code> yields a code of length 23 * 2^m-4 - 3, redundancy 2m-1, minimum distance 4 and covering radius 2. The parameters <var>m</var>, <var>e</var>, <var>beta</var>, <var>gamma</var>, <var>w1</var> and <var>w2</var> are defined as in <code class="code">TombakCode</code>. <var>u</var> is an element of GF(2^m-1).</p>


<table class="example">
<tr><td><pre>

gap&gt; GabidulinCode( 4, Z(4)^0, Z(4)^1 );
a linear [19,12,3]2 Gabidulin code (m=4) over GF(2)
gap&gt; EnlargedGabidulinCode( 4, Z(4)^0, Z(4)^1, Z(16)^11 );
a linear [26,18,3]2 enlarged Gabidulin code (m=4) over GF(2)
gap&gt; DavydovCode( 6, 3, Z(8)^1, Z(8)^5 );
a linear [13,7,4]2 Davydov code (r=6, v=3) over GF(2)
gap&gt; TombakCode( 5, Z(32)^6, Z(16)^14, Z(16)^10, Z(4)^0, Z(4)^1 );
a linear [57,47,4]2 Tombak code (m=5) over GF(2)
gap&gt; EnlargedTombakCode( 6, Z(32)^6, Z(16)^14, Z(16)^10,
&gt; Z(4)^0, Z(4)^0, Z(32)^23 );
a linear [89,78,4]2 enlarged Tombak code (m=6) over GF(2)

</pre></td></tr></table>

<p><a id="s4ss0" name="s4ss0"></a></p>

<h4>5.4 
Golay Codes
</h4>

<p>" The Golay code is probably the most important of all codes for both practical and theoretical reasons. " (<a href="chapBib.html#biBMS83">[MS83]</a>, pg. 64). Though born in Switzerland, M. J. E. Golay (1902-1989) worked for the US Army Labs for most of his career. For more information on his life, see his obit in the June 1990 IEEE Information Society Newsletter.</p>

<p><a id="s4ss1" name="s4ss1"></a></p>

<h5>5.4-1 BinaryGolayCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BinaryGolayCode</code>( <var></var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">BinaryGolayCode</code> returns a binary Golay code. This is a perfect [23,12,7] code. It is also cyclic, and has generator polynomial g(x)=1+x^2+x^4+x^5+x^6+x^10+x^11. Extending it results in an extended Golay code (see <code class="func">ExtendedBinaryGolayCode</code> (<a href="chap5.html#s4ss2"><b>5.4-2</b></a>)). There's also the ternary Golay code (see <code class="func">TernaryGolayCode</code> (<a href="chap5.html#s4ss3"><b>5.4-3</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=BinaryGolayCode();
a cyclic [23,12,7]3 binary Golay code over GF(2)
gap&gt; ExtendedBinaryGolayCode() = ExtendedCode(BinaryGolayCode());
true
gap&gt; IsPerfectCode(C);
true 
gap&gt; IsCyclicCode(C);
true

</pre></td></tr></table>

<p><a id="s4ss2" name="s4ss2"></a></p>

<h5>5.4-2 ExtendedBinaryGolayCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ExtendedBinaryGolayCode</code>( <var></var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ExtendedBinaryGolayCode</code> returns an extended binary Golay code. This is a [24,12,8] code. Puncturing in the last position results in a perfect binary Golay code (see <code class="func">BinaryGolayCode</code> (<a href="chap5.html#s4ss1"><b>5.4-1</b></a>)). The code is self-dual.</p>


<table class="example">
<tr><td><pre>

gap&gt; C := ExtendedBinaryGolayCode();
a linear [24,12,8]4 extended binary Golay code over GF(2)
gap&gt; IsSelfDualCode(C);
true
gap&gt; P := PuncturedCode(C);
a linear [23,12,7]3 punctured code
gap&gt; P = BinaryGolayCode();
true 
gap&gt; IsCyclicCode(C);
false


</pre></td></tr></table>

<p><a id="s4ss3" name="s4ss3"></a></p>

<h5>5.4-3 TernaryGolayCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TernaryGolayCode</code>( <var></var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">TernaryGolayCode</code> returns a ternary Golay code. This is a perfect [11,6,5] code. It is also cyclic, and has generator polynomial g(x)=2+x^2+2x^3+x^4+x^5. Extending it results in an extended Golay code (see <code class="func">ExtendedTernaryGolayCode</code> (<a href="chap5.html#s4ss4"><b>5.4-4</b></a>)). There's also the binary Golay code (see <code class="func">BinaryGolayCode</code> (<a href="chap5.html#s4ss1"><b>5.4-1</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=TernaryGolayCode();
a cyclic [11,6,5]2 ternary Golay code over GF(3)
gap&gt; ExtendedTernaryGolayCode() = ExtendedCode(TernaryGolayCode());
true 
gap&gt; IsCyclicCode(C);
true

</pre></td></tr></table>

<p><a id="s4ss4" name="s4ss4"></a></p>

<h5>5.4-4 ExtendedTernaryGolayCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ExtendedTernaryGolayCode</code>( <var></var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ExtendedTernaryGolayCode</code> returns an extended ternary Golay code. This is a [12,6,6] code. Puncturing this code results in a perfect ternary Golay code (see <code class="func">TernaryGolayCode</code> (<a href="chap5.html#s4ss3"><b>5.4-3</b></a>)). The code is self-dual.</p>


<table class="example">
<tr><td><pre>

gap&gt; C := ExtendedTernaryGolayCode();
a linear [12,6,6]3 extended ternary Golay code over GF(3)
gap&gt; IsSelfDualCode(C);
true
gap&gt; P := PuncturedCode(C);
a linear [11,6,5]2 punctured code
gap&gt; P = TernaryGolayCode();
true 
gap&gt; IsCyclicCode(C);
false

</pre></td></tr></table>

<p><a id="s5ss0" name="s5ss0"></a></p>

<h4>5.5 
Generating Cyclic Codes
</h4>

<p>The elements of a cyclic code C are all multiples of a ('generator') polynomial g(x), where calculations are carried out modulo x^n-1. Therefore, as polynomials in x, the elements always have degree less than n. A cyclic code is an ideal in the ring F[x]/(x^n-1) of polynomials modulo x^n - 1. The unique monic polynomial of least degree that generates C is called the <em>generator polynomial</em> of C. It is a divisor of the polynomial x^n-1.</p>

<p>The <em>check polynomial</em> is the polynomial h(x) with g(x)h(x)=x^n-1. Therefore it is also a divisor of x^n-1. The check polynomial has the property that</p>

<p class="pcenter">\[
c(x)h(x) \equiv  0 \pmod{x^n-1},
 \]</p>

<p>for every codeword c(x)in C.</p>

<p>The first two functions described below generate cyclic codes from a given generator or check polynomial. All cyclic codes can be constructed using these functions.</p>

<p>Two of the Golay codes already described are cyclic (see <code class="func">BinaryGolayCode</code> (<a href="chap5.html#s4ss1"><b>5.4-1</b></a>) and <code class="func">TernaryGolayCode</code> (<a href="chap5.html#s4ss3"><b>5.4-3</b></a>)). For example, the <strong class="pkg">GUAVA</strong> record for a binary Golay code contains the generator polynomial:</p>


<table class="example">
<tr><td><pre>

gap&gt; C := BinaryGolayCode();
a cyclic [23,12,7]3 binary Golay code over GF(2)
gap&gt; NamesOfComponents(C);
[ "LeftActingDomain", "GeneratorsOfLeftOperatorAdditiveGroup", "WordLength",
  "GeneratorMat", "GeneratorPol", "Dimension", "Redundancy", "Size", "name",
  "lowerBoundMinimumDistance", "upperBoundMinimumDistance", "WeightDistribution",
  "boundsCoveringRadius", "MinimumWeightOfGenerators", 
  "UpperBoundOptimalMinimumDistance" ]
gap&gt; C!.GeneratorPol;
x_1^11+x_1^10+x_1^6+x_1^5+x_1^4+x_1^2+Z(2)^0

</pre></td></tr></table>

<p>Then functions that generate cyclic codes from a prescribed set of roots of the generator polynomial are described, including the BCH codes (see <code class="func">RootsCode</code> (<a href="chap5.html#s5ss3"><b>5.5-3</b></a>), <code class="func">BCHCode</code> (<a href="chap5.html#s5ss4"><b>5.5-4</b></a>), <code class="func">ReedSolomonCode</code> (<a href="chap5.html#s5ss5"><b>5.5-5</b></a>) and <code class="func">QRCode</code> (<a href="chap5.html#s5ss6"><b>5.5-6</b></a>)).</p>

<p>Finally we describe the trivial codes (see <code class="func">WholeSpaceCode</code> (<a href="chap5.html#s5ss8"><b>5.5-8</b></a>), <code class="func">NullCode</code> (<a href="chap5.html#s5ss9"><b>5.5-9</b></a>), <code class="func">RepetitionCode</code> (<a href="chap5.html#s5ss10"><b>5.5-10</b></a>)), and the command <code class="code">CyclicCodes</code> which lists all cyclic codes (<code class="func">CyclicCodes</code> (<a href="chap5.html#s5ss11"><b>5.5-11</b></a>)).</p>

<p><a id="s5ss1" name="s5ss1"></a></p>

<h5>5.5-1 GeneratorPolCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GeneratorPolCode</code>( <var>g, n[, name,] F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">GeneratorPolCode</code> creates a cyclic code with a generator polynomial <var>g</var>, word length <var>n</var>, over <var>F</var>. <var>name</var> can contain a short description of the code.</p>

<p>If <var>g</var> is not a divisor of x^n-1, it cannot be a generator polynomial. In that case, a code is created with generator polynomial gcd( g, x^n-1 ), i.e. the greatest common divisor of <var>g</var> and x^n-1. This is a valid generator polynomial that generates the ideal (g). See <code class="func">Generating Cyclic Codes</code> (<a href="chap5.html#s5ss0"><b>5.5</b></a>).</p>


<table class="example">
<tr><td><pre>

gap&gt; x:= Indeterminate( GF(2) );; P:= x^2+1;
Z(2)^0+x^2
gap&gt; C1 := GeneratorPolCode(P, 7, GF(2));
a cyclic [7,6,1..2]1 code defined by generator polynomial over GF(2)
gap&gt; GeneratorPol( C1 );
Z(2)^0+x
gap&gt; C2 := GeneratorPolCode( x+1, 7, GF(2)); 
a cyclic [7,6,1..2]1 code defined by generator polynomial over GF(2)
gap&gt; GeneratorPol( C2 );
Z(2)^0+x

</pre></td></tr></table>

<p><a id="s5ss2" name="s5ss2"></a></p>

<h5>5.5-2 CheckPolCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CheckPolCode</code>( <var>h, n[, name,] F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">CheckPolCode</code> creates a cyclic code with a check polynomial <var>h</var>, word length <var>n</var>, over <var>F</var>. <var>name</var> can contain a short description of the code (as a string).</p>

<p>If <var>h</var> is not a divisor of x^n-1, it cannot be a check polynomial. In that case, a code is created with check polynomial gcd( h, x^n-1 ), i.e. the greatest common divisor of <var>h</var> and x^n-1. This is a valid check polynomial that yields the same elements as the ideal (h). See <a href="chap5.html#s5ss0"><b>5.5</b></a>.</p>


<table class="example">
<tr><td><pre>

gap&gt;  x:= Indeterminate( GF(3) );; P:= x^2+2;
-Z(3)^0+x_1^2
gap&gt; H := CheckPolCode(P, 7, GF(3));
a cyclic [7,1,7]4 code defined by check polynomial over GF(3)
gap&gt; CheckPol(H);
-Z(3)^0+x_1
gap&gt; Gcd(P, X(GF(3))^7-1);
-Z(3)^0+x_1

</pre></td></tr></table>

<p><a id="s5ss3" name="s5ss3"></a></p>

<h5>5.5-3 RootsCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RootsCode</code>( <var>n, list</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This is the generalization of the BCH, Reed-Solomon and quadratic residue codes (see <code class="func">BCHCode</code> (<a href="chap5.html#s5ss4"><b>5.5-4</b></a>), <code class="func">ReedSolomonCode</code> (<a href="chap5.html#s5ss5"><b>5.5-5</b></a>) and <code class="func">QRCode</code> (<a href="chap5.html#s5ss6"><b>5.5-6</b></a>)). The user can give a length of the code <var>n</var> and a prescribed set of zeros. The argument <var>list</var> must be a valid list of primitive n^th roots of unity in a splitting field GF(q^m). The resulting code will be over the field GF(q). The function will return the largest possible cyclic code for which the list <var>list</var> is a subset of the roots of the code. From this list, <strong class="pkg">GUAVA</strong> calculates the entire set of roots.</p>

<p>This command can also be called with the syntax <code class="code">RootsCode( n, list, q )</code>. In this second form, the second argument is a list of integers, ranging from 0 to n-1. The resulting code will be over a field GF(q). <strong class="pkg">GUAVA</strong> calculates a primitive n^th root of unity, alpha, in the extension field of GF(q). It uses the set of the powers of alpha in the list as a prescribed set of zeros.</p>


<table class="example">
<tr><td><pre>

gap&gt; a := PrimitiveUnityRoot( 3, 14 );
Z(3^6)^52
gap&gt; C1 := RootsCode( 14, [ a^0, a, a^3 ] );
a cyclic [14,7,3..6]3..7 code defined by roots over GF(3)
gap&gt; MinimumDistance( C1 );
4
gap&gt; b := PrimitiveUnityRoot( 2, 15 );
Z(2^4)
gap&gt; C2 := RootsCode( 15, [ b, b^2, b^3, b^4 ] );
a cyclic [15,7,5]3..5 code defined by roots over GF(2)
gap&gt; C2 = BCHCode( 15, 5, GF(2) );
true 


</pre></td></tr></table>

<p><a id="s5ss4" name="s5ss4"></a></p>

<h5>5.5-4 BCHCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BCHCode</code>( <var>n[, b,] delta, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The function <code class="code">BCHCode</code> returns a 'Bose-Chaudhuri-Hockenghem code' (or <em>BCH code</em> for short). This is the largest possible cyclic code of length <var>n</var> over field <var>F</var>, whose generator polynomial has zeros</p>

<p class="pcenter">\[
a^{b},a^{b+1}, ..., a^{b+delta-2}, 
 \]</p>

<p>where a is a primitive n^th root of unity in the splitting field GF(q^m), <var>b</var> is an integer 0&lt;= b&lt;= n-delta+1 and m is the multiplicative order of q modulo <var>n</var>. (The integers b,...,b+delta-2 typically lie in the range 1,...,n-1.) Default value for <var>b</var> is 1, though the algorithm allows b=0. The length <var>n</var> of the code and the size q of the field must be relatively prime. The generator polynomial is equal to the least common multiple of the minimal polynomials of</p>

<p class="pcenter">\[
a^{b}, a^{b+1}, ..., a^{b+delta-2}.
 \]</p>

<p>The set of zeroes of the generator polynomial is equal to the union of the sets</p>

<p class="pcenter">\[
\{a^x\ |\ x \in C_k\},
 \]</p>

<p>where C_k is the k^th cyclotomic coset of q modulo n and b&lt;= k&lt;= b+delta-2 (see <code class="func">CyclotomicCosets</code> (<a href="chap7.html#s5ss13"><b>7.5-13</b></a>)).</p>

<p>Special cases are b=1 (resulting codes are called 'narrow-sense' BCH codes), and n=q^m-1 (known as 'primitive' BCH codes). <strong class="pkg">GUAVA</strong> calculates the largest value of d for which the BCH code with designed distance d coincides with the BCH code with designed distance <var>delta</var>. This distance d is called the <em>Bose distance</em> of the code. The true minimum distance of the code is greater than or equal to the Bose distance.</p>

<p>Printed are the designed distance (to be precise, the Bose distance) d, and the starting power b.</p>

<p>The Sugiyama decoding algorithm has been implemented for this code (see <code class="func">Decode</code> (<a href="chap3.html#s10ss1"><b>3.10-1</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := BCHCode( 15, 3, 5, GF(2) );
a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
gap&gt; DesignedDistance( C1 );
7
gap&gt; C2 := BCHCode( 23, 2, GF(2) );
a cyclic [23,12,5..7]3 BCH code, delta=5, b=1 over GF(2)
gap&gt; DesignedDistance( C2 );       
5
gap&gt; MinimumDistance(C2);
7 

</pre></td></tr></table>

<p>See <code class="func">RootsCode</code> (<a href="chap5.html#s5ss3"><b>5.5-3</b></a>) for a more general construction.</p>

<p><a id="s5ss5" name="s5ss5"></a></p>

<h5>5.5-5 ReedSolomonCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ReedSolomonCode</code>( <var>n, d</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ReedSolomonCode</code> returns a 'Reed-Solomon code' of length <var>n</var>, designed distance <var>d</var>. This code is a primitive narrow-sense BCH code over the field GF(q), where q=n+1. The dimension of an RS code is n-d+1. According to the Singleton bound (see <code class="func">UpperBoundSingleton</code> (<a href="chap7.html#s1ss1"><b>7.1-1</b></a>)) the dimension cannot be greater than this, so the true minimum distance of an RS code is equal to <var>d</var> and the code is maximum distance separable (see <code class="func">IsMDSCode</code> (<a href="chap3.html#s3ss7"><b>3.3-7</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := ReedSolomonCode( 3, 2 );
a cyclic [3,2,2]1 Reed-Solomon code over GF(4)
gap&gt; IsCyclicCode(C1);
true
gap&gt; C2 := ReedSolomonCode( 4, 3 );
a cyclic [4,2,3]2 Reed-Solomon code over GF(5)
gap&gt; RootsOfCode( C2 );
[ Z(5), Z(5)^2 ]
gap&gt; IsMDSCode(C2);
true 

</pre></td></tr></table>

<p>See <code class="func">GeneralizedReedSolomonCode</code> (<a href="chap5.html#s6ss2"><b>5.6-2</b></a>) for a more general construction.</p>

<p><a id="s5ss6" name="s5ss6"></a></p>

<h5>5.5-6 QRCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QRCode</code>( <var>n, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">QRCode</code> returns a quadratic residue code. If <var>F</var> is a field GF(q), then q must be a quadratic residue modulo <var>n</var>. That is, an x exists with x^2 = q mod n. Both <var>n</var> and q must be primes. Its generator polynomial is the product of the polynomials x-a^i. a is a primitive n^th root of unity, and i is an integer in the set of quadratic residues modulo <var>n</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := QRCode( 7, GF(2) );
a cyclic [7,4,3]1 quadratic residue code over GF(2)
gap&gt; IsEquivalent( C1, HammingCode( 3, GF(2) ) );
true
gap&gt; IsCyclicCode(C1);
true
gap&gt; IsCyclicCode(HammingCode( 3, GF(2) ));
false
gap&gt; C2 := QRCode( 11, GF(3) );
a cyclic [11,6,4..5]2 quadratic residue code over GF(3)
gap&gt; C2 = TernaryGolayCode();
true 

</pre></td></tr></table>

<p><a id="s5ss7" name="s5ss7"></a></p>

<h5>5.5-7 FireCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; FireCode</code>( <var>g, b</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">FireCode</code> constructs a (binary) Fire code. <var>g</var> is a primitive polynomial of degree m, and a factor of x^r-1. <var>b</var> an integer 0 &lt;= b &lt;= m not divisible by r, that determines the burst length of a single error burst that can be corrected. The argument <var>g</var> can be a polynomial with base ring GF(2), or a list of coefficients in GF(2). The generator polynomial of the code is defined as the product of <var>g</var> and x^2b-1+1.</p>

<p>Here is the general definition of 'Fire code', named after P. Fire, who introduced these codes in 1959 in order to correct burst errors. First, a definition. If F=GF(q) and fin F[x] then we say f has <em>order</em> e if f(x)|(x^e-1). A <em>Fire code</em> is a cyclic code over F with generator polynomial g(x)= (x^2t-1-1)p(x), where p(x) does not divide x^2t-1-1 and satisfies deg(p(x))&gt;= t. The length of such a code is the order of g(x). Non-binary Fire codes have not been implemented.</p>

<p>.</p>


<table class="example">
<tr><td><pre>

gap&gt; x:= Indeterminate( GF(2) );; G:= x^3+x^2+1;
Z(2)^0+x^2+x^3
gap&gt; Factors( G );
[ Z(2)^0+x^2+x^3 ]
gap&gt; C := FireCode( G, 3 );
a cyclic [35,27,1..4]2..6 3 burst error correcting fire code over GF(2)
gap&gt; MinimumDistance( C );
4     # Still it can correct bursts of length 3 

</pre></td></tr></table>

<p><a id="s5ss8" name="s5ss8"></a></p>

<h5>5.5-8 WholeSpaceCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; WholeSpaceCode</code>( <var>n, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">WholeSpaceCode</code> returns the cyclic whole space code of length <var>n</var> over <var>F</var>. This code consists of all polynomials of degree less than <var>n</var> and coefficients in <var>F</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; C := WholeSpaceCode( 5, GF(3) );
a cyclic [5,5,1]0 whole space code over GF(3)

</pre></td></tr></table>

<p><a id="s5ss9" name="s5ss9"></a></p>

<h5>5.5-9 NullCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; NullCode</code>( <var>n, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">NullCode</code> returns the zero-dimensional nullcode with length <var>n</var> over <var>F</var>. This code has only one word: the all zero word. It is cyclic though!</p>


<table class="example">
<tr><td><pre>

gap&gt; C := NullCode( 5, GF(3) );
a cyclic [5,0,5]5 nullcode over GF(3)
gap&gt; AsSSortedList( C );
[ [ 0 0 0 0 0 ] ]

</pre></td></tr></table>

<p><a id="s5ss10" name="s5ss10"></a></p>

<h5>5.5-10 RepetitionCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RepetitionCode</code>( <var>n, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">RepetitionCode</code> returns the cyclic repetition code of length <var>n</var> over <var>F</var>. The code has as many elements as <var>F</var>, because each codeword consists of a repetition of one of these elements.</p>


<table class="example">
<tr><td><pre>

gap&gt; C := RepetitionCode( 3, GF(5) );
a cyclic [3,1,3]2 repetition code over GF(5)
gap&gt; AsSSortedList( C );
[ [ 0 0 0 ], [ 1 1 1 ], [ 2 2 2 ], [ 4 4 4 ], [ 3 3 3 ] ]
gap&gt; IsPerfectCode( C );
false
gap&gt; IsMDSCode( C );
true 

</pre></td></tr></table>

<p><a id="s5ss11" name="s5ss11"></a></p>

<h5>5.5-11 CyclicCodes</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CyclicCodes</code>( <var>n, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">CyclicCodes</code> returns a list of all cyclic codes of length <var>n</var> over <var>F</var>. It constructs all possible generator polynomials from the factors of x^n-1. Each combination of these factors yields a generator polynomial after multiplication.</p>


<table class="example">
<tr><td><pre>

gap&gt; CyclicCodes(3,GF(3));
[ a cyclic [3,3,1]0 enumerated code over GF(3), 
a cyclic [3,2,1..2]1 enumerated code over GF(3), 
a cyclic [3,1,3]2 enumerated code over GF(3), 
a cyclic [3,0,3]3 enumerated code over GF(3) ]

</pre></td></tr></table>

<p><a id="s5ss12" name="s5ss12"></a></p>

<h5>5.5-12 NrCyclicCodes</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; NrCyclicCodes</code>( <var>n, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The function <code class="code">NrCyclicCodes</code> calculates the number of cyclic codes of length <var>n</var> over field <var>F</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; NrCyclicCodes( 23, GF(2) );
8
gap&gt; codelist := CyclicCodes( 23, GF(2) );
[ a cyclic [23,23,1]0 enumerated code over GF(2), 
  a cyclic [23,22,1..2]1 enumerated code over GF(2), 
  a cyclic [23,11,1..8]4..7 enumerated code over GF(2), 
  a cyclic [23,0,23]23 enumerated code over GF(2), 
  a cyclic [23,11,1..8]4..7 enumerated code over GF(2), 
  a cyclic [23,12,1..7]3 enumerated code over GF(2), 
  a cyclic [23,1,23]11 enumerated code over GF(2), 
  a cyclic [23,12,1..7]3 enumerated code over GF(2) ]
gap&gt; BinaryGolayCode() in codelist;
true
gap&gt; RepetitionCode( 23, GF(2) ) in codelist;
true
gap&gt; CordaroWagnerCode( 23 ) in codelist;
false    # This code is not cyclic 

</pre></td></tr></table>

<p><a id="s6ss0" name="s6ss0"></a></p>

<h4>5.6 
Evaluation Codes
</h4>

<p><a id="s6ss1" name="s6ss1"></a></p>

<h5>5.6-1 EvaluationCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; EvaluationCode</code>( <var>P, L, R</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Input: <var>F</var> is a finite field, <var>L</var> is a list of rational functions in R=F[x_1,...,x_r], <var>P</var> is a list of n points in F^r at which all of the functions in <var>L</var> are defined. <br /> Output: The 'evaluation code' C, which is the image of the evalation map</p>

<p class="pcenter">\[
Eval_P:span(L)\rightarrow F^n,
 \]</p>

<p>given by flongmapsto (f(p_1),...,f(p_n)), where P=p_1,...,p_n and f in L. The generator matrix of C is G=(f_i(p_j))_f_iin L,p_jin P.</p>

<p>This command returns a "record" object <code class="code">C</code> with several extra components (type <code class="code">NamesOfComponents(C)</code> to see them all): <code class="code">C!.points</code> (namely <var>P</var>), <code class="code">C!.basis</code> (namely <var>L</var>), and <code class="code">C!.ring</code> (namely <var>R</var>).</p>


<table class="example">
<tr><td><pre>

gap&gt; F:=GF(11);
GF(11)
gap&gt; R := PolynomialRing(F,["x","y"]);
PolynomialRing(..., [ x, y ])
gap&gt; indets := IndeterminatesOfPolynomialRing(R);;
gap&gt; x:=indets[1];; y:=indets[2];;
gap&gt; L:=[x^2*y,x*y,x^5,x^4,x^3,x^2,x,x^0];;
gap&gt; Pts:=[ [ Z(11)^9, Z(11) ], [ Z(11)^8, Z(11) ], [ Z(11)^7, 0*Z(11) ],
   [ Z(11)^6, 0*Z(11) ], [ Z(11)^5, 0*Z(11) ], [ Z(11)^4, 0*Z(11) ],
   [ Z(11)^3, Z(11) ], [ Z(11)^2, 0*Z(11) ], [ Z(11), 0*Z(11) ], [ Z(11)^0, 0*Z(11) ],
   [ 0*Z(11), Z(11) ] ];;
gap&gt; C:=EvaluationCode(Pts,L,R);
a linear [11,8,1..3]2..3  evaluation code over GF(11)
gap&gt; MinimumDistance(C);
3


</pre></td></tr></table>

<p><a id="s6ss2" name="s6ss2"></a></p>

<h5>5.6-2 GeneralizedReedSolomonCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GeneralizedReedSolomonCode</code>( <var>P, k, R</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Input: R=F[x], where <var>F</var> is a finite field, <var>k</var> is a positive integer, <var>P</var> is a list of n points in F. <br /> Output: The C which is the image of the evaluation map</p>

<p class="pcenter">\[
Eval_P:F[x]_k\rightarrow F^n,
 \]</p>

<p>given by flongmapsto (f(p_1),...,f(p_n)), where P=p_1,...,p_nsubset F and f ranges over the space F[x]_k of all polynomials of degree less than k.</p>

<p>This command returns a "record" object <code class="code">C</code> with several extra components (type <code class="code">NamesOfComponents(C)</code> to see them all): <code class="code">C!.points</code> (namely <var>P</var>), <code class="code">C!.degree</code> (namely <var>k</var>), and <code class="code">C!.ring</code> (namely <var>R</var>).</p>

<p>This code can be decoded using <code class="code">Decodeword</code>, which applies the special decoder method (the interpolation method), or using <code class="code">GeneralizedReedSolomonDecoderGao</code> which applies an algorithm of S. Gao (see <code class="func">GeneralizedReedSolomonDecoderGao</code> (<a href="chap3.html#s10ss3"><b>3.10-3</b></a>)). This code has a special decoder record which implements the interpolation algorithm described in section 5.2 of Justesen and Hoholdt <a href="chapBib.html#biBJH04">[JH04]</a>. See <code class="func">Decode</code> (<a href="chap3.html#s10ss1"><b>3.10-1</b></a>) and <code class="func">Decodeword</code> (<a href="chap3.html#s10ss2"><b>3.10-2</b></a>) for more details.</p>

<p>The weighted version has implemented with the option <code class="code">GeneralizedReedSolomonCode(P,k,R,wts)</code>, where wts = [v_1, ..., v_n] is a sequence of n non-zero elements from the base field F of <var>R</var>. See also the generalized Reed--Solomon code GRS_k(P, V) described in <a href="chapBib.html#biBMS83">[MS83]</a>, p.303.</p>

<p><em>Work in progress</em>: The list-decoding algorithm of Sudan-Guraswami (described in section 12.1 of <a href="chapBib.html#biBJH04">[JH04]</a>) should be implemented. See <code class="func">GeneralizedReedSolomonListDecoder</code> (<a href="chap3.html#s10ss4"><b>3.10-4</b></a>).</p>


<table class="example">
<tr><td><pre>

gap&gt; R:=PolynomialRing(GF(11),["t"]);
GF(11)[t]
gap&gt; P:=List([1,3,4,5,7],i-&gt;Z(11)^i);
[ Z(11), Z(11)^3, Z(11)^4, Z(11)^5, Z(11)^7 ]
gap&gt; C:=GeneralizedReedSolomonCode(P,3,R);
a linear [5,3,1..3]2  generalized Reed-Solomon code over GF(11)
gap&gt; MinimumDistance(C);
3
gap&gt; V:=[Z(11)^0,Z(11)^0,Z(11)^0,Z(11)^0,Z(11)];
[ Z(11)^0, Z(11)^0, Z(11)^0, Z(11)^0, Z(11) ]
gap&gt; C:=GeneralizedReedSolomonCode(P,3,R,V);
a linear [5,3,1..3]2  weighted generalized Reed-Solomon code over GF(11)
gap&gt; MinimumDistance(C);
3

</pre></td></tr></table>

<p>See <code class="func">EvaluationCode</code> (<a href="chap5.html#s6ss1"><b>5.6-1</b></a>) for a more general construction.</p>

<p><a id="s6ss3" name="s6ss3"></a></p>

<h5>5.6-3 GeneralizedReedMullerCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GeneralizedReedMullerCode</code>( <var>Pts, r, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">GeneralizedReedMullerCode</code> returns a 'Reed-Muller code' C with length |Pts| and order r. One considers (a) a basis of monomials for the vector space over F=GF(q) of all polynomials in F[x_1,...,x_d] of degree at most r, and (b) a set Pts of points in F^d. The generator matrix of the associated <em>Reed-Muller code</em> C is G=(f(p))_fin B,p in Pts. This code C is constructed using the command <code class="code">GeneralizedReedMullerCode(Pts,r,F)</code>. When Pts is the set of all q^d points in F^d then the command <code class="code">GeneralizedReedMuller(d,r,F)</code> yields the code. When Pts is the set of all (q-1)^d points with no coordinate equal to 0 then this is can be constructed using the <code class="code">ToricCode</code> command (as a special case).</p>

<p>This command returns a "record" object <code class="code">C</code> with several extra components (type <code class="code">NamesOfComponents(C)</code> to see them all): <code class="code">C!.points</code> (namely <var>Pts</var>) and <code class="code">C!.degree</code> (namely <var>r</var>).</p>


<table class="example">
<tr><td><pre>

gap&gt; Pts:=ToricPoints(2,GF(5));
[ [ Z(5)^0, Z(5)^0 ], [ Z(5)^0, Z(5) ], [ Z(5)^0, Z(5)^2 ], [ Z(5)^0, Z(5)^3 ],
  [ Z(5), Z(5)^0 ], [ Z(5), Z(5) ], [ Z(5), Z(5)^2 ], [ Z(5), Z(5)^3 ],
  [ Z(5)^2, Z(5)^0 ], [ Z(5)^2, Z(5) ], [ Z(5)^2, Z(5)^2 ], [ Z(5)^2, Z(5)^3 ],
  [ Z(5)^3, Z(5)^0 ], [ Z(5)^3, Z(5) ], [ Z(5)^3, Z(5)^2 ], [ Z(5)^3, Z(5)^3 ] ]
gap&gt; C:=GeneralizedReedMullerCode(Pts,2,GF(5));
a linear [16,6,1..11]6..10  generalized Reed-Muller code over GF(5)

</pre></td></tr></table>

<p>See <code class="func">EvaluationCode</code> (<a href="chap5.html#s6ss1"><b>5.6-1</b></a>) for a more general construction.</p>

<p><a id="s6ss4" name="s6ss4"></a></p>

<h5>5.6-4 AffinePointsOnCurve</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AffinePointsOnCurve</code>( <var>f, R, E</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">AffinePointsOnCurve(f,R,E)</code> returns the points (x,y) in E^2 satisying f(x,y)=0, where <var>f</var> is an element of R=F[x,y].</p>


<table class="example">
<tr><td><pre>

gap&gt; F:=GF(11);;
gap&gt; R := PolynomialRing(F,["x","y"]);
PolynomialRing(..., [ x, y ])
gap&gt; indets := IndeterminatesOfPolynomialRing(R);;
gap&gt; x:=indets[1];; y:=indets[2];;
gap&gt; P:=AffinePointsOnCurve(y^2-x^11+x,R,F);
[ [ Z(11)^9, 0*Z(11) ], [ Z(11)^8, 0*Z(11) ], [ Z(11)^7, 0*Z(11) ], 
  [ Z(11)^6, 0*Z(11) ], [ Z(11)^5, 0*Z(11) ], [ Z(11)^4, 0*Z(11) ], 
  [ Z(11)^3, 0*Z(11) ], [ Z(11)^2, 0*Z(11) ], [ Z(11), 0*Z(11) ], 
  [ Z(11)^0, 0*Z(11) ], [ 0*Z(11), 0*Z(11) ] ]

</pre></td></tr></table>

<p><a id="s6ss5" name="s6ss5"></a></p>

<h5>5.6-5 OnePointAGCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; OnePointAGCode</code>( <var>f, P, m, R</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Input: <var>f</var> is a polynomial in R=F[x,y], where <var>F</var> is a finite field, <var>m</var> is a positive integer (the multiplicity of the `point at infinity' infty on the curve f(x,y)=0), <var>P</var> is a list of n points on the curve over F. <br /> Output: The C which is the image of the evaluation map</p>

<p class="pcenter">\[
Eval_P:L(m \cdot \infty)\rightarrow F^n,
 \]</p>

<p>given by flongmapsto (f(p_1),...,f(p_n)), where p_i in P. Here L(m * infty) denotes the Riemann-Roch space of the divisor m * infty on the curve. This has a basis consisting of monomials x^iy^j, where (i,j) range over a polygon depending on m and f(x,y). For more details on the Riemann-Roch space of the divisor m * infty see Proposition III.10.5 in Stichtenoth <a href="chapBib.html#biBSt93">[S93]</a>.</p>

<p>This command returns a "record" object <code class="code">C</code> with several extra components (type <code class="code">NamesOfComponents(C)</code> to see them all): <code class="code">C!.points</code> (namely <var>P</var>), <code class="code">C!.multiplicity</code> (namely <var>m</var>), <code class="code">C!.curve</code> (namely <var>f</var>) and <code class="code">C!.ring</code> (namely <var>R</var>).</p>


<table class="example">
<tr><td><pre>

gap&gt; F:=GF(11);
GF(11)
gap&gt; R := PolynomialRing(F,["x","y"]);
PolynomialRing(..., [ x, y ])
gap&gt; indets := IndeterminatesOfPolynomialRing(R);
[ x, y ]
gap&gt; x:=indets[1]; y:=indets[2];
x
y
gap&gt; P:=AffinePointsOnCurve(y^2-x^11+x,R,F);;
gap&gt; C:=OnePointAGCode(y^2-x^11+x,P,15,R);
a linear [11,8,1..0]2..3  one-point AG code over GF(11)
gap&gt; MinimumDistance(C);
4
gap&gt; Pts:=List([1,2,4,6,7,8,9,10,11],i-&gt;P[i]);;
gap&gt; C:=OnePointAGCode(y^2-x^11+x,PT,10,R);
a linear [9,6,1..4]2..3 one-point AG code over GF(11)
gap&gt; MinimumDistance(C);
4

</pre></td></tr></table>

<p>See <code class="func">EvaluationCode</code> (<a href="chap5.html#s6ss1"><b>5.6-1</b></a>) for a more general construction.</p>

<p><a id="s6ss6" name="s6ss6"></a></p>

<h5>5.6-6 ToricPoints</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ToricPoints</code>( <var>n, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ToricPoints(n,F)</code> returns the points in (F^times)^n.</p>


<table class="example">
<tr><td><pre>

gap&gt; ToricPoints(2,GF(5));
[ [ Z(5)^0, Z(5)^0 ], [ Z(5)^0, Z(5) ], [ Z(5)^0, Z(5)^2 ], 
  [ Z(5)^0, Z(5)^3 ], [ Z(5), Z(5)^0 ], [ Z(5), Z(5) ], [ Z(5), Z(5)^2 ], 
  [ Z(5), Z(5)^3 ], [ Z(5)^2, Z(5)^0 ], [ Z(5)^2, Z(5) ], [ Z(5)^2, Z(5)^2 ], 
  [ Z(5)^2, Z(5)^3 ], [ Z(5)^3, Z(5)^0 ], [ Z(5)^3, Z(5) ], 
  [ Z(5)^3, Z(5)^2 ], [ Z(5)^3, Z(5)^3 ] ]

</pre></td></tr></table>

<p><a id="s6ss7" name="s6ss7"></a></p>

<h5>5.6-7 ToricCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ToricCode</code>( <var>L, F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This function returns the toric codes as in D. Joyner <a href="chapBib.html#biBJo04">[J04]</a> (see also J. P. Hansen <a href="chapBib.html#biBHan99">[H99]</a>). This is a truncated (generalized) Reed-Muller code. Here <var>L</var> is a list of integral vectors and <var>F</var> is the finite field. The size of <var>F</var> must be different from 2.</p>

<p>This command returns a record object <code class="code">C</code> with an extra component (type <code class="code">NamesOfComponents(C)</code> to see them all): <code class="code">C!.exponents</code> (namely <var>L</var>).</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=ToricCode([[1,0],[3,4]],GF(3));
a linear [4,1,4]2 toric code over GF(3)
gap&gt; Display(GeneratorMat(C));
 1 1 2 2
gap&gt; Elements(C);
[ [ 0 0 0 0 ], [ 1 1 2 2 ], [ 2 2 1 1 ] ]

</pre></td></tr></table>

<p>See <code class="func">EvaluationCode</code> (<a href="chap5.html#s6ss1"><b>5.6-1</b></a>) for a more general construction.</p>


<div class="pcenter">
<table class="chlink"><tr><td><a href="chap0.html">Top of Book</a></td><td><a href="chap4.html">Previous Chapter</a></td><td><a href="chap6.html">Next Chapter</a></td></tr></table>
<br />


<div class="pcenter"><table class="chlink"><tr><td class="chlink1">Goto Chapter: </td><td><a href="chap0.html">Top</a></td><td><a href="chap1.html">1</a></td><td><a href="chap2.html">2</a></td><td><a href="chap3.html">3</a></td><td><a href="chap4.html">4</a></td><td><a href="chap5.html">5</a></td><td><a href="chap6.html">6</a></td><td><a href="chap7.html">7</a></td><td><a href="chapBib.html">Bib</a></td><td><a href="chapInd.html">Ind</a></td></tr></table><br /></div>

</div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
