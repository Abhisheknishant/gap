<html><head><title>[GUAVA] 6 Bounds on Codes, Special Matrices and Miscellaneous Functions</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP005.htm">Previous</a>] [<a href ="CHAP007.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>6 Bounds on Codes, Special Matrices and Miscellaneous Functions</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP006.htm#SECT001">Bounds on codes</a>
<li> <A HREF="CHAP006.htm#SECT002">Special matrices in GUAVA</a>
<li> <A HREF="CHAP006.htm#SECT003">Miscellaneous functions</a>
</ol><p>
<p>
In this chapter we describe functions that determine bounds on  the  size
and minimum distance of codes (Section&nbsp;<a href="CHAP006.htm#SECT001">Bounds on codes</a>), functions that
work  with  special  matrices  <font face="Gill Sans,Helvetica,Arial">GUAVA</font>  needs  for  several  codes  (see
Section&nbsp;<a href="CHAP006.htm#SECT002">Special  matrices  in  GUAVA</a>),  and   constructing   codes   or
performing   calculations   with   codes   (see    Section&nbsp;<a href="CHAP006.htm#SECT003">Miscellaneous functions</a>).
<p>
<p>
<h2><a name="SECT001">6.1 Bounds on codes</a></h2>
<p><p>
This  section describes the functions  that calculate estimates for upper
bounds on the size and minimum distance  of codes. Several algorithms are
known to compute a largest  number of words a   code can have with  given
length and  minimum distance. It is important  however to understand that
in some cases the true  upper bound is unknown.  A code which has a  size
equal to  the calculated upper bound may  not  have been found.  However,
codes that have a larger size do not exist.
<p>
A second way to obtain bounds is a table. In <font face="Gill Sans,Helvetica,Arial">GUAVA</font>, an extensive table
is implemented for linear codes over  GF(2), GF(3) and GF(4). It contains
bounds on the minimum distance for given  word length and dimension.  For
binary codes, it contains  entries for word  length less than or equal to
257. For  codes over <i>GF</i>(3)  and  <i>GF</i>(4), it contains entries  for word
length less than or equal to 130.
<p>
Firstly, we describe functions that compute specific upper bounds on  the
code    size     (see     <a href="CHAP006.htm#SSEC001.1">UpperBoundSingleton</a>,     <a href="CHAP006.htm#SSEC001.2">UpperBoundHamming</a>,
<a href="CHAP006.htm#SSEC001.3">UpperBoundJohnson</a>,    <a href="CHAP006.htm#SSEC001.4">UpperBoundPlotkin</a>,    <a href="CHAP006.htm#SSEC001.5">UpperBoundElias</a>     and
<a href="CHAP006.htm#SSEC001.6">UpperBoundGriesmer</a>).
<p>
Next we describe a function that computes <font face="Gill Sans,Helvetica,Arial">GUAVA</font>'s best upper bound  on
the code size (see <a href="CHAP006.htm#SSEC001.7">UpperBound</a>).
<p>
Then we describe two functions that compute a lower and  upper  bound  on
the minimum distance  of  a  code  (see  <a href="CHAP006.htm#SSEC001.8">LowerBoundMinimumDistance</a>  and
<a href="CHAP006.htm#SSEC001.10">UpperBoundMinimumDistance</a>).
<p>
Finally, we describe a function that returns a lower and upper  bound  on
the minimum distance with given parameters and a description of  how  the
bounds were obtained (see <a href="CHAP006.htm#SSEC001.12">BoundsMinimumDistance</a>).
<p>
<a name = "I0"></a>

<a name = "SSEC001.1"></a>
<li><code>UpperBoundSingleton( </code><var>n</var><code>, </code><var>d</var><code>, </code><var>q</var><code> )</code>
<p>
<code>UpperBoundSingleton</code> returns the  Singleton bound for  a code of  length
<var>n</var>, minimum distance <var>d</var> over  a field of size  <var>q</var>. This bound is based
on  the  shortening of codes.  By  shortening an (<i>n</i>, <i>M</i>, <i>d</i>)  code <i>d</i><font face="symbol">-</font>1
times,  an (<i>n</i><font face="symbol">-</font><i>d</i>+1,<i>M</i>,1)   code results, with   <i>M</i>  <font face="symbol">£</font> <i>q</i><sup><i>n</i><font face="symbol">-</font><i>d</i>+1</sup> (see
<a href="CHAP005.htm#SSEC001.11">ShortenedCode</a>). Thus
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"><i>M</i>  <font face="symbol">£</font> <i>q</i> <sup><i>n</i> <font face="symbol">-</font><i>d</i> +1</sup></td></tr></table></td></tr></table>
<p>
<a name = "I1"></a>

Codes that  meet this bound  are called <strong>maximum distance separable</strong> (see
<a href="CHAP003.htm#SSEC003.5">IsMDSCode</a>).
<p>
<pre>
gap&gt; UpperBoundSingleton(4, 3, 5);
25
gap&gt; C := ReedSolomonCode(4,3);; Size(C);
25
gap&gt; IsMDSCode(C);
true 
</pre>
<p>
<a name = "I2"></a>

<a name = "I3"></a>

<a name = "SSEC001.2"></a>
<li><code>UpperBoundHamming( </code><var>n</var><code>, </code><var>d</var><code>, </code><var>q</var><code> )</code>
<p>
The Hamming bound (also known as <strong>sphere packing bound</strong>) returns an upper
bound on the size of a code  of length <var>n</var>, minimum  distance <var>d</var>, over a
field of size <var>q</var>. The Hamming bound is obtained by dividing the contents
of the entire space <i>GF</i>(<i>q</i> ) <sup><i>n</i> </sup> by the contents  of a ball with radius
<font face="symbol">ë</font>(<i>d</i> <font face="symbol">-</font>1) / 2<font face="symbol">û</font>.  As all  these balls are disjoint, they  can
never contain more than the whole vector  space.  <br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"><i>M</i>  <font face="symbol">£</font> </td><td nowrap="nowrap" align="center"><i>q</i> <sup><i>n</i> </sup><div class="hrcomp"><hr noshade="noshade" size="1"/></div><i>V</i>(<i>n</i> ,<i>e</i>)<br /></td><td nowrap="nowrap" align="center"></td></tr></table></td></tr></table> where <i>M</i> is the maxmimum number  of codewords and <i>V</i>(<i>n</i> ,<i>e</i>)
is   equal  to   the   contents   of   a  ball     of radius  <i>e</i>    (see
<a href="CHAP006.htm#SSEC003.1">SphereContent</a>).  This bound is  useful for small  values of <var>d</var>.  Codes
for which equality holds are called <strong>perfect</strong> (see <a href="CHAP003.htm#SSEC003.4">IsPerfectCode</a>).
<p>
<pre>
gap&gt; UpperBoundHamming( 15, 3, 2 );
2048
gap&gt; C := HammingCode( 4, GF(2) );
a linear [15,11,3]1 Hamming (4,2) code over GF(2)
gap&gt; Size( C );
2048 
</pre>
<p>
<a name = "I4"></a>

<a name = "SSEC001.3"></a>
<li><code>UpperBoundJohnson( </code><var>n</var><code>, </code><var>d</var><code> )</code>
<p>
The Johnson bound  is  an improved   version  of the Hamming  bound  (see
<a href="CHAP006.htm#SSEC001.2">UpperBoundHamming</a>).   In addition to the   Hamming bound, it takes into
account the elements of the space outside the  balls of radius <i>e</i> around
the elements of the code. The Johnson bound only works for binary codes.
<p>
<pre>
gap&gt; UpperBoundJohnson( 13, 5 );
77
gap&gt; UpperBoundHamming( 13, 5, 2);
89   # in this case the Johnson bound is better 
</pre>
<p>
<a name = "I5"></a>

<a name = "SSEC001.4"></a>
<li><code>UpperBoundPlotkin( </code><var>n</var><code>, </code><var>d</var><code>, </code><var>q</var><code> )</code>
<p>
The function <code>UpperBoundPlotkin</code> calculates  the sum of the  distances of
all ordered pairs of  different codewords. It  is based on the  fact that
the  minimum distance is  at most equal to  the average distance. It is a
good bound if the weights of the codewords do not differ much. It results
in: <br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"><i>M</i>  <font face="symbol">£</font> </td><td nowrap="nowrap" align="center"><i>d</i> <div class="hrcomp"><hr noshade="noshade" size="1"/></div><i>d</i> <font face="symbol">-</font>(1<font face="symbol">-</font>1/<i>q</i> )<i>n</i> <br /></td><td nowrap="nowrap" align="center"></td></tr></table></td></tr></table>  <i>M</i> is the maximum number
of codewords.  In this case, <var>d</var>  must be larger than (1<font face="symbol">-</font>1/<i>q</i> )<i>n</i> , but
by shortening the code, the case <i>d</i>   &lt;  (1<font face="symbol">-</font>1/<i>q</i> )<i>n</i>  is covered.
<p>
<pre>
gap&gt; UpperBoundPlotkin( 15, 7, 2 );
32
gap&gt; C := BCHCode( 15, 7, GF(2) );
a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
gap&gt; Size(C);
32
gap&gt; WeightDistribution(C);
[ 1, 0, 0, 0, 0, 0, 0, 15, 15, 0, 0, 0, 0, 0, 0, 1 ] 
</pre>
<p>
<a name = "I6"></a>

<a name = "SSEC001.5"></a>
<li><code>UpperBoundElias( </code><var>n</var><code>, </code><var>d</var><code>, </code><var>q</var><code> )</code>
<p>
The  Elias    bound  is   an  improvement  of   the  Plotkin   bound (see
<a href="CHAP006.htm#SSEC001.4">UpperBoundPlotkin</a>) for large codes. Subcodes  are used to decrease  the
size  of the code, in this  case  the subcode of   all codewords within a
certain ball. This bound is useful  for large codes with relatively small
minimum distances.
<p>
<pre>
gap&gt; UpperBoundPlotkin( 16, 3, 2 );
12288
gap&gt; UpperBoundElias( 16, 3, 2 );
10280 
</pre>
<p>
<a name = "I7"></a>

<a name = "SSEC001.6"></a>
<li><code>UpperBoundGriesmer( </code><var>n</var><code>, </code><var>d</var><code>, </code><var>q</var><code> )</code>
<p>
The Griesmer  bound is valid only   for linear codes.  It is  obtained by
counting the number of equal symbols in  each row of the generator matrix
of the code. By omitting the coordinates in which all rows have a zero, a
smaller code  results.  The Griesmer bound  is obtained by repeating this
proces until a trivial code is left in the end.
<p>
<pre>
gap&gt; UpperBoundGriesmer( 13, 5, 2 );
64
gap&gt; UpperBoundGriesmer( 18, 9, 2 );
8        # the maximum number of words for a linear code is 8
gap&gt; Size( PuncturedCode( HadamardCode( 20, 1 ) ) );
20       # this non-linear code has 20 elements 
</pre>
<p>
<a name = "I8"></a>

<a name = "SSEC001.7"></a>
<li><code>UpperBound( </code><var>n</var><code>, </code><var>d</var><code>, </code><var>q</var><code> )</code>
<p>
<code>UpperBound</code> returns the best known upper bound <i>A</i>(<i>n</i> ,<i>d</i> ) for the size
of a code of length <var>n</var>, minimum  distance <var>d</var> over a  field of size <var>q</var>.
The function <code>UpperBound</code> first checks for trivial cases (like <i>d</i> =1 or
<i>n</i> =<i>d</i> ) and if the value is in the  built-in table. Then it calculates
the minimum value of the upper bound using the  methods of Singleton (see
<a href="CHAP006.htm#SSEC001.1">UpperBoundSingleton</a>),  Hamming (see <a href="CHAP006.htm#SSEC001.2">UpperBoundHamming</a>), Johnson  (see
<a href="CHAP006.htm#SSEC001.3">UpperBoundJohnson</a>), Plotkin  (see  <a href="CHAP006.htm#SSEC001.4">UpperBoundPlotkin</a>)  and Elias (see
<a href="CHAP006.htm#SSEC001.5">UpperBoundElias</a>).  If the code is   binary, <i>A</i>(<i>n</i> , 2*<i>l</i><font face="symbol">-</font>1) = <i>A</i>(<i>n</i> +1, 2*<i>l</i>), so the <code>UpperBound</code> takes the minimum of the values obtained from
all methods for the parameters (<i>n</i> , 2*<i>l</i><font face="symbol">-</font>1) and (<i>n</i> +1, 2*<i>l</i>).
<p>
<pre>
gap&gt; UpperBound( 10, 3, 2 );
85
gap&gt; UpperBound( 25, 9, 8 );
1211778792827540 
</pre>
<p>
<a name = "SSEC001.8"></a>
<li><code>LowerBoundMinimumDistance( </code><var>C</var><code> )</code>
<p>
In this form, <code>LowerBoundMinimumDistance</code>  returns a lower bound for  the
minimum distance of code <var>C</var>.
<p>
<pre>
gap&gt; C := BCHCode( 45, 7 );
a cyclic [45,23,7..9]6..16 BCH code, delta=7, b=1 over GF(2)
gap&gt; LowerBoundMinimumDistance( C );
7     # designed distance is lower bound for minimum distance 
</pre>
<p>
<a name = "SSEC001.9"></a>
<li><code>LowerBoundMinimumDistance( </code><var>n</var><code>, </code><var>k</var><code>, </code><var>F</var><code> )</code>
<p>
In this  form, <code>LowerBoundMinimumDistance</code> returns a  lower bound for the
minimum distance of  the best known linear  code of length <var>n</var>, dimension
<var>k</var>   over  field <var>F</var>.   It  uses the   mechanism   explained in  section
<a href="CHAP006.htm#SSEC001.12">BoundsMinimumDistance</a>.
<p>
<pre>
gap&gt; LowerBoundMinimumDistance( 45, 23, GF(2) );
10 
</pre>
<p>
<a name = "SSEC001.10"></a>
<li><code>UpperBoundMinimumDistance( </code><var>C</var><code> )</code>
<p>
In this form, <code>UpperBoundMinimumDistance</code>  returns an upper bound for the
minimum distance of code <var>C</var>. For unrestricted codes, it just returns the
word length. For linear codes, it takes the minimum of the possibly known
value from the method of construction,  the weight of the generators, and
the value from the table (see <a href="CHAP006.htm#SSEC001.12">BoundsMinimumDistance</a>).
<p>
<pre>
gap&gt; C := BCHCode( 45, 7 );;
gap&gt; UpperBoundMinimumDistance( C );
9 
</pre>
<p>
<a name = "SSEC001.11"></a>
<li><code>UpperBoundMinimumDistance( </code><var>n</var><code>, </code><var>k</var><code>, </code><var>F</var><code> )</code>
<p>
In this form, <code>UpperBoundMinimumDistance</code> returns  an upper bound for the
minimum distance of the  best known linear  code of length <var>n</var>, dimension
<var>k</var>  over  field   <var>F</var>.  It  uses the    mechanism explained  in  section
<a href="CHAP006.htm#SSEC001.12">BoundsMinimumDistance</a>.
<p>
<pre>
gap&gt; UpperBoundMinimumDistance( 45, 23, GF(2) );
11 
</pre>
<p>
<a name = "SSEC001.12"></a>
<li><code>BoundsMinimumDistance( </code><var>n</var><code>, </code><var>k</var><code>, </code><var>F</var><code> )</code>
<p>
The function  <code>BoundsMinimumDistance</code> calculates a  lower and upper bound
for the minimum distance of an optimal  linear code with word length <var>n</var>,
dimension <var>k</var> over field <var>F</var>. The function  returns a record with the two
bounds and an explenation for  each bound. The  function <code>Display</code> can be
used to show the explanations.
<p>
The  values   for the  lower   and  upper   bound  are  obtained from   a
table. <font face="Gill Sans,Helvetica,Arial">GUAVA</font> has tables containing lower and upper bounds for <i>q</i>=2 (<i>n</i>  <font face="symbol">£</font> 257), 3 and 4 (<i>n</i>  <font face="symbol">£</font> 130).  These tables were derived from the
table of Brouwer &amp; Verhoeff. For codes over  other fields and for larger
word lengths, trivial bounds are used.
<p>
The  resulting record can  be  used in the function <code>BestKnownLinearCode</code>
(see <a href="CHAP004.htm#SSEC002.12">BestKnownLinearCode</a>) to   construct a code  with minimum  distance
equal to the lower bound.
<p>
<pre>
gap&gt; bounds := BoundsMinimumDistance( 7, 3 );; DisplayBoundsInfo( bounds );
an optimal linear [7,3,d] code over GF(2) has d=4
------------------------------------------------------------------------------
Lb(7,3)=4, by shortening of:
Lb(8,4)=4, u u+v construction of C1 and C2:
Lb(4,3)=2, dual of the repetition code
Lb(4,1)=4, repetition code
------------------------------------------------------------------------------
Ub(7,3)=4, Griesmer bound
# The lower bound is equal to the upper bound, so a code with
# these parameters is optimal.
gap&gt; C := BestKnownLinearCode( bounds );; Display( C );
a linear [7,3,4]2..3 shortened code of
a linear [8,4,4]2 U U+V construction code of
U: a cyclic [4,3,2]1 dual code of
   a cyclic [4,1,4]2 repetition code over GF(2)
V: a cyclic [4,1,4]2 repetition code over GF(2)
</pre>
<p>
<p>
<h2><a name="SECT002">6.2 Special matrices in GUAVA</a></h2>
<p><p>
This section explains functions  that work with special matrices <font face="Gill Sans,Helvetica,Arial">GUAVA</font>
needs for several codes.
<p>
Firstly,   we   describe   some   matrix   generating   functions    (see
<a href="CHAP006.htm#SSEC002.1">KrawtchoukMat</a>, <a href="CHAP006.htm#SSEC002.2">GrayMat</a>, <a href="CHAP006.htm#SSEC002.3">SylvesterMat</a>, <a href="CHAP006.htm#SSEC002.4">HadamardMat</a> and <a href="CHAP006.htm#SSEC002.5">MOLS</a>).
<p>
Next we describe two functions regarding a standard form of matrices (see
<a href="CHAP006.htm#SSEC002.6">PutStandardForm</a> and <a href="CHAP006.htm#SSEC002.7">IsInStandardForm</a>).
<p>
Then we describe functions that return a matrix after a manipulation (see
<a href="CHAP006.htm#SSEC002.8">PermutedCols</a>,             <a href="CHAP006.htm#SSEC002.9">VerticalConversionFieldMat</a>              and
<a href="CHAP006.htm#SSEC002.10">HorizontalConversionFieldMat</a>).
<p>
Finally, we describe functions  that  do  some  tests  on  matrices  (see
<a href="CHAP006.htm#SSEC002.11">IsLatinSquare</a> and <a href="CHAP006.htm#SSEC002.12">AreMOLS</a>).
<p>
<a name = "SSEC002.1"></a>
<li><code>KrawtchoukMat( </code><var>n</var><code> , </code><var>q</var><code> )</code>
<p>
<code>KrawtchoukMat</code> returns  the   <i>n</i> +1  by <i>n</i> +1   matrix  <i>K</i>=(<i>k</i><sub><i>ij</i></sub>)
defined by <i>k</i><sub><i>ij</i></sub>=<i>K</i><sub><i>i</i></sub>(<i>j</i>) for <i>i</i>,<i>j</i>=0,&#183;.&#183;,<i>n</i>.  <i>K</i><sub><i>i</i></sub>(<i>j</i>) is the Krawtchouk
number (see <a href="CHAP006.htm#SSEC003.2">Krawtchouk</a>). <var>n</var> must be a positive integer and <var>q</var> a prime
power.  The Krawtchouk  matrix is used  in  the <strong>MacWilliams identities</strong>,
defining the relation between the weight distribution of a code of length
<var>n</var>  over  a  field  of  size <var>q</var>,  and  its  dual code.    Each call  to
<code>KrawtchoukMat</code> returns a new matrix, so it is safe to modify the result.
<p>
<pre>
gap&gt; PrintArray( KrawtchoukMat( 3, 2 ) );
[ [   1,   1,   1,   1 ],
  [   3,   1,  -1,  -3 ],
  [   3,  -1,  -1,   3 ],
  [   1,  -1,   1,  -1 ] ]
gap&gt; C := HammingCode( 3 );; a := WeightDistribution( C );
[ 1, 0, 0, 7, 7, 0, 0, 1 ]
gap&gt; n := WordLength( C );; q := Size( LeftActingDomain( C ) );;
gap&gt; k := Dimension( C );;
gap&gt; q^( -k ) * KrawtchoukMat( n, q ) * a;
[ 1, 0, 0, 0, 7, 0, 0, 0 ]
gap&gt; WeightDistribution( DualCode( C ) );
[ 1, 0, 0, 0, 7, 0, 0, 0 ] 
</pre>
<p>
<a name = "SSEC002.2"></a>
<li><code>GrayMat( </code><var>n</var><code>, </code><var>F</var><code> )</code>
<p>
<code>GrayMat</code>  returns a list   of all different  vectors  (see <code>Vectors</code>) of
length <var>n</var>  over the   field <var>F</var>,  using  Gray ordening.  <var>n</var> must   be a
positive integer.   This order has  the property that  subsequent vectors
differ in exactly one  coordinate. The first  vector  is always the  null
vector. Each  call to <code>GrayMat</code> returns  a new matrix, so  it  is safe to
modify the result.
<p>
<pre>
gap&gt; GrayMat(3);
[ [ 0*Z(2), 0*Z(2), 0*Z(2) ], [ 0*Z(2), 0*Z(2), Z(2)^0 ],
  [ 0*Z(2), Z(2)^0, Z(2)^0 ], [ 0*Z(2), Z(2)^0, 0*Z(2) ],
  [ Z(2)^0, Z(2)^0, 0*Z(2) ], [ Z(2)^0, Z(2)^0, Z(2)^0 ],
  [ Z(2)^0, 0*Z(2), Z(2)^0 ], [ Z(2)^0, 0*Z(2), 0*Z(2) ] ]
gap&gt; G := GrayMat( 4, GF(4) );; Length(G);
256          # the length of a GrayMat is always $q^n$
gap&gt; G[101] - G[100];
[ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] 
</pre>
<p>
<a name = "SSEC002.3"></a>
<li><code>SylvesterMat( </code><var>n</var><code> )</code>
<p>
<code>SylvesterMat</code> returns the <var>n</var> by <var>n</var> Sylvester matrix of order <var>n</var>. This
is a special case of the  Hadamard matrices (see <a href="CHAP006.htm#SSEC002.4">HadamardMat</a>). For this
construction, <var>n</var>  must be  a power of  2. Each  call to <code>SylvesterMat</code>
returns a new matrix, so it is safe to modify the result.
<p>
<pre>
gap&gt; PrintArray(SylvesterMat(2));
[ [   1,   1 ],
  [   1,  -1 ] ]
gap&gt; PrintArray( SylvesterMat(4) );
[ [   1,   1,   1,   1 ],
  [   1,  -1,   1,  -1 ],
  [   1,   1,  -1,  -1 ],
  [   1,  -1,  -1,   1 ] ] 
</pre>
<p>
<a name = "SSEC002.4"></a>
<li><code>HadamardMat( </code><var>n</var><code> )</code>
<p>
<code>HadamardMat</code> returns a Hadamard matrix  of order <var>n</var>. This  is an <var>n</var> by
<var>n</var> matrix with the property that the matrix  multiplied by its transpose
returns <var>n</var> times the identity matrix. This is  only possible for <i>n</i> =1, <i>n</i> =2 or in cases where <var>n</var> is a multiple of 4. If the matrix does not
exist or is not known, <code>HadamardMat</code> returns  an error. A large number of
construction methods  is known  to create  these  matrices for  different
orders. <code>HadamardMat</code> makes use of  two construction methods (among which
the Sylvester   construction (see <a href="CHAP006.htm#SSEC002.3">SylvesterMat</a>)).   These methods cover
most of the possible  Hadamard matrices, although some special algorithms
have not been implemented yet. The following orders less  than 100 do not
have an implementation for a Hadamard  matrix in <font face="Gill Sans,Helvetica,Arial">GUAVA</font>: 28, 36, 52, 76, 92&#183;
<p>
<pre>
gap&gt; C := HadamardMat(8);; PrintArray(C);
[ [   1,   1,   1,   1,   1,   1,   1,   1 ],
  [   1,  -1,   1,  -1,   1,  -1,   1,  -1 ],
  [   1,   1,  -1,  -1,   1,   1,  -1,  -1 ],
  [   1,  -1,  -1,   1,   1,  -1,  -1,   1 ],
  [   1,   1,   1,   1,  -1,  -1,  -1,  -1 ],
  [   1,  -1,   1,  -1,  -1,   1,  -1,   1 ],
  [   1,   1,  -1,  -1,  -1,  -1,   1,   1 ],
  [   1,  -1,  -1,   1,  -1,   1,   1,  -1 ] ]
gap&gt; C * TransposedMat(C) = 8 * IdentityMat( 8, 8 );
true 
</pre>
<p>
<a name = "I9"></a>

<a name = "SSEC002.5"></a>
<li><code>MOLS( </code><var>q</var><code> )</code>
<li><code>MOLS( </code><var>q</var><code>, </code><var>n</var><code> )</code>
<p>
<code>MOLS</code>   returns a   list of  <var>n</var>    <strong>Mutually Orthogonal Latin  Squares</strong>
(<strong>MOLS</strong>). A <strong>Latin   square</strong> of order <var>q</var> is   a <var>q</var> by <var>q</var>  matrix whose
entries are from a  set <i>F</i><sub><i>q</i> </sub> of <var>q</var>  distinct symbols (<font face="Gill Sans,Helvetica,Arial">GUAVA</font> uses
the integers from 0  to <var>q</var>) such that each   row and each column  of the
matrix contains each symbol exactly once.
<p>
A set of Latin squares is a set of MOLS  if and only  if for each pair of
Latin squares in this set, every ordered pair of elements that are in the
same position in these matrices occurs exactly once.
<p>
<var>n</var> must be less than <var>q</var>.  If <var>n</var> is omitted, two  MOLS are returned. If
<var>q</var> is not a prime power,  at most 2 MOLS  can be created. For all values
of  <var>q</var> with  <i>q</i> &gt;    2 and <i>q</i>   <font face="symbol">¹</font> 6, a   list  of  MOLS can  be
constructed. <font face="Gill Sans,Helvetica,Arial">GUAVA</font> however  does not yet  construct MOLS for <i>q</i>  mod
4 = 2.  If  it  is not possible   to construct <var>n</var> MOLS,  the  function
returns <code>false</code>.
<p>
MOLS are used to create <var>q</var>-ary codes (see <a href="CHAP004.htm#SSEC001.6">MOLSCode</a>).
<p>
<pre>
gap&gt; M := MOLS( 4, 3 );;PrintArray( M[1] );
[ [  0,  1,  2,  3 ],
  [  1,  0,  3,  2 ],
  [  2,  3,  0,  1 ],
  [  3,  2,  1,  0 ] ]
gap&gt; PrintArray( M[2] );
[ [  0,  2,  3,  1 ],
  [  1,  3,  2,  0 ],
  [  2,  0,  1,  3 ],
  [  3,  1,  0,  2 ] ]
gap&gt; PrintArray( M[3] );
[ [  0,  3,  1,  2 ],
  [  1,  2,  0,  3 ],
  [  2,  1,  3,  0 ],
  [  3,  0,  2,  1 ] ]
gap&gt; MOLS( 12, 3 );
false 
</pre>
<p>
<a name = "SSEC002.6"></a>
<li><code>PutStandardForm( </code><var>M</var><code> )</code>
<li><code>PutStandardForm( </code><var>M</var><code>, </code><var>idleft</var><code> )</code>
<p>
<code>PutStandardForm</code> puts   a matrix <var>M</var>  in standard  form, and returns the
permutation needed to do so. <var>idleft</var> is a boolean that sets the position
of the identity matrix in <var>M</var>. If <var>idleft</var> is set to <code>true</code>, the identity
matrix is put in the left side of <var>M</var>. Otherwise,  it is put at the right
side. The default for <var>idleft</var> is <code>true</code>.
<p>
The function <code>BaseMat</code> also returns a similar standard form, but does not
apply column  permutations. The  rows of the  matrix  still span the same
vector space after <code>BaseMat</code>,  but after calling <code>PutStandardForm</code>,  this
is not necessarily true.
<p>
<pre>
gap&gt; M := Z(2)*[[1,0,0,1],[0,0,1,1]];; PrintArray(M);
[ [    Z(2),  0*Z(2),  0*Z(2),    Z(2) ],
  [  0*Z(2),  0*Z(2),    Z(2),    Z(2) ] ]
gap&gt; PutStandardForm(M);                   # identity at the left side
(2,3)
gap&gt; PrintArray(M);
[ [    Z(2),  0*Z(2),  0*Z(2),    Z(2) ],
  [  0*Z(2),    Z(2),  0*Z(2),    Z(2) ] ]
gap&gt; PutStandardForm(M, false);            # identity at the right side
(1,4,3)
gap&gt; PrintArray(M);
[ [  0*Z(2),    Z(2),    Z(2),  0*Z(2) ],
  [  0*Z(2),    Z(2),  0*Z(2),    Z(2) ] ]
</pre>
<p>
<a name = "SSEC002.7"></a>
<li><code>IsInStandardForm( </code><var>M</var><code> )</code>
<li><code>IsInStandardForm( </code><var>M</var><code>, </code><var>idleft</var><code> )</code>
<p>
<code>IsInStandardForm</code> determines if  <var>M</var> is in  standard form. <var>idleft</var> is a
boolean that indicates  the position of the  identity  matrix in  <var>M</var>. If
<var>idleft</var> is <code>true</code>, <code>IsInStandardForm</code>  checks if the identity matrix  is
at  the  left side of  <var>M</var>, otherwise  if it  is  at  the right side. The
default for <var>idleft</var>  is <code>true</code>. The elements  of <var>M</var> may be elements  of
any field.  To put a matrix  in standard form, use <code>PutStandardForm</code> (see
<a href="CHAP006.htm#SSEC002.6">PutStandardForm</a>).
<p>
<pre>
gap&gt; IsInStandardForm(IdentityMat(7, GF(2)));
true
gap&gt; IsInStandardForm([[1, 1, 0], [1, 0, 1]], false);
true
gap&gt; IsInStandardForm([[1, 3, 2, 7]]);
true
gap&gt; IsInStandardForm(HadamardMat(4));
false 
</pre>
<p>
<a name = "SSEC002.8"></a>
<li><code>PermutedCols( </code><var>M</var><code>, </code><var>P</var><code> )</code>
<p>
<code>PermutedCols</code> returns a matrix <var>M</var> with a permutation <var>P</var> applied to its
columns.
<p>
<pre>
gap&gt; M := [[1,2,3,4],[1,2,3,4]];; PrintArray(M);
[ [  1,  2,  3,  4 ],
  [  1,  2,  3,  4 ] ]
gap&gt; PrintArray(PermutedCols(M, (1,2,3)));
[ [  3,  1,  2,  4 ],
  [  3,  1,  2,  4 ] ] 
</pre>
<p>
<a name = "SSEC002.9"></a>
<li><code>VerticalConversionFieldMat( </code><var>M</var><code>, </code><var>F</var><code> )</code>
<p>
<code>VerticalConversionFieldMat</code>  returns the matrix   <var>M</var> with  its elements
converted from a field <i>F</i> =<i>GF</i>(<i>q</i><sup><i>m</i></sup>), <i>q</i> prime, to a field <i>GF</i>(<i>q</i>). Each
element is  replaced by its  representation over the latter field, placed
vertically in the matrix.
<p>
If <var>M</var>  is a <i>k</i> by  <i>n</i> matrix, the result is   a <i>k</i>*<i>m</i> by  <i>n</i> matrix,
since each element of <i>GF</i>(<i>q</i><sup><i>m</i></sup>)  can be represented  in <i>GF</i>(<i>q</i>) using <i>m</i>
elements.
<p>
<pre>
gap&gt; M := Z(9)*[[1,2],[2,1]];; PrintArray(M);
[ [    Z(3^2),  Z(3^2)^5 ],
  [  Z(3^2)^5,    Z(3^2) ] ]
gap&gt; DefaultField( Flat(M) );
GF(3^2)
gap&gt; VCFM := VerticalConversionFieldMat( M, GF(9) );; PrintArray(VCFM);
[ [  0*Z(3),  0*Z(3) ],
  [  Z(3)^0,    Z(3) ],
  [  0*Z(3),  0*Z(3) ],
  [    Z(3),  Z(3)^0 ] ]
gap&gt; DefaultField( Flat(VCFM) );
GF(3) 
</pre>
<p>
A similar function is <code>HorizontalConversionFieldMat</code> (see
<a href="CHAP006.htm#SSEC002.10">HorizontalConversionFieldMat</a>).
<p>
<a name = "SSEC002.10"></a>
<li><code>HorizontalConversionFieldMat( </code><var>M</var><code>, </code><var>F</var><code> )</code>
<p>
<code>HorizontalConversionFieldMat</code>  returns the matrix  <var>M</var> with its elements
converted from a field <i>F</i> =<i>GF</i>(<i>q</i><sup><i>m</i></sup>), <i>q</i> prime, to a field <i>GF</i>(<i>q</i>). Each
element  is replaced by its  representation over the latter field, placed
horizontally in the matrix.
<p>
If <var>M</var>  is  a  <i>k</i> by  <i>n</i>   matrix, the  result is a   <i>k</i>*<i>m</i> by  <i>n</i>*<i>m</i>
matrix.  The new word length  of the resulting   code is equal to <i>n</i>*<i>m</i>,
because each element of <i>GF</i>(<i>q</i><sup><i>m</i></sup>) can be represented in <i>GF</i>(<i>q</i>) using <i>m</i>
elements. The new dimension  is equal  to <i>k</i>*<i>m</i>  because the new  matrix
should be a basis for the same number of vectors as the old one.
<p>
<code>ConversionFieldCode</code> uses horizontal conversion  to convert a code  (see
<a href="CHAP005.htm#SSEC001.17">ConversionFieldCode</a>).
<p>
<pre>
gap&gt; M := Z(9)*[[1,2],[2,1]];; PrintArray(M);
[ [    Z(3^2),  Z(3^2)^5 ],
  [  Z(3^2)^5,    Z(3^2) ] ]
gap&gt; DefaultField( Flat(M) );
GF(3^2)
gap&gt; HCFM := HorizontalConversionFieldMat(M, GF(9));; PrintArray(HCFM);
[ [  0*Z(3),  Z(3)^0,  0*Z(3),    Z(3) ],
  [  Z(3)^0,  Z(3)^0,    Z(3),    Z(3) ],
  [  0*Z(3),    Z(3),  0*Z(3),  Z(3)^0 ],
  [    Z(3),    Z(3),  Z(3)^0,  Z(3)^0 ] ]
gap&gt; DefaultField( Flat(HCFM) );
GF(3) 
</pre>
<p>
A similar function is <code>VerticalConversionFieldMat</code> (see
<a href="CHAP006.htm#SSEC002.9">VerticalConversionFieldMat</a>).
<p>
<a name = "SSEC002.11"></a>
<li><code>IsLatinSquare( </code><var>M</var><code> )</code>
<p>
<code>IsLatinSquare</code> determines if a matrix <var>M</var> is a latin square. For a latin
square of size  <i>n</i> by <i>n</i>,  each row  and  each column contains  all the
integers 1,...,<i>n</i> exactly once.
<p>
<pre>
gap&gt; IsLatinSquare([[1,2],[2,1]]);
true
gap&gt; IsLatinSquare([[1,2,3],[2,3,1],[1,3,2]]);
false 
</pre>
<p>
<a name = "SSEC002.12"></a>
<li><code>AreMOLS( </code><var>L</var><code> )</code>
<p>
<code>AreMOLS</code> determines  if <var>L</var>   is a list    of mutually orthogonal  latin
squares (MOLS). For each pair of latin squares in this list, the function
checks if each ordered pair of elements that  are in the same position in
these matrices occurs exactly once. The function <code>MOLS</code> creates MOLS (see
<a href="CHAP006.htm#SSEC002.5">MOLS</a>).
<p>
<pre>
gap&gt; M := MOLS(4,2);
[ [ [ 0, 1, 2, 3 ], [ 1, 0, 3, 2 ], [ 2, 3, 0, 1 ], [ 3, 2, 1, 0 ] ],
  [ [ 0, 2, 3, 1 ], [ 1, 3, 2, 0 ], [ 2, 0, 1, 3 ], [ 3, 1, 0, 2 ] ] ]
gap&gt; AreMOLS(M);
true 
</pre>
<p>
<p>
<h2><a name="SECT003">6.3 Miscellaneous functions</a></h2>
<p><p>
In  this  section  we  describe  several  functions  <font face="Gill Sans,Helvetica,Arial">GUAVA</font>  uses   for
constructing codes or performing calculations with codes.
<p>
<a name = "SSEC003.1"></a>
<li><code>SphereContent( </code><var>n</var><code>, </code><var>t</var><code>, </code><var>F</var><code> )</code>
<p>
<code>SphereContent</code> returns the  content of a   ball of radius <var>t</var>  around an
arbitrary  element of the vectorspace <i>F</i> <sup><i>n</i> </sup>.  This is the cardinality
of  the set of    all elements of  <i>F</i> <sup><i>n</i> </sup>   that are at  distance (see
<a href="CHAP002.htm#SSEC006.2">DistanceCodeword</a>)  less  than  or   equal to <var>t</var>   from  an  element of
<i>F</i> <sup><i>n</i> </sup>.
<p>
In the context of codes, the function  is used to  determine if a code is
perfect. A code is perfect if spheres  of radius <i>t</i> around all codewords
contain exactly the whole vectorspace, where  <i>t</i> is the number of errors
the code can correct.
<p>
<pre>
gap&gt; SphereContent( 15, 0, GF(2) );
1    # Only one word with distance 0, which is the word itself
gap&gt; SphereContent( 11, 3, GF(4) );
4984
gap&gt; C := HammingCode(5);
a linear [31,26,3]1 Hamming (5,2) code over GF(2)
#the minimum distance is 3, so the code can correct one error
gap&gt; ( SphereContent( 31, 1, GF(2) ) * Size(C) ) = 2 ^ 31;
true 
</pre>
<p>
<a name = "SSEC003.2"></a>
<li><code>Krawtchouk( </code><var>k</var><code>, </code><var>i</var><code>, </code><var>n</var><code>, </code><var>q</var><code> )</code>
<p>
<code>Krawtchouk</code> returns the Krawtchouk number <i>K</i><sub><i>k</i> </sub>(<i>i</i> ).  <var>q</var> must be a
primepower, <var>n</var> must  be a positive integer,  <var>k</var> must  be a non-negative
integer less  then  or equal to   <var>n</var> and <var>i</var> can   be any  integer. (See
<a href="CHAP006.htm#SSEC002.1">KrawtchoukMat</a>).
<p>
<pre>
gap&gt; Krawtchouk( 2, 0, 3, 2);
3 
</pre>
<p>
<a name = "SSEC003.3"></a>
<li><code>PrimitiveUnityRoot( </code><var>F</var><code>, </code><var>n</var><code> )</code>
<p>
<code>PrimitiveUnityRoot</code>  returns a <strong>primitive  <var>n</var>th  root of  unity</strong> in  an
extension  field  of <var>F</var>. This  is a  finite  field element  <var>a</var> with the
property <i>a</i> <sup><i>n</i> </sup>=1 mod  <i>n</i>, and <var>n</var> is the smallest integer such that
this equality holds.
<p>
<pre>
gap&gt; PrimitiveUnityRoot( GF(2), 15 );
Z(2^4)
gap&gt; last^15;
Z(2)^0
gap&gt; PrimitiveUnityRoot( GF(8), 21 );
Z(2^6)^3 
</pre>
<p>
<a name = "SSEC003.5"></a>
<li><code>ReciprocalPolynomial( </code><var>P</var><code> )</code>
<p>
<code>ReciprocalPolynomial</code> returns the  <strong>reciprocal</strong> of  polynomial <var>P</var>. This
is a polynomial   with coefficients of <var>P</var>   in the reverse  order. So if
<i>P</i> =<i>a</i><sub>0</sub> + <i>a</i><sub>1</sub> <i>X</i> + &#183;.&#183;+ <i>a</i><sub><i>n</i> </sub> <i>X</i><sup><i>n</i> </sup>, the reciprocal polynomial is
<i>P</i> <font face="symbol">¢</font>=<i>a</i><sub><i>n</i> </sub> + <i>a</i><sub><i>n</i> <font face="symbol">-</font>1</sub> <i>X</i> + &#183;.&#183;+ <i>a</i><sub>0</sub> <i>X</i><sup><i>n</i> </sup>.
<p>
<pre>
gap&gt; P := UnivariatePolynomial( GF(3), Z(3)^0 * [1,0,1,2] );
Z(3)^0+x_1^2-x_1^3
gap&gt; RecP := ReciprocalPolynomial( P );
-Z(3)^0+x_1+x_1^3
gap&gt; ReciprocalPolynomial( RecP ) = P;
true 
</pre>
<p>
<li><code>ReciprocalPolynomial( </code><var>P</var><code> , </code><var>n</var><code> )</code>
<p>
In  this form, the number  of coefficients of  <var>P</var> is considered to be at
least <var>n</var>    (possibly    with   zero  coefficients  at      the  highest
degrees). Therefore, the  reciprocal polynomial <i>P</i> &aacute;lso has  degree
at least <var>n</var>.
<p>
<pre>
gap&gt; P := UnivariatePolynomial( GF(3), Z(3)^0 * [1,0,1,2] );
Z(3)^0+x_1^2-x_1^3
gap&gt; ReciprocalPolynomial( P, 6 );
-x_1^3+x_1^4+x_1^6
</pre>
<p>
In this form, the degree of <var>P</var> is considered to be at least <var>n</var> (if not,
zero  coefficients  are  added). Therefore,   the  reciprocal  polynomial
<i>P</i> &aacute;lso has degree at least <var>n</var>.
<p>
<a name = "SSEC003.6"></a>
<li><code>CyclotomicCosets( </code><var>q</var><code>, </code><var>n</var><code> )</code>
<p>
<code>CyclotomicCosets</code>  returns the cyclotomic cosets  of <var>q</var> modulo <var>n</var>. <var>q</var>
and <var>n</var> must  be relatively prime. Each  of the elements  of the returned
list is a list of integers that belong  to  one  cyclotomic  coset.  Each
coset contains all multiplications of the <strong>coset representative</strong> by  <var>q</var>,
modulo <var>n</var>. The coset representative is the smallest integer  that  isn't
in the previous cosets.
<p>
<pre>
gap&gt; CyclotomicCosets( 2, 15 );
[ [ 0 ], [ 1, 2, 4, 8 ], [ 3, 6, 12, 9 ], [ 5, 10 ],
  [ 7, 14, 13, 11 ] ]
gap&gt; CyclotomicCosets( 7, 6 );
[ [ 0 ], [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ] ] 
</pre>
<p>
<a name = "SSEC003.7"></a>
<li><code>WeightHistogram( </code><var>C</var><code> )</code>
<li><code>WeightHistogram( </code><var>C</var><code>, </code><var>h</var><code> )</code>
<p>
The   function <code>WeightHistogram</code>  plots  a histogram   of weights in code
<var>C</var>. The maximum   length of a column  is  <var>h</var>. Default value  for <var>h</var> is
1/3 of the  size of the  screen. The number  that appears at the top of
the histogram is the maximum value of the list of weights.
<p>
<pre>
gap&gt; H := HammingCode(2, GF(5));
a linear [6,4,3]1 Hamming (2,5) code over GF(5)
gap&gt; WeightDistribution(H);
[ 1, 0, 0, 80, 120, 264, 160 ]
gap&gt; WeightHistogram(H);
264----------------
               *
               *
               *
               *
               *  *
            *  *  *
         *  *  *  *
         *  *  *  *
+--------+--+--+--+--
0  1  2  3  4  5  6 
</pre>
<p>
<p>
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP005.htm">Previous</a>] [<a href ="CHAP007.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>GUAVA manual<br>April 2004
</address></body></html>