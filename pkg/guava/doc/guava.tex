% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[11pt]{report}
\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}
\definecolor{FuncColor}{rgb}{1.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,1.0}

\usepackage{fancyvrb}

\usepackage{pslatex}

\usepackage[
        a4paper=true,bookmarks=false,pdftitle={Written with GAPDoc},
        pdfcreator={LaTeX with hyperref package / GAPDoc},
        colorlinks=true,backref=page,breaklinks=true,linkcolor=RoyalBlue,
        citecolor=RoyalGreen,filecolor=RoyalRed,
        urlcolor=RoyalRed,pagecolor=RoyalBlue]{hyperref}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\F}{\mathbb{F}}

\newcommand{\GAP}{\textsf{GAP}}

\newsavebox{\backslashbox}
\sbox{\backslashbox}{\texttt{\symbol{92}}}
\newcommand{\bs}{\usebox{\backslashbox}}

\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\begin{center}{\Huge \textbf{ \textsf{GUAVA} }}\\[1cm]
\hypersetup{pdftitle= \textsf{GUAVA} }
\markright{\scriptsize \mbox{}\hfill  \textsf{GUAVA}  \hfill\mbox{}}
{\Large \textbf{  A \textsf{GAP}4 Package for computing with error-correcting codes ~ }}\\[1cm]
{Version 2}\\[1cm]
{December 17, 2004}\\[1cm]
\mbox{}\\[2cm]
{\large \textbf{ Jasper Cramwinckel }}\\
{\large \textbf{ Erik Roijackers }}\\
{\large \textbf{ Reinald Baart }}\\
{\large \textbf{Eric Minkes}}\\
{\large \textbf{ Lea Ruscio }}\\
{\large \textbf{ David Joyner\\
  ~    }}\\
\hypersetup{pdfauthor= Jasper Cramwinckel ;  Erik Roijackers ;  Reinald Baart ; Eric Minkes;  Lea Ruscio ;  David Joyner\\
  ~    }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ David Joyner\\
  ~    } --- Email: \href{mailto:// wdj@usna.edu}{\texttt{ wdj@usna.edu}}\\
 --- Homepage: \href{http://cadigweb.ew.usna.edu/~wdj/gap/GUAVA/}{\texttt{http://cadigweb.ew.usna.edu/\~{}wdj/gap/GUAVA/}}\\
 --- Address: \begin{minipage}[t]{8cm}\noindent
 Mathematics Department,\\
 U. S. Naval Academy,\\
 Annapolis, MD,\\
 21402 USA. \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
  \textsf{GUAVA} is released under the GNU General Public License (GPL). This file is part of \textsf{GUAVA}, though as documentation it is released under the GNU Free Documentation
License (see \href{http://www.gnu.org/licenses/licenses.html#FDL}{\texttt{http://www.gnu.org/licenses/licenses.html\#FDL}}). 

 \textsf{GUAVA} is free software; you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation;
either version 2 of the License, or (at your option) any later version. 

 \textsf{GUAVA} is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details. 

 You should have received a copy of the GNU General Public License along with \textsf{GUAVA}; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite
330, Boston, MA 02111-1307 USA 

 For more details, see \href{http://www.fsf.org/licenses/gpl.html}{\texttt{http://www.fsf.org/licenses/gpl.html}}. }\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 2 ]}
  

 \textsf{GUAVA} was originally written by Jasper Cramwinckel, Erik Roijackers, and Reinald
Baart in the early-to-mid 1990's as a final project during their study of
Mathematics at the Delft University of Technology, Department of Pure
Mathematics, under the direction of Professor Juriaan Simonis. This work was
continued in Aachen, at Lehrstuhl D fur Mathematik. In version 1.3, new
functions were added by Eric Minkes, also from Delft University of Technology. 

 JC, ER and RB would like to thank the \textsf{GAP} people at the RWTH Aachen for their support, A.E. Brouwer for his advice and
J. Simonis for his supervision. 

 The \textsf{GAP} 4 version of \textsf{GUAVA} (versions 1.4 and 1.5) was created by Lea Ruscio and (since 2001, starting
with version 1.6) is currently maintained by David Joyner, who (with the help
of several students) has added several new functions. For further details, see
the CHANGES file in the \textsf{GUAVA} directory, also available at \href{http://cadigweb.ew.usna.edu/~wdj/gap/GUAVA/CHANGES.guava}{\texttt{http://cadigweb.ew.usna.edu/\~{}wdj/gap/GUAVA/CHANGES.guava}}. 

 

This documentation was prepared with the \textsf{GAPDoc} package of Frank L\"ubeck and Max Neunh\"offer. The conversion from TeX to \textsf{GAPDoc}'s XML was done by David Joyner in 2004. 

 Please send bug reports, suggestions and other comments about \textsf{GUAVA} to \href{mailto://support@gap-system.org}{\texttt{support@gap-system.org}}. Currently known bugs and suggested \textsf{GUAVA} projects are listed on the bugs and projects web page \href{http://cadigweb.ew.usna.edu/~wdj/gap/GUAVA/guava2do.html}{\texttt{http://cadigweb.ew.usna.edu/\~{}wdj/gap/GUAVA/guava2do.html}}. Older releases and further history can be found on the \textsf{GUAVA} web page \href{http://cadigweb.ew.usna.edu/~wdj/gap/GUAVA/}{\texttt{http://cadigweb.ew.usna.edu/\~{}wdj/gap/GUAVA/}}. 

 \emph{Contributors}: Other than the authors listed on the title page, the following people have
contributed code to the \textsf{GUAVA} project: Alexander Hulpke, Steve Linton, Frank L\"ubeck, Aron Foster, Wayne
Irons, Clifton (``Clipper") Lennon, Jason McGowan, Shuhong Gao, and,
indirectly, Jeffrey Leon, Joe Nicely. }\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 3 ]}}

\tableofcontents
\newpage

  
\chapter{\textcolor{Chapter }{Introduction}}\logpage{[ 1, 0, 0 ]}
{
 
\section{\textcolor{Chapter }{Introduction to the \textsf{GUAVA} package}}\logpage{[ 1, 1, 0 ]}
{
  

 This is the manual of the \textsf{GAP} package \textsf{GUAVA} that provides implementations of some routines designed for the construction
and analysis of in the theory of error-correcting codes. 

 The functions can be divided into three subcategories: 
\begin{itemize}
\item  Construction of codes: \textsf{GUAVA} can construct unrestricted, linear and cyclic codes. Information about the
code, such as operations applicable to the code, is stored in a record-like
data structure called a \textsf{GAP} object. 
\item  Manipulations of codes: Manipulation transforms one code into another, or
constructs a new code from two codes. The new code can profit from the data in
the record of the old code(s), so in these cases calculation time decreases. 
\item  Computations of information about codes: \textsf{GUAVA} can calculate important parameters of codes quickly. The results are stored in
the codes' object components. 
\end{itemize}
 

 Except for the automorphism group and isomorphism testing functions, which
make use of J.S. Leon's programs (see \cite{Leon91} and the documentation in the 'src' subdirectory of the 'guava' directory for
some details), \textsf{GUAVA} is written in the \textsf{GAP} language, and runs on any system supporting \textsf{GAP}4.3 and above. Several algorithms that need the speed were integrated in the \textsf{GAP} kernel. 

 Good general references for error-correcting codes and the technical terms in
this manual are MacWilliams and Sloane \cite{MS83} Huffman and Pless \cite{HP03}. }

 
\section{\textcolor{Chapter }{Installing \textsf{GUAVA}}}\logpage{[ 1, 2, 0 ]}
{
  \label{Installing GUAVA} To install \textsf{GUAVA} (as a \textsf{GAP} 4 Package) unpack the archive file in a directory in the `pkg' hierarchy of
your version of \textsf{GAP} 4. 

 After unpacking \textsf{GUAVA} the \textsf{GAP}-only part of \textsf{GUAVA} is installed. The parts of \textsf{GUAVA} depending on J. Leon's backtrack programs package (for computing automorphism
groups) are only available in a UNIX environment, where you should proceed as
follows: Go to the newly created `guava' directory and call \texttt{`./configure /gappath'} where \texttt{/gappath} is the path to the \textsf{GAP} home directory. So for example, if you install the package in the main `pkg'
directory call 
\begin{verbatim}  ./configure ../..
\end{verbatim}
 This will fetch the architecture type for which \textsf{GAP} has been compiled last and create a `Makefile'. Now call 
\begin{verbatim}  make
\end{verbatim}
 to compile the binary and to install it in the appropriate place. (For a
windows machine with CYGWIN installed - see \href{http://www.cygwin.com/}{\texttt{http://www.cygwin.com/}} - instructions for compiling Leon's binaries are likely to be similar to those
above. On a 64-bit SUSE linux computer, instead of the configure command above
- which will only compile the 32-bit binary - type 
\begin{verbatim}  ./configure ../.. --enable-libsuffix=64 
  make
\end{verbatim}
 to compile Leon's program as a 64 bit native binary. This may also work for
other 64-bit linux distributions as well.) 

 This completes the installation of \textsf{GUAVA} for a single architecture. If you use this installation of \textsf{GUAVA} on different hardware platforms you will have to compile the binary for each
platform separately. }

 
\section{\textcolor{Chapter }{Loading \textsf{GUAVA}}}\logpage{[ 1, 3, 0 ]}
{
  After starting up \textsf{GAP}, the \textsf{GUAVA} package needs to be loaded. Load \textsf{GUAVA} by typing at the \textsf{GAP} prompt: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> LoadPackage( "guava", "2.0", false );
\end{Verbatim}
 If \textsf{GUAVA} isn't already in memory, it is loaded and the author information is displayed.
If you are a frequent user of \textsf{GUAVA}, you might consider putting this line in your `.gaprc' file. }

 }

 
\chapter{\textcolor{Chapter }{Codewords}}\logpage{[ 2, 0, 0 ]}
{
  \label{Codewords} Let $GF(q)$ denote a finite field with $q$ (a prime power) elements. A \emph{code} is a subset $C$ of some finite-dimensional vector space $V$ over $GF(q)$. The \emph{length} of $C$ is the dimension of $V$. Usually, $V=GF(q)^n$ and the length is the number of coordinate entries. When $C$ is itself a vector space over $GF(q)$ then it is called a \emph{linear code} \index{linear code} and the \emph{dimension} of $C$ is its dimension as a vector space over $GF(q)$. 

 In \textsf{GUAVA}, a `codeword' is a \textsf{GAP} record, with one of its components being an element in $V$. Likewise, a `code' is a \textsf{GAP} record, with one of its components being a subset (or subspace with given
basis, if $C$ is linear) of $V$. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
    gap> C:=RandomLinearCode(20,10,GF(4));
    a  [20,10,?] randomly generated code over GF(4)
    gap> c:=Random(C);
    [ 1 a 0 0 0 1 1 a^2 0 0 a 1 1 1 a 1 1 a a 0 ]
    gap> NamesOfComponents(C);
    [ "LeftActingDomain", "GeneratorsOfLeftOperatorAdditiveGroup", "WordLength",
      "GeneratorMat", "name", "Basis", "NiceFreeLeftModule", "Dimension", 
       "Representative", "ZeroImmutable" ]
    gap> NamesOfComponents(c);
    [ "VectorCodeword", "WordLength", "treatAsPoly" ]
    gap> c!.VectorCodeword;
    [ immutable compressed vector length 20 over GF(4) ] 
    gap> Display(last);
    [ Z(2^2), Z(2^2), Z(2^2), Z(2)^0, Z(2^2), Z(2^2)^2, 0*Z(2), Z(2^2), Z(2^2),
      Z(2)^0, Z(2^2)^2, 0*Z(2), 0*Z(2), Z(2^2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2^2)^2,
      Z(2)^0, 0*Z(2) ]
    gap> C!.Dimension;
    10
\end{Verbatim}
  Mathematically, a `codeword' is an element of a code $C$, but in \textsf{GUAVA} the \texttt{Codeword} and \texttt{VectorCodeword} commands have implementations which do not check if the codeword belongs to $C$ (i.e., are independent of the code itself). They exist primarily to make it
easier for the user to construct a the associated \textsf{GAP} record. Using these commands, one can enter into a \textsf{GAP} both a codeword $c$ (belonging to $C$) and a received word $r$ (not belonging to $C$) using the same command. The user can input codewords in different formats
(as strings, vectors, and polynomials), and output information is formatted in
a readable way. 

 A codeword $c$ in a linear code $C$ arises in practice by an initial encoding of a 'block' message $m$, adding enough redundancy to recover $m$ after $c$ is transmitted via a 'noisy' communication medium. In \textsf{GUAVA}, for linear codes, the map $m\longmapsto c$ is computed using the command \texttt{c:=m*C} and recovering $m$ from $c$ is obtained by the command \texttt{InformationWord(c,C)}. These commands are explained more below. 

 Many operations are available on codewords themselves, although codewords also
work together with codes (see chapter \ref{Codes} on Codes). 

 The first section describes how codewords are constructed (see \texttt{Codeword} (\ref{Codeword}) and \texttt{IsCodeword} (\ref{IsCodeword})). Sections \ref{Comparisons of Codewords} and \ref{Arithmetic Operations for Codewords} describe the arithmetic operations applicable to codewords. Section \ref{convert Codewords to Vectors or Polynomials} describe functions that convert codewords back to vectors or polynomials (see \texttt{VectorCodeword} (\ref{VectorCodeword}) and \texttt{PolyCodeword} (\ref{PolyCodeword})). Section \ref{Functions that Change the Display Form of a 
Codeword} describe functions that change the way a codeword is displayed (see \texttt{TreatAsVector} (\ref{TreatAsVector}) and \texttt{TreatAsPoly} (\ref{TreatAsPoly})). Finally, Section \ref{Other Codeword Functions} describes a function to generate a null word (see \texttt{NullWord} (\ref{NullWord})) and some functions for extracting properties of codewords (see \texttt{DistanceCodeword} (\ref{DistanceCodeword}), \texttt{Support} (\ref{Support}) and \texttt{WeightCodeword} (\ref{WeightCodeword})). 
\section{\textcolor{Chapter }{Construction of Codewords}}\logpage{[ 2, 1, 0 ]}
{
  \label{Construction of Codewords} 

\subsection{\textcolor{Chapter }{Codeword}}
\logpage{[ 2, 1, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Codeword( obj[, n][,][F] )\index{Codeword@\texttt{Codeword}}
\label{Codeword}
}\hfill{\scriptsize (function)}}\\


 \texttt{Codeword} returns a codeword or a list of codewords constructed from \mbox{\texttt{obj}}. The object \mbox{\texttt{obj}} can be a vector, a string, a polynomial or a codeword. It may also be a list
of those (even a mixed list). 

 If a number \mbox{\texttt{n}} is specified, all constructed codewords have length \mbox{\texttt{n}}. This is the only way to make sure that all elements of \mbox{\texttt{obj}} are converted to codewords of the same length. Elements of \mbox{\texttt{obj}} that are longer than \mbox{\texttt{n}} are reduced in length by cutting of the last positions. Elements of \mbox{\texttt{obj}} that are shorter than \mbox{\texttt{n}} are lengthened by adding zeros at the end. If no \mbox{\texttt{n}} is specified, each constructed codeword is handled individually. 

 If a Galois field \mbox{\texttt{F}} is specified, all codewords are constructed over this field. This is the only
way to make sure that all elements of \mbox{\texttt{obj}} are converted to the same field \mbox{\texttt{F}} (otherwise they are converted one by one). Note that all elements of \mbox{\texttt{obj}} must have elements over \mbox{\texttt{F}} or over `Integers'. Converting from one Galois field to another is not
allowed. If no \mbox{\texttt{F}} is specified, vectors or strings with integer elements will be converted to
the smallest Galois field possible. 

 Note that a significant speed increase is achieved if \mbox{\texttt{F}} is specified, even when all elements of \mbox{\texttt{obj}} already have elements over \mbox{\texttt{F}}. 

 Every vector in \mbox{\texttt{obj}} can be a finite field vector over \mbox{\texttt{F}} or a vector over `Integers'. In the last case, it is converted to \mbox{\texttt{F}} or, if omitted, to the smallest Galois field possible. 

 Every string in \mbox{\texttt{obj}} must be a string of numbers, without spaces, commas or any other characters.
These numbers must be from 0 to 9. The string is converted to a codeword over \mbox{\texttt{F}} or, if \mbox{\texttt{F}} is omitted, over the smallest Galois field possible. Note that since all
numbers in the string are interpreted as one-digit numbers, Galois fields of
size larger than 10 are not properly represented when using strings. In fact,
no finite field of size larger than 11 arises in this fashion at all. 

 Every polynomial in \mbox{\texttt{obj}} is converted to a codeword of length \mbox{\texttt{n}} or, if omitted, of a length dictated by the degree of the polynomial. If \mbox{\texttt{F}} is specified, a polynomial in \mbox{\texttt{obj}} must be over \mbox{\texttt{F}}. 

 Every element of \mbox{\texttt{obj}} that is already a codeword is changed to a codeword of length \mbox{\texttt{n}}. If no \mbox{\texttt{n}} was specified, the codeword doesn't change. If \mbox{\texttt{F}} is specified, the codeword must have base field \mbox{\texttt{F}}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> c := Codeword([0,1,1,1,0]);
  [ 0 1 1 1 0 ]
  gap> VectorCodeword( c ); 
  [ 0*Z(2), Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2) ]
  gap> c2 := Codeword([0,1,1,1,0], GF(3));
  [ 0 1 1 1 0 ]
  gap> VectorCodeword( c2 );
  [ 0*Z(3), Z(3)^0, Z(3)^0, Z(3)^0, 0*Z(3) ]
  gap> Codeword([c, c2, "0110"]);
  [ [ 0 1 1 1 0 ], [ 0 1 1 1 0 ], [ 0 1 1 0 ] ]
  gap> p := UnivariatePolynomial(GF(2), [Z(2)^0, 0*Z(2), Z(2)^0]);
  Z(2)^0+x_1^2
  gap> Codeword(p);
  x^2 + 1 
\end{Verbatim}
  

 This command can also be called using the syntax \texttt{Codeword(obj,C)}. In this format, the elements of \mbox{\texttt{obj}} are converted to elements of the same ambient vector space as the elements of
a code \mbox{\texttt{C}}. The command \texttt{Codeword(c,C)} is the same as calling \texttt{Codeword(c,n,F)}, where \mbox{\texttt{n}} is the word length of \mbox{\texttt{C}} and the \mbox{\texttt{F}} is the ground field of \mbox{\texttt{C}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := WholeSpaceCode(7,GF(5));
  a cyclic [7,7,1]0 whole space code over GF(5)
  gap> Codeword(["0220110", [1,1,1]], C);
  [ [ 0 2 2 0 1 1 0 ], [ 1 1 1 0 0 0 0 ] ]
  gap> Codeword(["0220110", [1,1,1]], 7, GF(5));
  [ [ 0 2 2 0 1 1 0 ], [ 1 1 1 0 0 0 0 ] ] 
  gap> C:=RandomLinearCode(10,5,GF(3));
  a linear [10,5,1..3]3..5 random linear code over GF(3)
  gap> Codeword("1000000000",C);
  [ 1 0 0 0 0 0 0 0 0 0 ]
  gap> Codeword("1000000000",10,GF(3));
  [ 1 0 0 0 0 0 0 0 0 0 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CodewordNr}}
\logpage{[ 2, 1, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CodewordNr( C, list )\index{CodewordNr@\texttt{CodewordNr}}
\label{CodewordNr}
}\hfill{\scriptsize (function)}}\\


 \texttt{CodewordNr} returns a list of codewords of \mbox{\texttt{C}}. \mbox{\texttt{list}} may be a list of integers or a single integer. For each integer of \mbox{\texttt{list}}, the corresponding codeword of \mbox{\texttt{C}} is returned. The correspondence of a number $i$ with a codeword is determined as follows: if a list of elements of \mbox{\texttt{C}} is available, the $i^{th}$ element is taken. Otherwise, it is calculated by multiplication of the $i^{th}$ information vector by the generator matrix or generator polynomial, where the
information vectors are ordered lexicographically. In particular, the returned
codeword(s) could be a vector or a polynomial. So \texttt{CodewordNr(C, i)} is equal to \texttt{AsSSortedList(C)[i]}, described in the next chapter. The latter function first calculates the set
of all the elements of $C$ and then returns the $i^{th}$ element of that set, whereas the former only calculates the $i^{th}$ codeword. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> B := BinaryGolayCode();
  a cyclic [23,12,7]3 binary Golay code over GF(2)
  gap> c := CodewordNr(B, 4);
  x^22 + x^20 + x^17 + x^14 + x^13 + x^12 + x^11 + x^10
  gap> R := ReedSolomonCode(2,2);
  a cyclic [2,1,2]1 Reed-Solomon code over GF(3)
  gap> AsSSortedList(R);
  [ [ 0 0 ], [ 1 1 ], [ 2 2 ] ]
  gap> CodewordNr(R, [1,3]);
  [ [ 0 0 ], [ 2 2 ] ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsCodeword}}
\logpage{[ 2, 1, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsCodeword( obj )\index{IsCodeword@\texttt{IsCodeword}}
\label{IsCodeword}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsCodeword} returns `true' if \mbox{\texttt{obj}}, which can be an object of arbitrary type, is of the codeword type and
`false' otherwise. The function will signal an error if \mbox{\texttt{obj}} is an unbound variable. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsCodeword(1);
  false
  gap> IsCodeword(ReedMullerCode(2,3));
  false
  gap> IsCodeword("11111");
  false
  gap> IsCodeword(Codeword("11111"));
  true 
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{Comparisons of Codewords}}\logpage{[ 2, 2, 0 ]}
{
  \label{Comparisons of Codewords} 

\subsection{\textcolor{Chapter }{=}}
\logpage{[ 2, 2, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{=( c1, c2 )\index{=@\texttt{=}}
\label{=}
}\hfill{\scriptsize (function)}}\\


 The equality operator \texttt{c1 = c2} evaluates to `true' if the codewords \mbox{\texttt{c1}} and \mbox{\texttt{c2}} are equal, and to `false' otherwise. Note that codewords are equal if and only
if their base vectors are equal. Whether they are represented as a vector or
polynomial has nothing to do with the comparison. 

 Comparing codewords with objects of other types is not recommended, although
it is possible. If \mbox{\texttt{c2}} is the codeword, the other object \mbox{\texttt{c1}} is first converted to a codeword, after which comparison is possible. This
way, a codeword can be compared with a vector, polynomial, or string. If \mbox{\texttt{c1}} is the codeword, then problems may arise if \mbox{\texttt{c2}} is a polynomial. In that case, the comparison always yields a `false', because
the polynomial comparison is called. 

 The equality operator is also denoted \texttt{EQ}, and \texttt{EQ(c1,c2)} is the same as \texttt{c1 = c2}. There is also an inequality operator, {\textless} {\textgreater}, or \texttt{not EQ}. \index{not =} \index{{\textless} {\textgreater}} }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> P := UnivariatePolynomial(GF(2), Z(2)*[1,0,0,1]);
  Z(2)^0+x_1^3
  gap> c := Codeword(P, GF(2));
  x^3 + 1
  gap> P = c;        # codeword operation
  true
  gap> c2 := Codeword("1001", GF(2));
  [ 1 0 0 1 ]
  gap> c = c2;
  true 
  gap> C:=HammingCode(3);
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  gap> c1:=Random(C);
  [ 1 0 0 1 1 0 0 ]
  gap> c2:=Random(C);
  [ 0 1 0 0 1 0 1 ]
  gap> EQ(c1,c2);
  false
  gap> not EQ(c1,c2);
  true
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{Arithmetic Operations for Codewords}}\logpage{[ 2, 3, 0 ]}
{
  \label{Arithmetic Operations for Codewords} 

\subsection{\textcolor{Chapter }{+}}
\logpage{[ 2, 3, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{+( c1, c2 )\index{+@\texttt{+}}
\label{+}
}\hfill{\scriptsize (function)}}\\


 The following operations are always available for codewords. The operands must
have a common base field, and must have the same length. No implicit
conversions are performed. \index{codewords, addition} 

 The operator \texttt{+} evaluates to the sum of the codewords \mbox{\texttt{c1}} and \mbox{\texttt{c2}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(10,5,GF(3));
  a linear [10,5,1..3]3..5 random linear code over GF(3)
  gap> c:=Random(C);
  [ 1 0 2 2 2 2 1 0 2 0 ]
  gap> Codeword(c+"2000000000");
  [ 0 0 2 2 2 2 1 0 2 0 ]
  gap> Codeword(c+"1000000000");
\end{Verbatim}
  The last command return a \textsf{GAP} ERROR since the `codeword' which \textsf{GUAVA} associates to "1000000000" belongs to $GF(2)$ and not $GF(3)$. 

\subsection{\textcolor{Chapter }{-}}
\logpage{[ 2, 3, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{-( c1, c2 )\index{-@\texttt{-}}
\label{-}
}\hfill{\scriptsize (function)}}\\


 Similar to addition: the operator \texttt{-} evaluates to the difference of the codewords \mbox{\texttt{c1}} and \mbox{\texttt{c2}}. \index{codewords, subtraction} }

 

\subsection{\textcolor{Chapter }{+}}
\logpage{[ 2, 3, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{+( v, C )\index{+@\texttt{+}}
\label{+}
}\hfill{\scriptsize (function)}}\\


 The operator \texttt{v+C} evaluates to the coset code of code \mbox{\texttt{C}} after adding a `codeword' \mbox{\texttt{v}} to all codewords in \mbox{\texttt{C}}. Note that if $c \in C$ then mathematically $c+C=C$ but \textsf{GUAVA} only sees them equal as \emph{sets}. See \texttt{CosetCode} (\ref{CosetCode}). 

 Note that the command \texttt{C+v} returns the same output as the command \texttt{v+C}. 

 \index{codewords, cosets} }

 \index{coset} 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(10,5);
  a  [10,5,?] randomly generated code over GF(2)
  gap> c:=Random(C);
  [ 0 0 0 0 0 0 0 0 0 0 ]
  gap> c+C;
  [ add. coset of a  [10,5,?] randomly generated code over GF(2) ]
  gap> c+C=C;
  true
  gap> IsLinearCode(c+C);
  false
  gap> v:=Codeword("100000000");
  [ 1 0 0 0 0 0 0 0 0 ]
  gap> v+C;
  [ add. coset of a  [10,5,?] randomly generated code over GF(2) ]
  gap> C=v+C;
  false
  gap> C := GeneratorMatCode( [ [1, 0,0,0], [0, 1,0,0] ], GF(2) );
  a linear [4,2,1]1 code defined by generator matrix over GF(2)
  gap> Elements(C);
  [ [ 0 0 0 0 ], [ 0 1 0 0 ], [ 1 0 0 0 ], [ 1 1 0 0 ] ]
  gap> v:=Codeword("0011");
  [ 0 0 1 1 ]
  gap> C+v;
  [ add. coset of a linear [4,2,4]1 code defined by generator matrix over GF(2) ]
  gap> Elements(C+v);
  [ [ 0 0 1 1 ], [ 0 1 1 1 ], [ 1 0 1 1 ], [ 1 1 1 1 ] ]
\end{Verbatim}
  In general, the operations just described can also be performed on codewords
expressed as vectors, strings or polynomials, although this is not
recommended. The vector, string or polynomial is first converted to a
codeword, after which the normal operation is performed. For this to go right,
make sure that at least one of the operands is a codeword. Further more, it
will not work when the right operand is a polynomial. In that case, the
polynomial operations (\texttt{FiniteFieldPolynomialOps}) are called, instead of the codeword operations (\texttt{CodewordOps}). 

 Some other code-oriented operations with codewords are described in \ref{Operations for Codes}. }

 
\section{\textcolor{Chapter }{ Functions that Convert Codewords to Vectors or Polynomials }}\logpage{[ 2, 4, 0 ]}
{
  \label{convert Codewords to Vectors or Polynomials} 

\subsection{\textcolor{Chapter }{VectorCodeword}}
\logpage{[ 2, 4, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{VectorCodeword( obj )\index{VectorCodeword@\texttt{VectorCodeword}}
\label{VectorCodeword}
}\hfill{\scriptsize (function)}}\\


 Here \mbox{\texttt{obj}} can be a code word or a list of code words. This function returns the
corresponding vectors over a finite field. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> a := Codeword("011011");; 
  gap> VectorCodeword(a);
  [ 0*Z(2), Z(2)^0, Z(2)^0, 0*Z(2), Z(2)^0, Z(2)^0 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{PolyCodeword}}
\logpage{[ 2, 4, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PolyCodeword( obj )\index{PolyCodeword@\texttt{PolyCodeword}}
\label{PolyCodeword}
}\hfill{\scriptsize (function)}}\\


 \texttt{PolyCodeword} returns a polynomial or a list of polynomials over a Galois field, converted
from \mbox{\texttt{obj}}. The object \mbox{\texttt{obj}} can be a codeword, or a list of codewords. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> a := Codeword("011011");; 
  gap> PolyCodeword(a);
  x_1+x_1^2+x_1^4+x_1^5
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Functions that Change the Display Form of a Codeword }}\logpage{[ 2, 5, 0 ]}
{
  \label{Functions that Change the Display Form of a Codeword} 

\subsection{\textcolor{Chapter }{TreatAsVector}}
\logpage{[ 2, 5, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TreatAsVector( obj )\index{TreatAsVector@\texttt{TreatAsVector}}
\label{TreatAsVector}
}\hfill{\scriptsize (function)}}\\


 \texttt{TreatAsVector} adapts the codewords in \mbox{\texttt{obj}} to make sure they are printed as vectors. \mbox{\texttt{obj}} may be a codeword or a list of codewords. Elements of \mbox{\texttt{obj}} that are not codewords are ignored. After this function is called, the
codewords will be treated as vectors. The vector representation is obtained by
using the coefficient list of the polynomial. 

 Note that this \emph{only} changes the way a codeword is \emph{printed}. \texttt{TreatAsVector} returns nothing, it is called only for its side effect. The function \texttt{VectorCodeword} converts codewords to vectors (see \texttt{VectorCodeword} (\ref{VectorCodeword})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> B := BinaryGolayCode();
  a cyclic [23,12,7]3 binary Golay code over GF(2)
  gap> c := CodewordNr(B, 4);
  x^22 + x^20 + x^17 + x^14 + x^13 + x^12 + x^11 + x^10
  gap> TreatAsVector(c);
  gap> c;
  [ 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 1 0 0 1 0 1 ] 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{TreatAsPoly}}
\logpage{[ 2, 5, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TreatAsPoly( obj )\index{TreatAsPoly@\texttt{TreatAsPoly}}
\label{TreatAsPoly}
}\hfill{\scriptsize (function)}}\\


 \texttt{TreatAsPoly} adapts the codewords in \mbox{\texttt{obj}} to make sure they are printed as polynomials. \mbox{\texttt{obj}} may be a codeword or a list of codewords. Elements of \mbox{\texttt{obj}} that are not codewords are ignored. After this function is called, the
codewords will be treated as polynomials. The finite field vector that defines
the codeword is used as a coefficient list of the polynomial representation,
where the first element of the vector is the coefficient of degree zero, the
second element is the coefficient of degree one, etc, until the last element,
which is the coefficient of highest degree. 

 Note that this \emph{only} changes the way a codeword is \emph{printed}. \texttt{TreatAsPoly} returns nothing, it is called only for its side effect. The function \texttt{PolyCodeword} converts codewords to polynomials (see \texttt{PolyCodeword} (\ref{PolyCodeword})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> a := Codeword("00001",GF(2));
  [ 0 0 0 0 1 ]
  gap> TreatAsPoly(a); a;
  x^4
  gap> b := NullWord(6,GF(4));
  [ 0 0 0 0 0 0 ]
  gap> TreatAsPoly(b); b;
  0 
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Other Codeword Functions }}\logpage{[ 2, 6, 0 ]}
{
  \label{Other Codeword Functions} 

\subsection{\textcolor{Chapter }{NullWord}}
\logpage{[ 2, 6, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NullWord( n, F )\index{NullWord@\texttt{NullWord}}
\label{NullWord}
}\hfill{\scriptsize (function)}}\\


 Other uses: \texttt{NullWord( n )} (default $F=GF(2)$) and \texttt{NullWord( C )}. \texttt{NullWord} returns a codeword of length \mbox{\texttt{n}} over the field \mbox{\texttt{F}} of only zeros. The integer \mbox{\texttt{n}} must be greater then zero. If only a code \mbox{\texttt{C}} is specified, \texttt{NullWord} will return a null word with both the word length and the Galois field of \mbox{\texttt{C}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> NullWord(8);
  [ 0 0 0 0 0 0 0 0 ]
  gap> Codeword("0000") = NullWord(4);
  true
  gap> NullWord(5,GF(16));
  [ 0 0 0 0 0 ]
  gap> NullWord(ExtendedTernaryGolayCode());
  [ 0 0 0 0 0 0 0 0 0 0 0 0 ] 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DistanceCodeword}}
\logpage{[ 2, 6, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DistanceCodeword( c1, c2 )\index{DistanceCodeword@\texttt{DistanceCodeword}}
\label{DistanceCodeword}
}\hfill{\scriptsize (function)}}\\


 \texttt{DistanceCodeword} returns the Hamming distance from \mbox{\texttt{c1}} to \mbox{\texttt{c2}}. Both variables must be codewords with equal word length over the same Galois
field. The Hamming distance between two words is the number of places in which
they differ. As a result, \texttt{DistanceCodeword} always returns an integer between zero and the word length of the codewords. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> a := Codeword([0, 1, 2, 0, 1, 2]);; b := NullWord(6, GF(3));;
  gap> DistanceCodeword(a, b);
  4
  gap> DistanceCodeword(b, a);
  4
  gap> DistanceCodeword(a, a);
  0 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{Support}}
\logpage{[ 2, 6, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Support( c )\index{Support@\texttt{Support}}
\label{Support}
}\hfill{\scriptsize (function)}}\\


 \texttt{Support} returns a set of integers indicating the positions of the non-zero entries in
a codeword \mbox{\texttt{c}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> a := Codeword("012320023002");; Support(a);
  [ 2, 3, 4, 5, 8, 9, 12 ]
  gap> Support(NullWord(7));
  [  ] 
\end{Verbatim}
  The support of a list with codewords can be calculated by taking the union of
the individual supports. The weight of the support is the length of the set. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> L := Codeword(["000000", "101010", "222000"], GF(3));;
  gap> S := Union(List(L, i -> Support(i)));
  [ 1, 2, 3, 5 ]
  gap> Length(S);
  4 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{WeightCodeword}}
\logpage{[ 2, 6, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{WeightCodeword( c )\index{WeightCodeword@\texttt{WeightCodeword}}
\label{WeightCodeword}
}\hfill{\scriptsize (function)}}\\


 \texttt{WeightCodeword} returns the weight of a codeword $c$, the number of non-zero entries in \mbox{\texttt{c}}. As a result, \texttt{WeightCodeword} always returns an integer between zero and the word length of the codeword. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> WeightCodeword(Codeword("22222"));
  5
  gap> WeightCodeword(NullWord(3));
  0
  gap> C := HammingCode(3);
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  gap> Minimum(List(AsSSortedList(C){[2..Size(C)]}, WeightCodeword ) );
  3 
\end{Verbatim}
  }

 }

 
\chapter{\textcolor{Chapter }{Codes}}\logpage{[ 3, 0, 0 ]}
{
  \label{Codes} A \emph{code} is a set of codewords (recall a \index{code} \index{code, elements of} codeword in \textsf{GUAVA} is simply a sequence of elements of a finite field $GF(q)$, where $q$ is a prime power). We call these the \emph{elements} of the code. Depending on the type of code, a codeword can be interpreted as a
vector or as a polynomial. This is explained in more detail in Chapter \ref{Codewords}. 

 In \textsf{GUAVA}, codes can be a set specified by its elements (this will be called an \emph{unrestricted code}), \index{code, unrestricted} by a generator matrix listing a set of basis elements (for a linear code) or
by a generator polynomial (for a cyclic code). 

 Any code can be defined by its elements. If you like, you can give the code a
name. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := ElementsCode(["1100", "1010", "0001"], "example code", GF(2) );
  a (4,3,1..4)2..4 example code over GF(2) 
\end{Verbatim}
 An $(n,M,d)$ code is a code with word \emph{length} $n$, \emph{size} $M$ and \emph{minimum distance} $d$. \index{code, $(n,M,d)$} \index{minimum distance} \index{length} \index{size} If the minimum distance has not yet been calculated, the lower bound and upper
bound are printed (except in the case where the code is a random linear codes,
where these are not printed for efficiency reasons). So 
\begin{verbatim}  a (4,3,1..4)2..4 code over GF(2)
\end{verbatim}
 means a binary unrestricted code of length $4$, with $3$ elements and the minimum distance is greater than or equal to $1$ and less than or equal to $4$ and the covering radius is greater than or equal to $2$ and less than or equal to $4$. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := ElementsCode(["1100", "1010", "0001"], "example code", GF(2) );
  a (4,3,1..4)2..4 example code over GF(2) 
  gap> MinimumDistance(C);
  2
  gap> C;
  a (4,3,2)2..4 example code over GF(2) 
\end{Verbatim}
  If the set of elements is a linear subspace of $GF(q)^n$, the code is called \emph{linear}. If a code is linear, it can be defined by its \emph{generator matrix} or \emph{parity check matrix}. \index{code, linear} \index{parity check matrix} By definition, the rows of the generator matrix is a basis for the code (as a
vector space over $GF(q)$). By definition, the rows of the parity check matrix is a basis for the dual
space of the code, 
\[ C^* = \{ v \in GF(q)^n\ |\ v\cdot c = 0,\ for \ all\ c \in C \}. \]
 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> G := GeneratorMatCode([[1,0,1],[0,1,2]], "demo code", GF(3) );
  a linear [3,2,1..2]1 demo code over GF(3) 
\end{Verbatim}
 So a linear $[n, k, d]r$ code \index{code, $[n, k, d]r$} is a code with word \emph{length} $n$, \emph{dimension} $k$, \emph{minimum distance} $d$ and \emph{covering radius} $r$. 

 If the code is linear and all cyclic shifts of its codewords (regarded as $n$-tuples) are again codewords, the code is called \emph{cyclic}. \index{code, cyclic} All elements of a cyclic code are multiples of the monic polynomial modulo a
polynomial $x^n -1$, where $n$ is the word length of the code. Such a polynomial is called a \emph{generator polynomial} \index{generator polynomial} The generator polynomial must divide $x^n-1$ and its quotient is called a \emph{check polynomial}. \index{check polynomial} Multiplying a codeword in a cyclic code by the check polynomial yields zero
(modulo the polynomial $x^n -1$). In \textsf{GUAVA}, a cyclic code can be defined by either its generator polynomial or check
polynomial. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> G := GeneratorPolCode(Indeterminate(GF(2))+Z(2)^0, 7, GF(2) );
  a cyclic [7,6,1..2]1 code defined by generator polynomial over GF(2)
\end{Verbatim}
 It is possible that \textsf{GUAVA} does not know that an unrestricted code is in fact linear. This situation
occurs for example when a code is generated from a list of elements with the
function \texttt{ElementsCode} (see \texttt{ElementsCode} (\ref{ElementsCode})). By calling the function \texttt{IsLinearCode} (see \texttt{IsLinearCode} (\ref{IsLinearCode})), \textsf{GUAVA} tests if the code can be represented by a generator matrix. If so, the code
record and the operations are converted accordingly. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> L := Z(2)*[ [0,0,0], [1,0,0], [0,1,1], [1,1,1] ];;
  gap> C := ElementsCode( L, GF(2) );
  a (3,4,1..3)1 user defined unrestricted code over GF(2)
  # so far, GUAVA does not know what kind of code this is
  gap> IsLinearCode( C );
  true                      # it is linear
  gap> C;
  a linear [3,2,1]1 user defined unrestricted code over GF(2) 
\end{Verbatim}
  Of course the same holds for unrestricted codes that in fact are cyclic, or
codes, defined by a generator matrix, that actually are cyclic. 

 Codes are printed simply by giving a small description of their parameters,
the word length, size or dimension and perhaps the minimum distance, followed
by a short description and the base field of the code. The function \texttt{Display} gives a more detailed description, showing the construction history of the
code. 

 \textsf{GUAVA} doesn't place much emphasis on the actual encoding and decoding processes;
some algorithms have been included though. Encoding works simply by
multiplying an information vector with a code, decoding is done by the
functions \texttt{Decode} or \texttt{Decodeword}. For more information about encoding and decoding, see sections \ref{Operations for Codes} and \ref{Decode}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> R := ReedMullerCode( 1, 3 );
  a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
  gap> w := [ 1, 0, 1, 1 ] * R;
  [ 1 0 0 1 1 0 0 1 ]
  gap> Decode( R, w );
  [ 1 0 1 1 ]
  gap> Decode( R, w + "10000000" ); # One error at the first position
  [ 1 0 1 1 ]                       # Corrected by Guava 
\end{Verbatim}
  Sections \ref{Comparisons of Codes} and \ref{Operations for Codes} describe the operations that are available for codes. Section \ref{Boolean Functions for Codes} describe the functions that tests whether an object is a code and what kind of
code it is (see \texttt{IsCode}, \texttt{IsLinearCode} (\ref{IsLinearCode}) and \texttt{IsCyclicCode}) and various other boolean functions for codes. Section \ref{Equivalence and Isomorphism of Codes} describe functions about equivalence and isomorphism of codes (see \texttt{IsEquivalent} (\ref{IsEquivalent}), \texttt{CodeIsomorphism} (\ref{CodeIsomorphism}) and \texttt{AutomorphismGroup} (\ref{AutomorphismGroup})). Section \ref{Domain Functions for Codes} describes functions that work on \emph{domains} (see Chapter "Domains and their Elements" in the \textsf{GAP} Reference Manual). Section \ref{Printing and Displaying Codes} describes functions for printing and displaying codes. Section \ref{Generating (Check) Matrices and Polynomials} describes functions that return the matrices and polynomials that define a
code (see \texttt{GeneratorMat} (\ref{GeneratorMat}), \texttt{CheckMat} (\ref{CheckMat}), \texttt{GeneratorPol} (\ref{GeneratorPol}), \texttt{CheckPol} (\ref{CheckPol}), \texttt{RootsOfCode} (\ref{RootsOfCode})). Section \ref{Parameters of Codes} describes functions that return the basic parameters of codes (see \texttt{WordLength} (\ref{WordLength}), \texttt{Redundancy} (\ref{Redundancy}) and \texttt{MinimumDistance} (\ref{MinimumDistance})). Section \ref{Distributions} describes functions that return distance and weight distributions (see \texttt{WeightDistribution} (\ref{WeightDistribution}), \texttt{InnerDistribution} (\ref{InnerDistribution}), \texttt{OuterDistribution} (\ref{OuterDistribution}) and \texttt{DistancesDistribution} (\ref{DistancesDistribution})). Section \ref{Decoding Functions} describes functions that are related to decoding (see \texttt{Decode} (\ref{Decode}), \texttt{Decodeword} (\ref{Decodeword}), \texttt{Syndrome} (\ref{Syndrome}), \texttt{SyndromeTable} (\ref{SyndromeTable}) and \texttt{StandardArray} (\ref{StandardArray})). In Chapters \ref{Generating Codes} and \ref{Manipulating Codes} which follow, we describe functions that generate and manipulate codes. 
\section{\textcolor{Chapter }{Comparisons of Codes}}\logpage{[ 3, 1, 0 ]}
{
  \label{Comparisons of Codes} 

\subsection{\textcolor{Chapter }{=}}
\logpage{[ 3, 1, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{=( C1, C2 )\index{=@\texttt{=}}
\label{=}
}\hfill{\scriptsize (function)}}\\


 The equality operator \texttt{C1 = C2} evaluates to `true' if the codes \mbox{\texttt{C1}} and \mbox{\texttt{C2}} are equal, and to `false' otherwise. 

 The equality operator is also denoted \texttt{EQ}, and \texttt{Eq(C1,C2)} is the same as \texttt{C1 = C2}. There is also an inequality operator, {\textless} {\textgreater}, or \texttt{not EQ}. 

 Note that codes are equal if and only if their set of elements are equal.
Codes can also be compared with objects of other types. Of course they are
never equal. }

 \index{not =} \index{{\textless} {\textgreater}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> M := [ [0, 0], [1, 0], [0, 1], [1, 1] ];;
  gap> C1 := ElementsCode( M, GF(2) );
  a (2,4,1..2)0 user defined unrestricted code over GF(2)
  gap> M = C1;
  false
  gap> C2 := GeneratorMatCode( [ [1, 0], [0, 1] ], GF(2) );
  a linear [2,2,1]0 code defined by generator matrix over GF(2)
  gap> C1 = C2;
  true
  gap> ReedMullerCode( 1, 3 ) = HadamardCode( 8 );
  true
  gap> WholeSpaceCode( 5, GF(4) ) = WholeSpaceCode( 5, GF(2) );
  false
\end{Verbatim}
  Another way of comparing codes is \texttt{IsEquivalent}, which checks if two codes are equivalent (see \texttt{IsEquivalent} (\ref{IsEquivalent})). By the way, this called \texttt{CodeIsomorphism}. For the current version of \textsf{GUAVA}, unless one of the codes is unrestricted, this calls Leon's C program (which
only works for binary linear codes and only on a unix/linux computer). }

 
\section{\textcolor{Chapter }{ Operations for Codes }}\logpage{[ 3, 2, 0 ]}
{
  \label{Operations for Codes} 

\subsection{\textcolor{Chapter }{+}}
\logpage{[ 3, 2, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{+( C1, C2 )\index{+@\texttt{+}}
\label{+}
}\hfill{\scriptsize (function)}}\\


 \index{codes, addition} \index{codes, direct sum} The operator `+' evaluates to the direct sum of the codes \mbox{\texttt{C1}} and \mbox{\texttt{C2}}. See \texttt{DirectSumCode} (\ref{DirectSumCode}). 

 }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1:=RandomLinearCode(10,5);
  a  [10,5,?] randomly generated code over GF(2)
  gap> C2:=RandomLinearCode(9,4);
  a  [9,4,?] randomly generated code over GF(2)
  gap> C1+C2;
  a linear [10,9,1]0..10 unknown linear code over GF(2)
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{*}}
\logpage{[ 3, 2, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{*( C1, C2 )\index{*@\texttt{*}}
\label{*}
}\hfill{\scriptsize (function)}}\\


 \index{codes, product} The operator `*' evaluates to the direct product of the codes \mbox{\texttt{C1}} and \mbox{\texttt{C2}}. See \texttt{DirectProductCode} (\ref{DirectProductCode}). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := GeneratorMatCode( [ [1, 0,0,0], [0, 1,0,0] ], GF(2) );
  a linear [4,2,1]1 code defined by generator matrix over GF(2)
  gap> C2 := GeneratorMatCode( [ [0,0,1, 1], [0,0,0, 1] ], GF(2) );
  a linear [4,2,1]1 code defined by generator matrix over GF(2)
  gap> C1*C2;
  a linear [16,4,1]4..12 direct product code
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{*}}
\logpage{[ 3, 2, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{*( m, C )\index{*@\texttt{*}}
\label{*}
}\hfill{\scriptsize (function)}}\\


 \index{codes, encoding} \index{encoder map} The operator \texttt{m*C} evaluates to the element of \mbox{\texttt{C}} belonging to information word ('message') \mbox{\texttt{m}}. Here \mbox{\texttt{m}} may be a vector, polynomial, string or codeword or a list of those. This is
the way to do encoding in \textsf{GUAVA}. \mbox{\texttt{C}} must be linear, because in \textsf{GUAVA}, encoding by multiplication is only defined for linear codes. If \mbox{\texttt{C}} is a cyclic code, this multiplication is the same as multiplying an
information polynomial \mbox{\texttt{m}} by the generator polynomial of \mbox{\texttt{C}}. If \mbox{\texttt{C}} is a linear code, it is equal to the multiplication of an information vector \mbox{\texttt{m}} by a generator matrix of \mbox{\texttt{C}}. 

 To invert this, use the function \texttt{InformationWord} (see \texttt{InformationWord} (\ref{InformationWord}), which simply calls the function \texttt{Decode}). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := GeneratorMatCode( [ [1, 0,0,0], [0, 1,0,0] ], GF(2) );
  a linear [4,2,1]1 code defined by generator matrix over GF(2)
  gap> m:=Codeword("11");
  [ 1 1 ]
  gap> m*C;
  [ 1 1 0 0 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{InformationWord}}
\logpage{[ 3, 2, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{InformationWord( c, C )\index{InformationWord@\texttt{InformationWord}}
\label{InformationWord}
}\hfill{\scriptsize (function)}}\\


 \index{codes, decoding} \index{information bits} Here \mbox{\texttt{C}} is a linear code and \mbox{\texttt{c}} is a codeword in it. The command \texttt{InformationWord} returns the message word (or 'information digits') $m$ satisfying \texttt{c=m*C}. This command simply calls \texttt{Decode}, provided \texttt{c in C} is true. Otherwise, it returns an error. 

 To invert this, use the encoding function \texttt{*} (see \texttt{*} (\ref{*})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=HammingCode(3);
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  gap> c:=Random(C);
  [ 0 0 0 1 1 1 1 ]
  gap> InformationWord(C,c);
  [ 0 1 1 1 ]
  gap> c:=Codeword("1111100");
  [ 1 1 1 1 1 0 0 ]
  gap> InformationWord(C,c);
  "ERROR: codeword must belong to code"
  gap> C:=NordstromRobinsonCode();
  a (16,256,6)4 Nordstrom-Robinson code over GF(2)
  gap> c:=Random(C);
  [ 0 0 0 1 0 0 0 1 0 0 1 0 1 1 0 1 ]
  gap> InformationWord(C,c);
  "ERROR: code must be linear"
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Boolean Functions for Codes }}\logpage{[ 3, 3, 0 ]}
{
  \label{Boolean Functions for Codes} 

\subsection{\textcolor{Chapter }{in}}
\logpage{[ 3, 3, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{in( c, C )\index{in@\texttt{in}}
\label{in}
}\hfill{\scriptsize (function)}}\\


 \index{code, element test} The command \texttt{c in C} evaluates to `true' if \mbox{\texttt{C}} contains the codeword or list of codewords specified by \mbox{\texttt{c}}. Of course, \mbox{\texttt{c}} and \mbox{\texttt{C}} must have the same word lengths and base fields. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:= HammingCode( 2 );; eC:= AsSSortedList( C );
  [ [ 0 0 0 ], [ 1 1 1 ] ]
  gap> eC[2] in C;
  true
  gap> [ 0 ] in C;
  false 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsSubset}}
\logpage{[ 3, 3, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsSubset( C1, C2 )\index{IsSubset@\texttt{IsSubset}}
\label{IsSubset}
}\hfill{\scriptsize (function)}}\\


 \index{code, subcode} The command \texttt{IsSubset(C1,C2)} returns `true' if \mbox{\texttt{C2}} is a subcode of \mbox{\texttt{C1}}, i.e. if \mbox{\texttt{C1}} contains all the elements of \mbox{\texttt{C2}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsSubset( HammingCode(3), RepetitionCode( 7 ) );
  true
  gap> IsSubset( RepetitionCode( 7 ), HammingCode( 3 ) );
  false
  gap> IsSubset( WholeSpaceCode( 7 ), HammingCode( 3 ) );
  true
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsCode}}
\logpage{[ 3, 3, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsCode( obj )\index{IsCode@\texttt{IsCode}}
\label{IsCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsCode} returns `true' if \mbox{\texttt{obj}}, which can be an object of arbitrary type, is a code and `false' otherwise.
Will cause an error if \mbox{\texttt{obj}} is an unbound variable. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsCode( 1 );
  false
  gap> IsCode( ReedMullerCode( 2,3 ) );
  true
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsLinearCode}}
\logpage{[ 3, 3, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsLinearCode( obj )\index{IsLinearCode@\texttt{IsLinearCode}}
\label{IsLinearCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsLinearCode} checks if object \mbox{\texttt{obj}} (not necessarily a code) is a linear code. If a code has already been marked
as linear or cyclic, the function automatically returns `true'. Otherwise, the
function checks if a basis $G$ of the elements of \mbox{\texttt{obj}} exists that generates the elements of \mbox{\texttt{obj}}. If so, $G$ is recorded as a generator matrix of \mbox{\texttt{obj}} and the function returns `true'. If not, the function returns `false'. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := ElementsCode( [ [0,0,0],[1,1,1] ], GF(2) );
  a (3,2,1..3)1 user defined unrestricted code over GF(2)
  gap> IsLinearCode( C );
  true
  gap> IsLinearCode( ElementsCode( [ [1,1,1] ], GF(2) ) );
  false
  gap> IsLinearCode( 1 );
  false 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsCyclicCode}}
\logpage{[ 3, 3, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsCyclicCode( obj )\index{IsCyclicCode@\texttt{IsCyclicCode}}
\label{IsCyclicCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsCyclicCode} checks if the object \mbox{\texttt{obj}} is a cyclic code. If a code has already been marked as cyclic, the function
automatically returns `true'. Otherwise, the function checks if a polynomial $g$ exists that generates the elements of \mbox{\texttt{obj}}. If so, $g$ is recorded as a generator polynomial of \mbox{\texttt{obj}} and the function returns `true'. If not, the function returns `false'. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := ElementsCode( [ [0,0,0], [1,1,1] ], GF(2) );
  a (3,2,1..3)1 user defined unrestricted code over GF(2)
  gap> # GUAVA does not know the code is cyclic
  gap> IsCyclicCode( C );      # this command tells GUAVA to find out
  true
  gap> IsCyclicCode( HammingCode( 4, GF(2) ) );
  false
  gap> IsCyclicCode( 1 );
  false 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsPerfectCode}}
\logpage{[ 3, 3, 6 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsPerfectCode( C )\index{IsPerfectCode@\texttt{IsPerfectCode}}
\label{IsPerfectCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsPerfectCode(C)} returns `true' if \mbox{\texttt{C}} is a perfect code. If $C\subset GF(q)^n$ then, by definition, this means that for some positive integer $t$, the space $GF(q)^n$ is covered by non-overlapping spheres of (Hamming) radius $t$ centered at the codewords in \mbox{\texttt{C}}. For a code with odd minimum distance $d = 2t+1$, this is the case when every word of the vector space of \mbox{\texttt{C}} is at distance at most $t$ from exactly one element of \mbox{\texttt{C}}. Codes with even minimum distance are never perfect. 

 In fact, a code that is not "trivially perfect" (the binary repetition codes
of odd length, the codes consisting of one word, and the codes consisting of
the whole vector space), and does not have the parameters of a Hamming or
Golay code, cannot be perfect (see section 1.12 in \cite{HP03}). }

 \index{code, perfect} 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> H := HammingCode(2);
  a linear [3,1,3]1 Hamming (2,2) code over GF(2)
  gap> IsPerfectCode( H );
  true
  gap> IsPerfectCode( ElementsCode([[1,1,0],[0,0,1]],GF(2)) );
  true
  gap> IsPerfectCode( ReedSolomonCode( 6, 3 ) );
  false
  gap> IsPerfectCode( BinaryGolayCode() );
  true 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsMDSCode}}
\logpage{[ 3, 3, 7 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsMDSCode( C )\index{IsMDSCode@\texttt{IsMDSCode}}
\label{IsMDSCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsMDSCode(C)} returns true if \mbox{\texttt{C}} is a maximum distance separable (MDS) code. A linear $[n, k, d]$-code of length $n$, dimension $k$ and minimum distance $d$ is an MDS code if $k=n-d+1$, in other words if \mbox{\texttt{C}} meets the Singleton bound (see \texttt{UpperBoundSingleton} (\ref{UpperBoundSingleton})). An unrestricted $(n, M, d)$ code is called \emph{MDS} if $k=n-d+1$, with $k$ equal to the largest integer less than or equal to the logarithm of $M$ with base $q$, the size of the base field of \mbox{\texttt{C}}. 

 Well-known MDS codes include the repetition codes, the whole space codes, the
even weight codes (these are the only \emph{binary} MDS codes) and the Reed-Solomon codes. }

 \index{code, maximum distance separable} \index{MDS} 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := ReedSolomonCode( 6, 3 );
  a cyclic [6,4,3]2 Reed-Solomon code over GF(7)
  gap> IsMDSCode( C1 );
  true    # 6-3+1 = 4
  gap> IsMDSCode( QRCode( 23, GF(2) ) );
  false 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsSelfDualCode}}
\logpage{[ 3, 3, 8 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsSelfDualCode( C )\index{IsSelfDualCode@\texttt{IsSelfDualCode}}
\label{IsSelfDualCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsSelfDualCode(C)} returns `true' if \mbox{\texttt{C}} is self-dual, i.e. when \mbox{\texttt{C}} is equal to its dual code (see also \texttt{DualCode} (\ref{DualCode})). A code is self-dual if it contains all vectors that its elements are
orthogonal to. If a code is self-dual, it automatically is self-orthogonal
(see \texttt{IsSelfOrthogonalCode} (\ref{IsSelfOrthogonalCode})). 

 If \mbox{\texttt{C}} is a non-linear code, it cannot be self-dual (the dual code is always linear),
so `false' is returned. A linear code can only be self-dual when its dimension $k$ is equal to the redundancy $r$. }

 \index{code, self-dual} 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsSelfDualCode( ExtendedBinaryGolayCode() );
  true
  gap> C := ReedMullerCode( 1, 3 );
  a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
  gap> DualCode( C ) = C;
  true 
\end{Verbatim}
 \index{self-orthogonal} 

\subsection{\textcolor{Chapter }{IsSelfOrthogonalCode}}
\logpage{[ 3, 3, 9 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsSelfOrthogonalCode( C )\index{IsSelfOrthogonalCode@\texttt{IsSelfOrthogonalCode}}
\label{IsSelfOrthogonalCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsSelfOrthogonalCode(C)} returns `true' if \mbox{\texttt{C}} is self-orthogonal. A code is \emph{self-orthogonal} if every element of \mbox{\texttt{C}} is orthogonal to all elements of \mbox{\texttt{C}}, including itself. (In the linear case, this simply means that the generator
matrix of \mbox{\texttt{C}} multiplied with its transpose yields a null matrix.) }

 \index{code, self-orthogonal} 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> R := ReedMullerCode(1,4);
  a linear [16,5,8]6 Reed-Muller (1,4) code over GF(2)
  gap> IsSelfOrthogonalCode(R);
  true
  gap> IsSelfDualCode(R);
  false 
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Equivalence and Isomorphism of Codes }}\logpage{[ 3, 4, 0 ]}
{
  \label{Equivalence and Isomorphism of Codes} \index{permutation equivalent codes} \index{equivalent codes} 

\subsection{\textcolor{Chapter }{IsEquivalent}}
\logpage{[ 3, 4, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsEquivalent( C1, C2 )\index{IsEquivalent@\texttt{IsEquivalent}}
\label{IsEquivalent}
}\hfill{\scriptsize (function)}}\\


 We say that \mbox{\texttt{C1}} is \emph{permutation equivalent} to \mbox{\texttt{C2}} if \mbox{\texttt{C1}} can be obtained from \mbox{\texttt{C2}} by carrying out column permutations. \texttt{IsEquivalent} returns true if \mbox{\texttt{C1}} and \mbox{\texttt{C2}} are equivalent codes. At this time, \texttt{IsEquivalent} only handles \emph{binary} codes. (The external unix/linux program \textsc{desauto} from J. S. Leon is called by \texttt{IsEquivalent}.) Of course, if \mbox{\texttt{C1}} and \mbox{\texttt{C2}} are equal, they are also equivalent. 

 Note that the algorithm is \emph{very slow} for non-linear codes. 

 More generally, we say that \mbox{\texttt{C1}} is \emph{equivalent} to \mbox{\texttt{C2}} if \mbox{\texttt{C1}} can be obtained from \mbox{\texttt{C2}} by carrying out column permutations and a permutation of the alphabet. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> x:= Indeterminate( GF(2) );; pol:= x^3+x+1; 
  Z(2)^0+x_1+x_1^3
  gap> H := GeneratorPolCode( pol, 7, GF(2));          
  a cyclic [7,4,1..3]1 code defined by generator polynomial over GF(2)
  gap> H = HammingCode(3, GF(2));
  false
  gap> IsEquivalent(H, HammingCode(3, GF(2)));
  true                        # H is equivalent to a Hamming code
  gap> CodeIsomorphism(H, HammingCode(3, GF(2)));
  (3,4)(5,6,7) 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CodeIsomorphism}}
\logpage{[ 3, 4, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CodeIsomorphism( C1, C2 )\index{CodeIsomorphism@\texttt{CodeIsomorphism}}
\label{CodeIsomorphism}
}\hfill{\scriptsize (function)}}\\


 If the two codes \mbox{\texttt{C1}} and \mbox{\texttt{C2}} are permutation equivalent codes (see \texttt{IsEquivalent} (\ref{IsEquivalent})), \texttt{CodeIsomorphism} returns the permutation that transforms \mbox{\texttt{C1}} into \mbox{\texttt{C2}}. If the codes are not equivalent, it returns `false'. 

 At this time, \texttt{IsEquivalent} only computes isomorphisms between \emph{binary} codes on a linux/unix computer (since it calls Leon's C program \textsc{desauto}). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> x:= Indeterminate( GF(2) );; pol:= x^3+x+1; 
  Z(2)^0+x_1+x_1^3
  gap> H := GeneratorPolCode( pol, 7, GF(2));          
  a cyclic [7,4,1..3]1 code defined by generator polynomial over GF(2)
  gap> CodeIsomorphism(H, HammingCode(3, GF(2)));
  (3,4)(5,6,7) 
  gap> PermutedCode(H, (3,4)(5,6,7)) = HammingCode(3, GF(2));
  true 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{AutomorphismGroup}}
\logpage{[ 3, 4, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AutomorphismGroup( C )\index{AutomorphismGroup@\texttt{AutomorphismGroup}}
\label{AutomorphismGroup}
}\hfill{\scriptsize (function)}}\\


 \texttt{AutomorphismGroup} returns the automorphism group of a linear code \mbox{\texttt{C}}. For a binary code, the automorphism group is the largest permutation group
of degree $n$ such that each permutation applied to the columns of \mbox{\texttt{C}} again yields \mbox{\texttt{C}}. \textsf{GUAVA} calls the external program \textsc{desauto} written by J. S. Leon, if it exists, to compute the automorphism group. If
Leon's program is not compiled on the system (and in the default directory)
then it calls instead the much slower program \texttt{PermutationAutomorphismGroup}. 

 See Leon \cite{Leon82} for a more precise description of the method, and the \texttt{guava/src/leon/doc} subdirectory for for details about Leon's C programs. 

 The function \texttt{PermutedCode} permutes the columns of a code (see \texttt{PermutedCode} (\ref{PermutedCode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> R := RepetitionCode(7,GF(2));
  a cyclic [7,1,7]3 repetition code over GF(2)
  gap> AutomorphismGroup(R);
  Sym( [ 1 .. 7 ] )
                          # every permutation keeps R identical
  gap> C := CordaroWagnerCode(7);
  a linear [7,2,4]3 Cordaro-Wagner code over GF(2)
  gap> AsSSortedList(C);
  [ [ 0 0 0 0 0 0 0 ], [ 0 0 1 1 1 1 1 ], [ 1 1 0 0 0 1 1 ], [ 1 1 1 1 1 0 0 ] ]
  gap> AutomorphismGroup(C);
  Group([ (3,4), (4,5), (1,6)(2,7), (1,2), (6,7) ])
  gap> C2 :=  PermutedCode(C, (1,6)(2,7));
  a linear [7,2,4]3 permuted code
  gap> AsSSortedList(C2);
  [ [ 0 0 0 0 0 0 0 ], [ 0 0 1 1 1 1 1 ], [ 1 1 0 0 0 1 1 ], [ 1 1 1 1 1 0 0 ] ]
  gap> C2 = C;
  true 
\end{Verbatim}
  \index{PermutationGroup} 

\subsection{\textcolor{Chapter }{PermutationAutomorphismGroup}}
\logpage{[ 3, 4, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PermutationAutomorphismGroup( C )\index{PermutationAutomorphismGroup@\texttt{PermutationAutomorphismGroup}}
\label{PermutationAutomorphismGroup}
}\hfill{\scriptsize (function)}}\\


 \texttt{PermutationAutomorphismGroup} returns the permutation automorphism group of a linear code \mbox{\texttt{C}}. This is the largest permutation group of degree $n$ such that each permutation applied to the columns of \mbox{\texttt{C}} again yields \mbox{\texttt{C}}. It is written in GAP, so is much slower than \texttt{AutomorphismGroup}. 

 When \mbox{\texttt{C}} is binary \texttt{PermutationAutomorphismGroup} does \emph{not} call \texttt{AutomorphismGroup}, even though they agree mathematically in that case. This way \texttt{PermutationAutomorphismGroup} can be called on any platform which runs GAP. 

 The older name for this command, \texttt{PermutationGroup}, will become obsolete in the next version of GAP. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> R := RepetitionCode(3,GF(3));
  a cyclic [3,1,3]2 repetition code over GF(3)
  gap> G:=PermutationAutomorphismGroup(R);
  Group([ (), (1,3), (1,2,3), (2,3), (1,3,2), (1,2) ])
  gap> G=SymmetricGroup(3);
  true
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Domain Functions for Codes }}\logpage{[ 3, 5, 0 ]}
{
  \label{Domain Functions for Codes} These are some \textsf{GAP} functions that work on `Domains' in general. Their specific effect on `Codes'
is explained here. 

\subsection{\textcolor{Chapter }{IsFinite}}
\logpage{[ 3, 5, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsFinite( C )\index{IsFinite@\texttt{IsFinite}}
\label{IsFinite}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsFinite} is an implementation of the \textsf{GAP} domain function \texttt{IsFinite}. It returns true for a code \mbox{\texttt{C}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsFinite( RepetitionCode( 1000, GF(11) ) );
  true 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Size}}
\logpage{[ 3, 5, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Size( C )\index{Size@\texttt{Size}}
\label{Size}
}\hfill{\scriptsize (function)}}\\


 \texttt{Size} returns the size of \mbox{\texttt{C}}, the number of elements of the code. If the code is linear, the size of the
code is equal to $q^k$, where $q$ is the size of the base field of \mbox{\texttt{C}} and $k$ is the dimension. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> Size( RepetitionCode( 1000, GF(11) ) );
  11
  gap> Size( NordstromRobinsonCode() );
  256 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LeftActingDomain}}
\logpage{[ 3, 5, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LeftActingDomain( C )\index{LeftActingDomain@\texttt{LeftActingDomain}}
\label{LeftActingDomain}
}\hfill{\scriptsize (function)}}\\


 \texttt{LeftActingDomain} returns the base field of a code \mbox{\texttt{C}}. Each element of \mbox{\texttt{C}} consists of elements of this base field. If the base field is $F$, and the word length of the code is $n$, then the codewords are elements of $F^n$. If \mbox{\texttt{C}} is a cyclic code, its elements are interpreted as polynomials with
coefficients over $F$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := ElementsCode([[0,0,0], [1,0,1], [0,1,0]], GF(4));
  a (3,3,1..3)2..3 user defined unrestricted code over GF(4)
  gap> LeftActingDomain( C1 );
  GF(2^2)
  gap> LeftActingDomain( HammingCode( 3, GF(9) ) );
  GF(3^2) 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Dimension}}
\logpage{[ 3, 5, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Dimension( C )\index{Dimension@\texttt{Dimension}}
\label{Dimension}
}\hfill{\scriptsize (function)}}\\


 \texttt{Dimension} returns the parameter $k$ of \mbox{\texttt{C}}, the dimension of the code, or the number of information symbols in each
codeword. The dimension is not defined for non-linear codes; \texttt{Dimension} then returns an error. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> Dimension( NullCode( 5, GF(5) ) );
  0
  gap> C := BCHCode( 15, 4, GF(4) );
  a cyclic [15,9,5]3..4 BCH code, delta=5, b=1 over GF(4)
  gap> Dimension( C );
  9
  gap> Size( C ) = Size( LeftActingDomain( C ) ) ^ Dimension( C );
  true 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{AsSSortedList}}
\logpage{[ 3, 5, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AsSSortedList( C )\index{AsSSortedList@\texttt{AsSSortedList}}
\label{AsSSortedList}
}\hfill{\scriptsize (function)}}\\


 \texttt{AsSSortedList} (as strictly sorted list) returns an immutable, duplicate free list of the
elements of \mbox{\texttt{C}}. For a finite field $GF(q)$ generated by powers of $Z(q)$, the ordering on 
\[ GF(q)=\{ 0 , Z(q)^0, Z(q), Z(q)^2, ...Z(q)^{q-2} \} \]
 is that determined by the exponents $i$. These elements are of the type codeword (see \texttt{Codeword} (\ref{Codeword})). Note that for large codes, generating the elements may be very time- and
memory-consuming. For generating a specific element or a subset of the
elements, use \texttt{CodewordNr} (see \texttt{CodewordNr} (\ref{CodewordNr})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := ConferenceCode( 5 );
  a (5,12,2)1..4 conference code over GF(2)
  gap> AsSSortedList( C );
  [ [ 0 0 0 0 0 ], [ 0 0 1 1 1 ], [ 0 1 0 1 1 ], [ 0 1 1 0 1 ], [ 0 1 1 1 0 ], 
    [ 1 0 0 1 1 ], [ 1 0 1 0 1 ], [ 1 0 1 1 0 ], [ 1 1 0 0 1 ], [ 1 1 0 1 0 ], 
    [ 1 1 1 0 0 ], [ 1 1 1 1 1 ] ]
  gap> CodewordNr( C, [ 1, 2 ] );
  [ [ 0 0 0 0 0 ], [ 0 0 1 1 1 ] ]
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Printing and Displaying Codes }}\logpage{[ 3, 6, 0 ]}
{
  \label{Printing and Displaying Codes} 

\subsection{\textcolor{Chapter }{Print}}
\logpage{[ 3, 6, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Print( C )\index{Print@\texttt{Print}}
\label{Print}
}\hfill{\scriptsize (function)}}\\


 \texttt{Print} prints information about \mbox{\texttt{C}}. This is the same as typing the identifier \mbox{\texttt{C}} at the \textsf{GAP}-prompt. 

 If the argument is an unrestricted code, information in the form 
\begin{verbatim}  a (n,M,d)r ... code over GF(q)
\end{verbatim}
 is printed, where \mbox{\texttt{n}} is the word length, \mbox{\texttt{M}} the number of elements of the code, \mbox{\texttt{d}} the minimum distance and \mbox{\texttt{r}} the covering radius. 

 If the argument is a linear code, information in the form 
\begin{verbatim}  a linear [n,k,d]r ... code over GF(q)
\end{verbatim}
 is printed, where \mbox{\texttt{n}} is the word length, \mbox{\texttt{k}} the dimension of the code, \mbox{\texttt{d}} the minimum distance and \mbox{\texttt{r}} the covering radius. 

 Except for codes produced by \texttt{RandomLinearCode}, if \mbox{\texttt{d}} is not yet known, it is displayed in the form 
\begin{verbatim}  lowerbound..upperbound
\end{verbatim}
 and if \mbox{\texttt{r}} is not yet known, it is displayed in the same way. For certain ranges of $n$, the values of \mbox{\texttt{lowerbound}} and \mbox{\texttt{upperbound}} are obtained from tables. 

 The function \texttt{Display} gives more information. See \texttt{Display} (\ref{Display}). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := ExtendedCode( HammingCode( 3, GF(2) ) );
  a linear [8,4,4]2 extended code
  gap> Print( "This is ", NordstromRobinsonCode(), ". \n");
  This is a (16,256,6)4 Nordstrom-Robinson code over GF(2). 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{String}}
\logpage{[ 3, 6, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{String( C )\index{String@\texttt{String}}
\label{String}
}\hfill{\scriptsize (function)}}\\


 \texttt{String} returns information about \mbox{\texttt{C}} in a string. This function is used by \texttt{Print}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> x:= Indeterminate( GF(3) );; pol:= x^2+1;
  x_1^2+Z(3)^0
  gap> Factors(pol);
  [ x_1^2+Z(3)^0 ]
  gap> H := GeneratorPolCode( pol, 8, GF(3));
  a cyclic [8,6,1..2]1..2 code defined by generator polynomial over GF(3)
  gap> String(H);
  "a cyclic [8,6,1..2]1..2 code defined by generator polynomial over GF(3)"
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{Display}}
\logpage{[ 3, 6, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Display( C )\index{Display@\texttt{Display}}
\label{Display}
}\hfill{\scriptsize (function)}}\\


 \texttt{Display} prints the method of construction of code \mbox{\texttt{C}}. With this history, in most cases an equal or equivalent code can be
reconstructed. If \mbox{\texttt{C}} is an unmanipulated code, the result is equal to output of the function \texttt{Print} (see \texttt{Print} (\ref{Print})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> Display( RepetitionCode( 6, GF(3) ) );
  a cyclic [6,1,6]4 repetition code over GF(3)
  gap> C1 := ExtendedCode( HammingCode(2) );;
  gap> C2 := PuncturedCode( ReedMullerCode( 2, 3 ) );;
  gap> Display( LengthenedCode( UUVCode( C1, C2 ) ) );
  a linear [12,8,2]2..4 code, lengthened with 1 column(s) of
  a linear [11,8,1]1..2 U U+V construction code of
  U: a linear [4,1,4]2 extended code of
     a linear [3,1,3]1 Hamming (2,2) code over GF(2)
  V: a linear [7,7,1]0 punctured code of
     a cyclic [8,7,2]1 Reed-Muller (2,3) code over GF(2)
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Generating (Check) Matrices and Polynomials }}\logpage{[ 3, 7, 0 ]}
{
  \label{Generating (Check) Matrices and Polynomials} 

\subsection{\textcolor{Chapter }{GeneratorMat}}
\logpage{[ 3, 7, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneratorMat( C )\index{GeneratorMat@\texttt{GeneratorMat}}
\label{GeneratorMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneratorMat} returns a generator matrix of \mbox{\texttt{C}}. The code consists of all linear combinations of the rows of this matrix. 

 If until now no generator matrix of \mbox{\texttt{C}} was determined, it is computed from either the parity check matrix, the
generator polynomial, the check polynomial or the elements (if possible),
whichever is available. 

 If \mbox{\texttt{C}} is a non-linear code, the function returns an error. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> GeneratorMat( HammingCode( 3, GF(2) ) );
  [ [ an immutable GF2 vector of length 7], 
    [ an immutable GF2 vector of length 7], 
    [ an immutable GF2 vector of length 7], 
    [ an immutable GF2 vector of length 7] ]
  gap> Display(last);
   1 1 1 . . . .
   1 . . 1 1 . .
   . 1 . 1 . 1 .
   1 1 . 1 . . 1
  gap> GeneratorMat( RepetitionCode( 5, GF(25) ) );
  [ [ Z(5)^0, Z(5)^0, Z(5)^0, Z(5)^0, Z(5)^0 ] ]
  gap> GeneratorMat( NullCode( 14, GF(4) ) );
  [  ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CheckMat}}
\logpage{[ 3, 7, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CheckMat( C )\index{CheckMat@\texttt{CheckMat}}
\label{CheckMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{CheckMat} returns a parity check matrix of \mbox{\texttt{C}}. The code consists of all words orthogonal to each of the rows of this
matrix. The transpose of the matrix is a right inverse of the generator
matrix. The parity check matrix is computed from either the generator matrix,
the generator polynomial, the check polynomial or the elements of \mbox{\texttt{C}} (if possible), whichever is available. 

 If \mbox{\texttt{C}} is a non-linear code, the function returns an error. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> CheckMat( HammingCode(3, GF(2) ) );
  [ [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ], 
    [ 0*Z(2), Z(2)^0, Z(2)^0, 0*Z(2), 0*Z(2), Z(2)^0, Z(2)^0 ],
    [ Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ] ]
  gap> Display(last);
   . . . 1 1 1 1
   . 1 1 . . 1 1
   1 . 1 . 1 . 1
  gap> CheckMat( RepetitionCode( 5, GF(25) ) );
  [ [ Z(5)^0, Z(5)^2, 0*Z(5), 0*Z(5), 0*Z(5) ],
    [ 0*Z(5), Z(5)^0, Z(5)^2, 0*Z(5), 0*Z(5) ],
    [ 0*Z(5), 0*Z(5), Z(5)^0, Z(5)^2, 0*Z(5) ],
    [ 0*Z(5), 0*Z(5), 0*Z(5), Z(5)^0, Z(5)^2 ] ]
  gap> CheckMat( WholeSpaceCode( 12, GF(4) ) );
  [  ] 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{GeneratorPol}}
\logpage{[ 3, 7, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneratorPol( C )\index{GeneratorPol@\texttt{GeneratorPol}}
\label{GeneratorPol}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneratorPol} returns the generator polynomial of \mbox{\texttt{C}}. The code consists of all multiples of the generator polynomial modulo $x^{n}-1$, where $n$ is the word length of \mbox{\texttt{C}}. The generator polynomial is determined from either the check polynomial, the
generator or check matrix or the elements of \mbox{\texttt{C}} (if possible), whichever is available. 

 If \mbox{\texttt{C}} is not a cyclic code, the function returns `false'. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> GeneratorPol(GeneratorMatCode([[1, 1, 0], [0, 1, 1]], GF(2)));
  Z(2)^0+x_1
  gap> GeneratorPol( WholeSpaceCode( 4, GF(2) ) );
  Z(2)^0
  gap> GeneratorPol( NullCode( 7, GF(3) ) );
  -Z(3)^0+x_1^7
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CheckPol}}
\logpage{[ 3, 7, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CheckPol( C )\index{CheckPol@\texttt{CheckPol}}
\label{CheckPol}
}\hfill{\scriptsize (function)}}\\


 \texttt{CheckPol} returns the check polynomial of \mbox{\texttt{C}}. The code consists of all polynomials $f$ with 
\[ f\cdot h \equiv 0 \ ({\rm mod}\ x^n-1), \]
 where $h$ is the check polynomial, and $n$ is the word length of \mbox{\texttt{C}}. The check polynomial is computed from the generator polynomial, the
generator or parity check matrix or the elements of \mbox{\texttt{C}} (if possible), whichever is available. 

 If \mbox{\texttt{C}} if not a cyclic code, the function returns an error. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> CheckPol(GeneratorMatCode([[1, 1, 0], [0, 1, 1]], GF(2)));
  Z(2)^0+x_1+x_1^2
  gap> CheckPol(WholeSpaceCode(4, GF(2)));
  Z(2)^0+x_1^4
  gap> CheckPol(NullCode(7,GF(3)));
  Z(3)^0
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{RootsOfCode}}
\logpage{[ 3, 7, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RootsOfCode( C )\index{RootsOfCode@\texttt{RootsOfCode}}
\label{RootsOfCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{RootsOfCode} returns a list of all zeros of the generator polynomial of a cyclic code \mbox{\texttt{C}}. These are finite field elements in the splitting field of the generator
polynomial, $GF(q^m)$, $m$ is the multiplicative order of the size of the base field of the code, modulo
the word length. 

 The reverse process, constructing a code from a set of roots, can be carried
out by the function \texttt{RootsCode} (see \texttt{RootsCode} (\ref{RootsCode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := ReedSolomonCode( 16, 5 );
  a cyclic [16,12,5]3..4 Reed-Solomon code over GF(17)
  gap> RootsOfCode( C1 );
  [ Z(17), Z(17)^2, Z(17)^3, Z(17)^4 ]
  gap> C2 := RootsCode( 16, last );
  a cyclic [16,12,5]3..4 code defined by roots over GF(17)
  gap> C1 = C2;
  true 
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Parameters of Codes }}\logpage{[ 3, 8, 0 ]}
{
  \label{Parameters of Codes} 

\subsection{\textcolor{Chapter }{WordLength}}
\logpage{[ 3, 8, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{WordLength( C )\index{WordLength@\texttt{WordLength}}
\label{WordLength}
}\hfill{\scriptsize (function)}}\\


 \texttt{WordLength} returns the parameter $n$ of \mbox{\texttt{C}}, the word length of the elements. Elements of cyclic codes are polynomials of
maximum degree $n-1$, as calculations are carried out modulo $x^{n}-1$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> WordLength( NordstromRobinsonCode() );
  16
  gap> WordLength( PuncturedCode( WholeSpaceCode(7) ) );
  6
  gap> WordLength( UUVCode( WholeSpaceCode(7), RepetitionCode(7) ) );
  14 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{Redundancy}}
\logpage{[ 3, 8, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Redundancy( C )\index{Redundancy@\texttt{Redundancy}}
\label{Redundancy}
}\hfill{\scriptsize (function)}}\\


 \texttt{Redundancy} returns the redundancy $r$ of \mbox{\texttt{C}}, which is equal to the number of check symbols in each element. If \mbox{\texttt{C}} is not a linear code the redundancy is not defined and \texttt{Redundancy} returns an error. 

 If a linear code \mbox{\texttt{C}} has dimension $k$ and word length $n$, it has redundancy $r=n-k$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := TernaryGolayCode();
  a cyclic [11,6,5]2 ternary Golay code over GF(3)
  gap> Redundancy(C);
  5
  gap> Redundancy( DualCode(C) );
  6 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{MinimumDistance}}
\logpage{[ 3, 8, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MinimumDistance( C )\index{MinimumDistance@\texttt{MinimumDistance}}
\label{MinimumDistance}
}\hfill{\scriptsize (function)}}\\


 \texttt{MinimumDistance} returns the minimum distance of \mbox{\texttt{C}}, the largest integer $d$ with the property that every element of \mbox{\texttt{C}} has at least a Hamming distance $d$ (see \texttt{DistanceCodeword} (\ref{DistanceCodeword})) to any other element of \mbox{\texttt{C}}. For linear codes, the minimum distance is equal to the minimum weight. This
means that $d$ is also the smallest positive value with $w[d+1] \neq 0$, where $w=(w[1],w[2],...,w[n])$ is the weight distribution of \mbox{\texttt{C}} (see \texttt{WeightDistribution} (\ref{WeightDistribution})). For unrestricted codes, $d$ is the smallest positive value with $w[d+1] \neq 0$, where $w$ is the inner distribution of \mbox{\texttt{C}} (see \texttt{InnerDistribution} (\ref{InnerDistribution})). 

 For codes with only one element, the minimum distance is defined to be equal
to the word length. 

 For linear codes \mbox{\texttt{C}}, the algorithm used is the following: After replacing \mbox{\texttt{C}} by a permutation equivalent \mbox{\texttt{C'}}, one may assume the generator matrix has the following form $G=(I_{k} \, | \, A)$, for some $k\times (n-k)$ matrix $A$. If $A=0$ then return $d(C)=1$. Next, find the minimum distance of the code spanned by the rows of $A$. Call this distance $d(A)$. Note that $d(A)$ is equal to the the Hamming distance $d(v,0)$ where $v$ is some proper linear combination of $i$ distinct rows of $A$. Return $d(C)=d(A)+i$, where $i$ is as in the previous step. 

 This command may also be called using the syntax \texttt{MinimumDistance(C, w)}. In this form, \texttt{MinimumDistance} returns the minimum distance of a codeword \mbox{\texttt{w}} to the code \mbox{\texttt{C}}, also called the \emph{distance from \mbox{\texttt{w}} to} \mbox{\texttt{C}}. This is the smallest value $d$ for which there is an element $c$ of the code \mbox{\texttt{C}} which is at distance $d$ from \mbox{\texttt{w}}. So $d$ is also the minimum value for which $D[d+1] \neq 0$, where $D$ is the distance distribution of \mbox{\texttt{w}} to \mbox{\texttt{C}} (see \texttt{DistancesDistribution} (\ref{DistancesDistribution})). 

 Note that \mbox{\texttt{w}} must be an element of the same vector space as the elements of \mbox{\texttt{C}}. \mbox{\texttt{w}} does not necessarily belong to the code (if it does, the minimum distance is
zero). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := MOLSCode(7);; MinimumDistance(C);
  3
  gap> WeightDistribution(C);
  [ 1, 0, 0, 24, 24 ]
  gap> MinimumDistance( WholeSpaceCode( 5, GF(3) ) );
  1
  gap> MinimumDistance( NullCode( 4, GF(2) ) );
  4
  gap> C := ConferenceCode(9);; MinimumDistance(C);
  4
  gap> InnerDistribution(C);
  [ 1, 0, 0, 0, 63/5, 9/5, 18/5, 0, 9/10, 1/10 ] 
  gap> C := MOLSCode(7);; w := CodewordNr( C, 17 );
  [ 3 3 6 2 ]
  gap> MinimumDistance( C, w );
  0
  gap> C := RemovedElementsCode( C, w );; MinimumDistance( C, w );
  3                           # so w no longer belongs to C 
\end{Verbatim}
  See also the \textsf{GUAVA} commands relating to bounds on the minimum distance in section \ref{Distance bounds on codes}. 

\subsection{\textcolor{Chapter }{MinimumDistanceLeon}}
\logpage{[ 3, 8, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MinimumDistanceLeon( C )\index{MinimumDistanceLeon@\texttt{MinimumDistanceLeon}}
\label{MinimumDistanceLeon}
}\hfill{\scriptsize (function)}}\\


 \texttt{MinimumDistanceLeon} returns the ``probable'' minimum distance $d_{Leon}$ of a linear binary code \mbox{\texttt{C}}, using an implementation of Leon's probabilistic polynomial time algorithm.
Briefly: Let \mbox{\texttt{C}} be a linear code of dimension $k$ over $GF(q)$ as above. The algorithm has input parameters $s$ and $\rho$, where $s$ is an integer between $2$ and $n-k$, and $\rho$ is an integer between $2$ and $k$. 
\begin{itemize}
\item  Find a generator matrix $G$ of $C$. 
\item  Randomly permute the columns of $G$. 
\item  Perform Gaussian elimination on the permuted matrix to obtain a new matrix of
the following form: 
\[ G=(I_{k} \, | \, Z \, | \, B) \]
 with $Z$ a $k\times s$ matrix. If $(Z,B)$ is the zero matrix then return $1$ for the minimum distance. If $Z=0$ but not $B$ then either choose another permutation of the rows of \mbox{\texttt{C}} or return `method fails'. 
\item  Search $Z$ for at most $\rho$ rows that lead to codewords of weight less than $\rho$. 
\item  For these codewords, compute the weight of the whole word in \mbox{\texttt{C}}. Return this weight. 
\end{itemize}
 (See for example J. S. Leon, \cite{Leon88} for more details.) Sometimes (as is the case in \textsf{GUAVA}) this probabilistic algorithm is repeated several times and the most commonly
occurring value is taken. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(50,22,GF(2));
  a  [50,22,?] randomly generated code over GF(2)
  gap> MinimumDistanceLeon(C); time;
  6
  211
  gap> MinimumDistance(C); time;
  6
  1204
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DecreaseMinimumDistanceUpperBound}}
\logpage{[ 3, 8, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DecreaseMinimumDistanceUpperBound( C, t, m )\index{DecreaseMinimumDistanceUpperBound@\texttt{DecreaseMinimumDistanceUpperBound}}
\label{DecreaseMinimumDistanceUpperBound}
}\hfill{\scriptsize (function)}}\\


 \texttt{DecreaseMinimumDistanceUpperBound} is an implementation of the algorithm for the minimum distance of a linear
binary code \mbox{\texttt{C}} by Leon \cite{Leon88}. This algorithm tries to find codewords with small minimum weights. The
parameter \mbox{\texttt{t}} is at least $1$ and less than the dimension of \mbox{\texttt{C}}. The best results are obtained if it is close to the dimension of the code.
The parameter \mbox{\texttt{m}} gives the number of runs that the algorithm will perform. 

 The result returned is a record with two fields; the first, \texttt{mindist}, gives the lowest weight found, and \texttt{word} gives the corresponding codeword. (This was implemented before \texttt{MinimumDistanceLeon} but independently. The older manual had given the command incorrectly, so the
command was only found after reading all the \emph{*.gi} files in the \textsf{GUAVA} library. Though both \texttt{MinimumDistance} and \texttt{MinimumDistanceLeon} often run much faster than \texttt{DecreaseMinimumDistanceUpperBound}, \texttt{DecreaseMinimumDistanceUpperBound} appears to be more accurate than \texttt{MinimumDistanceLeon}.) }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(5,2,GF(2));
  a  [5,2,?] randomly generated code over GF(2)
  gap> DecreaseMinimumDistanceUpperBound(C,1,4);
  rec( mindist := 3, word := [ 0*Z(2), Z(2)^0, Z(2)^0, 0*Z(2), Z(2)^0 ] )
  gap> MinimumDistance(C);
  3
  gap> C:=RandomLinearCode(8,4,GF(2));
  a  [8,4,?] randomly generated code over GF(2)
  gap> DecreaseMinimumDistanceUpperBound(C,3,4);
  rec( mindist := 2,
    word := [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ] )
  gap> MinimumDistance(C);
  2
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{MinimumDistanceRandom}}
\logpage{[ 3, 8, 6 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MinimumDistanceRandom( C, num, s )\index{MinimumDistanceRandom@\texttt{MinimumDistanceRandom}}
\label{MinimumDistanceRandom}
}\hfill{\scriptsize (function)}}\\


 \texttt{MinimumDistanceRandom} returns an upper bound for the minimum distance $d_{random}$ of a linear binary code \mbox{\texttt{C}}, using a probabilistic polynomial time algorithm. Briefly: Let \mbox{\texttt{C}} be a linear code of dimension $k$ over $GF(q)$ as above. The algorithm has input parameters $num$ and $s$, where $s$ is an integer between $2$ and $n-1$, and $num$ is an integer greater than or equal to $1$. 
\begin{itemize}
\item  Find a generator matrix $G$ of $C$. 
\item  Randomly permute the columns of $G$, written $G_p$.. 
\item  
\[ G=(A, B) \]
 with $A$ a $k\times s$ matrix. If $A$ is the zero matrix then return `method fails'. 
\item  Search $A$ for at most $5$ rows that lead to codewords, in the code $C_A$ with generator matrix $A$, of minimum weight. 
\item  For these codewords, use the associated linear combination to compute the
weight of the whole word in \mbox{\texttt{C}}. Return this weight and codeword. 
\end{itemize}
 This probabilistic algorithm is repeated \mbox{\texttt{num}} times (with different random permutations of the rows of $G$ each time) and the weight and codeword of the lowest occurring weight is
taken. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(60,20,GF(2));
  a  [60,20,?] randomly generated code over GF(2)
  gap> #mindist(C);time;
  gap> #mindistleon(C,10,30);time; #doesn't work well
  gap> a:=MinimumDistanceRandom(C,10,30);time; # done 10 times -with fastest time!!
  
   This is a probabilistic algorithm which may return the wrong answer.
  [ 12, [ 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 1 0 0 
          1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 ] ]
  130
  gap> a[2] in C;
  true
  gap> b:=DecreaseMinimumDistanceUpperBound(C,10,1); time; #only done once!
  rec( mindist := 12, word := [ 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 
        Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 
        0*Z(2), Z(2)^0, Z(2)^0, 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 
        Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 
        0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 
        0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 
        0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] )
  649
  gap> Codeword(b!.word) in C;
  true
  gap> MinimumDistance(C);time;
  12
  196
  gap> c:=MinimumDistanceLeon(C);time;
  12
  66
  gap> C:=RandomLinearCode(30,10,GF(3));
  a  [30,10,?] randomly generated code over GF(3)
  gap> a:=MinimumDistanceRandom(C,10,10);time;
  
   This is a probabilistic algorithm which may return the wrong answer.
  [ 13, [ 0 0 0 1 0 0 0 0 0 0 1 0 2 2 1 1 0 2 2 0 1 0 2 1 0 0 0 1 0 2 ] ]
  229
  gap> a[2] in C;
  true
  gap> MinimumDistance(C);time;
  9
  45
  gap> c:=MinimumDistanceLeon(C);
  Code must be binary. Quitting.
  0
  gap> a:=MinimumDistanceRandom(C,1,29);time;
  
   This is a probabilistic algorithm which may return the wrong answer.
  [ 10, [ 0 0 1 0 2 0 2 0 1 0 0 0 0 0 0 1 0 1 0 0 1 0 0 0 0 0 2 2 2 0 ] ]
  53
\end{Verbatim}
  \index{$t(n,k)$} \index{covering code} 

\subsection{\textcolor{Chapter }{CoveringRadius}}
\logpage{[ 3, 8, 7 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CoveringRadius( C )\index{CoveringRadius@\texttt{CoveringRadius}}
\label{CoveringRadius}
}\hfill{\scriptsize (function)}}\\


 \texttt{CoveringRadius} returns the \emph{covering radius} of a linear code \mbox{\texttt{C}}. This is the smallest number $r$ with the property that each element $v$ of the ambient vector space of \mbox{\texttt{C}} has at most a distance $r$ to the code \mbox{\texttt{C}}. So for each vector $v$ there must be an element $c$ of \mbox{\texttt{C}} with $d(v,c) \leq r$. The smallest covering radius of any $[n,k]$ binary linear code is denoted $t(n,k)$. A binary linear code with reasonable small covering radius is called a \emph{covering code}. 

 If \mbox{\texttt{C}} is a perfect code (see \texttt{IsPerfectCode} (\ref{IsPerfectCode})), the covering radius is equal to $t$, the number of errors the code can correct, where $d = 2t+1$, with $d$ the minimum distance of \mbox{\texttt{C}} (see \texttt{MinimumDistance} (\ref{MinimumDistance})). 

 If there exists a function called \texttt{SpecialCoveringRadius} in the `operations' field of the code, then this function will be called to
compute the covering radius of the code. At the moment, no code-specific
functions are implemented. 

 If the length of \texttt{BoundsCoveringRadius} (see \texttt{BoundsCoveringRadius} (\ref{BoundsCoveringRadius})), is 1, then the value in 
\begin{verbatim}  C.boundsCoveringRadius
\end{verbatim}
 is returned. Otherwise, the function 
\begin{verbatim}  C.operations.CoveringRadius
\end{verbatim}
 is executed, unless the redundancy of \mbox{\texttt{C}} is too large. In the last case, a warning is issued. 

 The algorithm used to compute the covering radius is the following. First, \texttt{CosetLeadersMatFFE} is used to compute the list of coset leaders (which returns a codeword in each
coset of $GF(q)^n/C$ of minimum weight). Then \texttt{WeightVecFFE} is used to compute the weight of each of these coset leaders. The program
returns the maximum of these weights.  }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> H := RandomLinearCode(10, 5, GF(2));
  a  [10,5,?] randomly generated code over GF(2)
  gap> CoveringRadius(H);
  3
  gap> H := HammingCode(4, GF(2));; IsPerfectCode(H);
  true
  gap> CoveringRadius(H);
  1                       # Hamming codes have minimum distance 3
  gap> CoveringRadius(ReedSolomonCode(7,4));
  3 
  gap> CoveringRadius( BCHCode( 17, 3, GF(2) ) );
  3
  gap> CoveringRadius( HammingCode( 5, GF(2) ) );
  1
  gap> C := ReedMullerCode( 1, 9 );;
  gap> CoveringRadius( C );
  CoveringRadius: warning, the covering radius of
  this code cannot be computed straightforward.
  Try to use IncreaseCoveringRadiusLowerBound( code ).
  (see the manual for more details).
  The covering radius of code lies in the interval:
  [ 240 .. 248 ]
\end{Verbatim}
  See also the \textsf{GUAVA} commands relating to bounds on the minimum distance in section \ref{Covering radius bounds on codes}. 

\subsection{\textcolor{Chapter }{SetCoveringRadius}}
\logpage{[ 3, 8, 8 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SetCoveringRadius( C, intlist )\index{SetCoveringRadius@\texttt{SetCoveringRadius}}
\label{SetCoveringRadius}
}\hfill{\scriptsize (function)}}\\


 \texttt{SetCoveringRadius} enables the user to set the covering radius herself, instead of letting \textsf{GUAVA} compute it. If \mbox{\texttt{intlist}} is an integer, \textsf{GUAVA} will simply put it in the `boundsCoveringRadius' field. If it is a list of
integers, however, it will intersect this list with the `boundsCoveringRadius'
field, thus taking the best of both lists. If this would leave an empty list,
the field is set to \mbox{\texttt{intlist}}. Because some other computations use the covering radius of the code, it is
important that the entered value is not wrong, otherwise new results may be
invalid. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := BCHCode( 17, 3, GF(2) );;
  gap> BoundsCoveringRadius( C );
  [ 3 .. 4 ]
  gap> SetCoveringRadius( C, [ 2 .. 3 ] );
  gap> BoundsCoveringRadius( C );
  [ [ 2 .. 3 ] ]
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Distributions }}\logpage{[ 3, 9, 0 ]}
{
  \label{Distributions} 

\subsection{\textcolor{Chapter }{WeightDistribution}}
\logpage{[ 3, 9, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{WeightDistribution( C )\index{WeightDistribution@\texttt{WeightDistribution}}
\label{WeightDistribution}
}\hfill{\scriptsize (function)}}\\


 \texttt{WeightDistribution} returns the weight distribution of \mbox{\texttt{C}}, as a vector. The $i^{th}$ element of this vector contains the number of elements of \mbox{\texttt{C}} with weight $i-1$. For linear codes, the weight distribution is equal to the inner distribution
(see \texttt{InnerDistribution} (\ref{InnerDistribution})). If $w$ is the weight distribution of a linear code \mbox{\texttt{C}}, it must have the zero codeword, so $w[1] = 1$ (one word of weight 0). 

 Some codes, such as the Hamming codes, have precomputed weight distributions.
For others, the program WeightDistribution calls the GAP program \texttt{DistancesDistributionMatFFEVecFFE}, which is written in C. See also \texttt{CodeWeightEnumerator}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> WeightDistribution( ConferenceCode(9) );
  [ 1, 0, 0, 0, 0, 18, 0, 0, 0, 1 ]
  gap> WeightDistribution( RepetitionCode( 7, GF(4) ) );
  [ 1, 0, 0, 0, 0, 0, 0, 3 ]
  gap> WeightDistribution( WholeSpaceCode( 5, GF(2) ) );
  [ 1, 5, 10, 10, 5, 1 ] 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{InnerDistribution}}
\logpage{[ 3, 9, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{InnerDistribution( C )\index{InnerDistribution@\texttt{InnerDistribution}}
\label{InnerDistribution}
}\hfill{\scriptsize (function)}}\\


 \texttt{InnerDistribution} returns the inner distribution of \mbox{\texttt{C}}. The $i^{th}$ element of the vector contains the average number of elements of \mbox{\texttt{C}} at distance $i-1$ to an element of \mbox{\texttt{C}}. For linear codes, the inner distribution is equal to the weight distribution
(see \texttt{WeightDistribution} (\ref{WeightDistribution})). 

 Suppose $w$ is the inner distribution of \mbox{\texttt{C}}. Then $w[1] = 1$, because each element of \mbox{\texttt{C}} has exactly one element at distance zero (the element itself). The minimum
distance of \mbox{\texttt{C}} is the smallest value $d > 0$ with $w[d+1] \neq 0$, because a distance between zero and $d$ never occurs. See \texttt{MinimumDistance} (\ref{MinimumDistance}). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> InnerDistribution( ConferenceCode(9) );
  [ 1, 0, 0, 0, 63/5, 9/5, 18/5, 0, 9/10, 1/10 ]
  gap> InnerDistribution( RepetitionCode( 7, GF(4) ) );
  [ 1, 0, 0, 0, 0, 0, 0, 3 ] 
\end{Verbatim}
  \index{distance} 

\subsection{\textcolor{Chapter }{DistancesDistribution}}
\logpage{[ 3, 9, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DistancesDistribution( C, w )\index{DistancesDistribution@\texttt{DistancesDistribution}}
\label{DistancesDistribution}
}\hfill{\scriptsize (function)}}\\


 \texttt{DistancesDistribution} returns the distribution of the distances of all elements of \mbox{\texttt{C}} to a codeword \mbox{\texttt{w}} in the same vector space. The $i^{th}$ element of the distance distribution is the number of codewords of \mbox{\texttt{C}} that have distance $i-1$ to \mbox{\texttt{w}}. The smallest value $d$ with $w[d+1] \neq 0$, is defined as the \emph{distance to} \mbox{\texttt{C}} (see \texttt{MinimumDistance} (\ref{MinimumDistance})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> H := HadamardCode(20);
  a (20,40,10)6..8 Hadamard code of order 20 over GF(2)
  gap> c := Codeword("10110101101010010101", H);
  [ 1 0 1 1 0 1 0 1 1 0 1 0 1 0 0 1 0 1 0 1 ]
  gap> DistancesDistribution(H, c);
  [ 0, 0, 0, 0, 0, 1, 0, 7, 0, 12, 0, 12, 0, 7, 0, 1, 0, 0, 0, 0, 0 ]
  gap> MinimumDistance(H, c);
  5                           # distance to H 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{OuterDistribution}}
\logpage{[ 3, 9, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OuterDistribution( C )\index{OuterDistribution@\texttt{OuterDistribution}}
\label{OuterDistribution}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{OuterDistribution} returns a list of length $q^n$, where $q$ is the size of the base field of \mbox{\texttt{C}} and $n$ is the word length. The elements of the list consist of pairs, the first
coordinate being an element of $GF(q)^n$ (this is a codeword type) and the second coordinate being a distribution of
distances to the code (a list of integers). This table is \emph{very} large, and for $n > 20$ it will not fit in the memory of most computers. The function \texttt{DistancesDistribution} (see \texttt{DistancesDistribution} (\ref{DistancesDistribution})) can be used to calculate one entry of the list. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := RepetitionCode( 3, GF(2) );
  a cyclic [3,1,3]1 repetition code over GF(2)
  gap> OD := OuterDistribution(C);
  [ [ [ 0 0 0 ], [ 1, 0, 0, 1 ] ], [ [ 1 1 1 ], [ 1, 0, 0, 1 ] ],
    [ [ 0 0 1 ], [ 0, 1, 1, 0 ] ], [ [ 1 1 0 ], [ 0, 1, 1, 0 ] ],
    [ [ 1 0 0 ], [ 0, 1, 1, 0 ] ], [ [ 0 1 1 ], [ 0, 1, 1, 0 ] ],
    [ [ 0 1 0 ], [ 0, 1, 1, 0 ] ], [ [ 1 0 1 ], [ 0, 1, 1, 0 ] ] ]
  gap> WeightDistribution(C) = OD[1][2];
  true
  gap> DistancesDistribution( C, Codeword("110") ) = OD[4][2];
  true 
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Decoding Functions }}\logpage{[ 3, 10, 0 ]}
{
  \label{Decoding Functions} 

\subsection{\textcolor{Chapter }{Decode}}
\logpage{[ 3, 10, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Decode( C, r )\index{Decode@\texttt{Decode}}
\label{Decode}
}\hfill{\scriptsize (function)}}\\


 \texttt{Decode} decodes \mbox{\texttt{r}} (a 'received word') with respect to code \mbox{\texttt{C}} and returns the `message word' (i.e., the information digits associated to the
codeword $c \in C$ closest to \mbox{\texttt{r}}). Here \mbox{\texttt{r}} can be a \textsf{GUAVA} codeword or a list of codewords. First, possible errors in \mbox{\texttt{r}} are corrected, then the codeword is decoded to an \emph{information codeword} $m$ (and not an element of \mbox{\texttt{C}}). If the code record has a field `specialDecoder', this special algorithm is
used to decode the vector. Hamming codes and BCH codes have such a special
algorithm. (The algorithm used for BCH codes is the Sugiyama algorithm
described, for example, in section 5.4.3 of \cite{HP03}. \emph{Work in progress:} special decoders are now being written for the generalized Reed-Solomon code.)
If \mbox{\texttt{C}} is linear and no special decoder field has been set then syndrome decoding is
used. Otherwise (when \mbox{\texttt{C}} is non-linear), no decoding algorithms have been implemented and an error is
returned. 

 A special decoder can be created by defining a function 
\begin{verbatim}  C!.SpecialDecoder := function(C, r) ... end;
\end{verbatim}
 The function uses the arguments \mbox{\texttt{C}} (the code record itself) and \mbox{\texttt{r}} (a vector of the codeword type) to decode \mbox{\texttt{r}} to an information vector. A normal decoder would take a codeword \mbox{\texttt{r}} of the same word length and field as \mbox{\texttt{C}}, and would return an information vector of length $k$, the dimension of \mbox{\texttt{C}}. The user is not restricted to these normal demands though, and can for
instance define a decoder for non-linear codes. 

 Encoding is done by multiplying the information vector with the code (see \ref{Operations for Codes}). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := HammingCode(3);
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  gap> c := "1010"*C;                    # encoding
  [ 1 0 1 1 0 1 0 ]
  gap> Decode(C, c);                     # decoding
  [ 1 0 1 0 ]
  gap> Decode(C, Codeword("0010101"));
  [ 1 1 0 1 ]                            # one error corrected
  gap> C!.SpecialDecoder := function(C, c)
  > return NullWord(Dimension(C));
  > end;
  function ( C, c ) ... end
  gap> Decode(C, c);
  [ 0 0 0 0 ]           # new decoder always returns null word 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{Decodeword}}
\logpage{[ 3, 10, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Decodeword( C, r )\index{Decodeword@\texttt{Decodeword}}
\label{Decodeword}
}\hfill{\scriptsize (function)}}\\


 \texttt{Decodeword} decodes \mbox{\texttt{r}} (a 'received word') with respect to code \mbox{\texttt{C}} and returns the codeword $c \in C$ closest to \mbox{\texttt{r}}. Here \mbox{\texttt{r}} can be a \textsf{GUAVA} codeword or a list of codewords. If the code record has a field
`specialDecoder', this special algorithm is used to decode the vector. Hamming
codes, generalized Reed-Solomon codes, and BCH codes have such a special
algorithm. (The algorithm used for BCH codes is the Sugiyama algorithm
described, for example, in section 5.4.3 of \cite{HP03}. The algorithm used for generalized Reed-Solomon codes is the ``interpolation
algorithm'' described for example in chapter 5 of \cite{JH04}.) If \mbox{\texttt{C}} is linear and no special decoder field has been set then syndrome decoding is
used. Otherwise, when \mbox{\texttt{C}} is non-linear, the nearest neighbor algorithm has been implemented (which
should only be used for small-sized codes). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := HammingCode(3);
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  gap> c := "1010"*C;                    # encoding
  [ 1 0 1 1 0 1 0 ]
  gap> Decodeword(C, c);                     # decoding
  [ 1 0 1 1 0 1 0 ]
  gap>
  gap> R:=PolynomialRing(GF(11),["t"]);
  GF(11)[t]
  gap> P:=List([1,3,4,5,7],i->Z(11)^i);
  [ Z(11), Z(11)^3, Z(11)^4, Z(11)^5, Z(11)^7 ]
  gap> C:=GeneralizedReedSolomonCode(P,3,R);
  a linear [5,3,1..3]2  generalized Reed-Solomon code over GF(11)
  gap> MinimumDistance(C);
  3
  gap> c:=Random(C);
  [ 0 9 6 2 1 ]
  gap> v:=Codeword("09620");
  [ 0 9 6 2 0 ]
  gap> GeneralizedReedSolomonDecoderGao(C,v);
  [ 0 9 6 2 1 ]
  gap> Decodeword(C,v); # calls the special interpolation decoder
  [ 0 9 6 2 1 ]
  gap> G:=GeneratorMat(C);
  [ [ Z(11)^0, 0*Z(11), 0*Z(11), Z(11)^8, Z(11)^9 ],
    [ 0*Z(11), Z(11)^0, 0*Z(11), Z(11)^0, Z(11)^8 ],
    [ 0*Z(11), 0*Z(11), Z(11)^0, Z(11)^3, Z(11)^8 ] ]
  gap> C1:=GeneratorMatCode(G,GF(11));
  a linear [5,3,1..3]2 code defined by generator matrix over GF(11)
  gap> Decodeword(C,v); # calls syndrome decoding
  [ 0 9 6 2 1 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{GeneralizedReedSolomonDecoderGao}}
\logpage{[ 3, 10, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneralizedReedSolomonDecoderGao( C, r )\index{GeneralizedReedSolomonDecoderGao@\texttt{GeneralizedReedSolomonDecoderGao}}
\label{GeneralizedReedSolomonDecoderGao}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneralizedReedSolomonDecoderGao} decodes \mbox{\texttt{r}} (a 'received word') to a codeword $c \in C$ in a generalized Reed-Solomon code \mbox{\texttt{C}} (see \texttt{GeneralizedReedSolomonCode} (\ref{GeneralizedReedSolomonCode})), closest to \mbox{\texttt{r}}. Here \mbox{\texttt{r}} must be a \textsf{GUAVA} codeword. If the code record does not have name `generalized Reed-Solomon
code' then an error is returned. Otherwise, the Gao decoder \cite{Gao03} is used to compute $c$. 

 For long codes, this method is faster in practice than the interpolation
method used in \texttt{Decodeword}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> R:=PolynomialRing(GF(11),["t"]);
  GF(11)[t]
  gap> P:=List([1,3,4,5,7],i->Z(11)^i);
  [ Z(11), Z(11)^3, Z(11)^4, Z(11)^5, Z(11)^7 ]
  gap> C:=GeneralizedReedSolomonCode(P,3,R);
  a linear [5,3,1..3]2  generalized Reed-Solomon code over GF(11)
  gap> MinimumDistance(C);
  3
  gap> c:=Random(C);
  [ 0 9 6 2 1 ]
  gap> v:=Codeword("09620");
  [ 0 9 6 2 0 ]
  gap> GeneralizedReedSolomonDecoderGao(C,v); 
  [ 0 9 6 2 1 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{GeneralizedReedSolomonListDecoder}}
\logpage{[ 3, 10, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneralizedReedSolomonListDecoder( C, r, tau )\index{GeneralizedReedSolomonListDecoder@\texttt{GeneralizedReedSolomonListDecoder}}
\label{GeneralizedReedSolomonListDecoder}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneralizedReedSolomonListDecoder} implements Sudans list-decoding algorithm (see section 12.1 of \cite{JH04}) for ``low rate'' Reed-Solomon codes. It returns the list of all codewords in
C which are a distance of at most \mbox{\texttt{tau}} from \mbox{\texttt{r}} (a 'received word'). \mbox{\texttt{C}} must be a generalized Reed-Solomon code \mbox{\texttt{C}} (see \texttt{GeneralizedReedSolomonCode} (\ref{GeneralizedReedSolomonCode})) and \mbox{\texttt{r}} must be a \textsf{GUAVA} codeword. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> F:=GF(16);
  GF(2^4)
  gap>
  gap> a:=PrimitiveRoot(F);; b:=a^7;; b^4+b^3+1; 
  0*Z(2)
  gap> Pts:=List([0..14],i->b^i);
  [ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6, Z(2^4)^13, Z(2^2), Z(2^4)^12, Z(2^4)^4,
    Z(2^4)^11, Z(2^4)^3, Z(2^2)^2, Z(2^4)^2, Z(2^4)^9, Z(2^4), Z(2^4)^8 ]
  gap> x:=X(F);;
  gap> R1:=PolynomialRing(F,[x]);;
  gap> vars:=IndeterminatesOfPolynomialRing(R1);;
  gap> y:=X(F,vars);;
  gap> R2:=PolynomialRing(F,[x,y]);;
  gap> C:=GeneralizedReedSolomonCode(Pts,3,R1); 
  a linear [15,3,1..13]10..12  generalized Reed-Solomon code over GF(16)
  gap> MinimumDistance(C); ## 6 error correcting
  13
  gap> z:=Zero(F);;
  gap> r:=[z,z,z,z,z,z,z,z,b^6,b^2,b^5,b^14,b,b^7,b^11];; 
  gap> r:=Codeword(r);
  [ 0 0 0 0 0 0 0 0 a^12 a^14 a^5 a^8 a^7 a^4 a^2 ]
  gap> cs:=GeneralizedReedSolomonListDecoder(C,r,2); time;
  [ [ 0 a^9 a^3 a^13 a^6 a^10 a^11 a a^12 a^14 a^5 a^8 a^7 a^4 a^2 ],
    [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ] ]
  250
  gap> c1:=cs[1]; c1 in C;
  [ 0 a^9 a^3 a^13 a^6 a^10 a^11 a a^12 a^14 a^5 a^8 a^7 a^4 a^2 ]
  true
  gap> c2:=cs[2]; c2 in C;
  [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ]
  true
  gap> WeightCodeword(c1-r);
  7
  gap> WeightCodeword(c2-r);
  7
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{NearestNeighborGRSDecodewords}}
\logpage{[ 3, 10, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NearestNeighborGRSDecodewords( C, v, dist )\index{NearestNeighborGRSDecodewords@\texttt{NearestNeighborGRSDecodewords}}
\label{NearestNeighborGRSDecodewords}
}\hfill{\scriptsize (function)}}\\


 \texttt{NearestNeighborGRSDecodewords} finds all generalized Reed-Solomon codewords within distance \mbox{\texttt{dist}} from \mbox{\texttt{v}} \emph{and} the associated polynomial, using ``brute force''. Input: \mbox{\texttt{v}} is a received vector (a \textsf{GUAVA} codeword), \mbox{\texttt{C}} is a GRS code, \mbox{\texttt{dist}} > 0 is the distance from \mbox{\texttt{v}} to search in \mbox{\texttt{C}}. Output: a list of pairs $[c,f(x)]$, where $wt(c-v)\leq dist-1$ and $c = (f(x_1),...,f(x_n))$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> F:=GF(16);
  GF(2^4)
  gap> a:=PrimitiveRoot(F);; b:=a^7; b^4+b^3+1;
  Z(2^4)^7
  0*Z(2)
  gap> Pts:=List([0..14],i->b^i);
  [ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6, Z(2^4)^13, Z(2^2), Z(2^4)^12,
    Z(2^4)^4, Z(2^4)^11, Z(2^4)^3, Z(2^2)^2, Z(2^4)^2, Z(2^4)^9, Z(2^4),
    Z(2^4)^8 ]
  gap> x:=X(F);;
  gap> R1:=PolynomialRing(F,[x]);;
  gap> vars:=IndeterminatesOfPolynomialRing(R1);;
  gap> y:=X(F,vars);;
  gap> R2:=PolynomialRing(F,[x,y]);;
  gap> C:=GeneralizedReedSolomonCode(Pts,3,R1);
  a linear [15,3,1..13]10..12  generalized Reed-Solomon code over GF(16)
  gap> MinimumDistance(C); # 6 error correcting
  13
  gap> z:=Zero(F);
  0*Z(2)
  gap> r:=[z,z,z,z,z,z,z,z,b^6,b^2,b^5,b^14,b,b^7,b^11];; # 7 errors
  gap> r:=Codeword(r);
  [ 0 0 0 0 0 0 0 0 a^12 a^14 a^5 a^8 a^7 a^4 a^2 ]
  gap> cs:=NearestNeighborGRSDecodewords(C,r,7);
  [ [ [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ], 0*Z(2) ],
    [ [ 0 a^9 a^3 a^13 a^6 a^10 a^11 a a^12 a^14 a^5 a^8 a^7 a^4 a^2 ], x_1+Z(2)^0 ] ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{NearestNeighborDecodewords}}
\logpage{[ 3, 10, 6 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NearestNeighborDecodewords( C, v, dist )\index{NearestNeighborDecodewords@\texttt{NearestNeighborDecodewords}}
\label{NearestNeighborDecodewords}
}\hfill{\scriptsize (function)}}\\


 \texttt{NearestNeighborDecodewords} finds all codewords in a linear code \mbox{\texttt{C}} within distance \mbox{\texttt{dist}} from \mbox{\texttt{v}}, using ``brute force''. Input: \mbox{\texttt{v}} is a received vector (a \textsf{GUAVA} codeword), \mbox{\texttt{C}} is a linear code, \mbox{\texttt{dist}} > 0 is the distance from \mbox{\texttt{v}} to search in \mbox{\texttt{C}}. Output: a list of $c \in C$, where $wt(c-v)\leq dist-1$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> F:=GF(16);
  GF(2^4)
  gap> a:=PrimitiveRoot(F);; b:=a^7; b^4+b^3+1;
  Z(2^4)^7
  0*Z(2)
  gap> Pts:=List([0..14],i->b^i);
  [ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6, Z(2^4)^13, Z(2^2), Z(2^4)^12,
    Z(2^4)^4, Z(2^4)^11, Z(2^4)^3, Z(2^2)^2, Z(2^4)^2, Z(2^4)^9, Z(2^4),
    Z(2^4)^8 ]
  gap> x:=X(F);;
  gap> R1:=PolynomialRing(F,[x]);;
  gap> vars:=IndeterminatesOfPolynomialRing(R1);;
  gap> y:=X(F,vars);;
  gap> R2:=PolynomialRing(F,[x,y]);;
  gap> C:=GeneralizedReedSolomonCode(Pts,3,R1);
  a linear [15,3,1..13]10..12  generalized Reed-Solomon code over GF(16)
  gap> MinimumDistance(C);
  13
  gap> z:=Zero(F);
  0*Z(2)
  gap> r:=[z,z,z,z,z,z,z,z,b^6,b^2,b^5,b^14,b,b^7,b^11];;
  gap> r:=Codeword(r);
  [ 0 0 0 0 0 0 0 0 a^12 a^14 a^5 a^8 a^7 a^4 a^2 ]
  gap> cs:=NearestNeighborDecodewords(C,r,7);
  [ [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ], 
    [ 0 a^9 a^3 a^13 a^6 a^10 a^11 a a^12 a^14 a^5 a^8 a^7 a^4 a^2 ] ]
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{Syndrome}}
\logpage{[ 3, 10, 7 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Syndrome( C, v )\index{Syndrome@\texttt{Syndrome}}
\label{Syndrome}
}\hfill{\scriptsize (function)}}\\


 \texttt{Syndrome} returns the syndrome of word \mbox{\texttt{v}} with respect to a linear code \mbox{\texttt{C}}. \mbox{\texttt{v}} is a codeword in the ambient vector space of \mbox{\texttt{C}}. If \mbox{\texttt{v}} is an element of \mbox{\texttt{C}}, the syndrome is a zero vector. The syndrome can be used for looking up an
error vector in the syndrome table (see \texttt{SyndromeTable} (\ref{SyndromeTable})) that is needed to correct an error in $v$. 

 A syndrome is not defined for non-linear codes. \texttt{Syndrome} then returns an error. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := HammingCode(4);
  a linear [15,11,3]1 Hamming (4,2) code over GF(2)
  gap> v := CodewordNr( C, 7 );
  [ 1 1 0 0 0 0 0 0 0 0 0 0 1 1 0 ]
  gap> Syndrome( C, v );
  [ 0 0 0 0 ]
  gap> Syndrome( C, Codeword( "000000001100111" ) );
  [ 1 1 1 1 ]
  gap> Syndrome( C, Codeword( "000000000000001" ) );
  [ 1 1 1 1 ]    # the same syndrome: both codewords are in the same
                 # coset of C 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{SyndromeTable}}
\logpage{[ 3, 10, 8 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SyndromeTable( C )\index{SyndromeTable@\texttt{SyndromeTable}}
\label{SyndromeTable}
}\hfill{\scriptsize (function)}}\\


 \texttt{SyndromeTable} returns a \emph{syndrome table} of a linear code \mbox{\texttt{C}}, consisting of two columns. The first column consists of the error vectors
that correspond to the syndrome vectors in the second column. These vectors
both are of the codeword type. After calculating the syndrome of a word \mbox{\texttt{v}} with \texttt{Syndrome} (see \texttt{Syndrome} (\ref{Syndrome})), the error vector needed to correct \mbox{\texttt{v}} can be found in the syndrome table. Subtracting this vector from \mbox{\texttt{v}} yields an element of \mbox{\texttt{C}}. To make the search for the syndrome as fast as possible, the syndrome table
is sorted according to the syndrome vectors. }

 \index{syndrome table} 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> H := HammingCode(2);
  a linear [3,1,3]1 Hamming (2,2) code over GF(2)
  gap> SyndromeTable(H);
  [ [ [ 0 0 0 ], [ 0 0 ] ], [ [ 1 0 0 ], [ 0 1 ] ],
    [ [ 0 1 0 ], [ 1 0 ] ], [ [ 0 0 1 ], [ 1 1 ] ] ]
  gap> c := Codeword("101");
  [ 1 0 1 ]
  gap> c in H;
  false          # c is not an element of H
  gap> Syndrome(H,c);
  [ 1 0 ]        # according to the syndrome table,
                 # the error vector [ 0 1 0 ] belongs to this syndrome
  gap> c - Codeword("010") in H;
  true           # so the corrected codeword is
                 # [ 1 0 1 ] - [ 0 1 0 ] = [ 1 1 1 ],
                 # this is an element of H 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{StandardArray}}
\logpage{[ 3, 10, 9 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{StandardArray( C )\index{StandardArray@\texttt{StandardArray}}
\label{StandardArray}
}\hfill{\scriptsize (function)}}\\


 \texttt{StandardArray} returns the standard array of a code \mbox{\texttt{C}}. This is a matrix with elements of the codeword type. It has $q^r$ rows and $q^k$ columns, where $q$ is the size of the base field of \mbox{\texttt{C}}, $r=n-k$ is the redundancy of \mbox{\texttt{C}}, and $k$ is the dimension of \mbox{\texttt{C}}. The first row contains all the elements of \mbox{\texttt{C}}. Each other row contains words that do not belong to the code, with in the
first column their syndrome vector (see \texttt{Syndrome} (\ref{Syndrome})). 

 A non-linear code does not have a standard array. \texttt{StandardArray} then returns an error. 

 Note that calculating a standard array can be very time- and memory-
consuming. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> StandardArray(RepetitionCode(3)); 
  [ [ [ 0 0 0 ], [ 1 1 1 ] ], [ [ 0 0 1 ], [ 1 1 0 ] ], 
    [ [ 0 1 0 ], [ 1 0 1 ] ], [ [ 1 0 0 ], [ 0 1 1 ] ] ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{PermutationDecode}}
\logpage{[ 3, 10, 10 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PermutationDecode( C, v )\index{PermutationDecode@\texttt{PermutationDecode}}
\label{PermutationDecode}
}\hfill{\scriptsize (function)}}\\


 \texttt{PermutationDecode} performs permutation decoding when possible and returns original vector and
prints 'fail' when not possible. 

 This uses \texttt{AutomorphismGroup} in the binary case, and (the slower) \texttt{PermutationAutomorphismGroup} otherwise, to compute the permutation automorphism group $P$ of \mbox{\texttt{C}}. The algorithm runs through the elements $p$ of $P$ checking if the weight of $H(p\cdot v)$ is less than $(d-1)/2$. If it is then the vector $p\cdot v$ is used to decode $v$: assuming \mbox{\texttt{C}} is in standard form then $c=p^{-1}Em$ is the decoded word, where $m$ is the information digits part of $p\cdot v$. If no such $p$ exists then ``fail'' is returned. See, for example, section 10.2 of Huffman
and Pless \cite{HP03} for more details. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C0:=HammingCode(3,GF(2));
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  gap> G0:=GeneratorMat(C0);;
  gap> G := List(G0, ShallowCopy);;
  gap> PutStandardForm(G);
  ()
  gap> Display(G);
   1 . . . . 1 1
   . 1 . . 1 . 1
   . . 1 . 1 1 .
   . . . 1 1 1 1
  gap> H0:=CheckMat(C0);;
  gap> Display(H0);
   . . . 1 1 1 1
   . 1 1 . . 1 1
   1 . 1 . 1 . 1
  gap> c0:=Random(C0);
  [ 0 0 0 1 1 1 1 ]
  gap> v01:=c0[1]+Z(2)^2;;
  gap> v1:=List(c0, ShallowCopy);;
  gap> v1[1]:=v01;;
  gap> v1:=Codeword(v1);
  [ 1 0 0 1 1 1 1 ]
  gap> c1:=PermutationDecode(C0,v1);
  [ 0 0 0 1 1 1 1 ]
  gap> c1=c0;
  true
\end{Verbatim}
  }

 }

 
\chapter{\textcolor{Chapter }{Coding theory functions in the GAP kernel}}\logpage{[ 4, 0, 0 ]}
{
  \label{Coding theory functions in the GAP kernel} This chapter will recall from the GAP manual the GAP coding theory functions,
some of which are partially written in C. The main functions are \texttt{AClosestVectorCombinationsMatFFEVecFFE}, \texttt{AClosestVectorCombinationsMatFFEVecFFECoords}, \texttt{CosetLeadersMatFFE}, \texttt{DistancesDistributionMatFFEVecFFE}, \texttt{DistancesDistributionVecFFEsVecFFE}, \texttt{DistanceVecFFE}, and \texttt{WeightVecFFE}. These are declared in the GAP library file 'listcoef.gd' and implemented in
'listcoef.gi'. 

 
\section{\textcolor{Chapter }{ Distance functions }}\logpage{[ 4, 1, 0 ]}
{
  \label{Distance functions} 

\subsection{\textcolor{Chapter }{AClosestVectorCombinationsMatFFEVecFFE}}
\logpage{[ 4, 1, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AClosestVectorCombinationsMatFFEVecFFE( mat, F, vec, r, st )\index{AClosestVectorCombinationsMatFFEVecFFE@\texttt{AClosestVectorCombinationsMatFFEVecFFE}}
\label{AClosestVectorCombinationsMatFFEVecFFE}
}\hfill{\scriptsize (function)}}\\


 This command runs through the \mbox{\texttt{F}}-linear combinations of the vectors in the rows of the matrix \mbox{\texttt{mat}} that can be written as linear combinations of exactly \mbox{\texttt{r}} rows (that is without using zero as a coefficient) and returns a vector from
these that is closest to the vector \mbox{\texttt{vec}}. The length of the rows of \mbox{\texttt{mat}} and the length of \mbox{\texttt{vec}} must be equal, and all elements must lie in \mbox{\texttt{F}}. The rows of \mbox{\texttt{mat}} must be linearly independent. If it finds a vector of distance at most \mbox{\texttt{st}}, which must be a nonnegative integer, then it stops immediately and returns
this vector. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> F:=GF(3);;
  gap> x:= Indeterminate( F );; pol:= x^2+1;
  x_1^2+Z(3)^0
  gap> C := GeneratorPolCode(pol,8,F);
  a cyclic [8,6,1..2]1..2 code defined by generator polynomial over GF(3)
  gap> v:=Codeword("12101111");
  [ 1 2 1 0 1 1 1 1 ]
  gap> v:=VectorCodeword(v);
  [ Z(3)^0, Z(3), Z(3)^0, 0*Z(3), Z(3)^0, Z(3)^0, Z(3)^0, Z(3)^0 ]
  gap> G:=GeneratorMat(C);
  [ [ Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ],
    [ 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ],
    [ 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3) ],
    [ 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3) ],
    [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3) ],
    [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0 ] ]
  gap> AClosestVectorCombinationsMatFFEVecFFE(G,F,v,1,1);
  [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{AClosestVectorComb..MatFFEVecFFECoords}}
\logpage{[ 4, 1, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AClosestVectorComb..MatFFEVecFFECoords( mat, F, vec, r, st )\index{AClosestVectorComb..MatFFEVecFFECoords@\texttt{AClosestVectorComb..MatFFEVecFFECoords}}
\label{AClosestVectorComb..MatFFEVecFFECoords}
}\hfill{\scriptsize (function)}}\\


 \texttt{AClosestVectorCombinationsMatFFEVecFFECoords} returns a two element list containing (a) the same closest vector as in \texttt{AClosestVectorCombinationsMatFFEVecFFE}, and (b) a vector \mbox{\texttt{v}} with exactly \mbox{\texttt{r}} non-zero entries, such that $v*mat$ is the closest vector. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> F:=GF(3);;
  gap> x:= Indeterminate( F );; pol:= x^2+1;
  x_1^2+Z(3)^0
  gap> C := GeneratorPolCode(pol,8,F);
  a cyclic [8,6,1..2]1..2 code defined by generator polynomial over GF(3)
  gap> v:=Codeword("12101111"); v:=VectorCodeword(v);;
  [ 1 2 1 0 1 1 1 1 ]
  gap> G:=GeneratorMat(C);;
  gap> AClosestVectorCombinationsMatFFEVecFFECoords(G,F,v,1,1);
  [ [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0 ],
    [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0 ] ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DistancesDistributionMatFFEVecFFE}}
\logpage{[ 4, 1, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DistancesDistributionMatFFEVecFFE( vecs, vec )\index{DistancesDistributionMatFFEVecFFE@\texttt{DistancesDistributionMatFFEVecFFE}}
\label{DistancesDistributionMatFFEVecFFE}
}\hfill{\scriptsize (function)}}\\


 \texttt{DistancesDistributionMatFFEVecFFE} returns the distances distribution of the vector \mbox{\texttt{vec}} to the vectors in the list \mbox{\texttt{vecs}}. All vectors must have the same length, and all elements must lie in a common
field. The distances distribution is a list $d$ of length $Length(vec)+1$, such that the value $d[i]$ is the number of vectors in vecs that have distance $i+1$ to \mbox{\texttt{vec}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> v:=[ Z(3)^0, Z(3), Z(3)^0, 0*Z(3), Z(3)^0, Z(3)^0, Z(3)^0, Z(3)^0 ];;
  gap> vecs:=[ [ Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ],
  >   [ 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ],
  >   [ 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3) ],
  >   [ 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3) ],
  >   [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3) ],
  >   [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0 ] ];;
  gap> DistancesDistributionMatFFEVecFFE(vecs,GF(3),v);
  [ 0, 4, 6, 60, 109, 216, 192, 112, 30 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DistancesDistributionVecFFEsVecFFE}}
\logpage{[ 4, 1, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DistancesDistributionVecFFEsVecFFE( vecs, vec )\index{DistancesDistributionVecFFEsVecFFE@\texttt{DistancesDistributionVecFFEsVecFFE}}
\label{DistancesDistributionVecFFEsVecFFE}
}\hfill{\scriptsize (function)}}\\


 \texttt{DistancesDistributionVecFFEsVecFFE} returns the distances distribution of the vector \mbox{\texttt{vec}} to the vectors in the list \mbox{\texttt{vecs}}. All vectors must have the same length, and all elements must lie in a common
field. The distances distribution is a list $d$ of length $Length(vec)+1$, such that the value $d[i]$ is the number of vectors in \mbox{\texttt{vecs}} that have distance $i+1$ to \mbox{\texttt{vec}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> v:=[ Z(3)^0, Z(3), Z(3)^0, 0*Z(3), Z(3)^0, Z(3)^0, Z(3)^0, Z(3)^0 ];;
  gap> vecs:=[ [ Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ],
  >   [ 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ],
  >   [ 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3) ],
  >   [ 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3) ],
  >   [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3) ],
  >   [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0 ] ];;
  gap> DistancesDistributionVecFFEsVecFFE(vecs,v);
  [ 0, 0, 0, 0, 0, 4, 0, 1, 1 ]
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Other functions }}\logpage{[ 4, 2, 0 ]}
{
  \label{Other functions} 

\subsection{\textcolor{Chapter }{WeightVecFFE}}
\logpage{[ 4, 2, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{WeightVecFFE( vec )\index{WeightVecFFE@\texttt{WeightVecFFE}}
\label{WeightVecFFE}
}\hfill{\scriptsize (function)}}\\


 \texttt{WeightVecFFE} returns the weight of the finite field vector \mbox{\texttt{vec}}, i.e. the number of nonzero entries. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> v:=[ Z(3)^0, Z(3), Z(3)^0, 0*Z(3), Z(3)^0, Z(3)^0, Z(3)^0, Z(3)^0 ];;
  gap> WeightVecFFE(v);
  7
\end{Verbatim}
  \index{Hamming metric} 

\subsection{\textcolor{Chapter }{DistanceVecFFE}}
\logpage{[ 4, 2, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DistanceVecFFE( vec1, vec2 )\index{DistanceVecFFE@\texttt{DistanceVecFFE}}
\label{DistanceVecFFE}
}\hfill{\scriptsize (function)}}\\


 The \emph{Hamming metric} on $GF(q)^n$ is the function 
\[ dist((v_1,...,v_n),(w_1,...,w_n)) =|\{i\in [1..n]\ |\ v_i\not= w_i\}|. \]
 This is also called the (Hamming) distance between $v=(v_1,...,v_n)$ and $w=(w_1,...,w_n)$. \texttt{DistanceVecFFE} returns the distance between the two vectors \mbox{\texttt{vec1}} and \mbox{\texttt{vec2}}, which must have the same length and whose elements must lie in a common
field. The distance is the number of places where \mbox{\texttt{vec1}} and \mbox{\texttt{vec2}} differ. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> v1:=[ Z(3)^0, Z(3), Z(3)^0, 0*Z(3), Z(3)^0, Z(3)^0, Z(3)^0, Z(3)^0 ];;
  gap> v2:=[ Z(3), Z(3)^0, Z(3)^0, 0*Z(3), Z(3)^0, Z(3)^0, Z(3)^0, Z(3)^0 ];;
  gap> DistanceVecFFE(v1,v2);
  2
\end{Verbatim}
  }

 }

 
\chapter{\textcolor{Chapter }{Generating Codes}}\logpage{[ 5, 0, 0 ]}
{
  \label{Generating Codes} In this chapter we describe functions for generating codes. 

 Section \ref{Generating Unrestricted Codes} describes functions for generating unrestricted codes. 

 Section \ref{Generating Linear Codes} describes functions for generating linear codes. 

 Section \ref{Gabidulin Codes} describes functions for constructing certain covering codes, such as the
Gabidulin codes. 

 Section \ref{Golay Codes} describes functions for constructing the Golay codes. 

 Section \ref{Generating Cyclic Codes} describes functions for generating cyclic codes. 

 Section \ref{Evaluation Codes} describes functions for generating codes as the image of an evaluation map
applied to a space of functions. For example, generalized Reed-Solomon codes
and toric codes are described there. 

 
\section{\textcolor{Chapter }{ Generating Unrestricted Codes }}\logpage{[ 5, 1, 0 ]}
{
  \label{Generating Unrestricted Codes} In this section we start with functions that creating code from user defined
matrices or special matrices (see \texttt{ElementsCode} (\ref{ElementsCode}), \texttt{HadamardCode} (\ref{HadamardCode}), \texttt{ConferenceCode} (\ref{ConferenceCode}) and \texttt{MOLSCode} (\ref{MOLSCode})). These codes are unrestricted codes; they may later be discovered to be
linear or cyclic. 

 The next functions generate random codes (see \texttt{RandomCode} (\ref{RandomCode})) and the Nordstrom-Robinson code (see \texttt{NordstromRobinsonCode} (\ref{NordstromRobinsonCode})), respectively. 

 Finally, we describe two functions for generating Greedy codes. These are
codes that contructed by gathering codewords from a space (see \texttt{GreedyCode} (\ref{GreedyCode}) and \texttt{LexiCode} (\ref{LexiCode})). 

\subsection{\textcolor{Chapter }{ElementsCode}}
\logpage{[ 5, 1, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ElementsCode( L[, name,] F )\index{ElementsCode@\texttt{ElementsCode}}
\label{ElementsCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ElementsCode} creates an unrestricted code of the list of elements \mbox{\texttt{L}}, in the field \mbox{\texttt{F}}. \mbox{\texttt{L}} must be a list of vectors, strings, polynomials or codewords. \mbox{\texttt{name}} can contain a short description of the code. 

 If \mbox{\texttt{L}} contains a codeword more than once, it is removed from the list and a \textsf{GAP} set is returned. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> M := Z(3)^0 * [ [1, 0, 1, 1], [2, 2, 0, 0], [0, 1, 2, 2] ];;
  gap> C := ElementsCode( M, "example code", GF(3) );
  a (4,3,1..4)2 example code over GF(3)
  gap> MinimumDistance( C );
  4
  gap> AsSSortedList( C );
  [ [ 0 1 2 2 ], [ 1 0 1 1 ], [ 2 2 0 0 ] ]
\end{Verbatim}
  \index{code, Hadamard} 

\subsection{\textcolor{Chapter }{HadamardCode}}
\logpage{[ 5, 1, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{HadamardCode( H[, t] )\index{HadamardCode@\texttt{HadamardCode}}
\label{HadamardCode}
}\hfill{\scriptsize (function)}}\\


 The four forms this command can take are \texttt{HadamardCode(H,t)}, \texttt{HadamardCode(H)}, \texttt{HadamardCode(n,t)}, and \texttt{HadamardCode(n)}. 

 In the case when the arguments \mbox{\texttt{H}} and \mbox{\texttt{t}} are both given, \texttt{HadamardCode} returns a Hadamard code of the $t^{th}$ kind from the Hadamard matrix \mbox{\texttt{H}} In case only \mbox{\texttt{H}} is given, $t = 3$ is used. 

 By definition, a Hadamard matrix is a square matrix \mbox{\texttt{H}} with $H\cdot H^T = -n\cdot I_n$, where $n$ is the size of \mbox{\texttt{H}}. The entries of \mbox{\texttt{H}} are either 1 or -1. \index{Hadamard matrix} 

 The matrix \mbox{\texttt{H}} is first transformed into a binary matrix $A_n$ by replacing the $1$'s by $0$'s and the $-1$'s by $1$s). 

 The Hadamard matrix of the \emph{first kind} ($t=1$) is created by using the rows of $A_n$ as elements, after deleting the first column. This is a $(n-1, n, n/2)$ code. We use this code for creating the Hadamard code of the \emph{second kind} ($t=2$), by adding all the complements of the already existing codewords. This
results in a $(n-1, 2n, n/2 -1)$ code. The \emph{third kind} ($t=3$) is created by using the rows of $A_n$ (without cutting a column) and their complements as elements. This way, we
have an $(n, 2n, n/2)$-code. The returned code is generally an unrestricted code, but for $n = 2^r$, the code is linear. 

 The command \texttt{HadamardCode(n,t)} returns a Hadamard code with parameter \mbox{\texttt{n}} of the $t^{th}$ kind. For the command \texttt{HadamardCode(n)}, $t=3$ is used. 

 When called in these forms, \texttt{HadamardCode} first creates a Hadamard matrix (see \texttt{HadamardMat} (\ref{HadamardMat})), of size \mbox{\texttt{n}} and then follows the same procedure as described above. Therefore the same
restrictions with respect to \mbox{\texttt{n}} as for Hadamard matrices hold. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> H4 := [[1,1,1,1],[1,-1,1,-1],[1,1,-1,-1],[1,-1,-1,1]];;
  gap> HadamardCode( H4, 1 );
  a (3,4,2)1 Hadamard code of order 4 over GF(2)
  gap> HadamardCode( H4, 2 );
  a (3,8,1)0 Hadamard code of order 4 over GF(2)
  gap> HadamardCode( H4 );
  a (4,8,2)1 Hadamard code of order 4 over GF(2) 
  gap> H4 := [[1,1,1,1],[1,-1,1,-1],[1,1,-1,-1],[1,-1,-1,1]];;
  gap> C := HadamardCode( 4 );
  a (4,8,2)1 Hadamard code of order 4 over GF(2)
  gap> C = HadamardCode( H4 );
  true 
\end{Verbatim}
  \index{code, conference} 

\subsection{\textcolor{Chapter }{ConferenceCode}}
\logpage{[ 5, 1, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ConferenceCode( H )\index{ConferenceCode@\texttt{ConferenceCode}}
\label{ConferenceCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ConferenceCode} returns a code of length $n-1$ constructed from a symmetric 'conference matrix' \mbox{\texttt{H}}. A \emph{conference matrix} \mbox{\texttt{H}} is a symmetric matrix of order $n$, which satisfies $H\cdot H^T = ((n-1)\cdot I$, with $n \equiv 2 \pmod 4$. The rows of $\frac{1}{2}(H+I+J)$, $\frac{1}{2}(-H+I+J)$, plus the zero and all-ones vectors form the elements of a binary non-linear $(n-1, 2n, (n-2)/2)$ code. \index{conference matrix} 

 \textsf{GUAVA} constructs a symmetric conference matrix of order $n+1$ ($n\equiv 1 \pmod 4$) and uses the rows of that matrix, plus the zero and all-ones vectors, to
construct a binary non-linear $(n, 2(n+1), (n-1)/2)$-code. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> H6 := [[0,1,1,1,1,1],[1,0,1,-1,-1,1],[1,1,0,1,-1,-1],
  > [1,-1,1,0,1,-1],[1,-1,-1,1,0,1],[1,1,-1,-1,1,0]];;
  gap> C1 := ConferenceCode( H6 );
  a (5,12,2)1..4 conference code over GF(2)
  gap> IsLinearCode( C1 );
  false 
  gap> C2 := ConferenceCode( 5 );
  a (5,12,2)1..4 conference code over GF(2)
  gap> AsSSortedList( C2 );
  [ [ 0 0 0 0 0 ], [ 0 0 1 1 1 ], [ 0 1 0 1 1 ], [ 0 1 1 0 1 ], [ 0 1 1 1 0 ], 
    [ 1 0 0 1 1 ], [ 1 0 1 0 1 ], [ 1 0 1 1 0 ], [ 1 1 0 0 1 ], [ 1 1 0 1 0 ], 
    [ 1 1 1 0 0 ], [ 1 1 1 1 1 ] ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{MOLSCode}}
\logpage{[ 5, 1, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MOLSCode( [n,] q )\index{MOLSCode@\texttt{MOLSCode}}
\label{MOLSCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{MOLSCode} returns an $(n, q^2, n-1)$ code over $GF(q)$. The code is created from $n-2$ 'Mutually Orthogonal Latin Squares' (MOLS) of size $q \times q$. The default for \mbox{\texttt{n}} is $4$. \textsf{GUAVA} can construct a MOLS code for $n-2 \leq q$. Here \mbox{\texttt{q}} must be a prime power, $q > 2$. If there are no $n-2$ MOLS, an error is signalled. 

 Since each of the $n-2$ MOLS is a $q\times q$ matrix, we can create a code of size $q^2$ by listing in each code element the entries that are in the same position in
each of the MOLS. We precede each of these lists with the two coordinates that
specify this position, making the word length become $n$. 

 The MOLS codes are MDS codes (see \texttt{IsMDSCode} (\ref{IsMDSCode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := MOLSCode( 6, 5 );
  a (6,25,5)3..4 code generated by 4 MOLS of order 5 over GF(5)
  gap> mols := List( [1 .. WordLength(C1) - 2 ], function( nr )
  >       local ls, el;
  >       ls := NullMat( Size(LeftActingDomain(C1)), Size(LeftActingDomain(C1)) );
  >       for el in VectorCodeword( AsSSortedList( C1 ) ) do
  >          ls[IntFFE(el[1])+1][IntFFE(el[2])+1] := el[nr + 2];
  >       od;
  >       return ls;
  >    end );;
  gap> AreMOLS( mols );
  true
  gap> C2 := MOLSCode( 11 );
  a (4,121,3)2 code generated by 2 MOLS of order 11 over GF(11) 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{RandomCode}}
\logpage{[ 5, 1, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RandomCode( n, M, F )\index{RandomCode@\texttt{RandomCode}}
\label{RandomCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{RandomCode} returns a random unrestricted code of size \mbox{\texttt{M}} with word length \mbox{\texttt{n}} over \mbox{\texttt{F}}. \mbox{\texttt{M}} must be less than or equal to the number of elements in the space $GF(q)^n$. 

 The function \texttt{RandomLinearCode} returns a random linear code (see \texttt{RandomLinearCode} (\ref{RandomLinearCode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := RandomCode( 6, 10, GF(8) );
  a (6,10,1..6)4..6 random unrestricted code over GF(8)
  gap> MinimumDistance(C1);
  3
  gap> C2 := RandomCode( 6, 10, GF(8) );
  a (6,10,1..6)4..6 random unrestricted code over GF(8)
  gap> C1 = C2;
  false 
\end{Verbatim}
 \index{code, Nordstrom-Robinson} 

\subsection{\textcolor{Chapter }{NordstromRobinsonCode}}
\logpage{[ 5, 1, 6 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NordstromRobinsonCode(  )\index{NordstromRobinsonCode@\texttt{NordstromRobinsonCode}}
\label{NordstromRobinsonCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{NordstromRobinsonCode} returns a Nordstrom-Robinson code, the best code with word length $n=16$ and minimum distance $d=6$ over $GF(2)$. This is a non-linear $(16, 256, 6)$ code. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := NordstromRobinsonCode();
  a (16,256,6)4 Nordstrom-Robinson code over GF(2)
  gap> OptimalityCode( C );
  0 
\end{Verbatim}
 \index{code, greedy} 

\subsection{\textcolor{Chapter }{GreedyCode}}
\logpage{[ 5, 1, 7 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GreedyCode( L, d, F )\index{GreedyCode@\texttt{GreedyCode}}
\label{GreedyCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{GreedyCode} returns a Greedy code with design distance \mbox{\texttt{d}} over the finite field \mbox{\texttt{F}}. The code is constructed using the greedy algorithm on the list of vectors \mbox{\texttt{L}}. (The greedy algorithm checks each vector in \mbox{\texttt{L}} and adds it to the code if its distance to the current code is greater than or
equal to \mbox{\texttt{d}}. It is obvious that the resulting code has a minimum distance of at least \mbox{\texttt{d}}. 

 Greedy codes are often linear codes. 

 The function \texttt{LexiCode} creates a greedy code from a basis instead of an enumerated list (see \texttt{LexiCode} (\ref{LexiCode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := GreedyCode( Tuples( AsSSortedList( GF(2) ), 5 ), 3, GF(2) );
  a (5,4,3..5)2 Greedy code, user defined basis over GF(2)
  gap> C2 := GreedyCode( Permuted( Tuples( AsSSortedList( GF(2) ), 5 ),
  >                         (1,4) ), 3, GF(2) );
  a (5,4,3..5)2 Greedy code, user defined basis over GF(2)
  gap> C1 = C2;
  false 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{LexiCode}}
\logpage{[ 5, 1, 8 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LexiCode( n, d, F )\index{LexiCode@\texttt{LexiCode}}
\label{LexiCode}
}\hfill{\scriptsize (function)}}\\


 In this format, \texttt{Lexicode} returns a lexicode with word length \mbox{\texttt{n}}, design distance \mbox{\texttt{d}} over \mbox{\texttt{F}}. The code is constructed using the greedy algorithm on the lexicographically
ordered list of all vectors of length \mbox{\texttt{n}} over \mbox{\texttt{F}}. Every time a vector is found that has a distance to the current code of at
least \mbox{\texttt{d}}, it is added to the code. This results, obviously, in a code with minimum
distance greater than or equal to \mbox{\texttt{d}}. 

 Another syntax which one can use is \texttt{LexiCode( B, d, F )}. When called in this format, \texttt{LexiCode} uses the basis \mbox{\texttt{B}} instead of the standard basis. \mbox{\texttt{B}} is a matrix of vectors over \mbox{\texttt{F}}. The code is constructed using the greedy algorithm on the list of vectors
spanned by \mbox{\texttt{B}}, ordered lexicographically with respect to \mbox{\texttt{B}}. 

 Note that binary lexicodes are always linear. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := LexiCode( 4, 3, GF(5) );
  a (4,17,3..4)2..4 lexicode over GF(5) 
  gap> B := [ [Z(2)^0, 0*Z(2), 0*Z(2)], [Z(2)^0, Z(2)^0, 0*Z(2)] ];;
  gap> C := LexiCode( B, 2, GF(2) );
  a linear [3,1,2]1..2 lexicode over GF(2) 
\end{Verbatim}
 The function \texttt{GreedyCode} creates a greedy code that is not restricted to a lexicographical order (see \texttt{GreedyCode} (\ref{GreedyCode})). }

 
\section{\textcolor{Chapter }{ Generating Linear Codes }}\logpage{[ 5, 2, 0 ]}
{
  \label{Generating Linear Codes} In this section we describe functions for constructing linear codes. A linear
code always has a generator or check matrix. 

 The first two functions generate linear codes from the generator matrix (\texttt{GeneratorMatCode} (\ref{GeneratorMatCode})) or check matrix (\texttt{CheckMatCode} (\ref{CheckMatCode})). All linear codes can be constructed with these functions. 

 The next functions we describe generate some well-known codes, like Hamming
codes (\texttt{HammingCode} (\ref{HammingCode})), Reed-Muller codes (\texttt{ReedMullerCode} (\ref{ReedMullerCode})) and the extended Golay codes (\texttt{ExtendedBinaryGolayCode} (\ref{ExtendedBinaryGolayCode}) and \texttt{ExtendedTernaryGolayCode} (\ref{ExtendedTernaryGolayCode})). 

 A large and powerful family of codes are alternant codes. They are obtained by
a small modification of the parity check matrix of a BCH code (see \texttt{AlternantCode} (\ref{AlternantCode}), \texttt{GoppaCode} (\ref{GoppaCode}), \texttt{GeneralizedSrivastavaCode} (\ref{GeneralizedSrivastavaCode}) and \texttt{SrivastavaCode} (\ref{SrivastavaCode})). 

 Finally, we describe a function for generating random linear codes (see \texttt{RandomLinearCode} (\ref{RandomLinearCode})). 

 

\subsection{\textcolor{Chapter }{GeneratorMatCode}}
\logpage{[ 5, 2, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneratorMatCode( G[, name,] F )\index{GeneratorMatCode@\texttt{GeneratorMatCode}}
\label{GeneratorMatCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneratorMatCode} returns a linear code with generator matrix \mbox{\texttt{G}}. \mbox{\texttt{G}} must be a matrix over finite field \mbox{\texttt{F}}. \mbox{\texttt{name}} can contain a short description of the code. The generator matrix is the basis
of the elements of the code. The resulting code has word length $n$, dimension $k$ if \mbox{\texttt{G}} is a $k \times n$-matrix. If $GF(q)$ is the field of the code, the size of the code will be $q^k$. 

 If the generator matrix does not have full row rank, the linearly dependent
rows are removed. This is done by the \textsf{GAP} function \texttt{BaseMat} and results in an equal code. The generator matrix can be retrieved with the
function \texttt{GeneratorMat} (see \texttt{GeneratorMat} (\ref{GeneratorMat})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> G := Z(3)^0 * [[1,0,1,2,0],[0,1,2,1,1],[0,0,1,2,1]];;
  gap> C1 := GeneratorMatCode( G, GF(3) );
  a linear [5,3,1..2]1..2 code defined by generator matrix over GF(3)
  gap> C2 := GeneratorMatCode( IdentityMat( 5, GF(2) ), GF(2) );
  a linear [5,5,1]0 code defined by generator matrix over GF(2)
  gap> GeneratorMatCode( List( AsSSortedList( NordstromRobinsonCode() ),
  > x -> VectorCodeword( x ) ), GF( 2 ) );
  a linear [16,11,1..4]2 code defined by generator matrix over GF(2)
  # This is the smallest linear code that contains the N-R code 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CheckMatCode}}
\logpage{[ 5, 2, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CheckMatCode( H[, name,] F )\index{CheckMatCode@\texttt{CheckMatCode}}
\label{CheckMatCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{CheckMatCode} returns a linear code with check matrix \mbox{\texttt{H}}. \mbox{\texttt{H}} must be a matrix over Galois field \mbox{\texttt{F}}. \mbox{\texttt{[name.}} can contain a short description of the code. The parity check matrix is the
transposed of the nullmatrix of the generator matrix of the code. Therefore, $c\cdot H^T = 0$ where $c$ is an element of the code. If \mbox{\texttt{H}} is a $r\times n$-matrix, the code has word length $n$, redundancy $r$ and dimension $n-r$. 

 If the check matrix does not have full row rank, the linearly dependent rows
are removed. This is done by the \textsf{GAP} function \texttt{BaseMat}. and results in an equal code. The check matrix can be retrieved with the
function \texttt{CheckMat} (see \texttt{CheckMat} (\ref{CheckMat})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> G := Z(3)^0 * [[1,0,1,2,0],[0,1,2,1,1],[0,0,1,2,1]];;
  gap> C1 := CheckMatCode( G, GF(3) );
  a linear [5,2,1..2]2..3 code defined by check matrix over GF(3)
  gap> CheckMat(C1);
  [ [ Z(3)^0, 0*Z(3), Z(3)^0, Z(3), 0*Z(3) ],
    [ 0*Z(3), Z(3)^0, Z(3), Z(3)^0, Z(3)^0 ],
    [ 0*Z(3), 0*Z(3), Z(3)^0, Z(3), Z(3)^0 ] ]
  gap> C2 := CheckMatCode( IdentityMat( 5, GF(2) ), GF(2) );
  a cyclic [5,0,5]5 code defined by check matrix over GF(2)
\end{Verbatim}
  \index{code, Hamming} 

\subsection{\textcolor{Chapter }{HammingCode}}
\logpage{[ 5, 2, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{HammingCode( r, F )\index{HammingCode@\texttt{HammingCode}}
\label{HammingCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{HammingCode} returns a Hamming code with redundancy \mbox{\texttt{r}} over \mbox{\texttt{F}}. A Hamming code is a single-error-correcting code. The parity check matrix of
a Hamming code has all nonzero vectors of length \mbox{\texttt{r}} in its columns, except for a multiplication factor. The decoding algorithm of
the Hamming code (see \texttt{Decode} (\ref{Decode})) makes use of this property. 

 If $q$ is the size of its field \mbox{\texttt{F}}, the returned Hamming code is a linear $[(q^r-1)/(q-1), (q^r-1)/(q-1) - r, 3]$ code. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := HammingCode( 4, GF(2) );
  a linear [15,11,3]1 Hamming (4,2) code over GF(2)
  gap> C2 := HammingCode( 3, GF(9) );
  a linear [91,88,3]1 Hamming (3,9) code over GF(9) 
\end{Verbatim}
  \index{code, Reed-Muller} 

\subsection{\textcolor{Chapter }{ReedMullerCode}}
\logpage{[ 5, 2, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ReedMullerCode( r, k )\index{ReedMullerCode@\texttt{ReedMullerCode}}
\label{ReedMullerCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ReedMullerCode} returns a binary 'Reed-Muller code' \mbox{\texttt{R(r, k)}} with dimension \mbox{\texttt{k}} and order \mbox{\texttt{r}}. This is a code with length $2^k$ and minimum distance $2^{k-r}$ (see for example, section 1.10 in \cite{HP03}). By definition, the $r^{th}$ order binary Reed-Muller code of length $n=2^m$, for $0 \leq r \leq m$, is the set of all vectors $f$, where $f$ is a Boolean function which is a polynomial of degree at most $r$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> ReedMullerCode( 1, 3 );
  a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2) 
\end{Verbatim}
  See \texttt{GeneralizedReedMuller} (\ref{GeneralizedReedMuller}) for a more general construction. \index{code, alternant} 

\subsection{\textcolor{Chapter }{AlternantCode}}
\logpage{[ 5, 2, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AlternantCode( r, Y[, alpha,] F )\index{AlternantCode@\texttt{AlternantCode}}
\label{AlternantCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{AlternantCode} returns an 'alternant code', with parameters \mbox{\texttt{r}}, \mbox{\texttt{Y}} and \mbox{\texttt{alpha}} (optional). \mbox{\texttt{F}} denotes the (finite) base field. Here, \mbox{\texttt{r}} is the design redundancy of the code. \mbox{\texttt{Y}} and \mbox{\texttt{alpha}} are both vectors of length \mbox{\texttt{n}} from which the parity check matrix is constructed. The check matrix has the
form $H=([a_i^j y_i])$, where $0 \leq j\leq r-1$, $1 \leq i\leq n$, and where $[...]$ is as in \texttt{VerticalConversionFieldMat} (\ref{VerticalConversionFieldMat})). If no \mbox{\texttt{alpha}} is specified, the vector $[1, a, a^2, .., a^{n-1}]$ is used, where $a$ is a primitive element of a Galois field \mbox{\texttt{F}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> Y := [ 1, 1, 1, 1, 1, 1, 1];; a := PrimitiveUnityRoot( 2, 7 );;
  gap> alpha := List( [0..6], i -> a^i );;
  gap> C := AlternantCode( 2, Y, alpha, GF(8) );
  a linear [7,3,3..4]3..4 alternant code over GF(8) 
\end{Verbatim}
  \index{code, Goppa (classical)} 

\subsection{\textcolor{Chapter }{GoppaCode}}
\logpage{[ 5, 2, 6 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GoppaCode( G, L )\index{GoppaCode@\texttt{GoppaCode}}
\label{GoppaCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{GoppaCode} returns a Goppa code \mbox{\texttt{C}} from Goppa polynomial \mbox{\texttt{g}}, having coefficients in a Galois Field $GF(q)$. \mbox{\texttt{L}} must be a list of elements in $GF(q)$, that are not roots of \mbox{\texttt{g}}. The word length of the code is equal to the length of \mbox{\texttt{L}}. The parity check matrix has the form $H=([a_i^j / G(a_i)])_{0 \leq j \leq deg(g)-1,\ a_i \in L}$, where $a_i\in L$ and $[...]$ is as in \texttt{VerticalConversionFieldMat} (\ref{VerticalConversionFieldMat}), so $H$ has entries in $GF(q)$, $q=p^m$. It is known that $d(C)\geq deg(g)+1$, with a better bound in the binary case provided $g$ has no multiple roots. See Huffman and Pless \cite{HP03} section 13.2.2, and MacWilliams and Sloane \cite{MS83} section 12.3, for more details. 

 One can also call \texttt{GoppaCode} using the syntax \texttt{GoppaCode(g,n)}. When called with parameter \mbox{\texttt{n}}, \textsf{GUAVA} constructs a list $L$ of length \mbox{\texttt{n}}, such that no element of \mbox{\texttt{L}} is a root of \mbox{\texttt{g}}. 

 This is a special case of an alternant code. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> x:=Indeterminate(GF(8),"x");
  x
  gap> L:=Elements(GF(8));
  [ 0*Z(2), Z(2)^0, Z(2^3), Z(2^3)^2, Z(2^3)^3, Z(2^3)^4, Z(2^3)^5, Z(2^3)^6 ]
  gap> g:=x^2+x+1;
  x^2+x+Z(2)^0
  gap> C:=GoppaCode(g,L);
  a linear [8,2,5]3 Goppa code over GF(2)
  gap> xx := Indeterminate( GF(2), "xx" );; 
  gap> gg := xx^2 + xx + 1;; L := AsSSortedList( GF(8) );;
  gap> C1 := GoppaCode( gg, L );
  a linear [8,2,5]3 Goppa code over GF(2) 
  gap> y := Indeterminate( GF(2), "y" );; 
  gap> h := y^2 + y + 1;;
  gap> C2 := GoppaCode( h, 8 );
  a linear [8,2,5]3 Goppa code over GF(2) 
  gap> C1=C2;
  true
  gap> C=C1;
  true
\end{Verbatim}
  \index{code, Srivastava} 

\subsection{\textcolor{Chapter }{GeneralizedSrivastavaCode}}
\logpage{[ 5, 2, 7 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneralizedSrivastavaCode( a, w, z[, t,] F )\index{GeneralizedSrivastavaCode@\texttt{GeneralizedSrivastavaCode}}
\label{GeneralizedSrivastavaCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneralizedSrivastavaCode} returns a generalized Srivastava code with parameters \mbox{\texttt{a}}, \mbox{\texttt{w}}, \mbox{\texttt{z}}, \mbox{\texttt{t}}. $a =\{ a_1, ..., a_n\}$ and $w =\{ w_1, ..., w_s\}$ are lists of $n+s$ distinct elements of $F=GF(q^m)$, $z$ is a list of length $n$ of nonzero elements of $GF(q^m)$. The parameter \mbox{\texttt{t}} determines the designed distance: $d \geq st + 1$. The check matrix of this code is the form 
\[ H=([\frac{z_i}{(a_i - w_j)^k}]), \]
 $1\leq k\leq t$, where $[...]$ is as in \texttt{VerticalConversionFieldMat} (\ref{VerticalConversionFieldMat}). We use this definition of $H$ to define the code. The default for \mbox{\texttt{t}} is 1. The original Srivastava codes (see \texttt{SrivastavaCode} (\ref{SrivastavaCode})) are a special case $t=1$, $z_i=a_i^\mu$, for some $\mu$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> a := Filtered( AsSSortedList( GF(2^6) ), e -> e in GF(2^3) );;
  gap> w := [ Z(2^6) ];; z := List( [1..8], e -> 1 );;
  gap> C := GeneralizedSrivastavaCode( a, w, z, 1, GF(64) );
  a linear [8,2,2..5]3..4 generalized Srivastava code over GF(2) 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{SrivastavaCode}}
\logpage{[ 5, 2, 8 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SrivastavaCode( a, w[, mu,] F )\index{SrivastavaCode@\texttt{SrivastavaCode}}
\label{SrivastavaCode}
}\hfill{\scriptsize (function)}}\\


 $SrivastavaCode$ returns a Srivastava code with parameters \mbox{\texttt{a}}, \mbox{\texttt{w}} (and optionally \mbox{\texttt{mu}}). $a =\{ a_1, ..., a_n\}$ and $w =\{ w_1, ..., w_s\}$ are lists of $n+s$ distinct elements of $F=GF(q^m)$. The default for \mbox{\texttt{mu}} is 1. The Srivastava code is a generalized Srivastava code, in which $z_i = a_i^{mu}$ for some \mbox{\texttt{mu}} and $t=1$. 

 J. N. Srivastava introduced this code in 1967, though his work was not
published. See Helgert \cite{He72} for more details on the properties of this code. Related reference: G.
Roelofsen, \textsc{On Goppa and Generalized Srivastava Codes} PhD thesis, Dept. Math. and Comp. Sci., Eindhoven Univ. of Technology, the
Netherlands, 1982.  }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> a := AsSSortedList( GF(11) ){[2..8]};;
  gap> w := AsSSortedList( GF(11) ){[9..10]};;
  gap> C := SrivastavaCode( a, w, 2, GF(11) );
  a linear [7,5,3]2 Srivastava code over GF(11)
  gap> IsMDSCode( C );
  true    # Always true if F is a prime field 
\end{Verbatim}
  \index{code, Cordaro-Wagner} 

\subsection{\textcolor{Chapter }{CordaroWagnerCode}}
\logpage{[ 5, 2, 9 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CordaroWagnerCode( n )\index{CordaroWagnerCode@\texttt{CordaroWagnerCode}}
\label{CordaroWagnerCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{CordaroWagnerCode} returns a binary Cordaro-Wagner code. This is a code of length \mbox{\texttt{n}} and dimension $2$ having the best possible minimum distance $d$. This code is just a little bit less trivial than \texttt{RepetitionCode} (see \texttt{RepetitionCode} (\ref{RepetitionCode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := CordaroWagnerCode( 11 );
  a linear [11,2,7]5 Cordaro-Wagner code over GF(2)
  gap> AsSSortedList(C);                 
  [ [ 0 0 0 0 0 0 0 0 0 0 0 ], [ 0 0 0 0 1 1 1 1 1 1 1 ], 
    [ 1 1 1 1 0 0 0 1 1 1 1 ], [ 1 1 1 1 1 1 1 0 0 0 0 ] ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{RandomLinearCode}}
\logpage{[ 5, 2, 10 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RandomLinearCode( n, k, F )\index{RandomLinearCode@\texttt{RandomLinearCode}}
\label{RandomLinearCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{RandomLinearCode} returns a random linear code with word length \mbox{\texttt{n}}, dimension \mbox{\texttt{k}} over field \mbox{\texttt{F}}. The method used is to first construct a $k\times n$ matrix of the block form $(I,A)$, where $I$ is a $k\times k$ identity matrix and $A$ is a $k\times (n-k)$ matrix constructed using \texttt{Random(F)} repeatedly. Then the columns are permuted using a randomly selected element of \texttt{SymmetricGroup(n)}. 

 To create a random unrestricted code, use \texttt{RandomCode} (see \texttt{RandomCode} (\ref{RandomCode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := RandomLinearCode( 15, 4, GF(3) );
  a  [15,4,?] randomly generated code over GF(3)
  gap> Display(C);
  a linear [15,4,1..6]6..10 random linear code over GF(3)
\end{Verbatim}
  The method \textsf{GUAVA} chooses to output the result of a \texttt{RandomLinearCode} command is different than other codes. For example, the bounds on the minimum
distance is not displayed. Howeer, you can use the \texttt{Display} command to print this information. This new display method was added in
version 1.9 to speed up the command (if $n$ is about 80 and $k$ about 40, for example, the time it took to look up and/or calculate the bounds
on the minimum distance was too long). 

\subsection{\textcolor{Chapter }{OptimalityCode}}
\logpage{[ 5, 2, 11 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OptimalityCode( C )\index{OptimalityCode@\texttt{OptimalityCode}}
\label{OptimalityCode}
}\hfill{\scriptsize (function)}}\\


 In general this command is no longer accurate, since the tables have not been
updated since 1998. See the web site \href{http://www.win.tue.nl/~aeb/voorlincod.html}{\texttt{http://www.win.tue.nl/\~{}aeb/voorlincod.html}} for more recent data. 

 \texttt{OptimalityCode} returns the difference between the smallest known upper bound and the actual
size of the code. Note that the value of the function \texttt{UpperBound} is not always equal to the actual upper bound $A(n,d)$ thus the result may not be equal to $0$ even if the code is optimal! 

 \texttt{OptimalityLinearCode} is similar but applies only to linear codes. }

 

\subsection{\textcolor{Chapter }{BestKnownLinearCode}}
\logpage{[ 5, 2, 12 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BestKnownLinearCode( n, k, F )\index{BestKnownLinearCode@\texttt{BestKnownLinearCode}}
\label{BestKnownLinearCode}
}\hfill{\scriptsize (function)}}\\


 In general this command is no longer accurate, since the tables have not been
updated since 1998. See the web site \href{http://www.win.tue.nl/~aeb/voorlincod.html}{\texttt{http://www.win.tue.nl/\~{}aeb/voorlincod.html}} for more recent data. 

 \texttt{BestKnownLinearCode} returns the best known (as of 1998) linear code of length \mbox{\texttt{n}}, dimension \mbox{\texttt{k}} over field \mbox{\texttt{F}}. The function uses the tables described in section \texttt{BoundsMinimumDistance} (\ref{BoundsMinimumDistance}) to construct this code. 

 This command can also be called using the syntax \texttt{BestKnownLinearCode( rec )}, where \mbox{\texttt{rec}} must be a record containing the fields `lowerBound', `upperBound' and
`construction'. It uses the information in this field to construct a code.
This form is meant to be used together with the function \texttt{BoundsMinimumDistance} (see \texttt{BoundsMinimumDistance} (\ref{BoundsMinimumDistance})), if the bounds are already calculated. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := BestKnownLinearCode( 23, 12, GF(2) );
  a cyclic [23,12,7]3 binary Golay code over GF(2)
  gap> C1 = BinaryGolayCode();
  true
  gap> Display( BestKnownLinearCode( 8, 4, GF(4) ) );
  a linear [8,4,4]2..3 U U+V construction code of
  U: a cyclic [4,3,2]1 dual code of
     a cyclic [4,1,4]3 repetition code over GF(4)
  V: a cyclic [4,1,4]3 repetition code over GF(4)
  gap> C := BestKnownLinearCode(131,47);
  a linear [131,47,28..32]23..68 shortened code 
  gap> bounds := BoundsMinimumDistance( 20, 17, GF(4) );
  rec( n := 20, k := 17, q := 4, 
    references := rec( HM := [ "%T this reference is unknown, for more info", 
            "%T contact A.E. Brouwer (aeb@cwi.nl)" ] ), 
    construction := [ [Operation "ShortenedCode"], 
        [ [ [Operation "HammingCode"], [ 3, 4 ] ], [ 1 ] ] ], lowerBound := 3, 
    lowerBoundExplanation := [ "Lb(20,17)=3, by shortening of:", 
        "Lb(21,18)=3, reference: HM" ], upperBound := 3, 
    upperBoundExplanation := 
      [ "Ub(20,17)=3, otherwise construction B would contradict:", 
        "Ub(3,1)=3, repetition code" ] )
  gap> C := BestKnownLinearCode( bounds );
  a linear [20,17,3]2 shortened code
  gap> C = BestKnownLinearCode( 20, 17, GF(4) );
  true 
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Gabidulin Codes }}\logpage{[ 5, 3, 0 ]}
{
  \label{Gabidulin Codes}  These five binary, linear codes are derived from an article by Gabidulin,
Davydov and Tombak \cite{GDT91}. All these codes are defined by check matrices. Exact definitions can be
found in the article. The Gabidulin code, the enlarged Gabidulin code, the
Davydov code, the Tombak code, and the enlarged Tombak code, correspond with
theorem 1, 2, 3, 4, and 5, respectively in the article. 

 Like the Hamming codes, these codes have fixed minimum distance and covering
radius, but can be arbitrarily long. \index{code, Gabidulin} 

\subsection{\textcolor{Chapter }{GabidulinCode}}
\logpage{[ 5, 3, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GabidulinCode( m, w1, w2 )\index{GabidulinCode@\texttt{GabidulinCode}}
\label{GabidulinCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{GabidulinCode} yields a code of length $5$ . $2^{m-2}-1$, redundancy $2m-1$, minimum distance $3$ and covering radius $2$. \mbox{\texttt{w1}} and \mbox{\texttt{w2}} should be elements of $GF(2^{m-2})$. }

 

\subsection{\textcolor{Chapter }{EnlargedGabidulinCode}}
\logpage{[ 5, 3, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{EnlargedGabidulinCode( m, w1, w2, e )\index{EnlargedGabidulinCode@\texttt{EnlargedGabidulinCode}}
\label{EnlargedGabidulinCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{EnlargedGabidulinCode} yields a code of length $7$. $2^{m-2}-2$, redundancy $2m$, minimum distance $3$ and covering radius $2$. \mbox{\texttt{w1}} and \mbox{\texttt{w2}} are elements of $GF(2^{m-2})$. \mbox{\texttt{e}} is an element of $GF(2^m)$.  }

 \index{code, Davydov} 

\subsection{\textcolor{Chapter }{DavydovCode}}
\logpage{[ 5, 3, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DavydovCode( r, v, ei, ej )\index{DavydovCode@\texttt{DavydovCode}}
\label{DavydovCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{DavydovCode} yields a code of length $2^v + 2^{r-v} - 3$, redundancy \mbox{\texttt{r}}, minimum distance $4$ and covering radius $2$. \mbox{\texttt{v}} is an integer between $2$ and $r-2$. \mbox{\texttt{ei}} and \mbox{\texttt{ej}} are elements of $GF(2^v)$ and $GF(2^{r-v})$, respectively. }

 \index{code, Tombak} 

\subsection{\textcolor{Chapter }{TombakCode}}
\logpage{[ 5, 3, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TombakCode( m, e, beta, gamma, w1, w2 )\index{TombakCode@\texttt{TombakCode}}
\label{TombakCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{TombakCode} yields a code of length $15 \cdot 2^{m-3} - 3$, redundancy $2m$, minimum distance $4$ and covering radius $2$. \mbox{\texttt{e}} is an element of $GF(2^m)$. \mbox{\texttt{beta}} and \mbox{\texttt{gamma}} are elements of $GF(2^{m-1})$. \mbox{\texttt{w1}} and \mbox{\texttt{w2}} are elements of $GF(2^{m-3})$. }

 

\subsection{\textcolor{Chapter }{EnlargedTombakCode}}
\logpage{[ 5, 3, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{EnlargedTombakCode( m, e, beta, gamma, w1, w2, u )\index{EnlargedTombakCode@\texttt{EnlargedTombakCode}}
\label{EnlargedTombakCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{EnlargedTombakCode} yields a code of length $23 \cdot 2^{m-4} - 3$, redundancy $2m-1$, minimum distance $4$ and covering radius $2$. The parameters \mbox{\texttt{m}}, \mbox{\texttt{e}}, \mbox{\texttt{beta}}, \mbox{\texttt{gamma}}, \mbox{\texttt{w1}} and \mbox{\texttt{w2}} are defined as in \texttt{TombakCode}. \mbox{\texttt{u}} is an element of $GF(2^{m-1})$.  }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> GabidulinCode( 4, Z(4)^0, Z(4)^1 );
  a linear [19,12,3]2 Gabidulin code (m=4) over GF(2)
  gap> EnlargedGabidulinCode( 4, Z(4)^0, Z(4)^1, Z(16)^11 );
  a linear [26,18,3]2 enlarged Gabidulin code (m=4) over GF(2)
  gap> DavydovCode( 6, 3, Z(8)^1, Z(8)^5 );
  a linear [13,7,4]2 Davydov code (r=6, v=3) over GF(2)
  gap> TombakCode( 5, Z(32)^6, Z(16)^14, Z(16)^10, Z(4)^0, Z(4)^1 );
  a linear [57,47,4]2 Tombak code (m=5) over GF(2)
  gap> EnlargedTombakCode( 6, Z(32)^6, Z(16)^14, Z(16)^10,
  > Z(4)^0, Z(4)^0, Z(32)^23 );
  a linear [89,78,4]2 enlarged Tombak code (m=6) over GF(2)
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Golay Codes }}\logpage{[ 5, 4, 0 ]}
{
  \label{Golay Codes} `` The Golay code is probably the most important of all codes for both practical
and theoretical reasons. '' (\cite{MS83}, pg. 64). Though born in Switzerland, M. J. E. Golay (1902-1989) worked for
the US Army Labs for most of his career. For more information on his life, see
his obit in the June 1990 IEEE Information Society Newsletter. \index{code, Golay (binary)} 

\subsection{\textcolor{Chapter }{BinaryGolayCode}}
\logpage{[ 5, 4, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BinaryGolayCode(  )\index{BinaryGolayCode@\texttt{BinaryGolayCode}}
\label{BinaryGolayCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{BinaryGolayCode} returns a binary Golay code. This is a perfect $[23,12,7]$ code. It is also cyclic, and has generator polynomial $g(x)=1+x^2+x^4+x^5+x^6+x^{10}+x^{11}$. Extending it results in an extended Golay code (see \texttt{ExtendedBinaryGolayCode} (\ref{ExtendedBinaryGolayCode})). There's also the ternary Golay code (see \texttt{TernaryGolayCode} (\ref{TernaryGolayCode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=BinaryGolayCode();
  a cyclic [23,12,7]3 binary Golay code over GF(2)
  gap> ExtendedBinaryGolayCode() = ExtendedCode(BinaryGolayCode());
  true
  gap> IsPerfectCode(C);
  true 
  gap> IsCyclicCode(C);
  true
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{ExtendedBinaryGolayCode}}
\logpage{[ 5, 4, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ExtendedBinaryGolayCode(  )\index{ExtendedBinaryGolayCode@\texttt{ExtendedBinaryGolayCode}}
\label{ExtendedBinaryGolayCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ExtendedBinaryGolayCode} returns an extended binary Golay code. This is a $[24,12,8]$ code. Puncturing in the last position results in a perfect binary Golay code
(see \texttt{BinaryGolayCode} (\ref{BinaryGolayCode})). The code is self-dual. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := ExtendedBinaryGolayCode();
  a linear [24,12,8]4 extended binary Golay code over GF(2)
  gap> IsSelfDualCode(C);
  true
  gap> P := PuncturedCode(C);
  a linear [23,12,7]3 punctured code
  gap> P = BinaryGolayCode();
  true 
  gap> IsCyclicCode(C);
  false
  
\end{Verbatim}
  \index{code, Golay (ternary)} 

\subsection{\textcolor{Chapter }{TernaryGolayCode}}
\logpage{[ 5, 4, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TernaryGolayCode(  )\index{TernaryGolayCode@\texttt{TernaryGolayCode}}
\label{TernaryGolayCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{TernaryGolayCode} returns a ternary Golay code. This is a perfect $[11,6,5]$ code. It is also cyclic, and has generator polynomial $g(x)=2+x^2+2x^3+x^4+x^5$. Extending it results in an extended Golay code (see \texttt{ExtendedTernaryGolayCode} (\ref{ExtendedTernaryGolayCode})). There's also the binary Golay code (see \texttt{BinaryGolayCode} (\ref{BinaryGolayCode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=TernaryGolayCode();
  a cyclic [11,6,5]2 ternary Golay code over GF(3)
  gap> ExtendedTernaryGolayCode() = ExtendedCode(TernaryGolayCode());
  true 
  gap> IsCyclicCode(C);
  true
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{ExtendedTernaryGolayCode}}
\logpage{[ 5, 4, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ExtendedTernaryGolayCode(  )\index{ExtendedTernaryGolayCode@\texttt{ExtendedTernaryGolayCode}}
\label{ExtendedTernaryGolayCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ExtendedTernaryGolayCode} returns an extended ternary Golay code. This is a $[12,6,6]$ code. Puncturing this code results in a perfect ternary Golay code (see \texttt{TernaryGolayCode} (\ref{TernaryGolayCode})). The code is self-dual. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := ExtendedTernaryGolayCode();
  a linear [12,6,6]3 extended ternary Golay code over GF(3)
  gap> IsSelfDualCode(C);
  true
  gap> P := PuncturedCode(C);
  a linear [11,6,5]2 punctured code
  gap> P = TernaryGolayCode();
  true 
  gap> IsCyclicCode(C);
  false
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Generating Cyclic Codes }}\logpage{[ 5, 5, 0 ]}
{
  \label{Generating Cyclic Codes} The elements of a cyclic code $C$ are all multiples of a ('generator') polynomial $g(x)$, where calculations are carried out modulo $x^n-1$. Therefore, as polynomials in $x$, the elements always have degree less than $n$. A cyclic code is an ideal in the ring $F[x]/(x^n-1)$ of polynomials modulo $x^n - 1$. The unique monic polynomial of least degree that generates $C$ is called the \emph{generator polynomial} of $C$. It is a divisor of the polynomial $x^n-1$. \index{generator polynomial} \index{check polynomial} 

 The \emph{check polynomial} is the polynomial $h(x)$ with $g(x)h(x)=x^n-1$. Therefore it is also a divisor of $x^n-1$. The check polynomial has the property that 
\[ c(x)h(x) \equiv 0 \pmod{x^n-1}, \]
 for every codeword $c(x)\in C$. 

 The first two functions described below generate cyclic codes from a given
generator or check polynomial. All cyclic codes can be constructed using these
functions. 

 Two of the Golay codes already described are cyclic (see \texttt{BinaryGolayCode} (\ref{BinaryGolayCode}) and \texttt{TernaryGolayCode} (\ref{TernaryGolayCode})). For example, the \textsf{GUAVA} record for a binary Golay code contains the generator polynomial: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := BinaryGolayCode();
  a cyclic [23,12,7]3 binary Golay code over GF(2)
  gap> NamesOfComponents(C);
  [ "LeftActingDomain", "GeneratorsOfLeftOperatorAdditiveGroup", "WordLength",
    "GeneratorMat", "GeneratorPol", "Dimension", "Redundancy", "Size", "name",
    "lowerBoundMinimumDistance", "upperBoundMinimumDistance", "WeightDistribution",
    "boundsCoveringRadius", "MinimumWeightOfGenerators", 
    "UpperBoundOptimalMinimumDistance" ]
  gap> C!.GeneratorPol;
  x_1^11+x_1^10+x_1^6+x_1^5+x_1^4+x_1^2+Z(2)^0
\end{Verbatim}
  Then functions that generate cyclic codes from a prescribed set of roots of
the generator polynomial are described, including the BCH codes (see \texttt{RootsCode} (\ref{RootsCode}), \texttt{BCHCode} (\ref{BCHCode}), \texttt{ReedSolomonCode} (\ref{ReedSolomonCode}) and \texttt{QRCode} (\ref{QRCode})). 

 Finally we describe the trivial codes (see \texttt{WholeSpaceCode} (\ref{WholeSpaceCode}), \texttt{NullCode} (\ref{NullCode}), \texttt{RepetitionCode} (\ref{RepetitionCode})), and the command \texttt{CyclicCodes} which lists all cyclic codes (\texttt{CyclicCodes} (\ref{CyclicCodes})). 

\subsection{\textcolor{Chapter }{GeneratorPolCode}}
\logpage{[ 5, 5, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneratorPolCode( g, n[, name,] F )\index{GeneratorPolCode@\texttt{GeneratorPolCode}}
\label{GeneratorPolCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneratorPolCode} creates a cyclic code with a generator polynomial \mbox{\texttt{g}}, word length \mbox{\texttt{n}}, over \mbox{\texttt{F}}. \mbox{\texttt{name}} can contain a short description of the code. 

 If \mbox{\texttt{g}} is not a divisor of $x^n-1$, it cannot be a generator polynomial. In that case, a code is created with
generator polynomial $gcd( g, x^n-1 )$, i.e. the greatest common divisor of \mbox{\texttt{g}} and $x^n-1$. This is a valid generator polynomial that generates the ideal $(g)$. See \texttt{Generating Cyclic Codes} (\ref{Generating Cyclic Codes}). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> x:= Indeterminate( GF(2) );; P:= x^2+1;
  Z(2)^0+x^2
  gap> C1 := GeneratorPolCode(P, 7, GF(2));
  a cyclic [7,6,1..2]1 code defined by generator polynomial over GF(2)
  gap> GeneratorPol( C1 );
  Z(2)^0+x
  gap> C2 := GeneratorPolCode( x+1, 7, GF(2)); 
  a cyclic [7,6,1..2]1 code defined by generator polynomial over GF(2)
  gap> GeneratorPol( C2 );
  Z(2)^0+x
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CheckPolCode}}
\logpage{[ 5, 5, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CheckPolCode( h, n[, name,] F )\index{CheckPolCode@\texttt{CheckPolCode}}
\label{CheckPolCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{CheckPolCode} creates a cyclic code with a check polynomial \mbox{\texttt{h}}, word length \mbox{\texttt{n}}, over \mbox{\texttt{F}}. \mbox{\texttt{name}} can contain a short description of the code (as a string). 

 If \mbox{\texttt{h}} is not a divisor of $x^n-1$, it cannot be a check polynomial. In that case, a code is created with check
polynomial $gcd( h, x^n-1 )$, i.e. the greatest common divisor of \mbox{\texttt{h}} and $x^n-1$. This is a valid check polynomial that yields the same elements as the ideal $(h)$. See \ref{Generating Cyclic Codes}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>  x:= Indeterminate( GF(3) );; P:= x^2+2;
  -Z(3)^0+x_1^2
  gap> H := CheckPolCode(P, 7, GF(3));
  a cyclic [7,1,7]4 code defined by check polynomial over GF(3)
  gap> CheckPol(H);
  -Z(3)^0+x_1
  gap> Gcd(P, X(GF(3))^7-1);
  -Z(3)^0+x_1
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{RootsCode}}
\logpage{[ 5, 5, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RootsCode( n, list )\index{RootsCode@\texttt{RootsCode}}
\label{RootsCode}
}\hfill{\scriptsize (function)}}\\


 This is the generalization of the BCH, Reed-Solomon and quadratic residue
codes (see \texttt{BCHCode} (\ref{BCHCode}), \texttt{ReedSolomonCode} (\ref{ReedSolomonCode}) and \texttt{QRCode} (\ref{QRCode})). The user can give a length of the code \mbox{\texttt{n}} and a prescribed set of zeros. The argument \mbox{\texttt{list}} must be a valid list of primitive $n^{th}$ roots of unity in a splitting field $GF(q^m)$. The resulting code will be over the field $GF(q)$. The function will return the largest possible cyclic code for which the list \mbox{\texttt{list}} is a subset of the roots of the code. From this list, \textsf{GUAVA} calculates the entire set of roots. 

 This command can also be called with the syntax \texttt{RootsCode( n, list, q )}. In this second form, the second argument is a list of integers, ranging from $0$ to $n-1$. The resulting code will be over a field $GF(q)$. \textsf{GUAVA} calculates a primitive $n^{th}$ root of unity, $\alpha$, in the extension field of $GF(q)$. It uses the set of the powers of $\alpha$ in the list as a prescribed set of zeros. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> a := PrimitiveUnityRoot( 3, 14 );
  Z(3^6)^52
  gap> C1 := RootsCode( 14, [ a^0, a, a^3 ] );
  a cyclic [14,7,3..6]3..7 code defined by roots over GF(3)
  gap> MinimumDistance( C1 );
  4
  gap> b := PrimitiveUnityRoot( 2, 15 );
  Z(2^4)
  gap> C2 := RootsCode( 15, [ b, b^2, b^3, b^4 ] );
  a cyclic [15,7,5]3..5 code defined by roots over GF(2)
  gap> C2 = BCHCode( 15, 5, GF(2) );
  true 
  
\end{Verbatim}
  \index{code, Bose-Chaudhuri-Hockenghem} 

\subsection{\textcolor{Chapter }{BCHCode}}
\logpage{[ 5, 5, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BCHCode( n[, b,] delta, F )\index{BCHCode@\texttt{BCHCode}}
\label{BCHCode}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{BCHCode} returns a 'Bose-Chaudhuri-Hockenghem code' (or \emph{BCH code} for short). This is the largest possible cyclic code of length \mbox{\texttt{n}} over field \mbox{\texttt{F}}, whose generator polynomial has zeros 
\[ a^{b},a^{b+1}, ..., a^{b+delta-2}, \]
 where $a$ is a primitive $n^{th}$ root of unity in the splitting field $GF(q^m)$, \mbox{\texttt{b}} is an integer $0\leq b\leq n-delta+1$ and $m$ is the multiplicative order of $q$ modulo \mbox{\texttt{n}}. (The integers $\{b,...,b+delta-2\}$ typically lie in the range $\{1,...,n-1\}$.) Default value for \mbox{\texttt{b}} is $1$, though the algorithm allows $b=0$. The length \mbox{\texttt{n}} of the code and the size $q$ of the field must be relatively prime. The generator polynomial is equal to
the least common multiple of the minimal polynomials of 
\[ a^{b}, a^{b+1}, ..., a^{b+delta-2}. \]
 The set of zeroes of the generator polynomial is equal to the union of the
sets 
\[ \{a^x\ |\ x \in C_k\}, \]
 where $C_k$ is the $k^{th}$ cyclotomic coset of $q$ modulo $n$ and $b\leq k\leq b+delta-2$ (see \texttt{CyclotomicCosets} (\ref{CyclotomicCosets})). 

 Special cases are $b=1$ (resulting codes are called 'narrow-sense' BCH codes), and $n=q^m-1$ (known as 'primitive' BCH codes). \textsf{GUAVA} calculates the largest value of $d$ for which the BCH code with designed distance $d$ coincides with the BCH code with designed distance \mbox{\texttt{delta}}. This distance $d$ is called the \emph{Bose distance} of the code. The true minimum distance of the code is greater than or equal to
the Bose distance. \index{Bose distance} 

 Printed are the designed distance (to be precise, the Bose distance) $d$, and the starting power $b$. 

 The Sugiyama decoding algorithm has been implemented for this code (see \texttt{Decode} (\ref{Decode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := BCHCode( 15, 3, 5, GF(2) );
  a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
  gap> DesignedDistance( C1 );
  7
  gap> C2 := BCHCode( 23, 2, GF(2) );
  a cyclic [23,12,5..7]3 BCH code, delta=5, b=1 over GF(2)
  gap> DesignedDistance( C2 );       
  5
  gap> MinimumDistance(C2);
  7 
\end{Verbatim}
  See \texttt{RootsCode} (\ref{RootsCode}) for a more general construction. \index{code, Reed-Solomon} 

\subsection{\textcolor{Chapter }{ReedSolomonCode}}
\logpage{[ 5, 5, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ReedSolomonCode( n, d )\index{ReedSolomonCode@\texttt{ReedSolomonCode}}
\label{ReedSolomonCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ReedSolomonCode} returns a 'Reed-Solomon code' of length \mbox{\texttt{n}}, designed distance \mbox{\texttt{d}}. This code is a primitive narrow-sense BCH code over the field $GF(q)$, where $q=n+1$. The dimension of an RS code is $n-d+1$. According to the Singleton bound (see \texttt{UpperBoundSingleton} (\ref{UpperBoundSingleton})) the dimension cannot be greater than this, so the true minimum distance of
an RS code is equal to \mbox{\texttt{d}} and the code is maximum distance separable (see \texttt{IsMDSCode} (\ref{IsMDSCode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := ReedSolomonCode( 3, 2 );
  a cyclic [3,2,2]1 Reed-Solomon code over GF(4)
  gap> IsCyclicCode(C1);
  true
  gap> C2 := ReedSolomonCode( 4, 3 );
  a cyclic [4,2,3]2 Reed-Solomon code over GF(5)
  gap> RootsOfCode( C2 );
  [ Z(5), Z(5)^2 ]
  gap> IsMDSCode(C2);
  true 
\end{Verbatim}
  See \texttt{GeneralizedReedSolomonCode} (\ref{GeneralizedReedSolomonCode}) for a more general construction. 

\subsection{\textcolor{Chapter }{QRCode}}
\logpage{[ 5, 5, 6 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{QRCode( n, F )\index{QRCode@\texttt{QRCode}}
\label{QRCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{QRCode} returns a quadratic residue code. If \mbox{\texttt{F}} is a field $GF(q)$, then $q$ must be a quadratic residue modulo \mbox{\texttt{n}}. That is, an $x$ exists with $x^2 \equiv q \pmod n$. Both \mbox{\texttt{n}} and $q$ must be primes. Its generator polynomial is the product of the polynomials $x-a^i$. $a$ is a primitive $n^{th}$ root of unity, and $i$ is an integer in the set of quadratic residues modulo \mbox{\texttt{n}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := QRCode( 7, GF(2) );
  a cyclic [7,4,3]1 quadratic residue code over GF(2)
  gap> IsEquivalent( C1, HammingCode( 3, GF(2) ) );
  true
  gap> IsCyclicCode(C1);
  true
  gap> IsCyclicCode(HammingCode( 3, GF(2) ));
  false
  gap> C2 := QRCode( 11, GF(3) );
  a cyclic [11,6,4..5]2 quadratic residue code over GF(3)
  gap> C2 = TernaryGolayCode();
  true 
\end{Verbatim}
  \index{code, Fire} 

\subsection{\textcolor{Chapter }{FireCode}}
\logpage{[ 5, 5, 7 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{FireCode( g, b )\index{FireCode@\texttt{FireCode}}
\label{FireCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{FireCode} constructs a (binary) Fire code. \mbox{\texttt{g}} is a primitive polynomial of degree $m$, and a factor of $x^r-1$. \mbox{\texttt{b}} an integer $0 \leq b \leq m$ not divisible by $r$, that determines the burst length of a single error burst that can be
corrected. The argument \mbox{\texttt{g}} can be a polynomial with base ring $GF(2)$, or a list of coefficients in $GF(2)$. The generator polynomial of the code is defined as the product of \mbox{\texttt{g}} and $x^{2b-1}+1$. 

 Here is the general definition of 'Fire code', named after P. Fire, who
introduced these codes in 1959 in order to correct burst errors. First, a
definition. If $F=GF(q)$ and $f\in F[x]$ then we say $f$ has \emph{order} $e$ if $f(x)|(x^e-1)$. \index{order of polynomial} A \emph{Fire code} is a cyclic code over $F$ with generator polynomial $g(x)= (x^{2t-1}-1)p(x)$, where $p(x)$ does not divide $x^{2t-1}-1$ and satisfies $deg(p(x))\geq t$. The length of such a code is the order of $g(x)$.  Non-binary Fire codes have not been implemented. }

 . 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> x:= Indeterminate( GF(2) );; G:= x^3+x^2+1;
  Z(2)^0+x^2+x^3
  gap> Factors( G );
  [ Z(2)^0+x^2+x^3 ]
  gap> C := FireCode( G, 3 );
  a cyclic [35,27,1..4]2..6 3 burst error correcting fire code over GF(2)
  gap> MinimumDistance( C );
  4     # Still it can correct bursts of length 3 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{WholeSpaceCode}}
\logpage{[ 5, 5, 8 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{WholeSpaceCode( n, F )\index{WholeSpaceCode@\texttt{WholeSpaceCode}}
\label{WholeSpaceCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{WholeSpaceCode} returns the cyclic whole space code of length \mbox{\texttt{n}} over \mbox{\texttt{F}}. This code consists of all polynomials of degree less than \mbox{\texttt{n}} and coefficients in \mbox{\texttt{F}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := WholeSpaceCode( 5, GF(3) );
  a cyclic [5,5,1]0 whole space code over GF(3)
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{NullCode}}
\logpage{[ 5, 5, 9 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NullCode( n, F )\index{NullCode@\texttt{NullCode}}
\label{NullCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{NullCode} returns the zero-dimensional nullcode with length \mbox{\texttt{n}} over \mbox{\texttt{F}}. This code has only one word: the all zero word. It is cyclic though! }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := NullCode( 5, GF(3) );
  a cyclic [5,0,5]5 nullcode over GF(3)
  gap> AsSSortedList( C );
  [ [ 0 0 0 0 0 ] ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{RepetitionCode}}
\logpage{[ 5, 5, 10 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RepetitionCode( n, F )\index{RepetitionCode@\texttt{RepetitionCode}}
\label{RepetitionCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{RepetitionCode} returns the cyclic repetition code of length \mbox{\texttt{n}} over \mbox{\texttt{F}}. The code has as many elements as \mbox{\texttt{F}}, because each codeword consists of a repetition of one of these elements. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := RepetitionCode( 3, GF(5) );
  a cyclic [3,1,3]2 repetition code over GF(5)
  gap> AsSSortedList( C );
  [ [ 0 0 0 ], [ 1 1 1 ], [ 2 2 2 ], [ 4 4 4 ], [ 3 3 3 ] ]
  gap> IsPerfectCode( C );
  false
  gap> IsMDSCode( C );
  true 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CyclicCodes}}
\logpage{[ 5, 5, 11 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CyclicCodes( n, F )\index{CyclicCodes@\texttt{CyclicCodes}}
\label{CyclicCodes}
}\hfill{\scriptsize (function)}}\\


 \texttt{CyclicCodes} returns a list of all cyclic codes of length \mbox{\texttt{n}} over \mbox{\texttt{F}}. It constructs all possible generator polynomials from the factors of $x^n-1$. Each combination of these factors yields a generator polynomial after
multiplication. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> CyclicCodes(3,GF(3));
  [ a cyclic [3,3,1]0 enumerated code over GF(3), 
  a cyclic [3,2,1..2]1 enumerated code over GF(3), 
  a cyclic [3,1,3]2 enumerated code over GF(3), 
  a cyclic [3,0,3]3 enumerated code over GF(3) ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{NrCyclicCodes}}
\logpage{[ 5, 5, 12 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NrCyclicCodes( n, F )\index{NrCyclicCodes@\texttt{NrCyclicCodes}}
\label{NrCyclicCodes}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{NrCyclicCodes} calculates the number of cyclic codes of length \mbox{\texttt{n}} over field \mbox{\texttt{F}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> NrCyclicCodes( 23, GF(2) );
  8
  gap> codelist := CyclicCodes( 23, GF(2) );
  [ a cyclic [23,23,1]0 enumerated code over GF(2), 
    a cyclic [23,22,1..2]1 enumerated code over GF(2), 
    a cyclic [23,11,1..8]4..7 enumerated code over GF(2), 
    a cyclic [23,0,23]23 enumerated code over GF(2), 
    a cyclic [23,11,1..8]4..7 enumerated code over GF(2), 
    a cyclic [23,12,1..7]3 enumerated code over GF(2), 
    a cyclic [23,1,23]11 enumerated code over GF(2), 
    a cyclic [23,12,1..7]3 enumerated code over GF(2) ]
  gap> BinaryGolayCode() in codelist;
  true
  gap> RepetitionCode( 23, GF(2) ) in codelist;
  true
  gap> CordaroWagnerCode( 23 ) in codelist;
  false    # This code is not cyclic 
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Evaluation Codes }}\logpage{[ 5, 6, 0 ]}
{
  \label{Evaluation Codes} \index{code, evaluation} 

\subsection{\textcolor{Chapter }{EvaluationCode}}
\logpage{[ 5, 6, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{EvaluationCode( P, L, R )\index{EvaluationCode@\texttt{EvaluationCode}}
\label{EvaluationCode}
}\hfill{\scriptsize (function)}}\\


 Input: \mbox{\texttt{F}} is a finite field, \mbox{\texttt{L}} is a list of rational functions in $R=F[x_1,...,x_r]$, \mbox{\texttt{P}} is a list of $n$ points in $F^r$ at which all of the functions in \mbox{\texttt{L}} are defined. \\
 Output: The 'evaluation code' $C$, which is the image of the evalation map 
\[ Eval_P:span(L)\rightarrow F^n, \]
 given by $f\longmapsto (f(p_1),...,f(p_n))$, where $P=\{p_1,...,p_n\}$ and $f \in L$. The generator matrix of $C$ is $G=(f_i(p_j))_{f_i\in L,p_j\in P}$. 

 This command returns a "record" object \texttt{C} with several extra components (type \texttt{NamesOfComponents(C)} to see them all): \texttt{C!.points} (namely \mbox{\texttt{P}}), \texttt{C!.basis} (namely \mbox{\texttt{L}}), and \texttt{C!.ring} (namely \mbox{\texttt{R}}). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> F:=GF(11);
  GF(11)
  gap> R := PolynomialRing(F,["x","y"]);
  PolynomialRing(..., [ x, y ])
  gap> indets := IndeterminatesOfPolynomialRing(R);;
  gap> x:=indets[1];; y:=indets[2];;
  gap> L:=[x^2*y,x*y,x^5,x^4,x^3,x^2,x,x^0];;
  gap> Pts:=[ [ Z(11)^9, Z(11) ], [ Z(11)^8, Z(11) ], [ Z(11)^7, 0*Z(11) ],
     [ Z(11)^6, 0*Z(11) ], [ Z(11)^5, 0*Z(11) ], [ Z(11)^4, 0*Z(11) ],
     [ Z(11)^3, Z(11) ], [ Z(11)^2, 0*Z(11) ], [ Z(11), 0*Z(11) ], [ Z(11)^0, 0*Z(11) ],
     [ 0*Z(11), Z(11) ] ];;
  gap> C:=EvaluationCode(Pts,L,R);
  a linear [11,8,1..3]2..3  evaluation code over GF(11)
  gap> MinimumDistance(C);
  3
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{GeneralizedReedSolomonCode}}
\logpage{[ 5, 6, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneralizedReedSolomonCode( P, k, R )\index{GeneralizedReedSolomonCode@\texttt{GeneralizedReedSolomonCode}}
\label{GeneralizedReedSolomonCode}
}\hfill{\scriptsize (function)}}\\


 Input: R=F[x], where \mbox{\texttt{F}} is a finite field, \mbox{\texttt{k}} is a positive integer, \mbox{\texttt{P}} is a list of $n$ points in $F$. \\
 Output: The $C$ which is the image of the evaluation map 
\[ Eval_P:F[x]_k\rightarrow F^n, \]
 given by $f\longmapsto (f(p_1),...,f(p_n))$, where $P=\{p_1,...,p_n\}\subset F$ and $f$ ranges over the space $F[x]_k$ of all polynomials of degree less than $k$. 

 This command returns a "record" object \texttt{C} with several extra components (type \texttt{NamesOfComponents(C)} to see them all): \texttt{C!.points} (namely \mbox{\texttt{P}}), \texttt{C!.degree} (namely \mbox{\texttt{k}}), and \texttt{C!.ring} (namely \mbox{\texttt{R}}). 

 This code can be decoded using \texttt{Decodeword}, which applies the special decoder method (the interpolation method), or
using \texttt{GeneralizedReedSolomonDecoderGao} which applies an algorithm of S. Gao (see \texttt{GeneralizedReedSolomonDecoderGao} (\ref{GeneralizedReedSolomonDecoderGao})). This code has a special decoder record which implements the interpolation
algorithm described in section 5.2 of Justesen and Hoholdt \cite{JH04}. See \texttt{Decode} (\ref{Decode}) and \texttt{Decodeword} (\ref{Decodeword}) for more details. 

 The weighted version has implemented with the option \texttt{GeneralizedReedSolomonCode(P,k,R,wts)}, where $wts = [v_1, ..., v_n]$ is a sequence of $n$ non-zero elements from the base field $F$ of \mbox{\texttt{R}}. See also the generalized Reed--Solomon code $GRS_k(P, V)$ described in \cite{MS83}, p.303. 

 \emph{Work in progress}: The list-decoding algorithm of Sudan-Guraswami (described in section 12.1 of \cite{JH04}) should be implemented. See \texttt{GeneralizedReedSolomonListDecoder} (\ref{GeneralizedReedSolomonListDecoder}). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> R:=PolynomialRing(GF(11),["t"]);
  GF(11)[t]
  gap> P:=List([1,3,4,5,7],i->Z(11)^i);
  [ Z(11), Z(11)^3, Z(11)^4, Z(11)^5, Z(11)^7 ]
  gap> C:=GeneralizedReedSolomonCode(P,3,R);
  a linear [5,3,1..3]2  generalized Reed-Solomon code over GF(11)
  gap> MinimumDistance(C);
  3
  gap> V:=[Z(11)^0,Z(11)^0,Z(11)^0,Z(11)^0,Z(11)];
  [ Z(11)^0, Z(11)^0, Z(11)^0, Z(11)^0, Z(11) ]
  gap> C:=GeneralizedReedSolomonCode(P,3,R,V);
  a linear [5,3,1..3]2  weighted generalized Reed-Solomon code over GF(11)
  gap> MinimumDistance(C);
  3
\end{Verbatim}
  See \texttt{EvaluationCode} (\ref{EvaluationCode}) for a more general construction. 

\subsection{\textcolor{Chapter }{GeneralizedReedMullerCode}}
\logpage{[ 5, 6, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneralizedReedMullerCode( Pts, r, F )\index{GeneralizedReedMullerCode@\texttt{GeneralizedReedMullerCode}}
\label{GeneralizedReedMullerCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneralizedReedMullerCode} returns a 'Reed-Muller code' $C$ with length $|Pts|$ and order $r$. One considers (a) a basis of monomials for the vector space over $F=GF(q)$ of all polynomials in $F[x_1,...,x_d]$ of degree at most $r$, and (b) a set $Pts$ of points in $F^d$. The generator matrix of the associated \emph{Reed-Muller code} $C$ is $G=(f(p))_{f\in B,p \in Pts}$. This code $C$ is constructed using the command \texttt{GeneralizedReedMullerCode(Pts,r,F)}. When $Pts$ is the set of all $q^d$ points in $F^d$ then the command \texttt{GeneralizedReedMuller(d,r,F)} yields the code. When $Pts$ is the set of all $(q-1)^d$ points with no coordinate equal to $0$ then this is can be constructed using the \texttt{ToricCode} command (as a special case). 

 This command returns a "record" object \texttt{C} with several extra components (type \texttt{NamesOfComponents(C)} to see them all): \texttt{C!.points} (namely \mbox{\texttt{Pts}}) and \texttt{C!.degree} (namely \mbox{\texttt{r}}). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> Pts:=ToricPoints(2,GF(5));
  [ [ Z(5)^0, Z(5)^0 ], [ Z(5)^0, Z(5) ], [ Z(5)^0, Z(5)^2 ], [ Z(5)^0, Z(5)^3 ],
    [ Z(5), Z(5)^0 ], [ Z(5), Z(5) ], [ Z(5), Z(5)^2 ], [ Z(5), Z(5)^3 ],
    [ Z(5)^2, Z(5)^0 ], [ Z(5)^2, Z(5) ], [ Z(5)^2, Z(5)^2 ], [ Z(5)^2, Z(5)^3 ],
    [ Z(5)^3, Z(5)^0 ], [ Z(5)^3, Z(5) ], [ Z(5)^3, Z(5)^2 ], [ Z(5)^3, Z(5)^3 ] ]
  gap> C:=GeneralizedReedMullerCode(Pts,2,GF(5));
  a linear [16,6,1..11]6..10  generalized Reed-Muller code over GF(5)
\end{Verbatim}
 See \texttt{EvaluationCode} (\ref{EvaluationCode}) for a more general construction. 

\subsection{\textcolor{Chapter }{AffinePointsOnCurve}}
\logpage{[ 5, 6, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AffinePointsOnCurve( f, R, E )\index{AffinePointsOnCurve@\texttt{AffinePointsOnCurve}}
\label{AffinePointsOnCurve}
}\hfill{\scriptsize (function)}}\\


 \texttt{AffinePointsOnCurve(f,R,E)} returns the points $(x,y) \in E^2$ satisying $f(x,y)=0$, where \mbox{\texttt{f}} is an element of $R=F[x,y]$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> F:=GF(11);;
  gap> R := PolynomialRing(F,["x","y"]);
  PolynomialRing(..., [ x, y ])
  gap> indets := IndeterminatesOfPolynomialRing(R);;
  gap> x:=indets[1];; y:=indets[2];;
  gap> P:=AffinePointsOnCurve(y^2-x^11+x,R,F);
  [ [ Z(11)^9, 0*Z(11) ], [ Z(11)^8, 0*Z(11) ], [ Z(11)^7, 0*Z(11) ], 
    [ Z(11)^6, 0*Z(11) ], [ Z(11)^5, 0*Z(11) ], [ Z(11)^4, 0*Z(11) ], 
    [ Z(11)^3, 0*Z(11) ], [ Z(11)^2, 0*Z(11) ], [ Z(11), 0*Z(11) ], 
    [ Z(11)^0, 0*Z(11) ], [ 0*Z(11), 0*Z(11) ] ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{OnePointAGCode}}
\logpage{[ 5, 6, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OnePointAGCode( f, P, m, R )\index{OnePointAGCode@\texttt{OnePointAGCode}}
\label{OnePointAGCode}
}\hfill{\scriptsize (function)}}\\


 Input: \mbox{\texttt{f}} is a polynomial in R=F[x,y], where \mbox{\texttt{F}} is a finite field, \mbox{\texttt{m}} is a positive integer (the multiplicity of the `point at infinity' $\infty$ on the curve $f(x,y)=0$), \mbox{\texttt{P}} is a list of $n$ points on the curve over $F$. \\
 Output: The $C$ which is the image of the evaluation map 
\[ Eval_P:L(m \cdot \infty)\rightarrow F^n, \]
 given by $f\longmapsto (f(p_1),...,f(p_n))$, where $p_i \in P$. Here $L(m \cdot \infty)$ denotes the Riemann-Roch space of the divisor $m \cdot \infty$ on the curve. This has a basis consisting of monomials $x^iy^j$, where $(i,j)$ range over a polygon depending on $m$ and $f(x,y)$. For more details on the Riemann-Roch space of the divisor $m \cdot \infty$ see Proposition III.10.5 in Stichtenoth \cite{St93}. 

 This command returns a "record" object \texttt{C} with several extra components (type \texttt{NamesOfComponents(C)} to see them all): \texttt{C!.points} (namely \mbox{\texttt{P}}), \texttt{C!.multiplicity} (namely \mbox{\texttt{m}}), \texttt{C!.curve} (namely \mbox{\texttt{f}}) and \texttt{C!.ring} (namely \mbox{\texttt{R}}). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> F:=GF(11);
  GF(11)
  gap> R := PolynomialRing(F,["x","y"]);
  PolynomialRing(..., [ x, y ])
  gap> indets := IndeterminatesOfPolynomialRing(R);
  [ x, y ]
  gap> x:=indets[1]; y:=indets[2];
  x
  y
  gap> P:=AffinePointsOnCurve(y^2-x^11+x,R,F);;
  gap> C:=OnePointAGCode(y^2-x^11+x,P,15,R);
  a linear [11,8,1..0]2..3  one-point AG code over GF(11)
  gap> MinimumDistance(C);
  4
  gap> Pts:=List([1,2,4,6,7,8,9,10,11],i->P[i]);;
  gap> C:=OnePointAGCode(y^2-x^11+x,PT,10,R);
  a linear [9,6,1..4]2..3 one-point AG code over GF(11)
  gap> MinimumDistance(C);
  4
\end{Verbatim}
  See \texttt{EvaluationCode} (\ref{EvaluationCode}) for a more general construction. 

\subsection{\textcolor{Chapter }{ToricPoints}}
\logpage{[ 5, 6, 6 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ToricPoints( n, F )\index{ToricPoints@\texttt{ToricPoints}}
\label{ToricPoints}
}\hfill{\scriptsize (function)}}\\


 \texttt{ToricPoints(n,F)} returns the points in $(F^{\times})^n$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> ToricPoints(2,GF(5));
  [ [ Z(5)^0, Z(5)^0 ], [ Z(5)^0, Z(5) ], [ Z(5)^0, Z(5)^2 ], 
    [ Z(5)^0, Z(5)^3 ], [ Z(5), Z(5)^0 ], [ Z(5), Z(5) ], [ Z(5), Z(5)^2 ], 
    [ Z(5), Z(5)^3 ], [ Z(5)^2, Z(5)^0 ], [ Z(5)^2, Z(5) ], [ Z(5)^2, Z(5)^2 ], 
    [ Z(5)^2, Z(5)^3 ], [ Z(5)^3, Z(5)^0 ], [ Z(5)^3, Z(5) ], 
    [ Z(5)^3, Z(5)^2 ], [ Z(5)^3, Z(5)^3 ] ]
\end{Verbatim}
  \index{code, toric} 

\subsection{\textcolor{Chapter }{ToricCode}}
\logpage{[ 5, 6, 7 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ToricCode( L, F )\index{ToricCode@\texttt{ToricCode}}
\label{ToricCode}
}\hfill{\scriptsize (function)}}\\


 This function returns the toric codes as in D. Joyner \cite{Jo04} (see also J. P. Hansen \cite{Han99}). This is a truncated (generalized) Reed-Muller code. Here \mbox{\texttt{L}} is a list of integral vectors and \mbox{\texttt{F}} is the finite field. The size of \mbox{\texttt{F}} must be different from $2$. 

 This command returns a record object \texttt{C} with an extra component (type \texttt{NamesOfComponents(C)} to see them all): \texttt{C!.exponents} (namely \mbox{\texttt{L}}). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=ToricCode([[1,0],[3,4]],GF(3));
  a linear [4,1,4]2 toric code over GF(3)
  gap> Display(GeneratorMat(C));
   1 1 2 2
  gap> Elements(C);
  [ [ 0 0 0 0 ], [ 1 1 2 2 ], [ 2 2 1 1 ] ]
\end{Verbatim}
  See \texttt{EvaluationCode} (\ref{EvaluationCode}) for a more general construction. }

 }

 
\chapter{\textcolor{Chapter }{Manipulating Codes}}\logpage{[ 6, 0, 0 ]}
{
  \label{Manipulating Codes} In this chapter we describe several functions \textsf{GUAVA} uses to manipulate codes. Some of the best codes are obtained by starting with
for example a BCH code, and manipulating it. 

 In some cases, it is faster to perform calculations with a manipulated code
than to use the original code. For example, if the dimension of the code is
larger than half the word length, it is generally faster to compute the weight
distribution by first calculating the weight distribution of the dual code
than by directly calculating the weight distribution of the original code. The
size of the dual code is smaller in these cases. 

 Because \textsf{GUAVA} keeps all information in a code record, in some cases the information can be
preserved after manipulations. Therefore, computations do not always have to
start from scratch. 

 In Section \ref{Functions that Generate a New Code from a Given Code}, we describe functions that take a code with certain parameters, modify it in
some way and return a different code (see \texttt{ExtendedCode} (\ref{ExtendedCode}), \texttt{PuncturedCode} (\ref{PuncturedCode}), \texttt{EvenWeightSubcode} (\ref{EvenWeightSubcode}), \texttt{PermutedCode} (\ref{PermutedCode}), \texttt{ExpurgatedCode} (\ref{ExpurgatedCode}), \texttt{AugmentedCode} (\ref{AugmentedCode}), \texttt{RemovedElementsCode} (\ref{RemovedElementsCode}), \texttt{AddedElementsCode} (\ref{AddedElementsCode}), \texttt{ShortenedCode} (\ref{ShortenedCode}), \texttt{LengthenedCode} (\ref{LengthenedCode}), \texttt{ResidueCode} (\ref{ResidueCode}), \texttt{ConstructionBCode} (\ref{ConstructionBCode}), \texttt{DualCode} (\ref{DualCode}), \texttt{ConversionFieldCode} (\ref{ConversionFieldCode}), \texttt{ConstantWeightSubcode} (\ref{ConstantWeightSubcode}), \texttt{StandardFormCode} (\ref{StandardFormCode}) and \texttt{CosetCode} (\ref{CosetCode})). In Section \ref{Functions that Generate a New Code from Two Given Codes}, we describe functions that generate a new code out of two codes (see \texttt{DirectSumCode} (\ref{DirectSumCode}), \texttt{UUVCode} (\ref{UUVCode}), \texttt{DirectProductCode} (\ref{DirectProductCode}), \texttt{IntersectionCode} (\ref{IntersectionCode}) and \texttt{UnionCode} (\ref{UnionCode})). 
\section{\textcolor{Chapter }{ Functions that Generate a New Code from a Given Code }}\logpage{[ 6, 1, 0 ]}
{
  \label{Functions that Generate a New Code from a Given Code} \index{Parity check} 

\subsection{\textcolor{Chapter }{ExtendedCode}}
\logpage{[ 6, 1, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ExtendedCode( C[, i] )\index{ExtendedCode@\texttt{ExtendedCode}}
\label{ExtendedCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ExtendedCode} extends the code \mbox{\texttt{C}} \mbox{\texttt{i}} times and returns the result. \mbox{\texttt{i}} is equal to $1$ by default. Extending is done by adding a parity check bit after the last
coordinate. The coordinates of all codewords now add up to zero. In the binary
case, each codeword has even weight. 

 The word length increases by \mbox{\texttt{i}}. The size of the code remains the same. In the binary case, the minimum
distance increases by one if it was odd. In other cases, that is not always
true. 

 A cyclic code in general is no longer cyclic after extending. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := HammingCode( 3, GF(2) );
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  gap> C2 := ExtendedCode( C1 );
  a linear [8,4,4]2 extended code
  gap> IsEquivalent( C2, ReedMullerCode( 1, 3 ) );
  true
  gap> List( AsSSortedList( C2 ), WeightCodeword );
  [ 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8 ]
  gap> C3 := EvenWeightSubcode( C1 );
  a linear [7,3,4]2..3 even weight subcode 
\end{Verbatim}
  To undo extending, call \texttt{PuncturedCode} (see \texttt{PuncturedCode} (\ref{PuncturedCode})). The function \texttt{EvenWeightSubcode} (see \texttt{EvenWeightSubcode} (\ref{EvenWeightSubcode})) also returns a related code with only even weights, but without changing its
word length. 

\subsection{\textcolor{Chapter }{PuncturedCode}}
\logpage{[ 6, 1, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PuncturedCode( C )\index{PuncturedCode@\texttt{PuncturedCode}}
\label{PuncturedCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{PuncturedCode} punctures \mbox{\texttt{C}} in the last column, and returns the result. Puncturing is done simply by
cutting off the last column from each codeword. This means the word length
decreases by one. The minimum distance in general also decrease by one. 

 This command can also be called with the syntax \texttt{PuncturedCode( C, L )}. In this case, \texttt{PuncturedCode} punctures \mbox{\texttt{C}} in the columns specified by \mbox{\texttt{L}}, a list of integers. All columns specified by \mbox{\texttt{L}} are omitted from each codeword. If $l$ is the length of \mbox{\texttt{L}} (so the number of removed columns), the word length decreases by $l$. The minimum distance can also decrease by $l$ or less. 

 Puncturing a cyclic code in general results in a non-cyclic code. If the code
is punctured in all the columns where a word of minimal weight is unequal to
zero, the dimension of the resulting code decreases. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := BCHCode( 15, 5, GF(2) );
  a cyclic [15,7,5]3..5 BCH code, delta=5, b=1 over GF(2)
  gap> C2 := PuncturedCode( C1 );
  a linear [14,7,4]3..5 punctured code
  gap> ExtendedCode( C2 ) = C1;
  false
  gap> PuncturedCode( C1, [1,2,3,4,5,6,7] );
  a linear [8,7,1]1 punctured code
  gap> PuncturedCode( WholeSpaceCode( 4, GF(5) ) );
  a linear [3,3,1]0 punctured code  # The dimension decreased from 4 to 3 
\end{Verbatim}
  \texttt{ExtendedCode} extends the code again (see \texttt{ExtendedCode} (\ref{ExtendedCode})), although in general this does not result in the old code. 

\subsection{\textcolor{Chapter }{EvenWeightSubcode}}
\logpage{[ 6, 1, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{EvenWeightSubcode( C )\index{EvenWeightSubcode@\texttt{EvenWeightSubcode}}
\label{EvenWeightSubcode}
}\hfill{\scriptsize (function)}}\\


 \texttt{EvenWeightSubcode} returns the even weight subcode of \mbox{\texttt{C}}, consisting of all codewords of \mbox{\texttt{C}} with even weight. If \mbox{\texttt{C}} is a linear code and contains words of odd weight, the resulting code has a
dimension of one less. The minimum distance always increases with one if it
was odd. If \mbox{\texttt{C}} is a binary cyclic code, and $g(x)$ is its generator polynomial, the even weight subcode either has generator
polynomial $g(x)$ (if $g(x)$ is divisible by $x-1$) or $g(x)\cdot (x-1)$ (if no factor $x-1$ was present in $g(x)$). So the even weight subcode is again cyclic. 

 Of course, if all codewords of \mbox{\texttt{C}} are already of even weight, the returned code is equal to \mbox{\texttt{C}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := EvenWeightSubcode( BCHCode( 8, 4, GF(3) ) );
  an (8,33,4..8)3..8 even weight subcode
  gap> List( AsSSortedList( C1 ), WeightCodeword );
  [ 0, 4, 4, 4, 4, 4, 4, 6, 4, 4, 4, 4, 6, 4, 4, 6, 4, 4, 8, 6, 4, 6, 8, 4, 4, 
    4, 6, 4, 6, 8, 4, 6, 8 ]
  gap> EvenWeightSubcode( ReedMullerCode( 1, 3 ) );
  a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2) 
\end{Verbatim}
  \texttt{ExtendedCode} also returns a related code of only even weights, but without reducing its
dimension (see \texttt{ExtendedCode} (\ref{ExtendedCode})). 

\subsection{\textcolor{Chapter }{PermutedCode}}
\logpage{[ 6, 1, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PermutedCode( C, L )\index{PermutedCode@\texttt{PermutedCode}}
\label{PermutedCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{PermutedCode} returns \mbox{\texttt{C}} after column permutations. \mbox{\texttt{L}} (in \textsf{GAP} disjoint cycle notation) is the permutation to be executed on the columns of \mbox{\texttt{C}}. If \mbox{\texttt{C}} is cyclic, the result in general is no longer cyclic. If a permutation results
in the same code as \mbox{\texttt{C}}, this permutation belongs to the automorphism group of \mbox{\texttt{C}} (see \texttt{AutomorphismGroup} (\ref{AutomorphismGroup})). In any case, the returned code is equivalent to \mbox{\texttt{C}} (see \texttt{IsEquivalent} (\ref{IsEquivalent})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := PuncturedCode( ReedMullerCode( 1, 4 ) );
  a linear [15,5,7]5 punctured code
  gap> C2 := BCHCode( 15, 7, GF(2) );
  a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
  gap> C2 = C1;
  false
  gap> p := CodeIsomorphism( C1, C2 );
  ( 2, 4,14, 9,13, 7,11,10, 6, 8,12, 5)
  gap> C3 := PermutedCode( C1, p );
  a linear [15,5,7]5 permuted code
  gap> C2 = C3;
  true 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{ExpurgatedCode}}
\logpage{[ 6, 1, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ExpurgatedCode( C, L )\index{ExpurgatedCode@\texttt{ExpurgatedCode}}
\label{ExpurgatedCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ExpurgatedCode} expurgates the code \mbox{\texttt{C}}> by throwing away codewords in list \mbox{\texttt{L}}. \mbox{\texttt{C}} must be a linear code. \mbox{\texttt{L}} must be a list of codeword input. The generator matrix of the new code no
longer is a basis for the codewords specified by \mbox{\texttt{L}}. Since the returned code is still linear, it is very likely that, besides the
words of \mbox{\texttt{L}}, more codewords of \mbox{\texttt{C}} are no longer in the new code. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := HammingCode( 4 );; WeightDistribution( C1 );
  [ 1, 0, 0, 35, 105, 168, 280, 435, 435, 280, 168, 105, 35, 0, 0, 1 ]
  gap> L := Filtered( AsSSortedList(C1), i -> WeightCodeword(i) = 3 );;
  gap> C2 := ExpurgatedCode( C1, L );
  a linear [15,4,3..4]5..11 code, expurgated with 7 word(s)
  gap> WeightDistribution( C2 );
  [ 1, 0, 0, 0, 14, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 ] 
\end{Verbatim}
  This function does not work on non-linear codes. For removing words from a
non-linear code, use \texttt{RemovedElementsCode} (see \texttt{RemovedElementsCode} (\ref{RemovedElementsCode})). For expurgating a code of all words of odd weight, use `EvenWeightSubcode'
(see \texttt{EvenWeightSubcode} (\ref{EvenWeightSubcode})). 

\subsection{\textcolor{Chapter }{AugmentedCode}}
\logpage{[ 6, 1, 6 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AugmentedCode( C, L )\index{AugmentedCode@\texttt{AugmentedCode}}
\label{AugmentedCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{AugmentedCode} returns \mbox{\texttt{C}} after augmenting. \mbox{\texttt{C}} must be a linear code, \mbox{\texttt{L}} must be a list of codeword inputs. The generator matrix of the new code is a
basis for the codewords specified by \mbox{\texttt{L}} as well as the words that were already in code \mbox{\texttt{C}}. Note that the new code in general will consist of more words than only the
codewords of \mbox{\texttt{C}} and the words \mbox{\texttt{L}}. The returned code is also a linear code. 

 This command can also be called with the syntax \texttt{AugmentedCode(C)}. When called without a list of codewords, \texttt{AugmentedCode} returns \mbox{\texttt{C}} after adding the all-ones vector to the generator matrix. \mbox{\texttt{C}} must be a linear code. If the all-ones vector was already in the code, nothing
happens and a copy of the argument is returned. If \mbox{\texttt{C}} is a binary code which does not contain the all-ones vector, the complement of
all codewords is added. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C31 := ReedMullerCode( 1, 3 );
  a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
  gap> C32 := AugmentedCode(C31,["00000011","00000101","00010001"]);
  a linear [8,7,1..2]1 code, augmented with 3 word(s)
  gap> C32 = ReedMullerCode( 2, 3 );
  true 
  gap> C1 := CordaroWagnerCode(6);
  a linear [6,2,4]2..3 Cordaro-Wagner code over GF(2)
  gap> Codeword( [0,0,1,1,1,1] ) in C1;
  true
  gap> C2 := AugmentedCode( C1 );
  a linear [6,3,1..2]2..3 code, augmented with 1 word(s)
  gap> Codeword( [1,1,0,0,0,0] ) in C2;
  true
\end{Verbatim}
  The function \texttt{AddedElementsCode} adds elements to the codewords instead of adding them to the basis (see \texttt{AddedElementsCode} (\ref{AddedElementsCode})). 

\subsection{\textcolor{Chapter }{RemovedElementsCode}}
\logpage{[ 6, 1, 7 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RemovedElementsCode( C, L )\index{RemovedElementsCode@\texttt{RemovedElementsCode}}
\label{RemovedElementsCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{RemovedElementsCode} returns code \mbox{\texttt{C}} after removing a list of codewords \mbox{\texttt{L}} from its elements. \mbox{\texttt{L}} must be a list of codeword input. The result is an unrestricted code. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := HammingCode( 4 );; WeightDistribution( C1 );
  [ 1, 0, 0, 35, 105, 168, 280, 435, 435, 280, 168, 105, 35, 0, 0, 1 ]
  gap> L := Filtered( AsSSortedList(C1), i -> WeightCodeword(i) = 3 );;
  gap> C2 := RemovedElementsCode( C1, L );
  a (15,2013,3..15)2..15 code with 35 word(s) removed
  gap> WeightDistribution( C2 );
  [ 1, 0, 0, 0, 105, 168, 280, 435, 435, 280, 168, 105, 35, 0, 0, 1 ]
  gap> MinimumDistance( C2 );
  3        # C2 is not linear, so the minimum weight does not have to
           # be equal to the minimum distance 
\end{Verbatim}
  Adding elements to a code is done by the function \texttt{AddedElementsCode} (see \texttt{AddedElementsCode} (\ref{AddedElementsCode})). To remove codewords from the base of a linear code, use \texttt{ExpurgatedCode} (see \texttt{ExpurgatedCode} (\ref{ExpurgatedCode})). 

\subsection{\textcolor{Chapter }{AddedElementsCode}}
\logpage{[ 6, 1, 8 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AddedElementsCode( C, L )\index{AddedElementsCode@\texttt{AddedElementsCode}}
\label{AddedElementsCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{AddedElementsCode} returns code \mbox{\texttt{C}} after adding a list of codewords \mbox{\texttt{L}} to its elements. \mbox{\texttt{L}} must be a list of codeword input. The result is an unrestricted code. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := NullCode( 6, GF(2) );
  a cyclic [6,0,6]6 nullcode over GF(2)
  gap> C2 := AddedElementsCode( C1, [ "111111" ] );
  a (6,2,1..6)3 code with 1 word(s) added
  gap> IsCyclicCode( C2 );
  true
  gap> C3 := AddedElementsCode( C2, [ "101010", "010101" ] );
  a (6,4,1..6)2 code with 2 word(s) added
  gap> IsCyclicCode( C3 );
  true 
\end{Verbatim}
 To remove elements from a code, use \texttt{RemovedElementsCode} (see \texttt{RemovedElementsCode} (\ref{RemovedElementsCode})). To add elements to the base of a linear code, use \texttt{AugmentedCode} (see \texttt{AugmentedCode} (\ref{AugmentedCode})). 

\subsection{\textcolor{Chapter }{ShortenedCode}}
\logpage{[ 6, 1, 9 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ShortenedCode( C[, L] )\index{ShortenedCode@\texttt{ShortenedCode}}
\label{ShortenedCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ShortenedCode( C )} returns the code \mbox{\texttt{C}} shortened by taking a cross section. If \mbox{\texttt{C}} is a linear code, this is done by removing all codewords that start with a
non-zero entry, after which the first column is cut off. If \mbox{\texttt{C}} was a $[n,k,d]$ code, the shortened code generally is a $[n-1,k-1,d]$ code. It is possible that the dimension remains the same; it is also possible
that the minimum distance increases. 

 If \mbox{\texttt{C}} is a non-linear code, \texttt{ShortenedCode} first checks which finite field element occurs most often in the first column
of the codewords. The codewords not starting with this element are removed
from the code, after which the first column is cut off. The resulting
shortened code has at least the same minimum distance as \mbox{\texttt{C}}. 

 This command can also be called using the syntax \texttt{ShortenedCode(C,L)}. When called in this format, \texttt{ShortenedCode} repeats the shortening process on each of the columns specified by \mbox{\texttt{L}}. \mbox{\texttt{L}} therefore is a list of integers. The column numbers in \mbox{\texttt{L}} are the numbers as they are before the shortening process. If \mbox{\texttt{L}} has $l$ entries, the returned code has a word length of $l$ positions shorter than \mbox{\texttt{C}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := HammingCode( 4 );
  a linear [15,11,3]1 Hamming (4,2) code over GF(2)
  gap> C2 := ShortenedCode( C1 );
  a linear [14,10,3]2 shortened code
  gap> C3 := ElementsCode( ["1000", "1101", "0011" ], GF(2) );
  a (4,3,1..4)2 user defined unrestricted code over GF(2)
  gap> MinimumDistance( C3 );
  2
  gap> C4 := ShortenedCode( C3 );
  a (3,2,2..3)1..2 shortened code
  gap> AsSSortedList( C4 );
  [ [ 0 0 0 ], [ 1 0 1 ] ]
  gap> C5 := HammingCode( 5, GF(2) );
  a linear [31,26,3]1 Hamming (5,2) code over GF(2)
  gap> C6 := ShortenedCode( C5, [ 1, 2, 3 ] );
  a linear [28,23,3]2 shortened code
  gap> OptimalityLinearCode( C6 );
  0
\end{Verbatim}
  The function \texttt{LengthenedCode} lengthens the code again (only for linear codes), see \texttt{LengthenedCode} (\ref{LengthenedCode}). In general, this is not exactly the inverse function. 

\subsection{\textcolor{Chapter }{LengthenedCode}}
\logpage{[ 6, 1, 10 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LengthenedCode( C[, i] )\index{LengthenedCode@\texttt{LengthenedCode}}
\label{LengthenedCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{LengthenedCode( C )} returns the code \mbox{\texttt{C}} lengthened. \mbox{\texttt{C}} must be a linear code. First, the all-ones vector is added to the generator
matrix (see \texttt{AugmentedCode} (\ref{AugmentedCode})). If the all-ones vector was already a codeword, nothing happens to the code.
Then, the code is extended \mbox{\texttt{i}} times (see \texttt{ExtendedCode} (\ref{ExtendedCode})). \mbox{\texttt{i}} is equal to $1$ by default. If \mbox{\texttt{C}} was an $[n,k]$ code, the new code generally is a $[n+i,k+1]$ code. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := CordaroWagnerCode( 5 );
  a linear [5,2,3]2 Cordaro-Wagner code over GF(2)
  gap> C2 := LengthenedCode( C1 );
  a linear [6,3,2]2..3 code, lengthened with 1 column(s) 
\end{Verbatim}
 \texttt{ShortenedCode}' shortens the code, see \texttt{ShortenedCode} (\ref{ShortenedCode}). In general, this is not exactly the inverse function. 

\subsection{\textcolor{Chapter }{ResidueCode}}
\logpage{[ 6, 1, 11 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ResidueCode( C[, c] )\index{ResidueCode@\texttt{ResidueCode}}
\label{ResidueCode}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{ResidueCode} takes a codeword \mbox{\texttt{c}} of \mbox{\texttt{C}} (if \mbox{\texttt{c}} is omitted, a codeword of minimal weight is used). It removes this word and
all its linear combinations from the code and then punctures the code in the
coordinates where \mbox{\texttt{c}} is unequal to zero. The resulting code is an $[n-w, k-1, d-\lfloor w*(q-1)/q \rfloor ]$ code. \mbox{\texttt{C}} must be a linear code and \mbox{\texttt{c}} must be non-zero. If \mbox{\texttt{c}} is not in \mbox{\texttt{}} then no change is made to \mbox{\texttt{C}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := BCHCode( 15, 7 );
  a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
  gap> C2 := ResidueCode( C1 );
  a linear [8,4,4]2 residue code
  gap> c := Codeword( [ 0,0,0,1,0,0,1,1,0,1,0,1,1,1,1 ], C1);;
  gap> C3 := ResidueCode( C1, c );
  a linear [7,4,3]1 residue code 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{ConstructionBCode}}
\logpage{[ 6, 1, 12 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ConstructionBCode( C )\index{ConstructionBCode@\texttt{ConstructionBCode}}
\label{ConstructionBCode}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{ConstructionBCode} takes a binary linear code \mbox{\texttt{C}} and calculates the minimum distance of the dual of \mbox{\texttt{C}} (see \texttt{DualCode} (\ref{DualCode})). It then removes the columns of the parity check matrix of \mbox{\texttt{C}} where a codeword of the dual code of minimal weight has coordinates unequal to
zero. The resulting matrix is a parity check matrix for an $[n-dd, k-dd+1, \geq d]$ code, where $dd$ is the minimum distance of the dual of \mbox{\texttt{C}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := ReedMullerCode( 2, 5 );
  a linear [32,16,8]6 Reed-Muller (2,5) code over GF(2)
  gap> C2 := ConstructionBCode( C1 );
  a linear [24,9,8]5..10 Construction B (8 coordinates)
  gap> BoundsMinimumDistance( 24, 9, GF(2) );
  rec( n := 24, k := 9, q := 2, references := rec(  ), 
    construction := [ [ Operation "UUVCode" ], 
        [ [ [ Operation "UUVCode" ], [ [ [ Operation "DualCode" ], 
                        [ [ [ Operation "RepetitionCode" ], [ 6, 2 ] ] ] ], 
                    [ [ Operation "CordaroWagnerCode" ], [ 6 ] ] ] ], 
            [ [ Operation "CordaroWagnerCode" ], [ 12 ] ] ] ], lowerBound := 8, 
    lowerBoundExplanation := [ "Lb(24,9)=8, u u+v construction of C1 and C2:", 
        "Lb(12,7)=4, u u+v construction of C1 and C2:", 
        "Lb(6,5)=2, dual of the repetition code", 
        "Lb(6,2)=4, Cordaro-Wagner code", "Lb(12,2)=8, Cordaro-Wagner code" ], 
    upperBound := 8, 
    upperBoundExplanation := [ "Ub(24,9)=8, otherwise construction B would 
                               contradict:", "Ub(18,4)=8, Griesmer bound" ] )
  # so C2 is optimal
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DualCode}}
\logpage{[ 6, 1, 13 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DualCode( C )\index{DualCode@\texttt{DualCode}}
\label{DualCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{DualCode} returns the dual code of \mbox{\texttt{C}}. The dual code consists of all codewords that are orthogonal to the codewords
of \mbox{\texttt{C}}. If \mbox{\texttt{C}} is a linear code with generator matrix $G$, the dual code has parity check matrix $G$ (or if \mbox{\texttt{C}} has parity check matrix $H$, the dual code has generator matrix $H$). So if \mbox{\texttt{C}} is a linear $[n, k]$ code, the dual code of \mbox{\texttt{C}} is a linear $[n, n-k]$ code. If \mbox{\texttt{C}} is a cyclic code with generator polynomial $g(x)$, the dual code has the reciprocal polynomial of $g(x)$ as check polynomial. 

 The dual code is always a linear code, even if \mbox{\texttt{C}} is non-linear. 

 If a code \mbox{\texttt{C}} is equal to its dual code, it is called \emph{self-dual}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> R := ReedMullerCode( 1, 3 );
  a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
  gap> RD := DualCode( R );
  a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
  gap> R = RD;
  true
  gap> N := WholeSpaceCode( 7, GF(4) );
  a cyclic [7,7,1]0 whole space code over GF(4)
  gap> DualCode( N ) = NullCode( 7, GF(4) );
  true 
\end{Verbatim}
  \index{self-dual} 

\subsection{\textcolor{Chapter }{ConversionFieldCode}}
\logpage{[ 6, 1, 14 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ConversionFieldCode( C )\index{ConversionFieldCode@\texttt{ConversionFieldCode}}
\label{ConversionFieldCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ConversionFieldCode} returns code \mbox{\texttt{C}} after converting its field. If the field of \mbox{\texttt{C}} is $GF(q^m)$, the returned code has field $GF(q)$. Each symbol of every codeword is replaced by a concatenation of $m$ symbols from $GF(q)$. If \mbox{\texttt{C}} is an $(n, M, d_1)$ code, the returned code is a $(n\cdot m, M, d_2)$ code, where $d_2 > d_1$. 

 See also \texttt{HorizontalConversionFieldMat} (\ref{HorizontalConversionFieldMat}). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> R := RepetitionCode( 4, GF(4) );
  a cyclic [4,1,4]3 repetition code over GF(4)
  gap> R2 := ConversionFieldCode( R );
  a linear [8,2,4]3..4 code, converted to basefield GF(2)
  gap> Size( R ) = Size( R2 );
  true
  gap> GeneratorMat( R );
  [ [ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ] ]
  gap> GeneratorMat( R2 );
  [ [ Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2) ],
    [ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ] ] 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{CosetCode}}
\logpage{[ 6, 1, 15 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CosetCode( C, w )\index{CosetCode@\texttt{CosetCode}}
\label{CosetCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{CosetCode} returns the coset of a code \mbox{\texttt{C}} with respect to word \mbox{\texttt{w}}. \mbox{\texttt{w}} must be of the codeword type. Then, \mbox{\texttt{w}} is added to each codeword of \mbox{\texttt{C}}, yielding the elements of the new code. If \mbox{\texttt{C}} is linear and \mbox{\texttt{w}} is an element of \mbox{\texttt{C}}, the new code is equal to \mbox{\texttt{C}}, otherwise the new code is an unrestricted code. 

 Generating a coset is also possible by simply adding the word \mbox{\texttt{w}} to \mbox{\texttt{C}}. See \ref{Operations for Codes}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> H := HammingCode(3, GF(2));
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  gap> c := Codeword("1011011");; c in H;
  false
  gap> C := CosetCode(H, c);
  a (7,16,3)1 coset code
  gap> List(AsSSortedList(C), el-> Syndrome(H, el));
  [ [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ],
    [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ],
    [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ] ]
  # All elements of the coset have the same syndrome in H 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{ConstantWeightSubcode}}
\logpage{[ 6, 1, 16 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ConstantWeightSubcode( C, w )\index{ConstantWeightSubcode@\texttt{ConstantWeightSubcode}}
\label{ConstantWeightSubcode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ConstantWeightSubcode} returns the subcode of \mbox{\texttt{C}} that only has codewords of weight \mbox{\texttt{w}}. The resulting code is a non-linear code, because it does not contain the
all-zero vector. 

 This command also can be called with the syntax \texttt{ConstantWeightSubcode(C)} In this format, \texttt{ConstantWeightSubcode} returns the subcode of \mbox{\texttt{C}} consisting of all minimum weight codewords of \mbox{\texttt{C}}. 

 \texttt{ConstantWeightSubcode} first checks if Leon's binary \texttt{wtdist} exists on your computer (in the default directory). If it does, then this
program is called. Otherwise, the constant weight subcode is computed using a
GAP program which checks each codeword in \mbox{\texttt{C}} to see if it is of the desired weight. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> N := NordstromRobinsonCode();; WeightDistribution(N);
  [ 1, 0, 0, 0, 0, 0, 112, 0, 30, 0, 112, 0, 0, 0, 0, 0, 1 ]
  gap> C := ConstantWeightSubcode(N, 8);
  a (16,30,6..16)5..8 code with codewords of weight 8
  gap> WeightDistribution(C);
  [ 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0 ] 
  gap> eg := ExtendedTernaryGolayCode();; WeightDistribution(eg);
  [ 1, 0, 0, 0, 0, 0, 264, 0, 0, 440, 0, 0, 24 ]
  gap> C := ConstantWeightSubcode(eg);
  a (12,264,6..12)3..6 code with codewords of weight 6
  gap> WeightDistribution(C);
  [ 0, 0, 0, 0, 0, 0, 264, 0, 0, 0, 0, 0, 0 ] 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{StandardFormCode}}
\logpage{[ 6, 1, 17 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{StandardFormCode( C )\index{StandardFormCode@\texttt{StandardFormCode}}
\label{StandardFormCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{StandardFormCode} returns \mbox{\texttt{C}} after putting it in standard form. If \mbox{\texttt{C}} is a non-linear code, this means the elements are organized using
lexicographical order. This means they form a legal \textsf{GAP} `Set'. 

 If \mbox{\texttt{C}} is a linear code, the generator matrix and parity check matrix are put in
standard form. The generator matrix then has an identity matrix in its left
part, the parity check matrix has an identity matrix in its right part.
Although \textsf{GUAVA} always puts both matrices in a standard form using \texttt{BaseMat}, this never alters the code. \texttt{StandardFormCode} even applies column permutations if unavoidable, and thereby changes the code.
The column permutations are recorded in the construction history of the new
code (see \texttt{Display} (\ref{Display})). \mbox{\texttt{C}} and the new code are of course equivalent. 

 If \mbox{\texttt{C}} is a cyclic code, its generator matrix cannot be put in the usual upper
triangular form, because then it would be inconsistent with the generator
polynomial. The reason is that generating the elements from the generator
matrix would result in a different order than generating the elements from the
generator polynomial. This is an unwanted effect, and therefore \texttt{StandardFormCode} just returns a copy of \mbox{\texttt{C}} for cyclic codes. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> G := GeneratorMatCode( Z(2) * [ [0,1,1,0], [0,1,0,1], [0,0,1,1] ],
  > "random form code", GF(2) );
  a linear [4,2,1..2]1..2 random form code over GF(2)
  gap> Codeword( GeneratorMat( G ) );
  [ [ 0 1 0 1 ], [ 0 0 1 1 ] ]
  gap> Codeword( GeneratorMat( StandardFormCode( G ) ) );
  [ [ 1 0 0 1 ], [ 0 1 0 1 ] ] 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{PiecewiseConstantCode}}
\logpage{[ 6, 1, 18 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PiecewiseConstantCode( part, wts[, F] )\index{PiecewiseConstantCode@\texttt{PiecewiseConstantCode}}
\label{PiecewiseConstantCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{PiecewiseConstantCode} returns a code with length $n = \sum n_i$, where \mbox{\texttt{part}}=$[ n_1, \dots, n_k ]$. \mbox{\texttt{wts}} is a list of \mbox{\texttt{constraints}} $w=(w_1,...,w_k)$, each of length $k$, where $0 \leq w_i \leq n_i$. The default field is $GF(2)$. 

 A constraint is a list of integers, and a word $c = ( c_1, \dots, c_k )$ (according to \mbox{\texttt{part}}, i.e., each $c_i$ is a subword of length $n_i$) is in the resulting code if and only if, for some constraint $w \in$ \mbox{\texttt{wts}}, $\|c_i\| = w_i$ for all $1 \leq i \leq k$, where $\| ...\|$ denotes the Hamming weight. 

 An example might make things clearer: }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> PiecewiseConstantCode( [ 2, 3 ],
  > [ [ 0, 0 ], [ 0, 3 ], [ 1, 0 ], [ 2, 2 ] ],
  > GF(2) );
  a (5,7,1..5)1..5 piecewise constant code over GF(2)
  gap> AsSSortedList(last);
  [ [ 0 0 0 0 0 ], [ 0 0 1 1 1 ], [ 0 1 0 0 0 ], [ 1 0 0 0 0 ], [ 1 1 0 1 1 ], 
    [ 1 1 1 0 1 ], [ 1 1 1 1 0 ] ]
\end{Verbatim}
 The first constraint is satisfied by codeword 1, the second by codeword 2, the
third by codewords 3 and 4, and the fourth by codewords 5, 6 and 7. }

 
\section{\textcolor{Chapter }{ Functions that Generate a New Code from Two Given Codes }}\logpage{[ 6, 2, 0 ]}
{
  \label{Functions that Generate a New Code from Two Given Codes} 

\subsection{\textcolor{Chapter }{DirectSumCode}}
\logpage{[ 6, 2, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DirectSumCode( C1, C2 )\index{DirectSumCode@\texttt{DirectSumCode}}
\label{DirectSumCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{DirectSumCode} returns the direct sum of codes \mbox{\texttt{C1}} and \mbox{\texttt{C2}}. The direct sum code consists of every codeword of \mbox{\texttt{C1}} concatenated by every codeword of \mbox{\texttt{C2}}. Therefore, if \mbox{\texttt{Ci}} was a $(n_i,M_i,d_i)$ code, the result is a $(n_1+n_2,M_1*M_2,min(d_1,d_2))$ code. 

 If both \mbox{\texttt{C1}} and \mbox{\texttt{C2}} are linear codes, the result is also a linear code. If one of them is
non-linear, the direct sum is non-linear too. In general, a direct sum code is
not cyclic. 

 Performing a direct sum can also be done by adding two codes (see Section \ref{Operations for Codes}). Another often used method is the `u, u+v'-construction, described in \texttt{UUVCode} (\ref{UUVCode}). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := ElementsCode( [ [1,0], [4,5] ], GF(7) );;
  gap> C2 := ElementsCode( [ [0,0,0], [3,3,3] ], GF(7) );;
  gap> D := DirectSumCode(C1, C2);;
  gap> AsSSortedList(D);
  [ [ 1 0 0 0 0 ], [ 1 0 3 3 3 ], [ 4 5 0 0 0 ], [ 4 5 3 3 3 ] ]
  gap> D = C1 + C2;   # addition = direct sum
  true 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{UUVCode}}
\logpage{[ 6, 2, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UUVCode( C1, C2 )\index{UUVCode@\texttt{UUVCode}}
\label{UUVCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{UUVCode} returns the so-called $(u\|u+v)$ construction applied to \mbox{\texttt{C1}} and \mbox{\texttt{C2}}. The resulting code consists of every codeword $u$ of \mbox{\texttt{C1}} concatenated by the sum of $u$ and every codeword $v$ of \mbox{\texttt{C2}}. If \mbox{\texttt{C1}} and \mbox{\texttt{C2}} have different word lengths, sufficient zeros are added to the shorter code to
make this sum possible. If \mbox{\texttt{Ci}} is a $(n_i,M_i,d_i)$ code, the result is an $(n_1+max(n_1,n_2),M_1\cdot M_2,min(2\cdot d_1,d_2))$ code. 

 If both \mbox{\texttt{C1}} and \mbox{\texttt{C2}} are linear codes, the result is also a linear code. If one of them is
non-linear, the UUV sum is non-linear too. In general, a UUV sum code is not
cyclic. 

 The function \texttt{DirectSumCode} returns another sum of codes (see \texttt{DirectSumCode} (\ref{DirectSumCode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := EvenWeightSubcode(WholeSpaceCode(4, GF(2)));
  a cyclic [4,3,2]1 even weight subcode
  gap> C2 := RepetitionCode(4, GF(2));
  a cyclic [4,1,4]2 repetition code over GF(2)
  gap> R := UUVCode(C1, C2);
  a linear [8,4,4]2 U U+V construction code
  gap> R = ReedMullerCode(1,3);
  true 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{DirectProductCode}}
\logpage{[ 6, 2, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DirectProductCode( C1, C2 )\index{DirectProductCode@\texttt{DirectProductCode}}
\label{DirectProductCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{DirectProductCode} returns the direct product of codes \mbox{\texttt{C1}} and \mbox{\texttt{C2}}. Both must be linear codes. Suppose \mbox{\texttt{Ci}} has generator matrix $G_i$. The direct product of \mbox{\texttt{C1}} and \mbox{\texttt{C2}} then has the Kronecker product of $G_1$ and $G_2$ as the generator matrix (see the \textsf{GAP} command \texttt{KroneckerProduct}). 

 If \mbox{\texttt{Ci}} is a $[n_i, k_i, d_i]$ code, the direct product then is an $[n_1\cdot n_2,k_1\cdot k_2,d_1\cdot d_2]$ code. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> L1 := LexiCode(10, 4, GF(2));
  a linear [10,5,4]2..4 lexicode over GF(2)
  gap> L2 := LexiCode(8, 3, GF(2));
  a linear [8,4,3]2..3 lexicode over GF(2)
  gap> D := DirectProductCode(L1, L2);
  a linear [80,20,12]20..45 direct product code 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IntersectionCode}}
\logpage{[ 6, 2, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IntersectionCode( C1, C2 )\index{IntersectionCode@\texttt{IntersectionCode}}
\label{IntersectionCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IntersectionCode} returns the intersection of codes \mbox{\texttt{C1}} and \mbox{\texttt{C2}}. This code consists of all codewords that are both in \mbox{\texttt{C1}} and \mbox{\texttt{C2}}. If both codes are linear, the result is also linear. If both are cyclic, the
result is also cyclic. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := CyclicCodes(7, GF(2));
  [ a cyclic [7,7,1]0 enumerated code over GF(2),
    a cyclic [7,6,1..2]1 enumerated code over GF(2),
    a cyclic [7,3,1..4]2..3 enumerated code over GF(2),
    a cyclic [7,0,7]7 enumerated code over GF(2),
    a cyclic [7,3,1..4]2..3 enumerated code over GF(2),
    a cyclic [7,4,1..3]1 enumerated code over GF(2),
    a cyclic [7,1,7]3 enumerated code over GF(2),
    a cyclic [7,4,1..3]1 enumerated code over GF(2) ]
  gap> IntersectionCode(C[6], C[8]) = C[7];
  true 
\end{Verbatim}
 \index{hull} The \emph{hull} of a linear code is the intersection of the code with its dual code. In other
words, the hull of $C$ is \texttt{IntersectionCode(C, DualCode(C))}. 

\subsection{\textcolor{Chapter }{UnionCode}}
\logpage{[ 6, 2, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UnionCode( C1, C2 )\index{UnionCode@\texttt{UnionCode}}
\label{UnionCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{UnionCode} returns the union of codes \mbox{\texttt{C1}} and \mbox{\texttt{C2}}. This code consists of the union of all codewords of \mbox{\texttt{C1}} and \mbox{\texttt{C2}} and all linear combinations. Therefore this function works only for linear
codes. The function \texttt{AddedElementsCode} can be used for non-linear codes, or if the resulting code should not include
linear combinations. See \texttt{AddedElementsCode} (\ref{AddedElementsCode}). If both arguments are cyclic, the result is also cyclic. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> G := GeneratorMatCode([[1,0,1],[0,1,1]]*Z(2)^0, GF(2));
  a linear [3,2,1..2]1 code defined by generator matrix over GF(2)
  gap> H := GeneratorMatCode([[1,1,1]]*Z(2)^0, GF(2));
  a linear [3,1,3]1 code defined by generator matrix over GF(2)
  gap> U := UnionCode(G, H);
  a linear [3,3,1]0 union code
  gap> c := Codeword("010");; c in G;
  false
  gap> c in H;
  false
  gap> c in U;
  true 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{ExtendedDirectSumCode}}
\logpage{[ 6, 2, 6 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ExtendedDirectSumCode( L, B, m )\index{ExtendedDirectSumCode@\texttt{ExtendedDirectSumCode}}
\label{ExtendedDirectSumCode}
}\hfill{\scriptsize (function)}}\\


 The extended direct sum construction is described in section V of Graham and
Sloane \cite{GS85}. The resulting code consists of \mbox{\texttt{m}} copies of \mbox{\texttt{L}}, extended by repeating the codewords of \mbox{\texttt{B}} \mbox{\texttt{m}} times. 

 Suppose \mbox{\texttt{L}} is an $[n_L, k_L]r_L$ code, and \mbox{\texttt{B}} is an $[n_L, k_B]r_B$ code (non-linear codes are also permitted). The length of \mbox{\texttt{B}} must be equal to the length of \mbox{\texttt{L}}. The length of the new code is $n = m n_L$, the dimension (in the case of linear codes) is $k \leq m k_L + k_B$, and the covering radius is $r \leq \lfloor m \Psi( L, B ) \rfloor$, with 
\[ \Psi( L, B ) = \max_{u \in F_2^{n_L}} \frac{1}{2^{k_B}} \sum_{v \in B} {\rm
d}( L, v + u ). \]
 However, this computation will not be executed, because it may be too time
consuming for large codes. 

 If $L \subseteq B$, and $L$ and $B$ are linear codes, the last copy of \mbox{\texttt{L}} is omitted. In this case the dimension is $k = m k_L + (k_B - k_L)$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> c := HammingCode( 3, GF(2) );
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  gap> d := WholeSpaceCode( 7, GF(2) );
  a cyclic [7,7,1]0 whole space code over GF(2)
  gap> e := ExtendedDirectSumCode( c, d, 3 );
  a linear [21,15,1..3]2 3-fold extended direct sum code
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{AmalgamatedDirectSumCode}}
\logpage{[ 6, 2, 7 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AmalgamatedDirectSumCode( c1, c2[, check] )\index{AmalgamatedDirectSumCode@\texttt{AmalgamatedDirectSumCode}}
\label{AmalgamatedDirectSumCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{AmalgamatedDirectSumCode} returns the amalgamated direct sum of the codes \mbox{\texttt{c1}} and \mbox{\texttt{c2}}. The amalgamated direct sum code consists of all codewords of the form $(u \, \| \,0 \, \| \, v)$ if $(u \, \| \, 0) \in c_1$ and $(0 \, \| \, v) \in c_2$ and all codewords of the form $(u \, \| \, 1 \, \| \, v)$ if $(u \, \| \, 1) \in c_1$ and $(1 \, \| \, v) \in c_2$. The result is a code with length $ n = n_1 + n_2 - 1 $ and size $ M \leq M_1 \cdot M_2 / 2 $. 

 If both codes are linear, they will first be standardized, with information
symbols in the last and first coordinates of the first and second code,
respectively. 

 If \mbox{\texttt{c1}} is a normal code (see \texttt{IsNormalCode} (\ref{IsNormalCode})) with the last coordinate acceptable (see \texttt{IsCoordinateAcceptable} (\ref{IsCoordinateAcceptable})), and \mbox{\texttt{c2}} is a normal code with the first coordinate acceptable, then the covering
radius of the new code is $r \leq r_1 + r_2 $. However, checking whether a code is normal or not is a lot of work, and
almost all codes seem to be normal. Therefore, an option \mbox{\texttt{check}} can be supplied. If \mbox{\texttt{check}} is true, then the codes will be checked for normality. If \mbox{\texttt{check}} is false or omitted, then the codes will not be checked. In this case it is
assumed that they are normal. Acceptability of the last and first coordinate
of the first and second code, respectively, is in the last case also assumed
to be done by the user. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> c := HammingCode( 3, GF(2) );
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  gap> d := ReedMullerCode( 1, 4 );
  a linear [16,5,8]6 Reed-Muller (1,4) code over GF(2)
  gap> e := DirectSumCode( c, d );
  a linear [23,9,3]7 direct sum code
  gap> f := AmalgamatedDirectSumCode( c, d );;
  gap> MinimumDistance( f );;
  gap> CoveringRadius( f );; 
  gap> f;
  a linear [22,8,3]7 amalgamated direct sum code
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{BlockwiseDirectSumCode}}
\logpage{[ 6, 2, 8 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BlockwiseDirectSumCode( C1, L1, C2, L2 )\index{BlockwiseDirectSumCode@\texttt{BlockwiseDirectSumCode}}
\label{BlockwiseDirectSumCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{BlockwiseDirectSumCode} returns a subcode of the direct sum of \mbox{\texttt{C1}} and \mbox{\texttt{C2}}. The fields of \mbox{\texttt{C1}} and \mbox{\texttt{C2}} must be same. The lists \mbox{\texttt{L1}} and \mbox{\texttt{L2}} are two equally long with elements from the ambient vector spaces of \mbox{\texttt{C1}} and \mbox{\texttt{C2}}, respectively, \emph{or} \mbox{\texttt{L1}} and \mbox{\texttt{L2}} are two equally long lists containing codes. The union of the codes in \mbox{\texttt{L1}} and \mbox{\texttt{L2}} must be \mbox{\texttt{C1}} and \mbox{\texttt{C2}}, respectively. 

 In the first case, the blockwise direct sum code is defined as 
\[ bds = \bigcup_{1 \leq i \leq \ell} ( C_1 + (L_1)_i ) \oplus ( C_2 + (L_2)_i ), \]
 where $\ell$ is the length of \mbox{\texttt{L1}} and \mbox{\texttt{L2}}, and $\oplus$ is the direct sum. 

 In the second case, it is defined as 
\[ bds = \bigcup_{1 \leq i \leq \ell} ( (L_1)_i \oplus (L_2)_i ). \]
 The length of the new code is $n = n_1 + n_2$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C1 := HammingCode( 3, GF(2) );;
  gap> C2 := EvenWeightSubcode( WholeSpaceCode( 6, GF(2) ) );;
  gap> BlockwiseDirectSumCode( C1, [[ 0,0,0,0,0,0,0 ],[ 1,0,1,0,1,0,0 ]],
  > C2, [[ 0,0,0,0,0,0 ],[ 1,0,1,0,1,0 ]] );
  a (13,1024,1..13)1..2 blockwise direct sum code
\end{Verbatim}
 }

 }

 
\chapter{\textcolor{Chapter }{ Bounds on codes, special matrices and miscellaneous functions }}\logpage{[ 7, 0, 0 ]}
{
  In this chapter we describe functions that determine bounds on the size and
minimum distance of codes (Section \ref{Distance bounds on codes}), functions that determine bounds on the size and covering radius of codes
(Section \ref{Covering radius bounds on codes}), functions that work with special matrices \textsf{GUAVA} needs for several codes (see Section \ref{Special matrices in GUAVA}), and constructing codes or performing calculations with codes (see Section \ref{Miscellaneous functions}). 
\section{\textcolor{Chapter }{ Distance bounds on codes }}\logpage{[ 7, 1, 0 ]}
{
  \label{Distance bounds on codes} This section describes the functions that calculate estimates for upper bounds
on the size and minimum distance of codes. Several algorithms are known to
compute a largest number of words a code can have with given length and
minimum distance. It is important however to understand that in some cases the
true upper bound is unknown. A code which has a size equalto the calculated
upper bound may not have been found. However, codes that have a larger size do
not exist. 

 A second way to obtain bounds is a table. In \textsf{GUAVA}, an extensive table is implemented for linear codes over $GF(2)$, $GF(3)$ and $GF(4)$. It contains bounds on the minimum distance for given word length and
dimension. For binary codes, it contains entries for word length less than or
equal to $257$. For codes over $GF(3)$ and $GF(4)$, it contains entries for word length less than or equal to $130$. 

 Firstly, we describe functions that compute specific upper bounds on the code
size (see \texttt{UpperBoundSingleton} (\ref{UpperBoundSingleton}), \texttt{UpperBoundHamming} (\ref{UpperBoundHamming}), \texttt{UpperBoundJohnson} (\ref{UpperBoundJohnson}), \texttt{UpperBoundPlotkin} (\ref{UpperBoundPlotkin}), \texttt{UpperBoundElias} (\ref{UpperBoundElias}) and \texttt{UpperBoundGriesmer} (\ref{UpperBoundGriesmer})). 

 Next we describe a function that computes \textsf{GUAVA}'s best upper bound on the code size (see \texttt{UpperBound} (\ref{UpperBound})). 

 Then we describe two functions that compute a lower and upper bound on the
minimum distance of a code (see \texttt{LowerBoundMinimumDistance} (\ref{LowerBoundMinimumDistance}) and \texttt{UpperBoundMinimumDistance} (\ref{UpperBoundMinimumDistance})). 

 Finally, we describe a function that returns a lower and upper bound on the
minimum distance with given parameters and a description of how the bounds
were obtained (see \texttt{BoundsMinimumDistance} (\ref{BoundsMinimumDistance})). \index{bounds, Singleton} 

\subsection{\textcolor{Chapter }{UpperBoundSingleton}}
\logpage{[ 7, 1, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UpperBoundSingleton( n, d, q )\index{UpperBoundSingleton@\texttt{UpperBoundSingleton}}
\label{UpperBoundSingleton}
}\hfill{\scriptsize (function)}}\\


 \texttt{UpperBoundSingleton} returns the Singleton bound for a code of length \mbox{\texttt{n}}, minimum distance \mbox{\texttt{d}} over a field of size \mbox{\texttt{q}}. This bound is based on the shortening of codes. By shortening an $(n, M, d)$ code $d-1$ times, an $(n-d+1,M,1)$ code results, with $M \leq q^{n-d+1}$ (see \texttt{ShortenedCode} (\ref{ShortenedCode})). Thus 
\[ M \leq q^{n-d+1}. \]
 \index{maximum distance separable} Codes that meet this bound are called \emph{maximum distance separable} (see \texttt{IsMDSCode} (\ref{IsMDSCode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> UpperBoundSingleton(4, 3, 5);
  25
  gap> C := ReedSolomonCode(4,3);; Size(C);
  25
  gap> IsMDSCode(C);
  true 
\end{Verbatim}
 \index{bounds, Hamming} \index{bounds, sphere packing bound} \index{perfect} 

\subsection{\textcolor{Chapter }{UpperBoundHamming}}
\logpage{[ 7, 1, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UpperBoundHamming( n, d, q )\index{UpperBoundHamming@\texttt{UpperBoundHamming}}
\label{UpperBoundHamming}
}\hfill{\scriptsize (function)}}\\


 The Hamming bound (also known as the \emph{sphere packing bound}) returns an upper bound on the size of a code of length \mbox{\texttt{n}}, minimum distance \mbox{\texttt{d}}, over a field of size \mbox{\texttt{q}}. The Hamming bound is obtained by dividing the contents of the entire space $GF(q)^n$ by the contents of a ball with radius $\lfloor(d-1) / 2\rfloor$. As all these balls are disjoint, they can never contain more than the whole
vector space. 
\[ M \leq {q^n \over V(n,e)}, \]
 where $M$ is the maxmimum number of codewords and $V(n,e)$ is equal to the contents of a ball of radius $e$ (see \texttt{SphereContent} (\ref{SphereContent})). This bound is useful for small values of \mbox{\texttt{d}}. Codes for which equality holds are called \emph{perfect} (see \texttt{IsPerfectCode} (\ref{IsPerfectCode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> UpperBoundHamming( 15, 3, 2 );
  2048
  gap> C := HammingCode( 4, GF(2) );
  a linear [15,11,3]1 Hamming (4,2) code over GF(2)
  gap> Size( C );
  2048 
\end{Verbatim}
 \index{bounds, Johnson} 

\subsection{\textcolor{Chapter }{UpperBoundJohnson}}
\logpage{[ 7, 1, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UpperBoundJohnson( n, d )\index{UpperBoundJohnson@\texttt{UpperBoundJohnson}}
\label{UpperBoundJohnson}
}\hfill{\scriptsize (function)}}\\


 The Johnson bound is an improved version of the Hamming bound (see \texttt{UpperBoundHamming} (\ref{UpperBoundHamming})). In addition to the Hamming bound, it takes into account the elements of the
space outside the balls of radius $e$ around the elements of the code. The Johnson bound only works for binary
codes. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> UpperBoundJohnson( 13, 5 );
  77
  gap> UpperBoundHamming( 13, 5, 2);
  89   # in this case the Johnson bound is better 
\end{Verbatim}
 \index{bounds, Plotkin} 

\subsection{\textcolor{Chapter }{UpperBoundPlotkin}}
\logpage{[ 7, 1, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UpperBoundPlotkin( n, d, q )\index{UpperBoundPlotkin@\texttt{UpperBoundPlotkin}}
\label{UpperBoundPlotkin}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{UpperBoundPlotkin} calculates the sum of the distances of all ordered pairs of different
codewords. It is based on the fact that the minimum distance is at most equal
to the average distance. It is a good bound if the weights of the codewords do
not differ much. It results in: 
\[ M \leq {d \over {d-(1-1/q)n}}, \]
 where $M$ is the maximum number of codewords. In this case, \mbox{\texttt{d}} must be larger than $(1-1/q)n$, but by shortening the code, the case $d \langle (1-1/q)n$ is covered. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> UpperBoundPlotkin( 15, 7, 2 );
  32
  gap> C := BCHCode( 15, 7, GF(2) );
  a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
  gap> Size(C);
  32
  gap> WeightDistribution(C);
  [ 1, 0, 0, 0, 0, 0, 0, 15, 15, 0, 0, 0, 0, 0, 0, 1 ] 
\end{Verbatim}
 \index{bounds, Elias} 

\subsection{\textcolor{Chapter }{UpperBoundElias}}
\logpage{[ 7, 1, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UpperBoundElias( n, d, q )\index{UpperBoundElias@\texttt{UpperBoundElias}}
\label{UpperBoundElias}
}\hfill{\scriptsize (function)}}\\


 The Elias bound is an improvement of the Plotkin bound (see \texttt{UpperBoundPlotkin} (\ref{UpperBoundPlotkin})) for large codes. Subcodes are used to decrease the size of the code, in this
case the subcode of all codewords within a certain ball. This bound is useful
for large codes with relatively small minimum distances. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> UpperBoundPlotkin( 16, 3, 2 );
  12288
  gap> UpperBoundElias( 16, 3, 2 );
  10280 
  gap> UpperBoundElias( 20, 10, 3 );
  16255
\end{Verbatim}
 \index{bounds, Griesmer} 

\subsection{\textcolor{Chapter }{UpperBoundGriesmer}}
\logpage{[ 7, 1, 6 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UpperBoundGriesmer( n, d, q )\index{UpperBoundGriesmer@\texttt{UpperBoundGriesmer}}
\label{UpperBoundGriesmer}
}\hfill{\scriptsize (function)}}\\


 The Griesmer bound is valid only for linear codes. It is obtained by counting
the number of equal symbols in each row of the generator matrix of the code.
By omitting the coordinates in which all rows have a zero, a smaller code
results. The Griesmer bound is obtained by repeating this proces until a
trivial code is left in the end. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> UpperBoundGriesmer( 13, 5, 2 );
  64
  gap> UpperBoundGriesmer( 18, 9, 2 );
  8        # the maximum number of words for a linear code is 8
  gap> Size( PuncturedCode( HadamardCode( 20, 1 ) ) );
  20       # this non-linear code has 20 elements 
\end{Verbatim}
 \index{$A(n,d)$} 

\subsection{\textcolor{Chapter }{UpperBound}}
\logpage{[ 7, 1, 7 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UpperBound( n, d, q )\index{UpperBound@\texttt{UpperBound}}
\label{UpperBound}
}\hfill{\scriptsize (function)}}\\


 \texttt{UpperBound} returns the best known upper bound $A(n,d)$ for the size of a code of length \mbox{\texttt{n}}, minimum distance \mbox{\texttt{d}} over a field of size \mbox{\texttt{q}}. The function \texttt{UpperBound} first checks for trivial cases (like $d=1$ or $n=d$), and if the value is in the built-in table. Then it calculates the minimum
value of the upper bound using the methods of Singleton (see \texttt{UpperBoundSingleton} (\ref{UpperBoundSingleton})), Hamming (see \texttt{UpperBoundHamming} (\ref{UpperBoundHamming})), Johnson (see \texttt{UpperBoundJohnson} (\ref{UpperBoundJohnson})), Plotkin (see \texttt{UpperBoundPlotkin} (\ref{UpperBoundPlotkin})) and Elias (see \texttt{UpperBoundElias} (\ref{UpperBoundElias})). If the code is binary, $A(n, 2\cdot \ell-1) = A(n+1,2\cdot \ell)$, so the \texttt{UpperBound} takes the minimum of the values obtained from all methods for the parameters $(n, 2\cdot\ell-1)$ and $(n+1, 2\cdot \ell)$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> UpperBound( 10, 3, 2 );
  85
  gap> UpperBound( 25, 9, 8 );
  1211778792827540 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LowerBoundMinimumDistance}}
\logpage{[ 7, 1, 8 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LowerBoundMinimumDistance( C )\index{LowerBoundMinimumDistance@\texttt{LowerBoundMinimumDistance}}
\label{LowerBoundMinimumDistance}
}\hfill{\scriptsize (function)}}\\


 In this form, \texttt{LowerBoundMinimumDistance} returns a lower bound for the minimum distance of code \mbox{\texttt{C}}. 

 This command can also be called using the syntax \texttt{LowerBoundMinimumDistance( n, k, F )}. In this form, \texttt{LowerBoundMinimumDistance} returns a lower bound for the minimum distance of the best known linear code
of length \mbox{\texttt{n}}, dimension \mbox{\texttt{k}} over field \mbox{\texttt{F}}. It uses the mechanism explained in section \ref{BoundsMinimumDistance}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := BCHCode( 45, 7 );
  a cyclic [45,23,7..9]6..16 BCH code, delta=7, b=1 over GF(2)
  gap> LowerBoundMinimumDistance( C );
  7     # designed distance is lower bound for minimum distance 
  gap> LowerBoundMinimumDistance( 45, 23, GF(2) );
  10 
\end{Verbatim}
 \index{bound, Gilbert-Varshamov lower} 

\subsection{\textcolor{Chapter }{LowerBoundGilbertVarshamov}}
\logpage{[ 7, 1, 9 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LowerBoundGilbertVarshamov( n, d, q )\index{LowerBoundGilbertVarshamov@\texttt{LowerBoundGilbertVarshamov}}
\label{LowerBoundGilbertVarshamov}
}\hfill{\scriptsize (function)}}\\


 This is the lower bound due (independently) to Gilbert and Varshamov. It says
that for each \mbox{\texttt{n}} and \mbox{\texttt{d}}, there exists a linear code having length $n$ and minimum distance $d$ at least of size $q^{n-1}/ SphereContent(n-1,d-2,GF(q))$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> LowerBoundGilbertVarshamov(3,2,2);
  4
  gap> LowerBoundGilbertVarshamov(3,3,2);
  1
  gap> LowerBoundMinimumDistance(3,3,2);
  1
  gap> LowerBoundMinimumDistance(3,2,2);
  2
\end{Verbatim}
  \index{bound, sphere packing lower} 

\subsection{\textcolor{Chapter }{LowerBoundSpherePacking}}
\logpage{[ 7, 1, 10 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LowerBoundSpherePacking( n, d, q )\index{LowerBoundSpherePacking@\texttt{LowerBoundSpherePacking}}
\label{LowerBoundSpherePacking}
}\hfill{\scriptsize (function)}}\\


 This is the lower bound due (independently) to Gilbert and Varshamov. It says
that for each \mbox{\texttt{n}} and \mbox{\texttt{r}}, there exists an unrestricted code at least of size $q^n/ SphereContent(n,d,GF(q))$ minimum distance $d$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> LowerBoundSpherePacking(3,2,2);
  2
  gap> LowerBoundSpherePacking(3,3,2);
  1
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{UpperBoundMinimumDistance}}
\logpage{[ 7, 1, 11 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UpperBoundMinimumDistance( C )\index{UpperBoundMinimumDistance@\texttt{UpperBoundMinimumDistance}}
\label{UpperBoundMinimumDistance}
}\hfill{\scriptsize (function)}}\\


 In this form, \texttt{UpperBoundMinimumDistance} returns an upper bound for the minimum distance of code \mbox{\texttt{C}}. For unrestricted codes, it just returns the word length. For linear codes,
it takes the minimum of the possibly known value from the method of
construction, the weight of the generators, and the value from the table (see \ref{BoundsMinimumDistance}). 

 This command can also be called using the syntax \texttt{UpperBoundMinimumDistance( n, k, F )}. In this form, \texttt{UpperBoundMinimumDistance} returns an upper bound for the minimum distance of the best known linear code
of length \mbox{\texttt{n}}, dimension \mbox{\texttt{k}} over field \mbox{\texttt{F}}. It uses the mechanism explained in section \ref{BoundsMinimumDistance}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := BCHCode( 45, 7 );;
  gap> UpperBoundMinimumDistance( C );
  9 
  gap> UpperBoundMinimumDistance( 45, 23, GF(2) );
  11 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{BoundsMinimumDistance}}
\logpage{[ 7, 1, 12 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BoundsMinimumDistance( n, k, F )\index{BoundsMinimumDistance@\texttt{BoundsMinimumDistance}}
\label{BoundsMinimumDistance}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{BoundsMinimumDistance} calculates a lower and upper bound for the minimum distance of an optimal
linear code with word length \mbox{\texttt{n}}, dimension \mbox{\texttt{k}} over field \mbox{\texttt{F}}. The function returns a record with the two bounds and an explenation for
each bound. The function \texttt{Display} can be used to show the explanations. 

 The values for the lower and upper bound are obtained from a table. \textsf{GUAVA} has tables containing lower and upper bounds for $q=2 (n \leq 257), 3, 4 (n \leq 130)$. (Current as of 1998.) These tables were derived from the table of Brouwer
and Verhoeff. (See \href{http://www.win.tue.nl/~aeb/voorlincod.html}{\texttt{http://www.win.tue.nl/\~{}aeb/voorlincod.html}}.) For codes over other fields and for larger word lengths, trivial bounds are
used. 

 The resulting record can be used in the function \texttt{BestKnownLinearCode} (see \texttt{BestKnownLinearCode} (\ref{BestKnownLinearCode})) to construct a code with minimum distance equal to the lower bound. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> bounds := BoundsMinimumDistance( 7, 3 );; DisplayBoundsInfo( bounds );
  an optimal linear [7,3,d] code over GF(2) has d=4
  ------------------------------------------------------------------------------
  Lb(7,3)=4, by shortening of:
  Lb(8,4)=4, u u+v construction of C1 and C2:
  Lb(4,3)=2, dual of the repetition code
  Lb(4,1)=4, repetition code
  ------------------------------------------------------------------------------
  Ub(7,3)=4, Griesmer bound
  # The lower bound is equal to the upper bound, so a code with
  # these parameters is optimal.
  gap> C := BestKnownLinearCode( bounds );; Display( C );
  a linear [7,3,4]2..3 shortened code of
  a linear [8,4,4]2 U U+V construction code of
  U: a cyclic [4,3,2]1 dual code of
     a cyclic [4,1,4]2 repetition code over GF(2)
  V: a cyclic [4,1,4]2 repetition code over GF(2)
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Covering radius bounds on codes }}\logpage{[ 7, 2, 0 ]}
{
  \label{Covering radius bounds on codes} 

\subsection{\textcolor{Chapter }{BoundsCoveringRadius}}
\logpage{[ 7, 2, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BoundsCoveringRadius( C )\index{BoundsCoveringRadius@\texttt{BoundsCoveringRadius}}
\label{BoundsCoveringRadius}
}\hfill{\scriptsize (function)}}\\


 \texttt{BoundsCoveringRadius} returns a list of integers. The first entry of this list is the maximum of
some lower bounds for the covering radius of \mbox{\texttt{C}}, the last entry the minimum of some upper bounds of \mbox{\texttt{C}}. 

 If the covering radius of \mbox{\texttt{C}} is known, a list of length 1 is returned. \texttt{BoundsCoveringRadius} makes use of the functions \texttt{GeneralLowerBoundCoveringRadius} and \texttt{GeneralUpperBoundCoveringRadius}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> BoundsCoveringRadius( BCHCode( 17, 3, GF(2) ) );
  [ 3 .. 4 ]
  gap> BoundsCoveringRadius( HammingCode( 5, GF(2) ) );
  [ 1 ] 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IncreaseCoveringRadiusLowerBound}}
\logpage{[ 7, 2, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IncreaseCoveringRadiusLowerBound( C[, stopdist][,][startword] )\index{IncreaseCoveringRadiusLowerBound@\texttt{IncreaseCoveringRadiusLowerBound}}
\label{IncreaseCoveringRadiusLowerBound}
}\hfill{\scriptsize (function)}}\\


 \texttt{IncreaseCoveringRadiusLowerBound} tries to increase the lower bound of the covering radius of \mbox{\texttt{C}}. It does this by means of a probabilistic algorithm. This algorithm takes a
random word in $GF(q)^n$ (or \mbox{\texttt{startword}} if it is specified), and, by changing random coordinates, tries to get as far
from \mbox{\texttt{C}} as possible. If changing a coordinate finds a word that has a larger distance
to the code than the previous one, the change is made permanent, and the
algorithm starts all over again. If changing a coordinate does not find a
coset leader that is further away from the code, then the change is made
permanent with a chance of 1 in 100, if it gets the word closer to the code,
or with a chance of 1 in 10, if the word stays at the same distance.
Otherwise, the algorithm starts again with the same word as before. 

 If the algorithm did not allow changes that decrease the distance to the code,
it might get stuck in a sub-optimal situation (the coset leader corresponding
to such a situation - i.e. no coordinate of this coset leader can be changed
in such a way that we get at a larger distance from the code - is called an \emph{orphan}). 

 If the algorithm finds a word that has distance \mbox{\texttt{stopdist}} to the code, it ends and returns that word, which can be used for further
investigations. 

 The variable \mbox{\texttt{InfoCoveringRadius}} can be set to \mbox{\texttt{Print}} to print the maximum distance reached so far every 1000 runs. The algorithm
can be interrupted with \textsc{ctrl-C}, allowing the user to look at the word that is currently being examined
(called `current'), or to change the chances that the new word is made
permanent (these are called `staychance' and `downchance'). If one of these
variables is $i$, then it corresponds with a $i$ in 100 chance. 

 At the moment, the algorithm is only useful for codes with small dimension,
where small means that the elements of the code fit in the memory. It works
with larger codes, however, but when you use it for codes with large
dimension, you should be \emph{very} patient. If running the algorithm quits \textsf{GAP} (due to memory problems), you can change the global variable \mbox{\texttt{CRMemSize}} to a lower value. This might cause the algorithm to run slower, but without
quitting \textsf{GAP}. The only way to find out the best value of \mbox{\texttt{CRMemSize}} is by experimenting. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(10,5,GF(2));
  a  [10,5,?] randomly generated code over GF(2)
  gap> IncreaseCoveringRadiusLowerBound(C,10);
  Number of runs: 1000  best distance so far: 3
  Number of runs: 2000  best distance so far: 3
  Number of changes: 100
  Number of runs: 3000  best distance so far: 3
  Number of runs: 4000  best distance so far: 3
  Number of runs: 5000  best distance so far: 3
  Number of runs: 6000  best distance so far: 3
  Number of runs: 7000  best distance so far: 3
  Number of changes: 200
  Number of runs: 8000  best distance so far: 3
  Number of runs: 9000  best distance so far: 3
  Number of runs: 10000  best distance so far: 3
  Number of changes: 300
  Number of runs: 11000  best distance so far: 3
  Number of runs: 12000  best distance so far: 3
  Number of runs: 13000  best distance so far: 3
  Number of changes: 400
  Number of runs: 14000  best distance so far: 3
  user interrupt at... 
  #
  # used ctrl-c to break out of execution
  #
  ... called from 
  IncreaseCoveringRadiusLowerBound( code, -1, current ) called from
   function( arguments ) called from read-eval-loop
  Entering break read-eval-print loop ...
  you can 'quit;' to quit to outer loop, or
  you can 'return;' to continue
  brk> current;
  [ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ]
  brk>
  gap> CoveringRadius(C);
  3
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{ExhaustiveSearchCoveringRadius}}
\logpage{[ 7, 2, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ExhaustiveSearchCoveringRadius( C )\index{ExhaustiveSearchCoveringRadius@\texttt{ExhaustiveSearchCoveringRadius}}
\label{ExhaustiveSearchCoveringRadius}
}\hfill{\scriptsize (function)}}\\


 \texttt{ExhaustiveSearchCoveringRadius} does an exhaustive search to find the covering radius of \mbox{\texttt{C}}. Every time a coset leader of a coset with weight $w$ is found, the function tries to find a coset leader of a coset with weight $w+1$. It does this by enumerating all words of weight $w+1$, and checking whether a word is a coset leader. The start weight is the
current known lower bound on the covering radius. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(10,5,GF(2));
  a  [10,5,?] randomly generated code over GF(2)
  gap> ExhaustiveSearchCoveringRadius(C);
  Trying 3 ...
  [ 3 .. 5 ]
  gap> CoveringRadius(C);
  3
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{GeneralLowerBoundCoveringRadius}}
\logpage{[ 7, 2, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneralLowerBoundCoveringRadius( C )\index{GeneralLowerBoundCoveringRadius@\texttt{GeneralLowerBoundCoveringRadius}}
\label{GeneralLowerBoundCoveringRadius}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneralLowerBoundCoveringRadius} returns a lower bound on the covering radius of \mbox{\texttt{C}}. It uses as many functions which names start with \texttt{LowerBoundCoveringRadius} as possible to find the best known lower bound (at least that \textsf{GUAVA} knows of) together with tables for the covering radius of binary linear codes
with length not greater than $64$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(10,5,GF(2));
  a  [10,5,?] randomly generated code over GF(2)
  gap> GeneralLowerBoundCoveringRadius(C);
  2
  gap> CoveringRadius(C);
  3
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{GeneralUpperBoundCoveringRadius}}
\logpage{[ 7, 2, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneralUpperBoundCoveringRadius( C )\index{GeneralUpperBoundCoveringRadius@\texttt{GeneralUpperBoundCoveringRadius}}
\label{GeneralUpperBoundCoveringRadius}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneralUpperBoundCoveringRadius} returns an upper bound on the covering radius of \mbox{\texttt{C}}. It uses as many functions which names start with \texttt{UpperBoundCoveringRadius} as possible to find the best known upper bound (at least that \textsf{GUAVA} knows of). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(10,5,GF(2));
  a  [10,5,?] randomly generated code over GF(2)
  gap> GeneralUpperBoundCoveringRadius(C);
  4
  gap> CoveringRadius(C);
  3
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LowerBoundCoveringRadiusSphereCovering}}
\logpage{[ 7, 2, 6 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LowerBoundCoveringRadiusSphereCovering( n, M[, F,] false )\index{LowerBoundCoveringRadiusSphereCovering@\texttt{LowerBoundCoveringRadiusSphereCovering}}
\label{LowerBoundCoveringRadiusSphereCovering}
}\hfill{\scriptsize (function)}}\\


 This command can also be called using the syntax \texttt{LowerBoundCoveringRadiusSphereCovering( n, r, [F,] true )}. If the last argument of \texttt{LowerBoundCoveringRadiusSphereCovering} is \mbox{\texttt{false}}, then it returns a lower bound for the covering radius of a code of size \mbox{\texttt{M}} and length \mbox{\texttt{n}}. Otherwise, it returns a lower bound for the size of a code of length \mbox{\texttt{n}} and covering radius \mbox{\texttt{r}}. 

 \mbox{\texttt{F}} is the field over which the code is defined. If \mbox{\texttt{F}} is omitted, it is assumed that the code is over $GF(2)$. The bound is computed according to the sphere covering bound: 
\[ M \cdot V_q(n,r) \geq q^n \]
 where $V_q(n,r)$ is the size of a sphere of radius $r$ in $GF(q)^n$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(10,5,GF(2));
  a  [10,5,?] randomly generated code over GF(2)
  gap> Size(C);
  32
  gap> CoveringRadius(C);
  3
  gap> LowerBoundCoveringRadiusSphereCovering(10,32,GF(2),false);
  2
  gap> LowerBoundCoveringRadiusSphereCovering(10,3,GF(2),true);
  6
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LowerBoundCoveringRadiusVanWee1}}
\logpage{[ 7, 2, 7 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LowerBoundCoveringRadiusVanWee1( n, M[, F,] false )\index{LowerBoundCoveringRadiusVanWee1@\texttt{LowerBoundCoveringRadiusVanWee1}}
\label{LowerBoundCoveringRadiusVanWee1}
}\hfill{\scriptsize (function)}}\\


 This command can also be called using the syntax \texttt{LowerBoundCoveringRadiusVanWee1( n, r, [F,] true )}. If the last argument of \texttt{LowerBoundCoveringRadiusVanWee1} is \mbox{\texttt{false}}, then it returns a lower bound for the covering radius of a code of size \mbox{\texttt{M}} and length \mbox{\texttt{n}}. Otherwise, it returns a lower bound for the size of a code of length \mbox{\texttt{n}} and covering radius \mbox{\texttt{r}}. 

 \mbox{\texttt{F}} is the field over which the code is defined. If \mbox{\texttt{F}} is omitted, it is assumed that the code is over $GF(2)$. 

 The Van Wee bound is an improvement of the sphere covering bound: 
\[ M \cdot \left\{ V_q(n,r) - \frac{{n \choose r}}{\lceil\frac{n-r}{r+1}\rceil}
\left(\left\lceil\frac{n+1}{r+1}\right\rceil - \frac{n+1}{r+1}\right) \right\}
\geq q^n \]
 }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(10,5,GF(2));
  a  [10,5,?] randomly generated code over GF(2)
  gap> Size(C);
  32
  gap> CoveringRadius(C);
  3
  gap> LowerBoundCoveringRadiusVanWee1(10,32,GF(2),false);
  2
  gap> LowerBoundCoveringRadiusVanWee1(10,3,GF(2),true);
  6
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LowerBoundCoveringRadiusVanWee2}}
\logpage{[ 7, 2, 8 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LowerBoundCoveringRadiusVanWee2( n, M, false )\index{LowerBoundCoveringRadiusVanWee2@\texttt{LowerBoundCoveringRadiusVanWee2}}
\label{LowerBoundCoveringRadiusVanWee2}
}\hfill{\scriptsize (function)}}\\


 This command can also be called using the syntax \texttt{LowerBoundCoveringRadiusVanWee2( n, r [,true] )}. If the last argument of \texttt{LowerBoundCoveringRadiusVanWee2} is \mbox{\texttt{false}}, then it returns a lower bound for the covering radius of a code of size \mbox{\texttt{M}} and length \mbox{\texttt{n}}. Otherwise, it returns a lower bound for the size of a code of length \mbox{\texttt{n}} and covering radius \mbox{\texttt{r}}. 

 This bound only works for binary codes. It is based on the following
inequality: 
\[ M \cdot \frac{\left( \left( V_2(n,2) - \frac{1}{2}(r+2)(r-1) \right) V_2(n,r)
+ \varepsilon V_2(n,r-2) \right)} {(V_2(n,2) - \frac{1}{2}(r+2)(r-1) +
\varepsilon)} \geq 2^n, \]
 where 
\[ \varepsilon = {r+2 \choose 2} \left\lceil {n-r+1 \choose 2} / {r+2 \choose 2}
\right\rceil - {n-r+1 \choose 2}. \]
 }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(10,5,GF(2));
  a  [10,5,?] randomly generated code over GF(2)
  gap> Size(C);
  32
  gap> CoveringRadius(C);
  3
  gap> LowerBoundCoveringRadiusVanWee2(10,32,false);
  2
  gap> LowerBoundCoveringRadiusVanWee2(10,3,true);
  7
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LowerBoundCoveringRadiusCountingExcess}}
\logpage{[ 7, 2, 9 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LowerBoundCoveringRadiusCountingExcess( n, M, false )\index{LowerBoundCoveringRadiusCountingExcess@\texttt{LowerBoundCoveringRadiusCountingExcess}}
\label{LowerBoundCoveringRadiusCountingExcess}
}\hfill{\scriptsize (function)}}\\


 This command can also be called with \texttt{LowerBoundCoveringRadiusCountingExcess( n, r [,true] )}. If the last argument of \texttt{LowerBoundCoveringRadiusCountingExcess} is \mbox{\texttt{false}}, then it returns a lower bound for the covering radius of a code of size \mbox{\texttt{M}} and length \mbox{\texttt{n}}. Otherwise, it returns a lower bound for the size of a code of length \mbox{\texttt{n}} and covering radius \mbox{\texttt{r}}. 

 This bound only works for binary codes. It is based on the following
inequality: 
\[ M \cdot \left( \rho V_2(n,r) + \varepsilon V_2(n,r-1) \right) \geq (\rho +
\varepsilon) 2^n, \]
 where 
\[ \varepsilon = (r+1) \left\lceil\frac{n+1}{r+1}\right\rceil - (n+1) \]
 and 
\[ \rho = \left\{ \begin{array}{l} n-3+\frac{2}{n}, \ \ \ \ \ \ {\rm if}\ r = 2\\
n-r-1 , \ \ \ \ \ \ {\rm if}\ r \geq 3 . \end{array} \right. \]
 }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(10,5,GF(2));
  a  [10,5,?] randomly generated code over GF(2)
  gap> Size(C);
  32
  gap> CoveringRadius(C);
  3
  gap> LowerBoundCoveringRadiusCountingExcess(10,32,false);
  0
  gap> LowerBoundCoveringRadiusCountingExcess(10,3,true);
  7
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LowerBoundCoveringRadiusEmbedded1}}
\logpage{[ 7, 2, 10 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LowerBoundCoveringRadiusEmbedded1( n, M, false )\index{LowerBoundCoveringRadiusEmbedded1@\texttt{LowerBoundCoveringRadiusEmbedded1}}
\label{LowerBoundCoveringRadiusEmbedded1}
}\hfill{\scriptsize (function)}}\\


 This command can also be called with \texttt{LowerBoundCoveringRadiusEmbedded1( n, r [,true] )}. If the last argument of \texttt{LowerBoundCoveringRadiusEmbedded1} is 'false', then it returns a lower bound for the covering radius of a code of
size \mbox{\texttt{M}} and length \mbox{\texttt{n}}. Otherwise, it returns a lower bound for the size of a code of length \mbox{\texttt{n}} and covering radius \mbox{\texttt{r}}. 

 This bound only works for binary codes. It is based on the following
inequality: 
\[ M \cdot \left( V_2(n,r) - {2r \choose r} \right) \geq 2^n - A( n, 2r+1 ) {2r
\choose r}, \]
 where $A(n,d)$ denotes the maximal cardinality of a (binary) code of length $n$ and minimum distance $d$. The function \texttt{UpperBound} is used to compute this value. 

 Sometimes \texttt{LowerBoundCoveringRadiusEmbedded1} is better than \texttt{LowerBoundCoveringRadiusEmbedded2}, sometimes it is the other way around. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(10,5,GF(2));
  a  [10,5,?] randomly generated code over GF(2)
  gap> Size(C);
  32
  gap> CoveringRadius(C);
  3
  gap> LowerBoundCoveringRadiusEmbedded1(10,32,false);
  2
  gap> LowerBoundCoveringRadiusEmbedded1(10,3,true);
  7
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LowerBoundCoveringRadiusEmbedded2}}
\logpage{[ 7, 2, 11 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LowerBoundCoveringRadiusEmbedded2( n, M, false )\index{LowerBoundCoveringRadiusEmbedded2@\texttt{LowerBoundCoveringRadiusEmbedded2}}
\label{LowerBoundCoveringRadiusEmbedded2}
}\hfill{\scriptsize (function)}}\\


 This command can also be called with \texttt{LowerBoundCoveringRadiusEmbedded2( n, r [,true] )}. If the last argument of \texttt{LowerBoundCoveringRadiusEmbedded2} is 'false', then it returns a lower bound for the covering radius of a code of
size \mbox{\texttt{M}} and length \mbox{\texttt{n}}. Otherwise, it returns a lower bound for the size of a code of length \mbox{\texttt{n}} and covering radius \mbox{\texttt{r}}. 

 This bound only works for binary codes. It is based on the following
inequality: 
\[ M \cdot \left( V_2(n,r) - \frac{3}{2} {2r \choose r} \right) \geq 2^n - 2A( n,
2r+1 ) {2r \choose r}, \]
 where $A(n,d)$ denotes the maximal cardinality of a (binary) code of length $n$ and minimum distance $d$. The function \texttt{UpperBound} is used to compute this value. 

 Sometimes \texttt{LowerBoundCoveringRadiusEmbedded1} is better than \texttt{LowerBoundCoveringRadiusEmbedded2}, sometimes it is the other way around. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(15,5,GF(2));
  a  [15,5,?] randomly generated code over GF(2)
  gap> Size(C);
  32
  gap> CoveringRadius(C);
  6
  gap> LowerBoundCoveringRadiusEmbedded2(10,32,false);
  2
  gap> LowerBoundCoveringRadiusEmbedded2(10,3,true);
  7
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LowerBoundCoveringRadiusInduction}}
\logpage{[ 7, 2, 12 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LowerBoundCoveringRadiusInduction( n, r )\index{LowerBoundCoveringRadiusInduction@\texttt{LowerBoundCoveringRadiusInduction}}
\label{LowerBoundCoveringRadiusInduction}
}\hfill{\scriptsize (function)}}\\


 \texttt{LowerBoundCoveringRadiusInduction} returns a lower bound for the size of a code with length \mbox{\texttt{n}} and covering radius \mbox{\texttt{r}}. 

 If $n = 2r+2$ and $r \geq 1$, the returned value is $4$. 

 If $n = 2r+3$ and $r \geq 1$, the returned value is $7$. 

 If $n = 2r+4$ and $r \geq 4$, the returned value is $8$. 

 Otherwise, $0$ is returned. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(15,5,GF(2));
  a  [15,5,?] randomly generated code over GF(2)
  gap> CoveringRadius(C);
  5
  gap> LowerBoundCoveringRadiusInduction(15,6);
  7
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{UpperBoundCoveringRadiusRedundancy}}
\logpage{[ 7, 2, 13 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UpperBoundCoveringRadiusRedundancy( C )\index{UpperBoundCoveringRadiusRedundancy@\texttt{UpperBoundCoveringRadiusRedundancy}}
\label{UpperBoundCoveringRadiusRedundancy}
}\hfill{\scriptsize (function)}}\\


 \texttt{UpperBoundCoveringRadiusRedundancy} returns the redundancy of \mbox{\texttt{C}} as an upper bound for the covering radius of \mbox{\texttt{C}}. \mbox{\texttt{C}} must be a linear code. }

 \index{external distance} 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(15,5,GF(2));
  a  [15,5,?] randomly generated code over GF(2)
  gap> CoveringRadius(C);
  5
  gap> UpperBoundCoveringRadiusRedundancy(C);
  10
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{UpperBoundCoveringRadiusDelsarte}}
\logpage{[ 7, 2, 14 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UpperBoundCoveringRadiusDelsarte( C )\index{UpperBoundCoveringRadiusDelsarte@\texttt{UpperBoundCoveringRadiusDelsarte}}
\label{UpperBoundCoveringRadiusDelsarte}
}\hfill{\scriptsize (function)}}\\


 \texttt{UpperBoundCoveringRadiusDelsarte} returns an upper bound for the covering radius of \mbox{\texttt{C}}. This upper bound is equal to the external distance of \mbox{\texttt{C}}, this is the minimum distance of the dual code, if \mbox{\texttt{C}} is a linear code. 

 This is described in Theorem 11.3.3 of \cite{HP03}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(15,5,GF(2));
  a  [15,5,?] randomly generated code over GF(2)
  gap> CoveringRadius(C);
  5
  gap> UpperBoundCoveringRadiusDelsarte(C);
  13
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{UpperBoundCoveringRadiusStrength}}
\logpage{[ 7, 2, 15 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UpperBoundCoveringRadiusStrength( C )\index{UpperBoundCoveringRadiusStrength@\texttt{UpperBoundCoveringRadiusStrength}}
\label{UpperBoundCoveringRadiusStrength}
}\hfill{\scriptsize (function)}}\\


 \texttt{UpperBoundCoveringRadiusStrength} returns an upper bound for the covering radius of \mbox{\texttt{C}}. 

 First the code is punctured at the zero coordinates (i.e. the coordinates
where all codewords have a zero). If the remaining code has \emph{strength} 1 (i.e. each coordinate contains each element of the field an equal number of
times), then it returns $\frac{q-1}{q}m + (n-m)$ (where $q$ is the size of the field and $m$ is the length of punctured code), otherwise it returns $n$. This bound works for all codes. }

 \index{strength} 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(15,5,GF(2));
  a  [15,5,?] randomly generated code over GF(2)
  gap> CoveringRadius(C);
  5
  gap> UpperBoundCoveringRadiusStrength(C);
  7
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{UpperBoundCoveringRadiusGriesmerLike}}
\logpage{[ 7, 2, 16 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UpperBoundCoveringRadiusGriesmerLike( C )\index{UpperBoundCoveringRadiusGriesmerLike@\texttt{UpperBoundCoveringRadiusGriesmerLike}}
\label{UpperBoundCoveringRadiusGriesmerLike}
}\hfill{\scriptsize (function)}}\\


 This function returns an upper bound for the covering radius of \mbox{\texttt{C}}, which must be linear, in a Griesmer-like fashion. It returns 
\[ n - \sum_{i=1}^k \left\lceil \frac{d}{q^i} \right\rceil \]
 }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=RandomLinearCode(15,5,GF(2));
  a  [15,5,?] randomly generated code over GF(2)
  gap> CoveringRadius(C);
  5
  gap> UpperBoundCoveringRadiusGriesmerLike(C);
  9
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{UpperBoundCoveringRadiusCyclicCode}}
\logpage{[ 7, 2, 17 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UpperBoundCoveringRadiusCyclicCode( C )\index{UpperBoundCoveringRadiusCyclicCode@\texttt{UpperBoundCoveringRadiusCyclicCode}}
\label{UpperBoundCoveringRadiusCyclicCode}
}\hfill{\scriptsize (function)}}\\


 This function returns an upper bound for the covering radius of \mbox{\texttt{C}}, which must be a cyclic code. It returns 
\[ n - k + 1 - \left\lceil \frac{w(g(x))}{2} \right\rceil, \]
 where $g(x)$ is the generator polynomial of \mbox{\texttt{C}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C:=CyclicCodes(15,GF(2))[3];
  a cyclic [15,12,1..2]1..3 enumerated code over GF(2)
  gap> CoveringRadius(C);
  3
  gap> UpperBoundCoveringRadiusCyclicCode(C);
  3
  
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Special matrices in \textsf{GUAVA} }}\logpage{[ 7, 3, 0 ]}
{
  \label{Special matrices in GUAVA} This section explains functions that work with special matrices \textsf{GUAVA} needs for several codes. 

 Firstly, we describe some matrix generating functions (see \texttt{KrawtchoukMat} (\ref{KrawtchoukMat}), \texttt{GrayMat} (\ref{GrayMat}), \texttt{SylvesterMat} (\ref{SylvesterMat}), \texttt{HadamardMat} (\ref{HadamardMat}) and \texttt{MOLS} (\ref{MOLS})). 

 Next we describe two functions regarding a standard form of matrices (see \texttt{PutStandardForm} (\ref{PutStandardForm}) and \texttt{IsInStandardForm} (\ref{IsInStandardForm})). 

 Then we describe functions that return a matrix after a manipulation (see \texttt{PermutedCols} (\ref{PermutedCols}), \texttt{VerticalConversionFieldMat} (\ref{VerticalConversionFieldMat}) and \texttt{HorizontalConversionFieldMat} (\ref{HorizontalConversionFieldMat})). 

 Finally, we describe functions that do some tests on matrices (see \texttt{IsLatinSquare} (\ref{IsLatinSquare}) and \texttt{AreMOLS} (\ref{AreMOLS})). 

\subsection{\textcolor{Chapter }{KrawtchoukMat}}
\logpage{[ 7, 3, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{KrawtchoukMat( n, q )\index{KrawtchoukMat@\texttt{KrawtchoukMat}}
\label{KrawtchoukMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{KrawtchoukMat} returns the $n+1$ by $n+1$ matrix $K=(k_{ij})$ defined by $k_{ij}=K_i(j)$ for $i,j=0,...,n$. $K_i(j)$ is the Krawtchouk number (see \texttt{Krawtchouk} (\ref{Krawtchouk})). \mbox{\texttt{n}} must be a positive integer and \mbox{\texttt{q}} a prime power. The Krawtchouk matrix is used in the \emph{MacWilliams identities}, defining the relation between the weight distribution of a code of length \mbox{\texttt{n}} over a field of size \mbox{\texttt{q}}, and its dual code. Each call to \texttt{KrawtchoukMat} returns a new matrix, so it is safe to modify the result. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> PrintArray( KrawtchoukMat( 3, 2 ) );
  [ [   1,   1,   1,   1 ],
    [   3,   1,  -1,  -3 ],
    [   3,  -1,  -1,   3 ],
    [   1,  -1,   1,  -1 ] ]
  gap> C := HammingCode( 3 );; a := WeightDistribution( C );
  [ 1, 0, 0, 7, 7, 0, 0, 1 ]
  gap> n := WordLength( C );; q := Size( LeftActingDomain( C ) );;
  gap> k := Dimension( C );;
  gap> q^( -k ) * KrawtchoukMat( n, q ) * a;
  [ 1, 0, 0, 0, 7, 0, 0, 0 ]
  gap> WeightDistribution( DualCode( C ) );
  [ 1, 0, 0, 0, 7, 0, 0, 0 ] 
\end{Verbatim}
 \index{Gary code} 

\subsection{\textcolor{Chapter }{GrayMat}}
\logpage{[ 7, 3, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GrayMat( n, F )\index{GrayMat@\texttt{GrayMat}}
\label{GrayMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{GrayMat} returns a list of all different vectors (see \textsf{GAP}'s \texttt{Vectors} command) of length \mbox{\texttt{n}} over the field \mbox{\texttt{F}}, using Gray ordering. \mbox{\texttt{n}} must be a positive integer. This order has the property that subsequent
vectors differ in exactly one coordinate. The first vector is always the null
vector. Each call to \texttt{GrayMat} returns a new matrix, so it is safe to modify the result. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> GrayMat(3);
  [ [ 0*Z(2), 0*Z(2), 0*Z(2) ], [ 0*Z(2), 0*Z(2), Z(2)^0 ],
    [ 0*Z(2), Z(2)^0, Z(2)^0 ], [ 0*Z(2), Z(2)^0, 0*Z(2) ],
    [ Z(2)^0, Z(2)^0, 0*Z(2) ], [ Z(2)^0, Z(2)^0, Z(2)^0 ],
    [ Z(2)^0, 0*Z(2), Z(2)^0 ], [ Z(2)^0, 0*Z(2), 0*Z(2) ] ]
  gap> G := GrayMat( 4, GF(4) );; Length(G);
  256          # the length of a GrayMat is always $q^n$
  gap> G[101] - G[100];
  [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{SylvesterMat}}
\logpage{[ 7, 3, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SylvesterMat( n )\index{SylvesterMat@\texttt{SylvesterMat}}
\label{SylvesterMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{SylvesterMat} returns the $n\times n$ Sylvester matrix of order \mbox{\texttt{n}}. This is a special case of the Hadamard matrices (see \texttt{HadamardMat} (\ref{HadamardMat})). For this construction, \mbox{\texttt{n}} must be a power of $2$. Each call to \texttt{SylvesterMat} returns a new matrix, so it is safe to modify the result. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> PrintArray(SylvesterMat(2));
  [ [   1,   1 ],
    [   1,  -1 ] ]
  gap> PrintArray( SylvesterMat(4) );
  [ [   1,   1,   1,   1 ],
    [   1,  -1,   1,  -1 ],
    [   1,   1,  -1,  -1 ],
    [   1,  -1,  -1,   1 ] ] 
\end{Verbatim}
 \index{Hadamard matrix} 

\subsection{\textcolor{Chapter }{HadamardMat}}
\logpage{[ 7, 3, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{HadamardMat( n )\index{HadamardMat@\texttt{HadamardMat}}
\label{HadamardMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{HadamardMat} returns a Hadamard matrix of order \mbox{\texttt{n}}. This is an $n\times n$ matrix with the property that the matrix multiplied by its transpose returns \mbox{\texttt{n}} times the identity matrix. This is only possible for $n=1, n=2$ or in cases where \mbox{\texttt{n}} is a multiple of $4$. If the matrix does not exist or is not known (as of 1998), \texttt{HadamardMat} returns an error. A large number of construction methods is known to create
these matrices for different orders. \texttt{HadamardMat} makes use of two construction methods (among which the Sylvester construction
-- see \texttt{SylvesterMat} (\ref{SylvesterMat})). These methods cover most of the possible Hadamard matrices, although some
special algorithms have not been implemented yet. The following orders less
than $100$ do not yet have an implementation for a Hadamard matrix in \textsf{GUAVA}: $28, 36, 52, 76, 92$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C := HadamardMat(8);; PrintArray(C);
  [ [   1,   1,   1,   1,   1,   1,   1,   1 ],
    [   1,  -1,   1,  -1,   1,  -1,   1,  -1 ],
    [   1,   1,  -1,  -1,   1,   1,  -1,  -1 ],
    [   1,  -1,  -1,   1,   1,  -1,  -1,   1 ],
    [   1,   1,   1,   1,  -1,  -1,  -1,  -1 ],
    [   1,  -1,   1,  -1,  -1,   1,  -1,   1 ],
    [   1,   1,  -1,  -1,  -1,  -1,   1,   1 ],
    [   1,  -1,  -1,   1,  -1,   1,   1,  -1 ] ]
  gap> C * TransposedMat(C) = 8 * IdentityMat( 8, 8 );
  true 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{VandermondeMat}}
\logpage{[ 7, 3, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{VandermondeMat( X, a )\index{VandermondeMat@\texttt{VandermondeMat}}
\label{VandermondeMat}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{VandermondeMat} returns the $(a+1)\times n$ matrix of powers $x_i^j$ where \mbox{\texttt{X}} is a list of elements of a field, $X=\{ x_1,...,x_n\}$, and \mbox{\texttt{a}} is a non-negative integer. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> M:=VandermondeMat([Z(5),Z(5)^2,Z(5)^0,Z(5)^3],2);
  [ [ Z(5)^0, Z(5), Z(5)^2 ], [ Z(5)^0, Z(5)^2, Z(5)^0 ],
    [ Z(5)^0, Z(5)^0, Z(5)^0 ], [ Z(5)^0, Z(5)^3, Z(5)^2 ] ]
  gap> Display(M);
   1 2 4
   1 4 1
   1 1 1
   1 3 4
\end{Verbatim}
  \index{standard form} 

\subsection{\textcolor{Chapter }{PutStandardForm}}
\logpage{[ 7, 3, 6 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PutStandardForm( M[, idleft] )\index{PutStandardForm@\texttt{PutStandardForm}}
\label{PutStandardForm}
}\hfill{\scriptsize (function)}}\\


 We say that a $k\times n$ matrix is in \emph{standard form} if it is equal to the block matrix $(I\ |\ A)$, for some $k\times (n-k)$ matrix $A$ and where $I$ is the $k\times k$ identity matrix. It follows from a basis result in linear algebra that, after
a possible permutation of the columns, using elementary row operations, every
matrix can be reduced to standard form. \texttt{PutStandardForm} puts a matrix \mbox{\texttt{M}} in standard form, and returns the permutation needed to do so. \mbox{\texttt{idleft}} is a boolean that sets the position of the identity matrix in \mbox{\texttt{M}}. (The default for \mbox{\texttt{idleft}} is `true'.) If \mbox{\texttt{idleft}} is set to `true', the identity matrix is put on the left side of \mbox{\texttt{M}}. Otherwise, it is put at the right side. (This option is useful when putting
a check matrix of a code into standard form.) The function \texttt{BaseMat} also returns a similar standard form, but does not apply column permutations.
The rows of the matrix still span the same vector space after \texttt{BaseMat}, but after calling \texttt{PutStandardForm}, this is not necessarily true. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> M := Z(2)*[[1,0,0,1],[0,0,1,1]];; PrintArray(M);
  [ [    Z(2),  0*Z(2),  0*Z(2),    Z(2) ],
    [  0*Z(2),  0*Z(2),    Z(2),    Z(2) ] ]
  gap> PutStandardForm(M);                   # identity at the left side
  (2,3)
  gap> PrintArray(M);
  [ [    Z(2),  0*Z(2),  0*Z(2),    Z(2) ],
    [  0*Z(2),    Z(2),  0*Z(2),    Z(2) ] ]
  gap> PutStandardForm(M, false);            # identity at the right side
  (1,4,3)
  gap> PrintArray(M);
  [ [  0*Z(2),    Z(2),    Z(2),  0*Z(2) ],
    [  0*Z(2),    Z(2),  0*Z(2),    Z(2) ] ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsInStandardForm}}
\logpage{[ 7, 3, 7 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsInStandardForm( M[, idleft] )\index{IsInStandardForm@\texttt{IsInStandardForm}}
\label{IsInStandardForm}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsInStandardForm} determines if \mbox{\texttt{M}} is in standard form. \mbox{\texttt{idleft}} is a boolean that indicates the position of the identity matrix in \mbox{\texttt{M}}, as in \texttt{PutStandardForm} (see \texttt{PutStandardForm} (\ref{PutStandardForm})). \texttt{IsInStandardForm} checks if the identity matrix is at the left side of \mbox{\texttt{M}}, otherwise if it is at the right side. The elements of \mbox{\texttt{M}} may be elements of any field. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsInStandardForm(IdentityMat(7, GF(2)));
  true
  gap> IsInStandardForm([[1, 1, 0], [1, 0, 1]], false);
  true
  gap> IsInStandardForm([[1, 3, 2, 7]]);
  true
  gap> IsInStandardForm(HadamardMat(4));
  false 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{PermutedCols}}
\logpage{[ 7, 3, 8 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PermutedCols( M, P )\index{PermutedCols@\texttt{PermutedCols}}
\label{PermutedCols}
}\hfill{\scriptsize (function)}}\\


 \texttt{PermutedCols} returns a matrix \mbox{\texttt{M}} with a permutation \mbox{\texttt{P}} applied to its columns. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> M := [[1,2,3,4],[1,2,3,4]];; PrintArray(M);
  [ [  1,  2,  3,  4 ],
    [  1,  2,  3,  4 ] ]
  gap> PrintArray(PermutedCols(M, (1,2,3)));
  [ [  3,  1,  2,  4 ],
    [  3,  1,  2,  4 ] ] 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{VerticalConversionFieldMat}}
\logpage{[ 7, 3, 9 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{VerticalConversionFieldMat( M, F )\index{VerticalConversionFieldMat@\texttt{VerticalConversionFieldMat}}
\label{VerticalConversionFieldMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{VerticalConversionFieldMat} returns the matrix \mbox{\texttt{M}} with its elements converted from a field $F=GF(q^m)$, $q$ prime, to a field $GF(q)$. Each element is replaced by its representation over the latter field, placed
vertically in the matrix, using the $GF(p)$-vector space isomorphism 
\[ [...] : GF(q)\rightarrow GF(p)^m, \]
 with $q=p^m$. 

 If \mbox{\texttt{M}} is a $k$ by $n$ matrix, the result is a $k\cdot m \times n$ matrix, since each element of $GF(q^m)$ can be represented in $GF(q)$ using $m$ elements. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> M := Z(9)*[[1,2],[2,1]];; PrintArray(M);
  [ [    Z(3^2),  Z(3^2)^5 ],
    [  Z(3^2)^5,    Z(3^2) ] ]
  gap> DefaultField( Flat(M) );
  GF(3^2)
  gap> VCFM := VerticalConversionFieldMat( M, GF(9) );; PrintArray(VCFM);
  [ [  0*Z(3),  0*Z(3) ],
    [  Z(3)^0,    Z(3) ],
    [  0*Z(3),  0*Z(3) ],
    [    Z(3),  Z(3)^0 ] ]
  gap> DefaultField( Flat(VCFM) );
  GF(3) 
\end{Verbatim}
 A similar function is \texttt{HorizontalConversionFieldMat} (see \texttt{HorizontalConversionFieldMat} (\ref{HorizontalConversionFieldMat})). 

\subsection{\textcolor{Chapter }{HorizontalConversionFieldMat}}
\logpage{[ 7, 3, 10 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{HorizontalConversionFieldMat( M, F )\index{HorizontalConversionFieldMat@\texttt{HorizontalConversionFieldMat}}
\label{HorizontalConversionFieldMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{HorizontalConversionFieldMat} returns the matrix \mbox{\texttt{M}} with its elements converted from a field $F=GF(q^m)$, $q$ prime, to a field $GF(q)$. Each element is replaced by its representation over the latter field, placed
horizontally in the matrix. 

 If \mbox{\texttt{M}} is a $k \times n$ matrix, the result is a $k\times m\times n\cdot m$ matrix. The new word length of the resulting code is equal to $n\cdot m$, because each element of $GF(q^m)$ can be represented in $GF(q)$ using $m$ elements. The new dimension is equal to $k\times m$ because the new matrix should be a basis for the same number of vectors as the
old one. 

 \texttt{ConversionFieldCode} uses horizontal conversion to convert a code (see \texttt{ConversionFieldCode} (\ref{ConversionFieldCode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> M := Z(9)*[[1,2],[2,1]];; PrintArray(M);
  [ [    Z(3^2),  Z(3^2)^5 ],
    [  Z(3^2)^5,    Z(3^2) ] ]
  gap> DefaultField( Flat(M) );
  GF(3^2)
  gap> HCFM := HorizontalConversionFieldMat(M, GF(9));; PrintArray(HCFM);
  [ [  0*Z(3),  Z(3)^0,  0*Z(3),    Z(3) ],
    [  Z(3)^0,  Z(3)^0,    Z(3),    Z(3) ],
    [  0*Z(3),    Z(3),  0*Z(3),  Z(3)^0 ],
    [    Z(3),    Z(3),  Z(3)^0,  Z(3)^0 ] ]
  gap> DefaultField( Flat(HCFM) );
  GF(3) 
\end{Verbatim}
 A similar function is \texttt{VerticalConversionFieldMat} (see \texttt{VerticalConversionFieldMat} (\ref{VerticalConversionFieldMat})). \index{mutually orthogonal Latin squares} \index{Latin square} 

\subsection{\textcolor{Chapter }{MOLS}}
\logpage{[ 7, 3, 11 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MOLS( q[, n] )\index{MOLS@\texttt{MOLS}}
\label{MOLS}
}\hfill{\scriptsize (function)}}\\


 \texttt{MOLS} returns a list of \mbox{\texttt{n}} \emph{Mutually Orthogonal Latin Squares} (MOLS). A \emph{Latin square} of order \mbox{\texttt{q}} is a $q\times q$ matrix whose entries are from a set $F_{q}$ of \mbox{\texttt{q}} distinct symbols (\textsf{GUAVA} uses the integers from $0$ to \mbox{\texttt{q}}) such that each row and each column of the matrix contains each symbol
exactly once. 

 A set of Latin squares is a set of MOLS if and only if for each pair of Latin
squares in this set, every ordered pair of elements that are in the same
position in these matrices occurs exactly once. 

 \mbox{\texttt{n}} must be less than \mbox{\texttt{q}}. If \mbox{\texttt{n}} is omitted, two MOLS are returned. If \mbox{\texttt{q}} is not a prime power, at most $2$ MOLS can be created. For all values of \mbox{\texttt{q}} with $q > 2$ and $q \neq 6$, a list of MOLS can be constructed. However, \textsf{GUAVA} does not yet construct MOLS for $q\equiv 2 \pmod 4$. If it is not possible to construct \mbox{\texttt{n}} MOLS, the function returns `false'. 

 MOLS are used to create \mbox{\texttt{q}}-ary codes (see \texttt{MOLSCode} (\ref{MOLSCode})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> M := MOLS( 4, 3 );;PrintArray( M[1] );
  [ [  0,  1,  2,  3 ],
    [  1,  0,  3,  2 ],
    [  2,  3,  0,  1 ],
    [  3,  2,  1,  0 ] ]
  gap> PrintArray( M[2] );
  [ [  0,  2,  3,  1 ],
    [  1,  3,  2,  0 ],
    [  2,  0,  1,  3 ],
    [  3,  1,  0,  2 ] ]
  gap> PrintArray( M[3] );
  [ [  0,  3,  1,  2 ],
    [  1,  2,  0,  3 ],
    [  2,  1,  3,  0 ],
    [  3,  0,  2,  1 ] ]
  gap> MOLS( 12, 3 );
  false 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsLatinSquare}}
\logpage{[ 7, 3, 12 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsLatinSquare( M )\index{IsLatinSquare@\texttt{IsLatinSquare}}
\label{IsLatinSquare}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsLatinSquare} determines if a matrix \mbox{\texttt{M}} is a Latin square. For a Latin square of size $n\times n$, each row and each column contains all the integers $1,\dots,n$ exactly once. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsLatinSquare([[1,2],[2,1]]);
  true
  gap> IsLatinSquare([[1,2,3],[2,3,1],[1,3,2]]);
  false 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{AreMOLS}}
\logpage{[ 7, 3, 13 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AreMOLS( L )\index{AreMOLS@\texttt{AreMOLS}}
\label{AreMOLS}
}\hfill{\scriptsize (function)}}\\


 \texttt{AreMOLS} determines if \mbox{\texttt{L}} is a list of mutually orthogonal Latin squares (MOLS). For each pair of Latin
squares in this list, the function checks if each ordered pair of elements
that are in the same position in these matrices occurs exactly once. The
function \texttt{MOLS} creates MOLS (see \texttt{MOLS} (\ref{MOLS})). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> M := MOLS(4,2);
  [ [ [ 0, 1, 2, 3 ], [ 1, 0, 3, 2 ], [ 2, 3, 0, 1 ], [ 3, 2, 1, 0 ] ],
    [ [ 0, 2, 3, 1 ], [ 1, 3, 2, 0 ], [ 2, 0, 1, 3 ], [ 3, 1, 0, 2 ] ] ]
  gap> AreMOLS(M);
  true 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Some functions related to the norm of a code }}\logpage{[ 7, 4, 0 ]}
{
  \label{Some functions related to the norm of a code} In this section, some functions that can be used to compute the norm of a code
and to decide upon its normality are discussed. Typically, these are applied
to binary linear codes. The definitions of this section were introduced in
Graham and Sloane \cite{GS85}. 

\subsection{\textcolor{Chapter }{CoordinateNorm}}
\logpage{[ 7, 4, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CoordinateNorm( C, coord )\index{CoordinateNorm@\texttt{CoordinateNorm}}
\label{CoordinateNorm}
}\hfill{\scriptsize (function)}}\\


 \texttt{CoordinateNorm} returns the norm of \mbox{\texttt{C}} with respect to coordinate \mbox{\texttt{coord}}. If $C_a = \{ c \in C \ |\ c_{coord} = a \}$, then the norm of \mbox{\texttt{C}} with respect to \mbox{\texttt{coord}} is defined as 
\[ \max_{v \in GF(q)^n} \sum_{a=1}^q d(x,C_a), \]
 with the convention that $d(x,C_a) = n$ if $C_a$ is empty. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> CoordinateNorm( HammingCode( 3, GF(2) ), 3 );
  3 
\end{Verbatim}
 \index{norm of a code} 

\subsection{\textcolor{Chapter }{CodeNorm}}
\logpage{[ 7, 4, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CodeNorm( C )\index{CodeNorm@\texttt{CodeNorm}}
\label{CodeNorm}
}\hfill{\scriptsize (function)}}\\


 \texttt{CodeNorm} returns the norm of \mbox{\texttt{C}}. The \emph{norm} of a code is defined as the minimum of the norms for the respective
coordinates of the code. In effect, for each coordinate \texttt{CoordinateNorm} is called, and the minimum of the calculated numbers is returned. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> CodeNorm( HammingCode( 3, GF(2) ) );
  3 
\end{Verbatim}
 \index{acceptable coordinate} 

\subsection{\textcolor{Chapter }{IsCoordinateAcceptable}}
\logpage{[ 7, 4, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsCoordinateAcceptable( C, coord )\index{IsCoordinateAcceptable@\texttt{IsCoordinateAcceptable}}
\label{IsCoordinateAcceptable}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsCoordinateAcceptable} returns `true' if coordinate \mbox{\texttt{coord}} of \mbox{\texttt{C}} is acceptable. A coordinate is called \emph{acceptable} if the norm of the code with respect to that coordinate is not more than two
times the covering radius of the code plus one. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsCoordinateAcceptable( HammingCode( 3, GF(2) ), 3 );
  true 
\end{Verbatim}
 \index{acceptable coordinate} 

\subsection{\textcolor{Chapter }{GeneralizedCodeNorm}}
\logpage{[ 7, 4, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneralizedCodeNorm( C, subcode1, subscode2, ..., subcodek )\index{GeneralizedCodeNorm@\texttt{GeneralizedCodeNorm}}
\label{GeneralizedCodeNorm}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneralizedCodeNorm} returns the \mbox{\texttt{k}}-norm of \mbox{\texttt{C}} with respect to \mbox{\texttt{k}} subcodes. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> c := RepetitionCode( 7, GF(2) );;
  gap> ham := HammingCode( 3, GF(2) );;
  gap> d := EvenWeightSubcode( ham );;
  gap> e := ConstantWeightSubcode( ham, 3 );;
  gap> GeneralizedCodeNorm( ham, c, d, e );
  4 
\end{Verbatim}
 \index{normal code} 

\subsection{\textcolor{Chapter }{IsNormalCode}}
\logpage{[ 7, 4, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsNormalCode( C )\index{IsNormalCode@\texttt{IsNormalCode}}
\label{IsNormalCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsNormalCode} returns `true' if \mbox{\texttt{C}} is normal. A code is called \emph{normal} if the norm of the code is not more than two times the covering radius of the
code plus one. Almost all codes are normal, however some (non-linear) abnormal
codes have been found. 

 Often, it is difficult to find out whether a code is normal, because it
involves computing the covering radius. However, \texttt{IsNormalCode} uses much information from the literature (in particular, \cite{GS85}) about normality for certain code parameters. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsNormalCode( HammingCode( 3, GF(2) ) );
  true 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Miscellaneous functions }}\logpage{[ 7, 5, 0 ]}
{
  \label{Miscellaneous functions} In this section we describe several functions \textsf{GUAVA} uses for constructing codes or performing calculations with codes. 

 In this section, some new miscellaneous functions are described, including
weight enumerators, the MacWilliams-transform and affinity and almost affinity
of codes. \index{weight enumerator polynomial} 

\subsection{\textcolor{Chapter }{CodeWeightEnumerator}}
\logpage{[ 7, 5, 1 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CodeWeightEnumerator( C )\index{CodeWeightEnumerator@\texttt{CodeWeightEnumerator}}
\label{CodeWeightEnumerator}
}\hfill{\scriptsize (function)}}\\


 \texttt{CodeWeightEnumerator} returns a polynomial of the following form: 
\[ f(x) = \sum_{i=0}^{n} A_i x^i, \]
 where $A_i$ is the number of codewords in \mbox{\texttt{C}} with weight $i$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> CodeWeightEnumerator( ElementsCode( [ [ 0,0,0 ], [ 0,0,1 ],
  > [ 0,1,1 ], [ 1,1,1 ] ], GF(2) ) );
  x^3 + x^2 + x + 1
  gap> CodeWeightEnumerator( HammingCode( 3, GF(2) ) );
  x^7 + 7*x^4 + 7*x^3 + 1 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{CodeDistanceEnumerator}}
\logpage{[ 7, 5, 2 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CodeDistanceEnumerator( C, w )\index{CodeDistanceEnumerator@\texttt{CodeDistanceEnumerator}}
\label{CodeDistanceEnumerator}
}\hfill{\scriptsize (function)}}\\


 \texttt{CodeDistanceEnumerator} returns a polynomial of the following form: 
\[ f(x) = \sum_{i=0}^{n} B_i x^i, \]
 where $B_i$ is the number of codewords with distance $i$ to \mbox{\texttt{w}}. 

 If \mbox{\texttt{w}} is a codeword, then \texttt{CodeDistanceEnumerator} returns the same polynomial as \texttt{CodeWeightEnumerator}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> CodeDistanceEnumerator( HammingCode( 3, GF(2) ),[0,0,0,0,0,0,1] );
  x^6 + 3*x^5 + 4*x^4 + 4*x^3 + 3*x^2 + x
  gap> CodeDistanceEnumerator( HammingCode( 3, GF(2) ),[1,1,1,1,1,1,1] );
  x^7 + 7*x^4 + 7*x^3 + 1 # `[1,1,1,1,1,1,1]' $\in$ `HammingCode( 3, GF(2 ) )'
\end{Verbatim}
 \index{MacWilliams transform} 

\subsection{\textcolor{Chapter }{CodeMacWilliamsTransform}}
\logpage{[ 7, 5, 3 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CodeMacWilliamsTransform( C )\index{CodeMacWilliamsTransform@\texttt{CodeMacWilliamsTransform}}
\label{CodeMacWilliamsTransform}
}\hfill{\scriptsize (function)}}\\


 \texttt{CodeMacWilliamsTransform} returns a polynomial of the following form: 
\[ f(x) = \sum_{i=0}^{n} C_i x^i, \]
 where $C_i$ is the number of codewords with weight $i$ in the \emph{dual} code of \mbox{\texttt{C}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> CodeMacWilliamsTransform( HammingCode( 3, GF(2) ) );
  7*x^4 + 1 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsSelfComplementaryCode}}
\logpage{[ 7, 5, 4 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsSelfComplementaryCode( C )\index{IsSelfComplementaryCode@\texttt{IsSelfComplementaryCode}}
\label{IsSelfComplementaryCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsSelfComplementaryCode} returns `true' if 
\[ v \in code \Rightarrow 1 - v \in code, \]
 where $1$ is the all-one word of length $n$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsSelfComplementaryCode( HammingCode( 3, GF(2) ) );
  true
  gap> IsSelfComplementaryCode( EvenWeightSubcode(
  > HammingCode( 3, GF(2) ) ) );
  false 
\end{Verbatim}
 \index{affine code} 

\subsection{\textcolor{Chapter }{IsAffineCode}}
\logpage{[ 7, 5, 5 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsAffineCode( C )\index{IsAffineCode@\texttt{IsAffineCode}}
\label{IsAffineCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsAffineCode} returns `true' if \mbox{\texttt{C}} is an affine code. A code is called \emph{affine} if it is an affine space. In other words, a code is affine if it is a coset of
a linear code. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsAffineCode( HammingCode( 3, GF(2) ) );
  true
  gap> IsAffineCode( CosetCode( HammingCode( 3, GF(2) ),
  > [ 1, 0, 0, 0, 0, 0, 0 ] ) );
  true
  gap> IsAffineCode( NordstromRobinsonCode() );
  false 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsAlmostAffineCode}}
\logpage{[ 7, 5, 6 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsAlmostAffineCode( C )\index{IsAlmostAffineCode@\texttt{IsAlmostAffineCode}}
\label{IsAlmostAffineCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsAlmostAffineCode} returns `true' if \mbox{\texttt{C}} is an almost affine code. A code is called \emph{almost affine} if the size of any punctured code of \mbox{\texttt{C}} is $q^r$ for some $r$, where $q$ is the size of the alphabet of the code. Every affine code is also almost
affine, and every code over $GF(2)$ and $GF(3)$ that is almost affine is also affine. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> code := ElementsCode( [ [0,0,0], [0,1,1], [0,2,2], [0,3,3],
  >                             [1,0,1], [1,1,0], [1,2,3], [1,3,2],
  >                             [2,0,2], [2,1,3], [2,2,0], [2,3,1],
  >                             [3,0,3], [3,1,2], [3,2,1], [3,3,0] ],
  >                             GF(4) );;
  gap> IsAlmostAffineCode( code );
  true
  gap> IsAlmostAffineCode( NordstromRobinsonCode() );
  false 
\end{Verbatim}
 \index{Griesmer code} 

\subsection{\textcolor{Chapter }{IsGriesmerCode}}
\logpage{[ 7, 5, 7 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsGriesmerCode( C )\index{IsGriesmerCode@\texttt{IsGriesmerCode}}
\label{IsGriesmerCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsGriesmerCode} returns `true' if \mbox{\texttt{C}}, which must be a linear code, is Griesmer code, and `false' otherwise. A code
is called \emph{Griesmer} if its length satisfies 
\[ n = g[k,d] = \sum_{i=0}^{k-1} \lceil \frac{d}{q^i} \rceil. \]
 }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsGriesmerCode( HammingCode( 3, GF(2) ) );
  true
  gap> IsGriesmerCode( BCHCode( 17, 2, GF(2) ) );
  false 
\end{Verbatim}
 \index{density of a code} 

\subsection{\textcolor{Chapter }{CodeDensity}}
\logpage{[ 7, 5, 8 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CodeDensity( C )\index{CodeDensity@\texttt{CodeDensity}}
\label{CodeDensity}
}\hfill{\scriptsize (function)}}\\


 \texttt{CodeDensity} returns the \emph{density} of \mbox{\texttt{C}}. The density of a code is defined as 
\[ \frac{M \cdot V_q(n,t)}{q^n}, \]
 where $M$ is the size of the code, $V_q(n,t)$ is the size of a sphere of radius $t$ in $GF(q^n)$ (which may be computed using \texttt{SphereContent}), $t$ is the covering radius of the code and $n$ is the length of the code. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> CodeDensity( HammingCode( 3, GF(2) ) );
  1
  gap> CodeDensity( ReedMullerCode( 1, 4 ) );
  14893/2048 
\end{Verbatim}
 \index{perfect} 

\subsection{\textcolor{Chapter }{SphereContent}}
\logpage{[ 7, 5, 9 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SphereContent( n, t, F )\index{SphereContent@\texttt{SphereContent}}
\label{SphereContent}
}\hfill{\scriptsize (function)}}\\


 \texttt{SphereContent} returns the content of a ball of radius \mbox{\texttt{t}} around an arbitrary element of the vectorspace $F^n$. This is the cardinality of the set of all elements of $F^n$ that are at distance (see \texttt{DistanceCodeword} (\ref{DistanceCodeword}) less than or equal to \mbox{\texttt{t}} from an element of $F^n$. 

 In the context of codes, the function is used to determine if a code is
perfect. A code is \emph{perfect} if spheres of radius $t$ around all codewords contain exactly the whole vectorspace, where \emph{t} is the number of errors the code can correct. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> SphereContent( 15, 0, GF(2) );
  1    # Only one word with distance 0, which is the word itself
  gap> SphereContent( 11, 3, GF(4) );
  4984
  gap> C := HammingCode(5);
  a linear [31,26,3]1 Hamming (5,2) code over GF(2)
  #the minimum distance is 3, so the code can correct one error
  gap> ( SphereContent( 31, 1, GF(2) ) * Size(C) ) = 2 ^ 31;
  true 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Krawtchouk}}
\logpage{[ 7, 5, 10 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Krawtchouk( k, i, n, q )\index{Krawtchouk@\texttt{Krawtchouk}}
\label{Krawtchouk}
}\hfill{\scriptsize (function)}}\\


 \texttt{Krawtchouk} returns the Krawtchouk number $K_{k}(i)$. \mbox{\texttt{q}} must be a prime power, \mbox{\texttt{n}} must be a positive integer, \mbox{\texttt{k}} must be a non-negative integer less then or equal to \mbox{\texttt{n}} and \mbox{\texttt{i}} can be any integer. (See \texttt{KrawtchoukMat} (\ref{KrawtchoukMat})). This number is the value at $x=i$ of the polynomial 
\[ K_k^{n,q}(x) =\sum_{j=0}^n (-1)^j(q-1)^{k-j}b(x,j)b(n-x,k-j), \]
 where $b(v,u)=u!/(v!(v-u)!)$ is the binomial coefficient if $u,v$ are
integers. For more properties of these polynomials, see \cite{MS83}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> Krawtchouk( 2, 0, 3, 2);
  3 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{PrimitiveUnityRoot}}
\logpage{[ 7, 5, 11 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PrimitiveUnityRoot( F, n )\index{PrimitiveUnityRoot@\texttt{PrimitiveUnityRoot}}
\label{PrimitiveUnityRoot}
}\hfill{\scriptsize (function)}}\\


 \texttt{PrimitiveUnityRoot} returns a primitive \mbox{\texttt{n}}-th root of unity in an extension field of \mbox{\texttt{F}}. This is a finite field element $a$ with the property $a^n=1$ in \mbox{\texttt{F}}, and \mbox{\texttt{n}} is the smallest integer such that this equality holds. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> PrimitiveUnityRoot( GF(2), 15 );
  Z(2^4)
  gap> last^15;
  Z(2)^0
  gap> PrimitiveUnityRoot( GF(8), 21 );
  Z(2^6)^3 
\end{Verbatim}
 \index{reciprocal polynomial} 

\subsection{\textcolor{Chapter }{ReciprocalPolynomial}}
\logpage{[ 7, 5, 12 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ReciprocalPolynomial( P )\index{ReciprocalPolynomial@\texttt{ReciprocalPolynomial}}
\label{ReciprocalPolynomial}
}\hfill{\scriptsize (function)}}\\


 \texttt{ReciprocalPolynomial} returns the \emph{reciprocal} of polynomial \mbox{\texttt{P}}. This is a polynomial with coefficients of \mbox{\texttt{P}} in the reverse order. So if $P=a_0 + a_1 X + ... + a_{n} X^{n}$, the reciprocal polynomial is $P'=a_{n} + a_{n-1} X + ... + a_0 X^{n}$. 

 This command can also be called using the syntax \texttt{ReciprocalPolynomial( P , n )}. In this form, the number of coefficients of \mbox{\texttt{P}} is assumed to be less than or equal to $n+1$ (with zero coefficients added in the highest degrees, if necessary).
Therefore, the reciprocal polynomial also has degree $n+1$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> P := UnivariatePolynomial( GF(3), Z(3)^0 * [1,0,1,2] );
  Z(3)^0+x_1^2-x_1^3
  gap> RecP := ReciprocalPolynomial( P );
  -Z(3)^0+x_1+x_1^3
  gap> ReciprocalPolynomial( RecP ) = P;
  true 
  gap> P := UnivariatePolynomial( GF(3), Z(3)^0 * [1,0,1,2] );
  Z(3)^0+x_1^2-x_1^3
  gap> ReciprocalPolynomial( P, 6 );
  -x_1^3+x_1^4+x_1^6
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CyclotomicCosets}}
\logpage{[ 7, 5, 13 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CyclotomicCosets( q, n )\index{CyclotomicCosets@\texttt{CyclotomicCosets}}
\label{CyclotomicCosets}
}\hfill{\scriptsize (function)}}\\


 \texttt{CyclotomicCosets} returns the cyclotomic cosets of $q \pmod n$. \mbox{\texttt{q}} and \mbox{\texttt{n}} must be relatively prime. Each of the elements of the returned list is a list
of integers that belong to one cyclotomic coset. A $q$-cyclotomic coset of $s \pmod n$ is a set of the form $\{s,sq,sq^2,...,sq^{r-1}\}$, where $r$ is the smallest positive integer such that $sq^r-s$ is $0 \pmod n$. In other words, each coset contains all multiplications of the coset
representative by $q \pmod n$. The coset representative is the smallest integer that isn't in the previous
cosets. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> CyclotomicCosets( 2, 15 );
  [ [ 0 ], [ 1, 2, 4, 8 ], [ 3, 6, 12, 9 ], [ 5, 10 ],
    [ 7, 14, 13, 11 ] ]
  gap> CyclotomicCosets( 7, 6 );
  [ [ 0 ], [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ] ] 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{WeightHistogram}}
\logpage{[ 7, 5, 14 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{WeightHistogram( C[, h] )\index{WeightHistogram@\texttt{WeightHistogram}}
\label{WeightHistogram}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{WeightHistogram} plots a histogram of weights in code \mbox{\texttt{C}}. The maximum length of a column is \mbox{\texttt{h}}. Default value for \mbox{\texttt{h}} is $1/3$ of the size of the screen. The number that appears at the top of the histogram
is the maximum value of the list of weights. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> H := HammingCode(2, GF(5));
  a linear [6,4,3]1 Hamming (2,5) code over GF(5)
  gap> WeightDistribution(H);
  [ 1, 0, 0, 80, 120, 264, 160 ]
  gap> WeightHistogram(H);
  264----------------
                 *
                 *
                 *
                 *
                 *  *
              *  *  *
           *  *  *  *
           *  *  *  *
  +--------+--+--+--+--
  0  1  2  3  4  5  6 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CoefficientToPolynomial}}
\logpage{[ 7, 5, 15 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CoefficientToPolynomial( coeffs, R )\index{CoefficientToPolynomial@\texttt{CoefficientToPolynomial}}
\label{CoefficientToPolynomial}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{CoefficientToPolynomial} returns the degree $d-1$ polynomial $c_0+c_1x+...+c_{d-1}x^{d-1}$, where \mbox{\texttt{coeffs}} is a list of elements of a field, $coeffs=\{ c_0,...,c_{d-1}\}$, and \mbox{\texttt{R}} is a univariate polynomial ring. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> F:=GF(11);
  GF(11)
  gap> R1:=PolynomialRing(F,["a"]);;
  gap> var1:=IndeterminatesOfPolynomialRing(R1);; a:=var1[1];;
  gap> coeffs:=Z(11)^0*[1,2,3,4];
  [ Z(11)^0, Z(11), Z(11)^8, Z(11)^2 ]
  gap> CoefficientToPolynomial(coeffs,R1);
  Z(11)^2*a^3+Z(11)^8*a^2+Z(11)*a+Z(11)^0
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DegreesMonomialTerm}}
\logpage{[ 7, 5, 16 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DegreesMonomialTerm( m, R )\index{DegreesMonomialTerm@\texttt{DegreesMonomialTerm}}
\label{DegreesMonomialTerm}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{DegreesMonomialTerm} returns the list of degrees to which each variable in the multivariate
polynomial ring \mbox{\texttt{R}} occurs in the monomial \mbox{\texttt{m}}, where \mbox{\texttt{coeffs}} is a list of elements of a field. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> F:=GF(11);
  GF(11)
  gap> R1:=PolynomialRing(F,["a"]);;
  gap> var1:=IndeterminatesOfPolynomialRing(R1);; a:=var1[1];;
  gap> b:=X(F,"b",var1);
  b
  gap> var2:=Concatenation(var1,[b]);
  [ a, b ]
  gap> R2:=PolynomialRing(F,var2);
  PolynomialRing(..., [ a, b ])
  gap> c:=X(F,"c",var2);
  c
  gap> var3:=Concatenation(var2,[c]);
  [ a, b, c ]
  gap> R3:=PolynomialRing(F,var3);
  PolynomialRing(..., [ a, b, c ])
  gap> m:=b^3*c^7;
  b^3*c^7
  gap> DegreesMonomialTerm(m,R3);
  [ 0, 3, 7 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DivisorsMultivariatePolynomial}}
\logpage{[ 7, 5, 17 ]}\nobreak
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DivisorsMultivariatePolynomial( f, R )\index{DivisorsMultivariatePolynomial@\texttt{DivisorsMultivariatePolynomial}}
\label{DivisorsMultivariatePolynomial}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{DivisorsMultivariatePolynomial} returns the list of polynomial divisors of \mbox{\texttt{f}} in the multivariate polynomial ring \mbox{\texttt{R}} with coefficients in a field. This program uses a simple but slow algorithm
(see Joachim von zur Gathen, J\"urgen Gerhard, \cite{GG03}, exercise 16.10) which first converts the multivariate polynomial \mbox{\texttt{f}} to an associated univariate polynomial $f^*$, then \texttt{Factors} $f^*$, and finally converts these univariate factors back into the multivariate
polynomial factors of \mbox{\texttt{f}}. Since \texttt{Factors} is non-deterministic, \texttt{DivisorsMultivariatePolynomial} is non-deterministic as well. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> R2:=PolynomialRing(GF(3),["x1","x2"]);
  PolynomialRing(..., [ x1, x2 ])
  gap> vars:=IndeterminatesOfPolynomialRing(R2);
  [ x1, x2 ]
  gap> x2:=vars[2];
  x2
  gap> x1:=vars[1];
  x1
  gap> f:=x1^3+x2^3;;
  gap> DivisorsMultivariatePolynomial(f,R2);
  [ x1+x2, x1+x2, x1+x2 ]
\end{Verbatim}
  }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}}

\bibliographystyle{alpha}
\bibliography{guava}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
