\Chapter{A polycyclic quotient algorithm}

The IPCQ package contains an algorithm for computing the largest polycyclic 
quotient of a given finitely presented group $G$ if $G$ has such a quotient.
There are various methods available to determine finite polycyclic quotients
of certain types for a finitely presented group. In contrast, the quotients 
determined by this package can also be infinite. Thus we called the package 
IPCQ package standing for ``infinite polycyclic quotients''.

The algorithm in this package proceeds by induction downwards along the 
derived series of $G$; that is, in the $i$-th inductive step the algorithm 
determines a polycyclic presentation for the $i$-th factor of its derived 
series $G/G^{(i)}$ if this factor is polycyclic. We recall that this factor
is polycyclic if and only if the previous derived factor $G / G^{(i-1)}$ is 
polycyclic and the abelian group $G^{(i-1)}/ G^{(i)}$ is finitely generated.

The groups computed by this package are polycyclically presented and the 
{\it Polycyclic} package \cite{polycyc} is used to facilitate the underlying 
arithmetic for these groups. Further, the IPCQ package uses the {\it Vecenum} 
package \cite{ve}. Both packages must be installed to use the IPCQ pacakge.

The implementation of this package is based on an algorithm developed by
B. Eick and A. C. Niemeyer in \cite{ENi00}. This method can be considered
as an extension of the algorithm by A. C. Niemeyer \cite{Nie94} to compute 
finite polycyclic quotients. While our algorithm covers a more general case,
we also note that the finite polycyclic group algorithm is usually more 
effective than our implementation. An alternative approach to computing
infinite polycyclic quotients is described by E. H. Lo \cite{Lo98b}. Lo's
alternative approach and Niemeyer's finite group method are both available 
as standalone programs and as a GAP 3 packages. 

There are various other algorithms with implementations available to 
compute certain more specific types of quotients such as finite polycyclic
quotients (\cite{Nie94, Ple87}), nilpotent quotients (\cite{Nic95}) or
$p$-group quotients (\cite{NOb96}). These implementations are usually more
effective on their special case than the method implemented here.

\Section{Computing polycyclic quotients}

The main header function of this package is

\> PolycyclicQuotient( <G> )

The input <G> is a finitely presented group. The function computes a 
polycyclic presented group <H> which is isomorphic to the largest polycyclic 
quotient of <G>. An explicit isomorphism is stored as <H>!.isomorphism.
Note that this function does not terminate if <G> does not have a largest
polycyclic quotient. We also note that the function can be time-consuming
if <G> has a large polycyclic quotient.

Information on the proceeding of the algorithm can be obtained by 

\> InfoIPCQ

This function takes values between 0 (no information) to 3 (full information).
If InfoIPCQ is set to 1, then the abelian invariants of the of quotients 
$G^{(i-1)}/G^{(i)}$ are printed after the $i$-th iteration step. If InfoIPCQ 
is set to a higher level, then more internal information on the underlying 
algorithm is printed. 

\Section{Calling the algorithm stepwise}

In many cases it is useful to call the polycyclic quotient algorithm stepwise
by hand. The functions for this purpose are 

\> InitQSystem( <G> )
\> NextStepQSystem( <Q> )
\> GroupByQSystem( <Q> )

The function 'InitQSystem' takes as input a finitely presented group <G>
and returns a quotient system <Q>. This quotient system <Q> represents the
derived quotient $G/G'$. 

The function 'NextStepQSystem' takes as input a quotient system <Q> 
representing a quotient $G/G^{(i)}$. It modifies this quotient system <Q>
in place to a quotient system representing the next quotient $G/G^{(i+1)}$. 
Note that this function does not terminate if the next quotient $G/G^{(i+1)}$
is not polycyclic (that is, if $G^{(i)}/G^{(i+1)}$ is not finitely generated).

The function 'GroupByQSystem' computes a polycyclically presented group <H>
corresponding to the input quotient system <Q>. An explicit epimorphism from
the underlying finitely presented group <G> onto <H> is stored in 
<H>!.isomorphism.

Quotient systems are records storing the information used by the algorithm
implemented in this package in a computationally useful format. 

\Section{Examples}

The function 'FpExamples( <n>, <m> )' provides some <n>-generator finitely
presented groups which we use in the following. The following example is
the infinite dihedral group.

\beginexample
gap> SetInfoLevel( InfoIPCQ, 1 );
gap> F := FpExamples(2,1);
<fp group on the generators [ f1, f2 ]>
gap> RelatorsOfFpGroup(F);
[ f1^-1*f2*f1*f2, f1^2 ]
gap> PolycyclicQuotient(F);
#I  init step yields orders : [ 2, 2 ]
#I  next step yields orders : [ 0 ]
#I  next step yields orders : [  ]
Pcp-group with orders [ 2, 2, 0 ]
\endexample

Next, we consider a 1-relator group. 

\beginexample
gap> F := FpExamples(2,3);
<fp group of size infinity on the generators [ f1, f2 ]>
gap> RelatorsOfFpGroup(F);
[ f1*f2*f1*f2^-1 ]
gap> PolycyclicQuotient(F);
#I  init step yields orders : [ 2, 0 ]
#I  next step yields orders : [ 0 ]
#I  next step yields orders : [  ]
Pcp-group with orders [ 2, 0, 0 ]
\endexample

The following group does not have a largest polycyclic quotient. However,
its derived length 2 quotient is polycyclic and we can compute it in the
following way.

\beginexample
gap> F := FpExamples(2,5);
<fp group on the generators [ f1, f2 ]>
gap> RelatorsOfFpGroup(F);
[ f2^-1*f1^-1*f2*f1^-1*f2^-1*f1*f2*f1, f1^-1*f2^-2*f1*f2^-2*f1^-1*f2^2*f1*f2^
    -1*f1^-1*f2^-1*f1*f2^8*f1^-1*f2^-1*f1*f2^-7*f1^-1*f2*f1*f2^6*f1^
    -1*f2*f1*f2^-4, f2^-1*f1^-1*f2*f1*f2^-1*f1^-1*f2*f1 ]
gap> Q := InitQSystem(F);;
#I  init step yields orders : [ 0, 0 ]
gap> NextStepQSystem(Q);
#I  next step yields orders : [ 2, 2, 2 ]
gap> H := GroupByQSystem(Q);
Pcp-group with orders [ 0, 0, 2, 2, 2 ]
gap> H!.isomorphism;
[ f1, f2 ] -> [ g1, g2 ]
\endexample

\Section{More details on the induction step}

The inductive step is facilitated by the function 'NextStepQSystem'. This
function takes a quotient system <Q> representing $G/G^{(i)}$ for the 
underlying finitely presented group <G>. It modifies this quotient system
to a quotient system for $G/G^{(i+1)}$ in three steps:

\beginitems
(1) & compute a module presentation $M$ for the abelian group 
      $G^{(i)}/G^{(i+1)}$ as a $G/G^{(i)}$-module. The generators for 
      this module presentation are called 'tails' and they correspond to 
      certain relations of the polycyclic presentation for $G/G^{(i)}$ 
      defined by <Q> or to certain generators of <G>.
      
(2) & compute an integral matrix representation for $M$; that is, determine 
      an explicit finitely generated abelian group $A$ isomorphic to 
      $G^{(i)}/G^{(i+1)}$. For each tail compute a corresponding element of $A$
      and for each generator of $G/G^{(i)}$ compute a corresponding 
      automorphism of $A$.

(3) & extend the polycyclic presentation for $G/G^{(i)}$ in <Q> by the abelian
      group $A$ to a polycyclic presentation for $G/G^{(i+1)}$. This step can
      now be read off from the information obtained in (2).
\enditems

These three steps can also be computed using the following functions.

\> ModulePresInt( <Q>, <flags> )
\> RunZme( <Q>, <M> )
\> ExtendQSystem( <Q>, <M>, <N> )

The function 'ModulePresInt' takes as input a quotient system <Q> and a 
record <flags> describing the tails which should be used by the algorithm. 
Using the empty record as <flags> yields that all tails are considered and 
this is the default case. The function returns a module presentation <M>.

The function 'RunZme' takes as input a quotient system <Q> and a module
presentation <M>. It computes an integral matrix representation <N> for
<M> if <M> is a presentation for a finitely generated group. Otherwise
the function does not terminate. This function uses the vector enumerator.

The function 'ExtendQSystem' takes as input a quotient system <Q>, a 
module presentation <M> and its integral matrix representation <N> for
<M> and <Q>. It modifies <Q> such that the resulting quotient system 
describes the extension of <N> by <Q>.

\> PrettyPrintMPres( <M> )

Takes as input a module presentation <M> and prints it in a more readable
format. 

Step (2) in the above list is facilitated by the vector enumerator. It is
often very difficult to predict the runtime used by this algorithm. Also,
if it is not known a priori that the considered module has a representation
by a finitely generated group, then it is also unclear whether this part
of the algorithm will terminate. To give an overview on the progress of 
the vector enumeration algorithm, there is the global variable 'PRINTVE'.
If this variable is set to true, then information about the process of the 
vector enumeration applications is provided.

\beginexample
gap> F;
<fp group on the generators [ f1, f2, f5, f6 ]>
gap> RelatorsOfFpGroup(F);
[ f2^-1*f6*f2*f6^-1, f1^-1*f2*f1*f2^-1, f1^-1*f6*f1*f6^-1, f5^-1*f6*f5*f6^-1, 
  f6^-1*f1*f6^-2*f1, f2*f1^-1*f2^3*f1^-1, 
  f6*f2^-1*f5*f2*f6^-2*f2^-1*f5^-1*f2*f6, 
  f2^-1*f5^-1*f2*f6*f5*f2^-1*f6*f5*f2*f5^-1, f1^-1*f5*f1^7*f5, 
  f2^-1*f5^-1*f6^-1*f2^-1*f5*f2^-1*f5^-1*f2^-1*f6*f5*f6, 
  f6^-1*f1^-1*f6^-1*f2^-1*f5^-1*f6^-1*f2*f1^-1*f6^-2*f2^-1*f5^-1*f6^-1*f2, 
  f2*f5^-1*f1*f2^-1*f1*f5*f6^-2*f2^-1*f6^-1*f2^-1*f5*f2*f5^-1*f2, 
  f5^-1*f6*f1*f2^-1*f1*f5*f1^-1*f5*f1^-1*f6^-2*f1^-1*f2*f6*f5^-1*f1, 
  f2^-1*f6^-1*f2^-2*f5*f2^-1*f6*f5*f6*f2*f5^-1*f6*f1*f2^-1*f1*f5^-1, 
  f6*f2^-1*f5*f2*f6*f2*f6*f5^-1*f2^2*f6^-1*f5^-1*f6^-1*f2^-2*f6^-1*f5*f2^-1 ]

gap> Q := InitQSystem(F);;
#I  init step yields orders : [ 2, 4, 2, 2 ]

# The next iteration step is a little time-consuming. We use the available
# print routines to observe the proceeding of the algorithm in more detail.

gap> SetInfoLevel(InfoIPCQ, 2);
gap> PRINTVE := true;;

gap> NextStepQSystem(Q);
#I    compute module presentation 
#I    call zme, 16 tails, 41 rels
  #VE: pushing at 1 of 149 ........................................ finished
  #VE: pushing at 2 of 432 ........................................ finished
  #VE: pushing at 3 of 695 ........................................ finished
  #VE: pushing at 4 of 824 ............................. finished
  #VE: pushing at 5 of 901 ........................................ finished
  #VE: pushing at 6 of 985 ..................................... finished
  #VE: pushing at 7 of 1132 ......... finished
  #VE: pushing at 8 of 1162 ........................................ finished
  #VE: pushing at 9 of 1283 ........................................ finished
  #VE: pushing at 11 of 1404 .... finished
  #VE: pushing at 12 of 1477 . finished
  #VE: pushing at 13 of 1509 .... finished
  #VE: pushing at 14 of 1560 .. finished
  #VE: pushing at 16 of 1594 ... finished
  #VE: pushing at 50 of 1630 ....................... finished
  #VE: pushing at 268 of 1774 ........................................ finished
  #VE: pushing at 269 of 1897 ...... finished
#I  next step yields orders : [ 2, 0, 0, 0 ]
\endexample

