#############################################################################
##
#W  classify.gd            GAP 4 package `genus'                Thomas Breuer
##
#H  @(#)$Id: classify.gd,v 1.3 2002/05/24 15:06:47 gap Exp $
##
#Y  Copyright (C)  1999,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
##
Revision.( "pkg/genus/classify_gd" ) :=
    "@(#)$Id: classify.gd,v 1.3 2002/05/24 15:06:47 gap Exp $";


#############################################################################
##
#F  RHInfo( <tbl> )
##
##  is a record with components
##
##  `repcycsub'
##      list of positions of representatives of cyclic subgroups,
##      ordered according to ascending element orders.
##
##  `T'
##      the transformation matrix $T$,
##      rows and columns indexed by `repcycsub',
##      such that
##      $$
##         v + (g_0;l_{\chi}^G(H))_{H\in CY(G)/\sim} \cdot T =
##              (a_{\varphi})_{\varphi\in Rat(G)} ,
##      $$
##      where $v$ is a constant vector and the coefficients $a_{\varphi}$
##      are given by $\chi = \sum_{\varphi\in Rat(G)} a_{\varphi} \varphi$.
##
##  `v'
##      the constant vector
##
DeclareGlobalFunction( "RHInfo" );


#############################################################################
##
#F  InfiniteSeriesOfExceptions( <tbl>, <repcycsub> )
##
##  is a list of lists, each describing an infinite series of
##  {\RH}-characters of the group $G$ with character table <tbl>
##  that do not come from Riemann surfaces.
##
##  Such a series has one of the following structures, with $g_0 = 1$.
##  1. $l_{\chi}(H)$ vanishes outside a central subgroup of prime order,
##     and either $G$ is abelian or $G$ cannot be generated by $3$
##     elements.
##  2. $l_{\chi}(H)$ vanishes outside a normal subgroup that is maximal
##     with the property to be properly contained in the derived subgroup
##     of $G$.
##
##  Each series is given by the positions of those cyclic subgroups $H$
##  in <repccysub> for which the value of $l_{\chi}(H)$ must be zero.
##
DeclareGlobalFunction( "InfiniteSeriesOfExceptions" );


#############################################################################
##
#F  NextVectorSameL1Norm( <v> )
##
##  Let <v> be a list of nonnegative integers.
##  We order all such lists with equal sum of entries lexicographically.
##  The successor of <v> w.r.t.~this ordering is returned if it exists,
##  otherwise `fail' is returned.
##
##  Let $v = [ v_1, v_2, \ldots, v_n ]$, and assume that the largest index
##  with nonzero entry is $s$.
##  (Set $s = 1$ if all entries are zero.)
##  Then any vector that is larger than $v$ must differ from $v$ in the
##  positions smaller than $s$.
##  So $v$ has a successor with same sum of entries if and only if $s > 1$.
##  In this case, the successor is
##  $[ v_1, v_2, \ldots, v_{s-2}, v_{s-1}+1, 0, \ldots, 0, v_s-1 ]$.
##
DeclareGlobalFunction( "NextVectorSameL1Norm" );


#############################################################################
##
#F  ClassifyCharactersFromRiemannSurfaces( <G> )
#F  ClassifyCharactersFromRiemannSurfaces( <G>, <range> )
##
##  Let <G> be a group, and <range> a list of nonnegative values of
##  $g_0$ to be tested.
##
##  `ClassifyCharactersFromRiemannSurfaces' returns a record with components
##
##  \beginitems
##  `rep' &
##      list of vectors $l$ describing representatives of <G>-characters
##      that come from Riemann surfaces,
##
##  `V' &
##      list of {\RH}-vectors $l$ belonging to <G>-characters
##      that do not come from Riemann surfaces;
##      together with the characters described by `I',
##      these are all such <G>-characters,
##
##  `I' &
##      list of {\RH}-vectors, each describing an infinite series of
##      <G>-characters that do not come from Riemann surfaces,
##
##  `S' &
##      list of vectors $l$ that fail to be {\RH}-vectors because of
##      condition 24.1 (iii),
##
##  `nreps' &
##      number of bound entries in `rep',
##
##  `time' &
##      the time that was needed for the computations.
##  \enditems
##
DeclareGlobalFunction( "ClassifyCharactersFromRiemannSurfaces" );


#############################################################################
##
#f  MyInducedCyclic( <tbl> )
#f  MyInducedCyclic( <tbl>, \"all\" )
#f  MyInducedCyclic( <tbl>, <classes> )
#f  MyInducedCyclic( <tbl>, <classes>, \"all\" )
##
#T  *not* returning a set!
##


#############################################################################
##
#F  ClassifyCharactersFromRiemannSurfaces2( <G> )
##
##  returns a record with components
##
##  \beginitems
##  `rep' &
##      list of vectors $l$ describing representatives of <G>-characters
##      that come from Riemann surfaces,
##
##  `V' &
##      list of {\RH}-vectors $l$ belonging to <G>-characters
##      that do not come from Riemann surfaces;
##      together with the characters described by `I',
##      these are all such <G>-characters,
##
##  `I' &
##      list of {\RH}-vectors, each describing an infinite series of
##      <G>-characters that do not come from Riemann surfaces,
##
##  `S' &
##      list of vectors $l$ that fail to be {\RH}-vectors because of
##      condition 24.1 (iii),
##
##  `nreps' &
##      number of bound entries in `rep',
##
##  `time' &
##      the time that was needed for the computations.
##  \enditems
##
DeclareGlobalFunction( "ClassifyCharactersFromRiemannSurfaces2" );


#############################################################################
##
#E

