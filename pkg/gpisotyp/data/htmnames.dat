#############################################################################
##
#W  htmnames.dat         GAP 4 package `gpisotyp'               Thomas Breuer
##
#H  @(#)$Id: htmnames.dat,v 1.2 2002/05/13 15:43:29 gap Exp $
##
#Y  Copyright (C)  2002,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
##
##  This file contains the HTML names defined by the package.
##  It is notified via an `AUTO' statement in `gap/stdnames.gd'.
##
Revision.( "gpisotyp/gap/htmnames_dat" ) :=
    "@(#)$Id: htmnames.dat,v 1.2 2002/05/13 15:43:29 gap Exp $";


#############################################################################
##
#V  HTMLNamesOfGroups
##
##  When this file is read automatically, we set the components `sortnames'
##  and `TestNotificationsOfNames' initially to `false';
##  after reading the file, the components are set to `true'.
##  (The consistency checks are performed when the file is read from
##  `tst/stdnames.tst'.)
##
if IsReadOnlyGlobal( "HTMLNamesOfGroups" ) then
  MakeReadWriteGlobal( "HTMLNamesOfGroups" );
  UnbindGlobal( "HTMLNamesOfGroups" );
fi;
HTMLNamesOfGroups := EmptyNameTranslatorObject( rec(
    NormalizedName           := LowercaseString,
    ParseFunction            := ParseForwardsWithSuffix,
    SortNames                := GpIsoTypGlobals.SortNames,
    TestNotificationsOfNames := GpIsoTypGlobals.TestNotificationsOfNames ) );
MakeReadOnlyGlobal( "HTMLNamesOfGroups" );


#############################################################################
##
##  Introduce shorthands that will be removed again in the end.
##
NIHNOG:= NotifyIndividualHTMLNameOfGroup;
NPHNOG:= NotifyParametrizedHTMLNameOfGroup;


#############################################################################
##
##  cyclic groups C<n>, $<n> \geq 1$
##  alternating groups A<n>, $<n> \geq 1$
##  symmetric groups S<n>, $<n> \geq 1$
##
for p in [ "C","A","S" ] do
  NPHNOG( [ p, IsDigitChar ],
          [ Concatenation( p, "<sub>" ), IsDigitChar, "</sub>" ],
          [ 2, "IsPosInt" ],
          [ 2, "IdFunc", 2 ] );
od;


#############################################################################
##
##  sporadic simple groups
##
for entry in StandardizerForNamesOfGroups.SporadicSimpleGroupInfo do
  pos:= PositionProperty( entry[1], IsDigitChar );
  if pos <> fail then
    NIHNOG( entry[1], Concatenation( entry[1]{ [ 1 .. pos-1 ] }, "<sub>",
            entry[1]{ [ pos .. Length( entry[1] ) ] }, "</sub>" ) );
  elif entry[1] <> "McL" then
    NIHNOG( entry[1], entry[1] );
  else
    NIHNOG( "McL", "M<sup>c</sup>L" );
  fi;
od;


#############################################################################
##
##  projective special linear groups L<n>(<q>), <q> a prime power
##  projective special unitary groups U<n>(<q>), <q> a prime power
##  projective symplectic groups S<n>(<q>), <n> even, <q> a prime power
##  orthogonal groups O<n>(<q>), <n> odd, <q> an odd prime power
##
for p in [ ["L","IsPosInt"], ["U","IsPosInt"], ["S","IsEvenInt"],
           ["O","IsOddInt"] ] do
  NPHNOG( [ p[1], IsDigitChar, "(", IsDigitChar, ")" ],
          [ Concatenation( p[1], "<sub>" ), IsDigitChar, "</sub>(",
            IsDigitChar, ")" ],
          [ 2, p[2],
            4, "IsPrimePowerInt" ],
          [ 2, "IdFunc", 2,
            4, "IdFunc", 4 ] );
od;


#############################################################################
##
##  orthogonal groups O<n>+(<q>), <n> even, <q> a prime power
##  orthogonal groups O<n>-(<q>), <n> even, <q> a prime power
##
for p in [ "+", "-" ] do
  NPHNOG( [ "O", IsDigitChar, Concatenation( p, "(" ), IsDigitChar, ")" ],
          [ Concatenation( "O<sup>", p, "</sup><sub>" ), IsDigitChar,
                "</sub>(", IsDigitChar, ")" ],
          [ 2, "IsEvenInt",
            4, "IsPrimePowerInt" ],
          [ 2, "IdFunc", 2,
            4, "IdFunc", 4 ] );
od;


#############################################################################
##
##  exceptional groups F4(<q>), <q> a prime power
##  exceptional groups G2(<q>), <q> a prime power
##  exceptional groups E<n>(<q>), $<n> \in \{ 6, 7, 8 \}$, <q> a prime power
##
for p in [ ["F","4"], ["G","2"], ["E","6"], ["E","7"], ["E","8"] ] do
  NPHNOG( [ Concatenation( p[1], p[2], "(" ), IsDigitChar, ")" ],
          [ Concatenation( p[1], "<sub>", p[2], "</sub>(" ),
            IsDigitChar, ")" ],
          [ 2, "IsPrimePowerInt" ],
          [ 2, "IdFunc", 2 ] );
od;


#############################################################################
##
##  exceptional groups 2E6(<q>), <q> a prime power
##  exceptional groups 3D4(<q>), <q> a prime power
##  exceptional groups 2G2(<q>), <q> a prime power
##  exceptional groups 2F4(<q>), <q> a power of $2$
##
for p in [ ["2","E","6"], ["3","D","4"], ["2","G","2"], ["2","F","4"] ] do
  NPHNOG( [ Concatenation( p[1], p[2], p[3], "(" ), IsDigitChar, ")" ],
          [ Concatenation( "<sup>", p[1], "</sup>", p[2], "<sub>", p[3],
                "</sub>(" ), IsDigitChar, ")" ],
          [ 2, "IsPrimePowerInt" ],
          [ 2, "IdFunc", 2 ] );
od;


#############################################################################
##
##  exceptional Suzuki groups Sz(<q>), <q> an odd power of $2$
##
NPHNOG( [ "Sz(", IsDigitChar, ")" ],
        [ "Sz(", IsDigitChar, ")" ],
        [ 2, "IsPrimePowerInt" ],
        [ 2, "IdFunc", 2 ] );


#############################################################################
##
##  Remove the shorthands,
##  sort the lists, and reset the components of the name translator object.
##
Unbind( NIHNOG );
Unbind( NPHNOG );

SortParallel( HTMLNamesOfGroups.IndividualAdmissibleNames,
              HTMLNamesOfGroups.IndividualTranslatedNames );
HTMLNamesOfGroups.SortNames := true;
HTMLNamesOfGroups.TestNotificationsOfNames := true;


#############################################################################
##
#E

