#############################################################################
##
#W  mkupname.dat         GAP 4 package `gpisotyp'               Thomas Breuer
##
#H  @(#)$Id: mkupname.dat,v 1.1 2002/07/10 15:41:09 gap Exp $
##
#Y  Copyright (C)  2002,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
##
##  This file contains the markup names defined by the package.
##  It is notified via an `AUTO' statement in `gap/stdnames.gd'.
##  The names are used to create {\LaTeX} and HTML formats.
##
Revision.( "gpisotyp/gap/mkupname_dat" ) :=
    "@(#)$Id: mkupname.dat,v 1.1 2002/07/10 15:41:09 gap Exp $";


#############################################################################
##
#V  MarkupNamesOfGroups
##
##  When this file is read automatically, we set the components `sortnames'
##  and `TestNotificationsOfNames' initially to `false';
##  after reading the file, the components are set to `true'.
##  (The consistency checks are performed when the file is read from
##  `tst/stdnames.tst'.)
##
BindGlobal( "MarkupNamesOfGroups",
    EmptyNameTranslatorObject( rec(
    NormalizedName           := LowercaseString,
    ParseFunction            := ParseForwardsWithSuffix,
    SortNames                := GpIsoTypGlobals.SortNames,
    TestNotificationsOfNames := GpIsoTypGlobals.TestNotificationsOfNames ) )
    );


#############################################################################
##
##  Introduce shorthands that will be removed again in the end.
##
NIN:= function( name, translation )
    NotifyIndividualTranslatedName( MarkupNamesOfGroups, name, translation );
end;

NPN:= function( nameformat, translatedformat, conditions, map )
    NotifyParametrizedTranslatedName( MarkupNamesOfGroups, nameformat,
        translatedformat, conditions, map );
end;


#############################################################################
##
##  cyclic groups C<n>, $<n> \geq 1$
##  alternating groups A<n>, $<n> \geq 1$
##  symmetric groups S<n>, $<n> \geq 1$
##
for p in [ "C","A","S" ] do
  NPN( [ p, IsDigitChar ],
       [ Concatenation( p, "<sub>" ), IsDigitChar, "</sub>" ],
       [ 2, "IsPosInt" ],
       [ 2, "IdFunc", 2 ] );
od;


#############################################################################
##
##  sporadic simple groups
##
for entry in StandardizerForNamesOfGroups.SporadicSimpleGroupInfo do
  pos:= PositionProperty( entry[1], IsDigitChar );
  if pos <> fail then
    NIN( entry[1], Concatenation( entry[1]{ [ 1 .. pos-1 ] }, "<sub>",
         entry[1]{ [ pos .. Length( entry[1] ) ] }, "</sub>" ) );
  elif entry[1] = "McL" then
    NIN( "McL", "M<sup>c</sup>L" );
  else
    NIN( entry[1], entry[1] );
  fi;
od;


#############################################################################
##
##  projective special linear groups L<n>(<q>), <q> a prime power
##  projective special unitary groups U<n>(<q>), <q> a prime power
##  projective symplectic groups S<n>(<q>), <n> even, <q> a prime power
##  orthogonal groups O<n>(<q>), <n> odd, <q> an odd prime power
##
for p in [ ["L","IsPosInt"], ["U","IsPosInt"], ["S","IsEvenInt"],
           ["O","IsOddInt"] ] do
  NPN( [ p[1], IsDigitChar, "(", IsDigitChar, ")" ],
       [ Concatenation( p[1], "<sub>" ), IsDigitChar, "</sub>(",
         IsDigitChar, ")" ],
       [ 2, p[2],
         4, "IsPrimePowerInt" ],
       [ 2, "IdFunc", 2,
         4, "IdFunc", 4 ] );
od;


#############################################################################
##
##  orthogonal groups O<n>+(<q>), <n> even, <q> a prime power
##  orthogonal groups O<n>-(<q>), <n> even, <q> a prime power
##
for p in [ "+", "-" ] do
  NPN( [ "O", IsDigitChar, Concatenation( p, "(" ), IsDigitChar, ")" ],
       [ Concatenation( "O^", p, "<sub>" ), IsDigitChar,
             "</sub>(", IsDigitChar, ")" ],
       [ 2, "IsEvenInt",
         4, "IsPrimePowerInt" ],
       [ 2, "IdFunc", 2,
         4, "IdFunc", 4 ] );
od;


#############################################################################
##
##  exceptional groups F4(<q>), <q> a prime power
##  exceptional groups G2(<q>), <q> a prime power
##  exceptional groups E<n>(<q>), $<n> \in \{ 6, 7, 8 \}$, <q> a prime power
##
for p in [ ["F","4"], ["G","2"], ["E","6"], ["E","7"], ["E","8"] ] do
  NPN( [ Concatenation( p[1], p[2], "(" ), IsDigitChar, ")" ],
       [ Concatenation( p[1], "<sub>", p[2], "<sub>(" ),
         IsDigitChar, ")" ],
       [ 2, "IsPrimePowerInt" ],
       [ 2, "IdFunc", 2 ] );
od;


#############################################################################
##
##  exceptional groups 2E6(<q>), <q> a prime power
##  exceptional groups 3D4(<q>), <q> a prime power
##
for p in [ ["2","E","6"], ["3","D","4"] ] do
  NPN( [ Concatenation( p[1], p[2], p[3], "(" ), IsDigitChar, ")" ],
       [ Concatenation( "<sup>", p[1], "</sup>", p[2], "<sub>", p[3],
             "<sub>(" ), IsDigitChar, ")" ],
       [ 2, "IsPrimePowerInt" ],
       [ 2, "IdFunc", 2 ] );
od;


#############################################################################
##
##  exceptional groups 2G2(<q>), <q> an odd power of $3$
##  exceptional groups 2F4(<q>), <q> an odd power of $2$
##
NPN( [ "2G2(", IsDigitChar, ")" ],
     [ "<sup>2</sup>G<sub>2<sub>(", IsDigitChar, ")" ],
     [ 2, "IsPrimePowerInt",
       2, "q -> q mod 3 = 0",
       2, "q -> IsOddInt( Length( Factors( q ) ) )" ],
     [ 2, "IdFunc", 2 ] );

NPN( [ "2F4(", IsDigitChar, ")" ],
     [ "<sup>2</sup>F<sub>4<sub>(", IsDigitChar, ")" ],
     [ 2, "IsPrimePowerInt",
       2, "IsEvenInt",
       2, "q -> IsOddInt( Length( Factors( q ) ) )" ],
     [ 2, "IdFunc", 2 ] );


#############################################################################
##
##  exceptional Suzuki groups Sz(<q>), <q> an odd power of $2$
##
NPN( [ "Sz(", IsDigitChar, ")" ],
     [ "Sz(", IsDigitChar, ")" ],
     [ 2, "IsPrimePowerInt",
       2, "IsEvenInt" ],
     [ 2, "IdFunc", 2 ] );


#############################################################################
##
##  Remove the shorthands,
##  sort the lists, and reset the components of the name translator object.
##
Unbind( NIN );
Unbind( NPN );
FinishInitializationOfNameTranslatorObject( MarkupNamesOfGroups );


#############################################################################
##
#E

