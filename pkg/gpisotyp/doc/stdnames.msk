%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  stdnames.msk              GAP documentation             Thomas Breuer
%%
%H  $Id: stdnames.msk,v 1.2 2002/07/10 15:43:42 gap Exp $
%%
%Y  Copyright (C) 2002, Lehrstuhl D fuer Mathematik, RWTH Aachen, Germany
%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Standard Names}

This chapter introduces *name translator objects* and, as special cases,
*name standardizer objects*.
They are intended for situations where strings are used to denote
mathematical objects, and other strings are associated to these names,
for example when one wants to define a mapping from several alternative
names to one distinguished standard name.

The following sections describe
some reasons for introducing name translator objects
(see~"Why Name Translator Objects?"),
the notation used
(see~"Translated Names, Admissible Names, and Composed Names"),
the functions for name translator objects (see~"Name Translator Objects")
and name standardizer objects (see~"Name Standardizer Objects"),
the special cases of standard names
(see~"Admissible Names and Standard Names of Groups")
and markup names for groups (see~"Markup Names of Groups"),
and finally some technicalities
(see~"Internal Structure of Name Translator Objects").


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Why Name Translator Objects?}

The implementation uses lists of names and of descriptions of name formats.
This may appear quite complicated.
For example, one could simply put the translation process into the body of
a {\GAP} function that takes a string as its argument;
the main disadvantage of this alternative is that one would have to rewrite
this function whenever one wants to extend the scope.
So one could think of using a list of functions which are applied
successively until a non-`fail' value is returned;
one disadvantage of this approach is that it gives no access to the rules
used, in particular one cannot check whether they are contradictory.

With the setup used in this package, users can add their favourite names
to the scope of the built-in name translator objects,
as long as they do not contradict the names that are already available.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Translated Names, Admissible Names, and Composed Names}

\FileHeader[1]{stdnames}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Name Translator Objects}

\Declaration{TranslatedName}
\Declaration{EmptyNameTranslatorObject}
\Declaration{NotifyIndividualTranslatedName}
\Declaration{NotifyParametrizedTranslatedName}

\beginexample
gap> transobj:= EmptyNameTranslatorObject( rec() );;
gap> NotifyIndividualTranslatedName( transobj, "M11", "M<sub>11</sub>" );
gap> NotifyParametrizedTranslatedName( transobj,
>        [ "S", IsDigitChar ],
>        [ "S<sub>", IsDigitChar, "</sub>" ],
>        [ 2, x -> IsPosInt( Int( x ) ) ],
>        [ 2, x -> x, 2 ] );
gap> TranslatedName( transobj, "M11" );
"M<sub>11</sub>"
gap> TranslatedName( transobj, "S7" );
"S<sub>7</sub>"
gap> TranslatedName( transobj, "S" );
fail
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Standard Names, Admissible Names, and Second Level Synonyms}

\FileHeader[3]{stdnames}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Name Standardizer Objects}

\Declaration{StandardName}
\Declaration{EmptyNameStandardizerObject}
\Declaration{NotifyIndividualStandardName}
\Declaration{NotifyIndividualAdmissibleName}
\Declaration{NotifyParametrizedStandardName}
\Declaration{NotifyParametrizedAdmissibleName}

\beginexample
gap> stdobj:= EmptyNameStandardizerObject( rec() );;
gap> NotifyIndividualStandardName( stdobj, "S5" );
gap> NotifyIndividualAdmissibleName( stdobj, "S5", "A5.2" );
gap> NotifyParametrizedStandardName( stdobj,
>        [ "C", IsDigitChar ],
>        [ 2, x -> IsPosInt( Int( x ) ) ] );
gap> NotifyParametrizedAdmissibleName( stdobj,
>        [ "C", IsDigitChar ],
>        [ "Z", IsDigitChar ],
>        [ 2, x -> IsPosInt( Int( x ) ) ],
>        [ 2, x -> x, 2 ] );
gap> StandardName( stdobj, "S5" );
"S5"
gap> StandardName( stdobj, "A5.2" );
"S5"
gap> StandardName( stdobj, "S4" );
fail
gap> StandardName( stdobj, "C7" );
"C7"
gap> StandardName( stdobj, "Z9" );
"C9"
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Admissible Names and Standard Names of Groups}

\Declaration{StandardizerForNamesOfGroups}
\Declaration{StandardNameOfGroup}

\beginexample
gap> StandardNameOfGroup( "L4(2)" );
"A8"
gap> StandardNameOfGroup( "J5" );   
fail
\endexample


\Declaration{StandardNameOfFiniteSimpleGroupFromSeriesInfo}

\beginexample
gap> info:= IsomorphismTypeInfoFiniteSimpleGroup( PSL( 2, 5 ) );;
gap> StandardNameOfFiniteSimpleGroupFromSeriesInfo( info );
"A5"
gap> info:= rec( series:= "A", parameter:= 4711 );;
gap> StandardNameOfFiniteSimpleGroupFromSeriesInfo( info ); 
"A4711"
gap> info:= rec( series:= "A", parameter:= -5 );;          
gap> StandardNameOfFiniteSimpleGroupFromSeriesInfo( info );
fail
\endexample


describe which names are available,
covering all finite simple groups!
(file header in stdnames.dat!)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Markup Names of Groups}

\Declaration{MarkupNamesOfGroups}

\beginexample
...
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Names of Schur Multipliers of Groups}

\Declaration{TranslatorForNamesOfSchurMultipliersOfGroups}

\beginexample
...
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Internal Structure of Name Translator Objects}

\FileHeader[8]{stdnames}

\Declaration{ParseBackwards}

\beginexample
gap> ParseBackwards( "A4711", [ "A", IsDigitChar, "11" ] );
[ "A", "47", "11" ]
gap> ParseForwards( "A4711", [ "A", IsDigitChar, "11" ] ); 
fail
gap> ParseForwardsWithSuffix( "A4711", [ "A", IsDigitChar, "11" ] );
[ "A", 47, "11" ]
gap> ParseBackwards( "A4711", [ "A4", IsDigitChar, "11" ] );          
fail
gap> ParseBackwardsWithPrefix( "A4711", [ "A4", IsDigitChar, "11" ] );
[ "A4", "7", "11" ]
\endexample

\Declaration{CompareFormatsOfParametrizedNames}
\Declaration{GpIsoTypGlobals}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

