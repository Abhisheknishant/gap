#############################################################################
##
#W  gpisotyp.gd          GAP 4 package `gpisotyp'               Thomas Breuer
##
#H  @(#)$Id: gpisotyp.gd,v 1.2 2002/05/13 15:43:29 gap Exp $
##
#Y  Copyright (C)  2002,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
##
##  This file contains the declarations concerning isomorphism types of
##  groups.
##
##  1. General Isomomorphism Types
##  2. Equality and Comparison of Isomorphism Type Objects
##
Revision.( "gpisotyp/gap/gpisotyp_gd" ) :=
    "@(#)$Id: gpisotyp.gd,v 1.2 2002/05/13 15:43:29 gap Exp $";


InstallIsomorphismMaintenance( IdGroup, IsGroup, IsGroup );


#############################################################################
##
##  1. General Isomomorphism Types
##


#############################################################################
##
##  Why Isomorphism Types as {\GAP} Objects?
#1
##  One reason for introducing *isomorphism types* of groups as {\GAP}
##  objects is that several attributes that are declared for groups are
##  invariant under group isomorphisms and thus the isomorphism type is the
##  natural object to store these attribute values.
##  Examples of such attributes are `Size', `IsAbelian', and
##  `NrConjugacyClasses';
##  they are declared as isomorphism invariant via
##  `InstallIsomorphismMaintenance' (see~"InstallIsomorphismMaintenance").
##
##  One can create isomorphism types from concretely given groups,
##  and examine the isomorphism type instead of the group itself,
##  which is stored in the isomorphism type as value of the attribute
##  `Representative'.
##  However, this is an issue of minor interest.
##  It is a more important aspect to view an isomorphism type as an object
##  for storing certain information about groups also if no groups are given
##  at all; such an isomorphism type will be called an
##  *abstract isomorphism type* in the following.
##
##  So the main advantage of isomorphism type objects may be that they
##  provide interfaces between various data libraries of {\GAP},
##  such as the libraries of character tables and of tables of marks,
##  and the {\GAP} package `AtlasRep',
##  in the sense that the data provided in these databases can be associated
##  to the appropriate isomorphism types.
##  This is done separately for each database, and the isomorphism types
##  allow us to use the information of the different databases together.
##

#############################################################################
##
##  Defining Isomorphism Types 
##
##  Isomorphism types of groups in {\GAP} can be *defined* in different ways.
##  \beginlist
##  \item{1.}
##      One can define it *by a representative*, i.e.,
##      by a specific group with this isomorphism type, or
##  \item{2.}
##      one can define an *abstract isomorphism type* by sufficient
##      conditions;
##      for example,
##      the following three descriptions define unique isomorphism types:
##      ``The simple group of order $60$'',
##      ``the group of order $120$ with trivial centre and simple derived
##      subgroup'',
##      ``the group of order $168$ that is generated by two elements
##      of orders $2$ and $3$, respectively, whose product has order $7$''.
##      The format for defining abstract isomorphism types is described
##      in~"...".
##  \endlist
##
##  (Clearly the two ways of defining isomorphism types can be combined;
##  for example, if a representative is given by a finite presentation
##  then the defining relations together with the group order yield
##  sufficient conditions to define an abstract isomorphism type.)
##
#T  And formally, for an isomorphism type <isotype> with representative,
#T  an ``abstract'' description is given by the function
#T  `G -> IsomorphismGroups( G, Representative( <isotype> ) ) <> fail'.
#T  But clearly this is not of practical interest.
##
##  The *relation* between groups and isomorphism types is defined
##  as follows.
##  The isomorphism type may ask a stored representative for everything,
##  but the representative may use the isomorphism type only for fetching
##  information that is already stored.
##  In other words, no computations with isomorphism types should be forced
##  by questions that had been asked to groups.
##  Loosely speaking, groups in {\GAP} shall not suffer from the availability
##  of isomorphism type objects.
##


#############################################################################
##
#C  IsIsomorphismType( <obj> )
##
##  Each isomorphism type object in {\GAP} lies in this category.
##
DeclareCategory( "IsIsomorphismType", IsObject );


#############################################################################
##
#V  IsomorphismTypesFamily
##
##  Each isomorphism type object of a group in {\GAP} lies in this family.
##
DeclareGlobalVariable( "IsomorphismTypesFamily" );


#############################################################################
##
#C  IsIsomorphismTypeOfGroup( <obj> )
##
##  Each isomorphism type object of a group in {\GAP} lies in this category.
##
DeclareCategory( "IsIsomorphismTypeOfGroup", IsIsomorphismType );


#############################################################################
##
#C  IsAbstractIsomorphismType( <obj> )
##
##  An *abstract isomorphism type* is defined by at least one set of
##  necessary and sufficient conditions for a group to have this isomorphism
##  type, see~"KnownDefinitionsOfIsomorphismType" for the format of these
##  definitions.
##
##  An abstract isomorphism type may, but need not, store a representative.
##
##  The defining attribute of an abstract isomorphism type is
##  `KnownDefinitionsOfIsomorphismType'
##  (see~"KnownDefinitionsOfIsomorphismType").
##
DeclareCategory( "IsAbstractIsomorphismType", IsIsomorphismType );


#############################################################################
##
##  2. Equality and Comparison of Isomorphism Types of Groups in {\GAP}
##
##  The methods for checking the equality of isomorphism types depend on the
##  way how the isomorphism types are defined.
##
##  Two isomorphism type objects with stored representatives can
##  (in principle) be checked for equality via checking the representatives
##  for isomorphism (see~"IsomorphismGroups").
##  An isomorphism type object with known representative and an abstract
##  isomorphism type can be checked for equality via testing the defining
##  conditions of the abstract isomorphism type for the representative of the
##  other isomorphism type.
##  Two abstract isomorphism types can in general not be checked for
##  equality;
##  if the known attribute values of the two isomorphism types are
##  inconsistent then `false' is returned,
##  but if no such conclusion is possible then an error is signalled.
##
##  When the equality check finds out that two isomorphism type objects are
##  equal then the isomorphism types are *merged*, that is,
##  the attribute values stored only in one of them are transferred to the
##  other isomorphism type.
##
##  *No ordering* via the operation `\<' is defined for isomorphism type
##  objects.
##  Thus one cannot form sets or ordered lists of isomorphism types;
##  for removing duplicates from lists of isomorphism types,
##  one can use `DuplicateFreeList' (see~"DuplicateFreeList").
##


#############################################################################
##
##  3. Attributes of Isomorphism Types of Groups
##

own representation of isom. types, to store shared attr. in a separate
bag that can be shared physically after merging?

G -> isotype(G) -> Representative( isotype(G) );
the repres. may be different from G!!


if repres. known, methods to compute attr. value from repres.!


- KnownNamesOfIsomorphismType
- StandardGeneratorsInfo
- IdGroup
- (all those attributes that are declared for something implied by `IsGroup'
  and that are isomorphism maintained;
  detect this automatically, declare/install those attributes for isotypes!!)

(problem:
some attributes are invariants of the isotype,
some are equal for equal types only ``up to something'';
e.g., CharacterTable and TableOfMarks,
and those are of particular interest!!

so distinguish two kinds of attributes,
one that can be shared between equal types, one that cannot ...)

[how to notify a shared attribute??
are these exactly the isom. maintained ones??
is CharacterTable isom. maintained??]

[problem e.g.: join the known library table to a group
whose conj. classes are not yet computed?]

[even bigger problem:
suppose the table is incomplete;
how shall GAP proceed when trying to use the table
--compute the table anew and ignore the partial one,
or try to identify the partial table?]


(how to make sure that known attributes of the isotype are set also
for the representative and v.v.?
provide a transfer function that has to be called explicitly,
for example before a call to \= for the isotypes?)



list the attributes for groups that are also attributes for isomorphism types!


#############################################################################
##
#V  AttributesOfIsomorphismTypeOfGroup
##
##  `AttributesOfIsomorphismTypeOfGroup' is a list of those names of {\GAP}
##  attributes that are invariant under group isomorphisms,
##  and thus can be shared by equal isomorphism types.
##  ...

how to achieve that the stored values in `ISOMORPHISM_MAINTAINED_INFO' are
used, and new values are automatically added?

##
DeclareGlobalVariable( "AttributesOfIsomorphismTypeOfGroup" );


#############################################################################
##
#M  attribute method for isomorphism types of groups
##
##  The following attribute function has the purpose to add each attribute
##  that is declared for isomorphism types of groups in the global list
##  `AttributesOfIsomorphismTypesOfGroups'.

is this really desirable?
Representative should be here,
but KnownDefinitions and AdmissibleNames not !

##
InstallAttributeFunction(
    function ( name, filter, getter, setter, tester, mutflag )
    if     ( not name in AttributesOfIsomorphismTypeOfGroup[1] )
       and IsIdenticalObj( filter, IsIsomorphismTypeOfGroup ) then
      Add( AttributesOfIsomorphismTypeOfGroup[1], name   );
      Add( AttributesOfIsomorphismTypeOfGroup[2], getter );
    fi;
    end );

what about attributes for arbitrary isomorphism types??
(see below!!)

DeclareAttribute( "Representative", IsIsomorphismType );

DeclareAttribute( "MaximalSubgroupsInfo", IsIsomorphismTypeOfGroup );



#############################################################################
##
##  x. Print, View, String for Isomorphism Types
##
##  The default `ViewObj' method of an isomorphism type of a group
##  just prints `<isomorphism type of a group>'.
and general isotype?
...
##  


#############################################################################
##
##  4. Abstract Isomorphism Types
#n
##  We want to define each abstract isomorphism type by listing conditions,
##  which can be thought of as a set of functions and corresponding values,
##  and calling these functions for a group will yield the prescribed
##  values if and only if the group has this isomorphism type.
##
##  For example, the alternating group $A_5$ is the unique simple group of
##  order $60$, up to isomorphism.
##  So a definition of the isomorphism type of $A_5$ can be given by the
##  functions `IsSimple' with value `true', and `Size' with value $60$.
##
##  However, we want to identify isomorphism types not only for groups
##  but also for the objects provided by {\GAP} databases,
##  for example character tables and tables of marks,
##  and thus the description of definitions used is more complex.
##  The above example would also work for the character table of $A_5$,
##  but already the function `G -> Size( Centre( G ) )' is applicable to
##  groups but not to character tables;
##  an analogon for character tables (but not for groups) is the function
##  `tbl -> Length( ClassPositionsOfCentre( tbl ) )'.
##
##  Each definition of an isomorphism type is represented by a list of even
##  length that contains at each odd position a string, denoting a unary
##  function, and at the following even position the corresponding value.
##  The mapping from the strings to the functions themselves is provided by
##  the global variable `DefiningConditionsOfIsomorphismTypes'
##  (see~"DefiningConditionsOfIsomorphismTypes").
##  ...
##  For each ``context'' (groups, character tables, tables of marks),
##  it stores a record whose components are the strings used in the
##  definitions, and the values of the components are the functions to be
##  applied.
##  For example, the above two functions for computing the order of the
##  centre are stored as values for the component "SizeOfCentre" in the
##  records for groups and character tables, respectively.
##


if two or more descriptions: method for IsInternallyConsistent

(possibility to *check* claims that two given isotypes are equal?)


#############################################################################
##
#A  KnownDefinitionsOfIsomorphismType( <isotype> )
##
##  For an isomorphism type <isotype>, `KnownDefinitionsOfIsomorphismType'
##  returns a list of definitions for this isomorphism type,
##  as described in~"...".
##  If <isotype> is an abstract isomorphism type then this list is nonempty.
##
DeclareAttribute( "KnownDefinitionsOfIsomorphismType",
    IsIsomorphismType, "mutable" );


#############################################################################
##
#V  DefiningConditionsOfIsomorphismTypes
##
##  This global variable is used for evaluating definitions of abstract
##  isomorphism groups in different contexts.
##  The value is a list of even length, containing in each odd position
##  a filter <filt> and in the following even position a record ...
##
DeclareGlobalVariable( "DefiningConditionsOfIsomorphismTypes" );


#############################################################################
##
#V  AbstractIsomorphismTypesOfGroups
##
##  a list of abstract isomorphism types (see~"...")
...
##
DeclareGlobalVariable( "AbstractIsomorphismTypesOfGroups" );


#############################################################################
##
#A  AdmissibleNamesOfIsomorphismType( <isotype> )
##
##  (`Identifier' is one of them, used for printing)
##
DeclareAttribute( "AdmissibleNamesOfIsomorphismType", IsIsomorphismType,
    "mutable" );

DeclareAttribute( "Identifier", IsAbstractIsomorphismType );


#############################################################################
##
#F  DeclareAdmissibleNamesOfIsomorphismType( <isotype>, <names> )
##
DeclareGlobalFunction( "DeclareAdmissibleNamesOfIsomorphismType" );


#############################################################################
##
#F  DeclareAbstractIsomorphismType( <name>, <record> )
##

or only list of definitions as second argument?

## 
##
DeclareGlobalFunction( "DeclareAbstractIsomorphismType" );


#############################################################################
##
#F  SizesSimpleGroups( ... )
##
##  ...
used as a utility for checking definitions of abstract isomorphism types
##
DeclareGlobalFunction( "SizesSimpleGroups" );


#############################################################################
##
#A  IsomorphismType( <G> )
#A  IsomorphismType( <tbl> )
#A  IsomorphismType( <tom> )
#A  IsomorphismType( <string> )
##
##  ...
##
##  For a string <string> that is a valid name of an abstract isomorphism
##  type (see~"AdmissibleNamesOfIsomorphismType"),
##  `IsomorphismType' returns this isomorphism type;
##  otherwise `fail' is returned.
##
DeclareAttribute( "IsomorphismType", IsGroup );
DeclareAttribute( "IsomorphismType", IsCharacterTable );
DeclareAttribute( "IsomorphismType", IsTableOfMarks );
DeclareAttribute( "IsomorphismType", IsString );


#############################################################################
##
#A  StandardGeneratorsInfo( <isotype> )
##
##  When called with the group isomorphism type <isotype>,
##  `StandardGeneratorsInfo' returns a list of records with at least one of
##  the components `script' and `description'.
##  Each such record defines *standard generators* of groups of isomorphism
##  type <isotype>, the $i$-th record is referred to as the $i$-th set of
##  standard generators for groups of type <isotype>.
##  The value of `script' is a dense list of lists, each encoding a command
##  that has one of the following forms.
##  \beginitems
##  A *definition* $[ i, n, k ]$ or $[ i, n ]$ &
##      means to search for an element of order $n$,
##      and to take its $k$-th power as candidate for the $i$-th standard
##      generator (the default for $k$ is $1$),
##
##  a *relation* $[ i_1, k_1, i_2, k_2, \ldots, i_m, k_m, n ]$ with $m > 1$ &
##      means a check whether the element
##      $g_{i_1}^{k_1} g_{i_2}^{k_2} \cdots g_{i_m}^{k_m}$ has order $n$;
##      if $g_j$ occurs then of course the $j$-th generator must have been
##      defined before,
##
##  a *relation* $[ [ i_1, i_2, \ldots, i_m ], <slp>, n ]$ &
##      means a check whether the result of the straight line program <slp>
##      (see~"Straight Line Programs") applied to the candidates
##      $g_{i_1}, g_{i_2}, \ldots, g_{i_m}$ has order $n$,
##      where the candidates $g_j$ for the $j$-th standard generators
##      must have been defined before,
##
##  a *condition* $[ [ i_1, k_1, i_2, k_2, \ldots, i_m, k_m ], f, v ]$ &
##      means a check whether the {\GAP} function in the global list
##      `StandardGeneratorsFunctions' (see~"StandardGeneratorsFunctions")
##      that is followed by the list $f$ of strings returns the value $v$
##      when it is called with $G$ and
##      $g_{i_1}^{k_1} g_{i_2}^{k_2} \cdots g_{i_m}^{k_m}$.
##  \enditems
##  Optional components of the returned records are
##  \beginitems
##  `generators' &
##      a string of names of the standard generators,
##
##  `description' &
##      a string describing the `script' information in human readable form,
##      in terms of the `generators' value,
##
##  `classnames' &
##      a list of strings, the $i$-th entry being the name of the conjugacy
##      class containing the $i$-th standard generator,
##      according to the {\ATLAS} character table of the group
##      (see~"ClassNames"), and
#T function that tries to compute the classes from the `description' value
#T and the character table?
##
##  `ATLAS' &
##      a boolean; `true' means that the standard generators coincide with
##      those defined in Rob Wilson's {\ATLAS} of Group Representations
##      (see~\cite{AGR}), and `false' means that this property is not
##      guaranteed.
##  \enditems
##
##  There is no default method for an arbitrary isomorphism type,
##  since in general the definition of standard generators is not obvious.
##
##  The function `StandardGeneratorsOfGroup'
##  (see~"StandardGeneratorsOfGroup")
##  can be used to find standard generators of a given group of isomorphism
##  type <isotype>.
##
##  The `generators' and `description' values, if not known, can be computed
##  by `HumanReadableDefinition' (see~"HumanReadableDefinition").
##
DeclareAttribute( "StandardGeneratorsInfo", IsIsomorphismTypeOfGroup );
#T make this an operation also for strings?


#############################################################################
##
#E

mails between 1.11.1999 and 09.11.1999!!


From dcs.st-and.ac.uk!sal Tue Nov  9 18:12:56 1999
To: Thomas.Breuer@Math.RWTH-Aachen.De
cc: ahulpke@math.ohio-state.edu, sam@Math.RWTH-Aachen.De
Subject: Re: isomorphism types 

> I am a little bit frightened about the idea that all the groups
> living in a GAP session would carry an isomorphism type
> (in addition to the GAP type).
> The normal case would be that the value is assigned only if
> someone asks for the isomorphism type, or?
> (The current GAP code does not ask for isomorphism types,
> so we are safe when introducing them.)
> 

In an extreme solution, whenever you ask a concrete group G for a property 
which it shares with its whole isomorphism class (like Size, or IsAbelian) 
then the class C would be created, knowing nothing much except for the one 
concrete instance and would answer the question (by looking at G). If you 
later did something that showed G to be isomorphic to another concrete group H 
in isomorphism class D, or to a database entry represented by an isomorphism 
class D then C and D would be merged.

This reflects the mathematics nicely, but is probably too painful for groups 
that are very small, or not around for very long. We might have to distinguish 
"quick" properties which would not trigger the creation of a class and "slow" 
properties which would, and merge the "quick" information from the concrete 
group into the abstract class when it is created by the first "slow" call.

--------------------------------------------------------------------


Offensichtlich bist Du zur Zeit stark besch"aftigt;
vor einiger Zeit hatten wir uns "uber eine Datenbank von Gruppen
unterhalten, und wie Steve mir heute schrieb, habt Ihr beide
auch diskutiert.
Zu Deiner Information h"ange ich unten meinen Brief an Steve
und seine Antwort an.

Die straight line programs in GAP (von Thomas Merkwitz f"ur seine
Markentafeln eingef"uhrt) habe ich verallgemeinert, um Rob's Format
auch abzudecken,
und als n"achstes sind jetzt die Standarderzeuger dran.
Bisher steht beides im `tom'-Directory,
aber eigentlich geh"ort es zu der Datenbank, die noch aufzubauen ist.
W"are ein `grpdata'-Directory der richtige Platz?
Meine Vorstellung ist im Moment, da\3 dort Datenbank-Objekte
etwa f"ur einfache Gruppen angemeldet werden,
Informationen wie Standarderzeuger eingetragen werden k"onnen,
`tom' und `tbl' liefern weitere Daten (zul"assige Namen,
Markentafeln und Charaktertafel),
und Rob's Atlas (directory `pkg/atlasrep', zur Zeit aber noch nicht
viel eingecheckt) analog.


> From sam Wed Nov  3 17:55:16 1999
Date: Wed, 3 Nov 1999 17:55:16 +0100 (CET)
To: sal@dcs.st-and.ac.uk
Subject: isomorphism types

Hi Steve,

you wrote

> I think this is a good idea. A GAP group is a "concrete" group with explicit 
> elements, not simply an "abstract" isomorphism class of groups, but it is 
> sometimes useful to access information about its isomorphism class (like a 
> name).

This question of making information about an abstract object available
for each concrete instance of the object occurs in several situations.
(You had told me that you are interested in such database issues.)

Currently I am writing a preliminary interface for Rob Wilson's atlas of
group representations, which made me rethink some of the implementation
decisions in the character table library and in Thomas Merkwitz's library
of tables of marks.

The pragmatic point of view is that certain attributes do not belong to
the character table or table of marks of a group but should be uniformly
available for different databases (that is, different aspects).

Examples I met are
- the list of admissible names, which should be the same
  for a character table or table of marks in the library,
  and also for accessing the representations from Rob's atlas and
- information about standard generators (including the possibility
  to find standard generators for a concrete group of the isomorphism
  type in question;
  for the table of marks, this allows one to describe representatives
  of the classes of subgroups, or the character table one may get a
  description of standard class representatives.

The question is for what kind of object attributes such as
`AdmissibleNames' and `StandardGeneratorsInfo' shall be defined;
of course we can say that valid arguments are strings, character tables,
tables of marks, and other objects fetched from databases,
and also concrete groups may be valid.

However, wouldn't it be reasonable to introduce an isomorphism
type itself as a GAP object, for which such attributes would naturally
apply?
More pragmatic,
an isomorphism type would be a kind of ``database object'',
more or less a record with an (open ended ...) list of possible
components, which can be used by all databases accessible in GAP.
One could think of giving properties such as `IsSimple' or `IsSolvable'
to isomorphism types, but this may be not so important.
I have no idea how to manage the administration of such isomorphism
types, for example, how components and their meaning are notified
to the rest of the system.

Do you think this is reasonable?
Or is the situation to deal with objects in connection with databases
too special for introducing this kind of overhead?

All the best,
Thomas

-----------------------------------------------------------------------

To: Thomas.Breuer@Math.RWTH-Aachen.De
Subject: Re: isomorphism types 
Date: Mon, 08 Nov 1999 22:04:21 +0000
> From: Steve Linton <sal@dcs.st-and.ac.uk>

Hi Thomas,

I think this is a good idea and I'd like to pursue it further. For the sake of 
discussion, at the least, where do we get to if we take this idea to its 
logical conclusion?

Every concrete group in GAP would have an Attribute which was its isomorphism 
class record. All information about the group that was really information 
about the class would be stored there (by way of suitable Setter and Getter 
methods). When two groups were found to be isomorphic (or a concrete group was 
recognised as isomorphic to an abstract group which had a database entry) the 
isomorphism class records would be merged. The isomorphism class record would 
have to contain (weak) pointers to all its concrete instances (for example to 
update their types when new information is discovered). Explicit isomorphisms 
might be stored to some "standard" concrete instance of the group, and used 
along the same lines as a niceomorphism. The databases would give rise to some 
isomorphism class records with no concrete instances.

We might also want to introduce some of the other concepts in my model of the 
database (in my Warwick talk): abstract representations, bases and abstract 
generated groups. Also, Lie algebras might be another candidate for a similar 
approach, since there is a strong classification theory for them already.


What about costs: assuming we are clever with weak pointers, this approach 
shouldn't introduce much storage overhead, and might even save some duplicated 
information. The question then is time overhead. Algorithms which create many 
groups quickly (for example some solvable group algorithms that run through 
many subgroups) might suffer if the isomorphism class records had to be 
constructed in each case when (for instance) Size or IsAbelian is requested. 
We might also have to careful to avoid looping through every concrete instance 
of the cyclic group of order 2 every time we prove something about one of them.

My immediate feeling is that this actually the right way to head, even if we 
don't have it uniformly for a while. As such, introducing the records as part 
of the database machinery is probably a good start.

-------------------------------------

Hi Steve,

thanks for your answer about isomorphism types as GAP objects.
I will think a little more about your ideas.

My starting point was much less involved;
I thought of an isomorphism type as an object with access to
at least one concrete instance of the group,
which makes it possible to answer each question about the
isomorphism type via this group;
o.k., we may omit the group and get a situation similar to that
of character tables from the library,
where some questions can be answered and others not.

I am a little bit frightened about the idea that all the groups
living in a GAP session would carry an isomorphism type
(in addition to the GAP type).
The normal case would be that the value is assigned only if
someone asks for the isomorphism type, or?
(The current GAP code does not ask for isomorphism types,
so we are safe when introducing them.)

But again, let me think a little bit more about
what we really want.

> PS Alexander mentioned to me that you and he might do some work in this kind 
> of direction -- do keep me informed.

The starting point was that I had changed the function
`IsomorphismTypeFiniteSimpleGroup' such that `fail' is returned
instead of signalling an error;
this allows one easily to get the list of simple groups with order
in a prescribed range.
Alexander wanted to implement loops over simple groups of prescribed
orders and found this change useful,
so we started a discussion what to do.

In this context, currently I am writing the interface for Rob Wilson's
Atlas of Group Representations,
and this turns out to be something that affects the forthcoming database
in a way that makes it necessary to reorganize some details concerning
the tables of marks as well as the character tables library.

------------------------------------------------------------------------

section on ``Standard Names of (Simple) Groups'' !!

define mappings
- series: S<n> -> A<n>.2 *except* if <n> = 6
- special cases: S6 -> A6.2_1


database info:
=============

- which simple groups are factors of which tables?
  (this can be checked for completeness via a loop over the table library!)
- for each simple groups, allow to access the list of ``extensions''
- database requests return a list of table names;
  for each table, we use a cache record (Size, NrCcl, ...)



