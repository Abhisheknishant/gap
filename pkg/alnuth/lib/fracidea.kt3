# KANT3 code used by ExponentsOfFractionalIdealDescriptionKant
# calculates the exponentsvectors of the fractional ideals
# generated by elms corresponding to the prime ideals
# arising in the factorization
# part of the code in the beginning coincides with units.kt3
#
# INPUT:
# - polynomial 'f' with integer coefficients
# - list 'elms'
#
# compute orders
om := MaximalOrder( f ); # was 'OrderMaximal'
# 'oe' is no longer used, replaced by 'om'. TODO: this should be also changed
# at the GAP level: use 'MaximalOrderBasis' instead of 'EquationOrderBasis'.
# oe := EquationOrder( om ); # was 'OrderEquationOrder'
os := OptimisedRepresentation( om ); # was 'OrderShort'
if os then
    os:=os.ext1;
else
    os:=om; 
fi;
os := Simplify(LLL(os)); # 'LLL' was 'Order LLL', 'Simplify' was 'OrderSimplify'
#
# TODO BELOW
#
# Express the elements in elms in terms of the maximalorder
a:=[];
for i in [1..Length(elms)] do
   b := Element( om, elms[i] ); # was 'Elt'
   c := Element( os, b );       # was 'EltMove'
   ## The two lines below were commented out in KANT 2.5 version,
   ## so we left them as is
   ##c := EltUnitDecompose( b, "expons" );
   ##AppendTo(outt,c,",\n");
   Add_(a,c);
od;
#
# factorize all ideals generated by the elements of a and collect all
# primideals which occur
primId:=[];
for i in [1..Length(a)] do
   factor:=Factorisation(a[i]*os); # was 'Factor'
   for j in [1..Length(factor)] do
       if not factor[j][1] in primId then
           Add_(primId,factor[j][1]);
       fi;
   od;
od;
#
# write for every element in a the exponentfactor corresponding to the
# ideals in primId in a row
# so we will have a martix #columns = Length(primId) and
#                          #rows = Length(a)
matrix:=[];
if Length( primId ) <> 0 then
   for i in [1..Length(a)] do
       Add_(matrix,[]);
   od;
   for i in [1..Length(a)] do
       for j in [1..Length(primId)] do
           matrix[i][j]:=Valuation(a[i]*os, primId[j]); # Was 'IdealValuation'
       od;
   od;
fi;
#
# OUTPUT: matrix
