#!/bin/sh
#############################################################################
##
#W  mtog                 GAP 4 package AtlasRep                 Thomas Breuer
##
#Y  Copyright (C)  2001,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
##
##  This script translates Magma format files with definitions of
##  matrix groups over the integers or over a ring of algebraic integers
##  (as contained in Rob Wilson's Atlas of Group Representations)
##  to {\GAP} readable format.
##
##  The input file is assumed to have the following form.
##  It starts with a *comment* in '/*...*/'.
##  Then a *description of the field and irrational matrix entries* follows,
##  supported field definitions are 'F:=Rationals();',
##  'F<nam>:=CyclotomicField(n);' where 'nam' is the name used for the 'n'-th
##  root of unity 'E(n)', and
##  'F<nam>:=QuadraticField(n);' where 'nam' is the name used for the square
##  root 'Sqrt(n)'.
##  (Assignments of further local variables in the declaration line are
##  accepted.
##  Lines with 'PolynomialRing' are ignored.)
##  Then follow (in any ordering) the *matrix generators*,
##  enclosed in lines '...MatrixGroup<dim,F...' and '>;' where 'dim' is the
##  dimension of the matrices,
##  and perhaps *invariant forms*,
##  starting with one of the lines '...nam (Symmetric form)...' or
##  '...nam (Antisymmetric form)...' or '...nam (Hermitian form)...'
##  and ending with ';',
##  and *generators of the centralizer algebra*,
##  starting with one of the lines '...Centralizing algebra: Generated by...'
##  or '...Centralising algebra: Scalars only...',
##  and ending with ';'.
##  
##  For producing <outfile> from <infile>,
##  just call 'mtog <infile> <outfile>'.
##
##  The output file can be read into {\GAP} with 'ReadAsFunction',
##  which yields a function whose return value is a record with at least the
##  component 'generators', which holds the list of generating matrices;
##  other components may be available.
##
gawk --traditional \
    -v "INFILE=$1" \
    'BEGIN {
         FS = ";";

         # Assume that the file starts with a comment;
         # turn it into a GAP string.
         # (Do not forget to escape double quotes.)
         if ( getline && $0 !~ /^\/\*/ ) {
             print( "no initial comment in \"",
                    INFILE, "\"", $0 ) | "cat 1>&2";
         }
         while ( getline && $0 !~ /^\*\// ) {
             gsub( "\"", "\\\"", $0 )
             comment = comment $0 "\\n\\\n"
         }

         # Skip empty lines.
         while ( getline  && $0 ~ /^$/ ) {
         }

         reduce = "";

         # Skip lines involving 'PolynomialRing'.
         if ( $0 ~ /PolynomialRing/ ) {
             printf( "# %s\n", $0 );
             while ( getline  && ( $0 ~ /PolynomialRing/ ) ) {
                 printf( "# %s\n", $0 );
             }
         }

         if ( $0 ~ /RationalField/ || $0 ~ /Rationals\(/ ) {
             # No irrationalities occur.
             printf( "# %s\n", $0 );
             getline
             printf( "local result, l;\n" );
         }
         else {
             # Define quadratic irrationalities or roots of unity if present.
             # (Declare each irrationality as a local variable.)
             if ( $0 ~ /F<.*QuadraticField/ || $0 ~ /F<.*CyclotomicField/ ) {

                 n = index( $0, "F<" ) + 2;
                 irrnam = substr( $0, n, index( $0, ">" ) - n );
                 locals = irrnam;
                 n = index( $0, "(" ) + 1;
                 n = substr( $0, n, index( $0, ")" )-n );
                 if ( $0 ~ /F<.*QuadraticField/ ) {
                   assign = irrnam ":= Sqrt(" n ")"
                 }
                 else {
                   assign = irrnam ":= E(" n ")"
                 }

                 for ( j = 2; j < NF; j++ ) {
                     k = index( $j, ":=" );
                     locals = locals ", " substr( $j, 1, k-1 );
                     assign = assign ";\n" $j;
                 }

                 printf( "local result, l, %s;\n", locals );
                 printf( "%s;\n", assign )

                 # Skip lines starting with '//' or involving 'PolynomialRing'.
                 while ( getline && ( $0 ~ /^\/\// || $0 ~ /PolynomialRing/ ) ) {
                 }
             }
             else {
                 # The representation may be written over a residue class ring.
                 if ( $0 ~ /:=Integers\(/ ) {
                     n = index( $0, "Integers(" ) + 9;
                     modulus = substr( $0, n, index( $0, ")" ) - n );
                     reduce = "*One(ZmodnZ(" modulus "))";
                     getline
                 }
                 else {
                     printf( "# %s\n", $0 );
                     print( "not rational, quadratic, cycl. field in \"",
                            INFILE, "\"" ) | "cat 1>&2";
                     getline
                 }
                 printf( "local result, l;\n" );
             }
         }

         # For convenience, assign empty lists for the optional components.
         printf( "result:= rec();\n" );
         printf( "result.comment:=\n\"%s\";\n", comment );
         printf( "result.symmetricforms:= [];\n" );
         printf( "result.antisymmetricforms:= [];\n" );
         printf( "result.hermitianforms:= [];\n" );
         printf( "result.centralizeralgebra:= [];\n" );
     }

     # Reproduce empty lines.
     /^$/ {
         print( $0 )
     }

     # Add the matrix generators.
     /MatrixGroup/ {
         # Get the dimension.
         n = index( $0, "MatrixGroup<" ) + 12;
         nn = index( $0, ",F" );
         if ( nn == 0 ) {
             nn = index( $0, ",Z" )
         }
         if ( nn == 0 ) {
             print( "dimension not found in \"",
                    INFILE, "\"" ) | "cat 1>&2";
         }
         dim = substr( $0, n, nn - n );

         # Write the assignment.
         printf( "result.generators:= List( [ [\n" );

         # Copy the matrix entries.
         # (Replace '\[' by '[' where it occurs.)
         while ( getline && $0 !~ /^>;/ ) {
             n = index( $0, "\\[" );
             if ( n == 0 ) {
                 print( $0 );
             }
             else {
                 printf( "%s[", substr( $0, 1, n-1 ) );
                 line = substr( $0, n+2 );
                 n = index( line, "\\[" );
                 while ( n != 0 ) {
                     printf( "%s[", substr( $0, 1, n-1 ) );
                     line = substr( $0, n+2 );
                     n = index( line, "\\[" );
                 }
                 printf( "%s\n", line );
             }
         }
         printf( "], l -> List( [ 0 .. %s ],\n", dim-1 );
         printf( "i -> l{ [ i*%s+1 .. (i+1)*%s ] } ) )%s;\n", dim, dim, reduce );
     }

     # Add symmetric invariant forms.
     /(Symmetric form)/ {
         getline
         if ( $0 ~ /;/ ) {
             printf( "Add( result.symmetricforms, IdentityMat(%s)%s );\n", dim, reduce );
         }
         else {
             printf( "l:= [\n" );
             while ( getline && $0 !~ /;/ ) {
                 print( $0 );
             }
             print( $0 );
             printf( "Add( result.symmetricforms, List( [ 0 .. %s ],\n", dim-1 );
             printf( "i -> l{ [ i*%s+1 .. (i+1)*%s ] } )%s );\n", dim, dim, reduce );
         }
     }

     # Add antisymmetric invariant forms.
     /(Antisymmetric form)/ {
         getline
         if ( $0 ~ /;/ ) {
             printf( "Add( result.antisymmetricforms, IdentityMat(%s)%s );\n", dim, reduce );
         }
         else {
             printf( "l:= [\n" );
             while ( getline && $0 !~ /;/ ) {
                 print( $0 );
             }
             print( $0 );
             printf( "Add( result.antisymmetricforms, List( [ 0 .. %s ],\n", dim-1 );
             printf( "i -> l{ [ i*%s+1 .. (i+1)*%s ] } )%s );\n", dim, dim, reduce );
         }
     }

     # Add hermitian invariant forms.
     /(Hermitian form)/ {
         getline
         if ( $0 ~ /;/ ) {
             printf( "Add( result.hermitianforms, IdentityMat(%s)%s );\n", dim, reduce );
         }
         else {
             printf( "l:= [\n" );
             while ( getline && $0 !~ /;/ ) {
                 print( $0 );
             }
             print( $0 );
             printf( "Add( result.hermitianforms, List( [ 0 .. %s ],\n", dim-1 );
             printf( "i -> l{ [ i*%s+1 .. (i+1)*%s ] } )%s );\n", dim, dim, reduce );
         }
     }

     # Add generators of the centralizer algebra.
     /Centralising algebra: Scalars only/ {
         printf( "Add( result.centralizeralgebra, IdentityMat(%s)%s );\n", dim, reduce );
         while ( getline && $0 !~ /;/ ) {
         }
     }

     /Centralising algebra: Generated by/ {
         # Assume that there are just two generators.
         while ( getline && $0 !~ /MatrixAlgebra/ ) {
         }
         if ( $0 ~ /;/ ) {
             printf( "Add( result.centralizeralgebra, IdentityMat(%s)%s );\n", dim, reduce );
         }
         else {
             n = index( $0, "[" ) + 1;
             printf( "l:= [%s\n", substr( $0, n ) );
             while ( getline && $0 !~ /;/ ) {
                 print( $0 );
             }
             print( $0 );
             printf( "Add( result.centralizeralgebra, List( [ 0 .. %s ],\n", dim-1 );
             printf( "i -> l{ [ i*%s+1 .. (i+1)*%s ] } )%s );\n", dim, dim, reduce );
         }
         while ( getline && $0 !~ /MatrixAlgebra/ ) {
         }
         n = index( $0, "[" ) + 1;
         printf( "l:= [%s\n", substr( $0, n ) );
         while ( getline && $0 !~ /;/ ) {
             print( $0 );
         }
         print( $0 );
         printf( "Add( result.centralizeralgebra, List( [ 0 .. %s ],\n", dim-1 );
         printf( "i -> l{ [ i*%s+1 .. (i+1)*%s ] } )%s );\n", dim, dim, reduce );
     }

     END {
         # Print the return statement.
         printf( "return result;\n" );
     }' $1 > $2


#############################################################################
##
#E

