

The proposed common format is the following (more complex to be 
described than to be used).

Each classification will have a name (which is a valid filename and a 
valid Gap identifier). 

For the classification named "xyz", there will be a file named xyz.g,
with the following content:

###########


LieAlgDataBase.xyz := rec( 

  information := rec ( <some textual information> ),

  common_data := rec( <data that is common to all algebras in this 
                      classification> ),

  # dimension 1
  1 := [ ... ], 

  # dimension 2
  2 := [ ... ],

  ...,

  # dimension n
  <n> := [ rec( <data about the 1st algebra of dimension n>),
           rec( <data about the 2nd algebra of dimension n>),
           rec( <data about the 3rd algebra of dimension n>),
           rec( <data about the 4th algebra of dimension n>),
           ... 
         ],

  ...

);


###########


"information" will be a record of the following form,
and will not be used by the code.

  information := rec(
      title := "a string",
      description := "a string",
      authors_of_classification := <a list of strings of the form
        "Surname, Name">,
      references := <a list of strings>,
      authors_of_conversion := <a list of strings of the form 
        "Surname, Name">
  ),



The record "common_data" and the individual records for each algebra may
contain the record fields described below. Only the relevant will be
present, all the other are optional and may be omitted.


"name": a string with the name of the algebra (for example as in the
classifications by Seeley and Gong), may be used for SetName.


"description": a string with the description of the algebra, will not be
used.


"is_the_field_valid" a function, that takes a field as input and returns
either true or false. For instance, if the algebra exists only for
characteristic 3, then "is_the_field_valid" may be

is_the_field_valid := function ( F )
    if Characteristic( F ) = 3  then
        return true;
    else
        return false;
    fi;
end;


"method": is the Gap function used to build the algebra. 
Usually it will be AlgebraByStructureConstants and means to use the
function AlgebraByStructureConstants. (Other methods may be used, such
as the Gap functions Algebra or AlgebraWithOne or LieAlgebra, but an
algebra built with these method will be less efficient, and using these
methods would decrease the uniformity of the database.)


"symmetry": it may be either "symmetric" or "antisymmetric", and the
algebra will be built using EmptySCTable( dim, zero, "symmetric" ) or
EmptySCTable( dim, zero, "antisymmetric" ). If not present, the algebra
will be built using EmptySCTable( dim, zero ).


"non_zero_products": a list of lists of the form [i, j, list]. For each
of them, the command
SetEntrySCTable( sct, i, j, list );
will be executed.

Some elements in <list> may be strings, and in this case EvalString
will be applied to them. In this way, it is possible to specify that the 
algebra depends on parameters. The string may contain, as substring, 
"LADB_1", which is the one of the field, and "LADB_p[1]", "LADB_p[2]", 
..., "LADB_p" being the list of parameters.


For families of algebras depending on a parameter, there will be:
parameters: a record with the following fields:
  number: (integer) the number of parameters,
  default: (list) a default value to be used in case that the user 
doesn't supply parameters and is interested just in a generic algebra of 
the family.
  forbidden: (list) values not allowed for the parameters.
  invariants: 



"generators", "zero", "basis": used with the methods Algebra or
AlgebraWithOne or LieAlgebra. Not used with method 
AlgebraByStructureConstants.


"non_zero_pth_powers": a list of lists of a form similar to
"non_zero_products"; used for instance in case of restricted Lie
algebras.


"grading": information about grading.


"properties_and_attributes": a list of lists, for instance: 
[[IsLieSolvable, true], [IsLieNilpotent, false]]; 
in this case, the following will be executed:

Setter(IsLieSolvable)(A,true);
Setter(IsLieNilpotent)(A,false);


