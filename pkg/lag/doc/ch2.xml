<#GAPDoc Label="ch2">
<Chapter Label="Second"><Heading>&LAGUNA; functions</Heading>

<Section Label="GenSec"><Heading>General functions for group algebras</Heading>
<ManSection>
   <Filt Name="IsGroupAlgebra" Arg="A" Label="" Comm="determines if A is a
group algebra"/>
   <Description>
    The argument <Code>A</Code> must be a  a group ring. The filter returns
<Code>true</Code> if the underlying ring of <Code>A</Code> is a field; 
<Code>false</Code> is returned otherwise.
   </Description>
  </ManSection>



<ManSection>
   <Filt Name="IsFModularGroupAlgebra" Arg="A" Label=""
Comm="determines if A is a modular group algebra"/>
   <Description>
A group algebra <M>FG</M> over the field <M>F</M>  is called
modular, if the characteristic of <M>F</M> divides the order of some element in <M>G</M>. This filter returns
<Code>true</Code> if <Code>A</Code> is modular according to this definition;
<Code>false</Code> is returned otherwise.
   </Description>
  </ManSection>


<ManSection>
   <Filt Name="IsPModularGroupAlgebra" Arg="A" Label="" Comm="determines if A is a
p-modular group algebra"/>
   <Description>
A group algebra <M>FG</M> is said to be <M>p</M>-modular, if <M>F</M> is a field of
characteristic <M>p</M> and <M>G</M> is a finite <M>p</M>-group for the same prime <M>p</M>. This
filter returns <Code>true</Code> if <Code>A</Code> is a <M>p</M>-modular group algebra, <Code>false</Code>
is returned otherwise.
   </Description>
  </ManSection>

<ManSection>
   <Attr Name="UnderlyingGroup" Arg="A" Label="" Comm="returns the
underlying group of a group ring"/>
   <Description>
Returns the underlying group of the group ring <Code>A</Code>.
   </Description>
  </ManSection>

<ManSection>
   <Attr Name="UnderlyingRing" Arg="A" Label="" Comm=""/>
   <Description>
Returns the underlying ring of the group ring <Code>A</Code>.
   </Description>
  </ManSection>

<ManSection>
   <Attr Name="UnderlyingField" Arg="A" Label="" Comm=""/>
   <Description>
Returns the underlying field of the group algebra <Code>A</Code>.
   </Description>
  </ManSection>

</Section>

<Section Label="ElemFunctions"><Heading>Operations with group algebra elements</Heading>


<ManSection>
   <Meth Name="Support" Arg="x" Label="" Comm=""/>
   <Description>
Returns the support of a group ring element. 
The support of a non-zero element <M> x = \sum_{g\in G} \alpha_g g </M>  of a
group ring
is the list of elements <M>g \in G</M> for which <M>\alpha_g</M> is non-zero.
The support of the  zero element of a group ring  is defined to 
be the empty list.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="CoefficientsBySupport" Arg="x" Label="" Comm=""/>
   <Description>
This method returns a list that contains the coefficients corresponding to the
elements of <Code>Support( x )</Code> in the same order as the elements appear
in <Code>Support( x )</Code>.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="TraceOfMagmaRingElement" Arg="x" Label="" Comm=""/>
   <Description>
This method returns the trace of a group ring element. 
By definition, 
the trace of an element <M> x = \sum_{g\in G} \alpha_g g </M> is <M>\alpha_1</M>, that is,
the coefficient of the identity element in <M>G</M>. 
The trace of the zero element is zero.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="Length" Arg="x" Label="" Comm=""/>
   <Description>
Returns the length of an element of a group ring which is defined as the number of elements in its support.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="Augmentation" Arg="x"/>
   <Description>
The augmentation of a group ring element <M> x = \sum_{g\in G} \alpha_g g </M>
is <M> \sum_{g\in G} \alpha_g </M>.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="Involution" Arg="x f"/>
   <Description>
Let <M>FG</M> be a group ring and let <M>f</M> be a mapping <M>G\rightarrow G</M>, 
such that <M>f^2</M> is the identity mapping on <M>G</M>.
Then the involution of <M>FG</M> with respect to <M>f</M> is defined by
<M>\sum_{g\in G}\alpha_g
g\mapsto\sum_{g\in G}\alpha_g f(g)</M>. This method returns the image of
<Code>x</Code> under the involution of <M>FG</M> with respect to <Code>f</Code>.   </Description>
  </ManSection>

<ManSection>
   <Meth Name="Involution" Arg="x" Label="" Comm=""/>
   <Description>
Returns the involution of <M>x</M> with respect to the map <M>x\mapsto
x^{-1}</M>; see also
<Ref Meth="Involution"/>.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="IsUnit" Arg="A x" Label="" Comm=""/>
   <Description>
Returns <Code>true</Code> if <Code>x</Code> is an invertible element of the
group ring <Code>A</Code>;
returns <Code>false</Code> otherwise.
   </Description>
  </ManSection>

<ManSection>
   <Meth Name="IsUnit" Arg="x" Label="" Comm=""/>
   <Description>
Returns <Code>true</Code> if <Code>x</Code> is an invertible element of a group ring;
returns <Code>false</Code> otherwise.
   </Description>
  </ManSection>



<ManSection>
   <Meth Name="InverseOp" Arg="x" Label="" Comm=""/>
   <Description>
This method calculates the inverse of a group algebra element. The user can
also invoke this function by typing <Code>x\^-1</Code>.
   </Description>
  </ManSection>


</Section>
<Section Label="Ideals"><Heading>Important attributes of group algebras</Heading>

<ManSection>
   <Meth Name="AugmentationIdeal" Arg="A" Label="" Comm=""/>
   <Description>
If <M>FG</M> is a group algebra, then its augmentation ideal is defined as the
set of all elements <M>FG</M> with augmentation <M>0</M>; see <Ref
Meth="Augmentation"/>. This method returns the augmentation of ideal of <Code>A</Code>.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="RadicalOfAlgebra" Arg="A" Label="" Comm=""/>
   <Description>
The radical of a <M>p</M>-modular group algebra coincides with the augmentation
ideal. This method simply checks if the algebra <M>A</M> is a <M>p</M>-modular group
algebra, and, if yes, it returns the augmentation ideal.
   </Description>
  </ManSection>




<ManSection>
   <Meth Name="WeightedBasis" Arg="A" Label="" Comm=""/>
   <Description>
The argument <Code>A</Code> must be a modular group algebra. 

<P/>
For a group
algebra <M>FG</M>, let <M>I</M> 
denote the augmentation ideal, and assume that <M>c</M> is the smallest number
such that <M>I^c=0</M>. Then a weighted basis of <M>FG</M> is some basis
<M>b_1,\ldots,b_n</M> for <M>I</M> (!) for which there are indices
<M>i_1=1,\ldots,i_{c-1}</M> such that <M>b_{i_k},\ldots,b_n</M> is a basis for
<M>I^k</M>. The weight of an element <M>b_i</M> of a weighted basis is the
unique integer <M>w</M> such that <M>b_i\in I^w\setminus I^{w+1}</M>. 

Note that this function actually 
constructs a basis for the augmentation ideal and not for <Code>A</Code>. Since
the augmentation ideal has co-dimension 1 in <Code>A</Code>,  a
basis for <Code>A</Code> can easily be obtained by adjoining the identity
element of the group.
The method returns a record whose basis entry is the basis and the weights entry
is a list of corresponding weights of basis elements. See Section~<Ref
Sect="ThirdThird"/> for more details.

   </Description>
  </ManSection>


<ManSection>
   <Meth Name="AugmentationIdealPowerSeries" Arg="A" Label="" Comm=""/>
   <Description>
The argument <Code>A</Code> is a <M>p</M>-modular group algebra.    
The method returns a list whose elements are the terms of the augmentation
ideal filtration of <Code>A</Code>. 
That is <Code>AugmentationIdealPowerSeries(A)[k]</Code> is the
<M>i</M>-th power of the augmentation ideal of A.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="AugmentationIdealNilpotencyIndex" Arg="A"
Label="" Comm=""/>
   <Description>
Returns the largest number <M>n</M> such that <M>I^n\neq0</M> where <M>I</M> is the augmentation
ideal of <Code>A</Code>.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="AugmentationIdealOfDerivedSubgroupNilpotencyIndex" Arg="A"
Label="" Comm=""/>
   <Description>
???
   </Description>
  </ManSection>

</Section>
<Section Label="UnitGroup"><Heading>Computations with the unit group</Heading>


<ManSection>
   <Meth Name="NormalizedUnitGroup" Arg="A"/>
   <Description>
Determines the normalized unit group of a <M>p</M>-modular group algebra
<M>A</M>. Returns the normalized unit group, as a group generated by some
elements of <Code>A</Code>; see Section~<Ref Sect="ThirdThird"/> for more details. 
For efficient computations the user is urged to use
<Ref Meth="PcNormalizedUnitGroup"/>.
   </Description>
  </ManSection>

<ManSection>
   <Meth Name="NormalizedUnitCF" Arg="A u"/>
   <Description>

   </Description>
  </ManSection>



<ManSection>
   <Meth Name="Size" Arg="U" Label="" Comm=""/>
   <Description>
The size of the normalized unit group of a <M>p</M>-modular group algebra
<M>FG</M> is <M>p^{|G|-1}</M>. If <Code>U</Code> is such a normalised unit
group, then this method returns the value given by this formula.
   </Description>
  </ManSection>

<ManSection>
   <Meth Name="PcNormalizedUnitGroup" Arg="A"/>
   <Description>
The argument <Code>A</Code> is a <M>p</M>-modular group algebra. Computes the normalized
unit group of <Code>A</Code>. This 
unit group is computed as a polycyclic group given by 
a polycyclic presentation. The generators of the presentation 
correspond to the weighted basis of <Code>A</Code>. For more details, see~<Ref Sect="ThirdThird"/>.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="Units" Arg="A" Label="" Comm=""/>
   <Description>
Returns the unit group of <Code>A</Code>, as a group generated by some
elements of <Code>A</Code>; see Chapter~<Ref Chap="Third"/> for more details.
   </Description>
  </ManSection>

<ManSection>
   <Meth Name="PcUnits" Arg="A" Label="" Comm=""/>
   <Description>
Returns the unit group of <Code>A</Code> as a polycyclic 
group given by a polycyclic presentation. See~<Ref Sect="ThirdFourth"/> for more details.
   </Description>
  </ManSection>



<ManSection>
   <Meth Name="Size" Arg="U" Label="" Comm=""/>
   <Description>
The size of the  unit group of a <M>p</M>-modular group algebra
<M>FG</M> is <M>(|F|-1)p^{|G|-1}</M>. I
f <Code>U</Code> is such a unit
group, then this method returns the value given by this formula.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="PcUnits" Arg="A" Label="" Comm="determines if A is a
group algebra"/>
   <Description>
Returns the group of units in <Code>A</Code> as a polycyclic group with a
polycyclic presentation. See~<Ref Sect="ThirdFourth"/> for more details.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="NaturalBijectionToPcNormalizedUnitGroup" Arg="A"/>
   <Description>
The normalised unit group of a <M>p</M>-modular group algebra <M>A</M> can be computed
using two methods, namely <Ref Meth="NormalizedUnitGroup"/> and
<Ref Meth="PcNormalizedUnitGroup"/>. These two methods return two different
objects, and they can be used for different types of computations. The elements
of <Code>NormalizedUnitGroup(A)</Code> are represented in their natural group
algebra representations, and hence they can easily be identified in the group
algebra. However, <Code>NormalizedUnitGroup(A)</Code> is often not suitable for
fast computation, and one  will have to use
<Code>PcNormalizedUnitGroup(A)</Code> if one wants to find some group theoretic
properties of the normalized unit group. This method returns the bijection
from <Code>NormalizedUnitGroup(A)</Code> onto <Code>PcNormalizedUnitGroup(A)</Code>.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="NaturalBijectionToNormalizedUnitGroup" Arg="A" Label="" Comm=""/>
   <Description>
This function returns the inverse of
<Code>NaturalBijectionToPcNormalizedUnitGroup(A)</Code>; see~<Ref Meth="NaturalBijectionToPcNormalizedUnitGroup"/>.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="GroupBases" Arg="A" Label="" Comm=""/>
   <Description>
???
   </Description>
  </ManSection>


</Section>
<Section Label="LieAlgebra"><Heading>The Lie algebra of a group algebra</Heading>

<ManSection>
   <Meth Name="LieAlgebraByDomain" Arg="A" Label="" Comm="determines if A is a
group algebra"/>
   <Description>
This method takes an associative algebra as its argument, and constructs 
its associated Lie algebra in which product is the bracket
operation: <M>[a,b]=ab-ba</M>.
It is recommended that the user never calls this method. The Lie algebra
for an associative algebra should normally be created using 
<Code>LieAlgebra( A )</Code>. When <Code>LieAlgebra</Code> is first invoked it
constructs the Lie algebra for <M>A</M> using <Code>LieAlgebraByDomain</Code>. After
that it stores this Lie algebra and simply returns it if
<Code>LieAlgebra</Code> is again called.
   </Description>
  </ManSection>

<ManSection>
   <Meth Name="CanonicalBasis" Arg="L"/>
   <Description>
The canonical basis of a group algebra <M>FG</M> is formed by the elements of
<M>G</M>. In this method <Code>L</Code> is a Lie algebra associated with a
group algebra <M>FG</M>, and the method returns the image of the elements of
<M>G</M> in <Code>L</Code>.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="StructureConstantsTable" Arg="L" Label="" Comm="determines if A is a
group algebra"/>
   <Description>
A very fast implementation for calculating the structure constants table 
for the Lie algebra <Code>L</Code> associated with a group ring with respect to
its canonical basis (see~<Ref Meth="CanonicalBasis"/>).
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="Embedding" Arg="U L"/>
   <Description>
 Let <M>FG</M> be a group, let <M>U</M> be a submagma of <M>G</M>, and let <M>L</M> be the associated Lie algebra of $FG$.
Then <Code>Embedding( U, L )</Code> returns the obvious mapping from
<Code>U</Code> to <Code>L</Code>,
(as the composition of the mappings <Code>Embedding( U, A )</Code> and
<Code>NaturalBijectionToLieAlgebra( A )</Code>).
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="LieDerivedSubalgebra" Arg="L"/>
   <Description>
If <Code>L</Code> is the Lie algebra associated with a group algebra, then this
method determines the derived subalgebra of <Code>L</Code>.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="LieCentre" Arg="L" Label=""/>
   <Description>
The  centre of the Lie algebra associated with a group ring corresponds to the 
centre of the underlying group ring, and it can 
be calculated very fast by considering the conjugacy classes 
of the group. This method returns the centre of <Code>L</Code> using this idea.
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="IsLieAbelian" Arg="A" Label="" Comm="determines if A is a
group algebra"/>
   <Description>
The Lie algebra <M>L</M> of an associative algebra <M>A</M> is Lie abelian, 
if and only if <M>A</M> is abelian, so this method refers 
to <Code>IsAbelian( A )</Code>. 
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="IsLieSolvable" Arg="A" Label="" Comm="determines if A is a
group algebra"/>
   <Description>
In <Cite Key="PPS73"/> Passi, Passman, and Sehgal have classified all groups <M>G</M> such that the 
associated 
Lie algebra <M>L</M> of the group ring is  solvable. This method uses 
their classification, making it considerably faster than 
the more elementary method which just calculates Lie commutators. 
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="IsLieNilpotent" Arg="A" Label="" Comm="determines if A is a
group algebra"/>
   <Description>
In <Cite Key="PPS73"/>
Passi-Passman-Sehgal have classified all groups <M>G</M> such that the 
associated 
Lie algebra <M>L</M> of the group ring is nilpotent. This method uses 
their classification, making it considerably faster than 
the more elementary method which just calculates Lie commutators. 
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="IsLieMetabelian" Arg="A" Label="" Comm="determines if A is a
group algebra"/>
   <Description>
In <Cite Key="LR86"/> Levin and Rosenberger have classified all groups <M>G</M> 
such that the associated 
Lie algebra <M>L</M> of the group ring is  metabelian. This method uses 
their classification, making it considerably faster than 
the more elementary method which just calculates Lie commutators. 
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="IsLieCentreByMetabelian" Arg="A" Label="" Comm="determines if A is a
group algebra"/>
   <Description>

In <Cite Key="Ross"/> the third author of this package classified all groups <M>G</M> 
such that the associated 
Lie algebra <M>L</M> of the group ring is  centre-by-metabelian. 
This method uses 
the classification, making it considerably faster than 
the more elementary method which just calculates Lie commutators. 
description
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="LieUpperNilpotencyIndex" Arg="A" Label="" Comm="determines if A is a
group algebra"/>
   <Description>
description
   </Description>
  </ManSection>

</Section>
<Section Label="Other"><Heading>Other commands</Heading>


<ManSection>
   <Meth Name="SubgroupsOfIndexTwo" Arg="A" Label="" Comm="determines if A is a
group algebra"/>
   <Description>
A list is returned here. (The subgroups of index two in the group <M>G</M>
are important for the Lie structure of the group algebra <M>FG</M>, in case
that the underlying field <M>F</M> has characteristic 2.)
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="DihedralDepth" Arg="A" Label="" Comm="determines if A is a
group algebra"/>
   <Description>
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="JenningsBasis" Arg="A" Label="" Comm="determines if A is a
group algebra"/>
   <Description>
description
   </Description>
  </ManSection>


<ManSection>
   <Meth Name="LieDimensionSubgroups" Arg="A" Label="" Comm="determines if A is a
group algebra"/>
   <Description>
description
   </Description>
  </ManSection>



</Section>
</Chapter>
<#/GAPDoc>









