% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[11pt]{report}
\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}
\definecolor{FuncColor}{rgb}{1.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,1.0}

\usepackage{fancyvrb}

\usepackage{pslatex}

\usepackage[
        a4paper=true,bookmarks=false,pdftitle={Written with GAPDoc},
        colorlinks=true,backref=page,breaklinks=true,linkcolor=RoyalBlue,
        citecolor=RoyalGreen,filecolor=RoyalRed,
        urlcolor=RoyalRed,pagecolor=RoyalBlue]{hyperref}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\F}{\mathbb{F}}

\newcommand{\GAP}{\textsf{GAP}}

\newsavebox{\backslashbox}
\sbox{\backslashbox}{\texttt{\symbol{92}}}
\newcommand{\bs}{\usebox{\backslashbox}}

\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\begin{center}{\Huge \textbf{\textsc{LAG} -- Lie Algebras of Group Algebras}}\\[1cm]
\markright{\scriptsize \mbox{}\hfill \textsc{LAG} -- Lie Algebras of Group Algebras \hfill\mbox{}}
{Version 3.0}\\[1cm]
{January 2003}\\[1cm]
\mbox{}\\[2cm]
{\large \textbf{Victor Bovdi   }}\\
{\large \textbf{Alexander Konovalov   }}\\
{\large \textbf{Richard Rossmanith   }}\\
{\large \textbf{ Csaba Schneider   }}\\
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{Victor Bovdi   } --- Email: \href{mailto://vbovdi@math.klte.hu}{\texttt{vbovdi@math.klte.hu}}\\
 --- Address: \begin{minipage}[t]{8cm}\noindent
 Institute of Mathematics and Informatics University of Debrecen P.O.Box 12,
Debrecen, H--4010 Hungary \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{Alexander Konovalov   } --- Email: \href{mailto://konovalov@member.ams.org}{\texttt{konovalov@member.ams.org}}\\
 --- Address: \begin{minipage}[t]{8cm}\noindent
 Department of Mathematics Zaporozhye State University P.O.Box 1317, Central
Post Office Zaporozhye, 69000 Ukraine \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{Richard Rossmanith   } --- Email: \href{mailto://ross@email.de}{\texttt{ross@email.de}}\\
 --- Address: \begin{minipage}[t]{8cm}\noindent
Richards's Address\end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{ Csaba Schneider   } --- Email: \href{mailto://csaba@maths.uwa.edu.au}{\texttt{csaba@maths.uwa.edu.au}}\\
 --- Address: \begin{minipage}[t]{8cm}\noindent
 School of Mathematics and Statistics The University of Western Australia 35
Stirling Highway 6009 Crawley Western Australia \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Abstract}
\logpage{[ 0, 0, 1 ]}
 \textsc{LAG} is a software package which is capable of computing the structure of the unit
group of a modular group algebra. It is written in the \textsf{GAP} computer algebra system (version 4.2), and it runs within the same system.
compatible with }\\[1cm]
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 2 ]}
{\copyright} 2003 by Victor Bovdi, Alexander Konovalov, Richard Rossmanith, and Csaba
Schneider }\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 3 ]}
 We thank St Andrews, Stuttgart, Debrecen, Thomas Breuer, Willem de Graaf, etc. }\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 4 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Introduction}}\label{First}
\logpage{[ 1, 0, 0 ]}
{
 he {\LAG} package contains the declaration of attributes, properties, and
operations for associated Lie algebras of associative algebras, in particular
group algebras. If $A$ is an associative algebra, its associated Lie algebra is the Lie Algebra $L$ which has the same underlying vector space as $A$, and which satisfies $[a,b]=ab-ba$ for all $a,b \in A$. In \textsf{GAP}, however, the bracket notation $[a,b]$ is reserved for lists, so the product in $L$ is denoted by the star `*' -- the same symbol which is also used to denote the
associative multiplication in $A$. Therefore, \textsf{GAP} needs to distinguish between the elements in $A$ and the elements in $L$, i.e.\ here the underlying vector spaces are not equal, but only (however
canonically) isomorphic. \textsf{GAP} stores the Lie algebra $L$ and the natural linear bijection from $A$ onto $L$ as attributes of the associative algebra $A$. The usual commands that apply to algebras, such as `Dimension',
`IsFiniteDimensional', `IsFinite', `Size', `Elements', etc.\ also work for the
Lie Algebra, if they work for the underlying associative algebra.
Additionally, the standard Lie algebra functions (described in the chapter
about Lie algebras) of course also apply to Lie algebras that come from
associative algebras. This will not be explained in detail for every single
command in this chapter. The main objective of this package, however, is to
deal with Lie algebras of group algebras. Some new functions are added, and,
for other functions that also apply to abstract Lie algebras, much faster
methods are implemented (which was possible due to the special structure of
such Lie algebras). I would like to point out that many properties of Lie
algebras of group algebras carry over to the commutator structure of the unit
group. E.g., if the Lie algebra of the group algebra is solvable, then so is
its unit group (in odd characteristic --- there are counterexamples in
characteristic 2). However, no such functions have been included in the {\LAG}
package, due to the fact that unit groups were only ``in the making'' at the
time when {\LAG} was programmed. See the survey article \cite{Bov98}  for a detailed description of the interplay between the unit group and the Lie
algebra of a group algebra. It might be useful for future implementations of
fast algorithms for the unit group. The {\LAG} package arose as a byproduct of
the author's dissertation thesis  \cite{Ros97}. It was ported to \textsf{GAP}~4 and brought into standard \textsf{GAP} package format during a visit to St.~Andrews in September 1998, under the
supervision of the \textsf{GAP} team. I want to thank everybody on the team for their support, in particular
Steve Linton, Willem de Graaf, Thomas Breuer, and Alexander Hulpke. }

 
\chapter{\textcolor{Chapter }{LAG functions}}\label{Second}
\logpage{[ 2, 0, 0 ]}
{
 
\section{\textcolor{Chapter }{General functions for group algebras}}\logpage{[ 2, 1, 0 ]}
{
 

\subsection{\textcolor{Chapter }{IsGroupAlgebra (IsGroupRing A)}}
\logpage{[ 2, 1, 1 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsGroupAlgebra( A )\index{IsGroupAlgebra@\texttt{IsGroupAlgebra}!IsGroupRing A}
\label{IsGroupAlgebra:IsGroupRing A}
}\hfill{\scriptsize (filter)}}\\


 The argument \texttt{A} must be a a group ring. The filter returns \texttt{true} if the underlying ring of \texttt{A} is a field; \texttt{false} is returned otherwise. }

 

\subsection{\textcolor{Chapter }{IsFModularGroupAlgebra (IsGroupAlgebra A)}}
\logpage{[ 2, 1, 2 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsFModularGroupAlgebra( A )\index{IsFModularGroupAlgebra@\texttt{IsFModularGroupAlgebra}!IsGroupAlgebra A}
\label{IsFModularGroupAlgebra:IsGroupAlgebra A}
}\hfill{\scriptsize (filter)}}\\


 A group algebra $FG$ over the field $F$ of characteristic $p$ is called modular, if $p$ devides the order of some element of $G$. This filter returns \texttt{true} if \texttt{A} is modular according to this definition; \texttt{false} is returned otherwise. }

 

\subsection{\textcolor{Chapter }{IsPModularGroupAlgebra (IsFModularGroupAlgebra A)}}
\logpage{[ 2, 1, 3 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsPModularGroupAlgebra( A )\index{IsPModularGroupAlgebra@\texttt{IsPModularGroupAlgebra}!IsFModularGroupAlgebra A}
\label{IsPModularGroupAlgebra:IsFModularGroupAlgebra A}
}\hfill{\scriptsize (filter)}}\\


 A group algebra $FG$ is said to be $p$-modular, if $F$ is a field of characteristic $p$ and $G$ is a finite $p$-group for the same prime $p$. This filter returns \texttt{true} if \texttt{A} is a $p$-modular group algebra, \texttt{false} is returned otherwise. }

 

\subsection{\textcolor{Chapter }{UnderlyingGroup (IsGroupRing A)}}
\logpage{[ 2, 1, 4 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UnderlyingGroup( A )\index{UnderlyingGroup@\texttt{UnderlyingGroup}!IsGroupRing A}
\label{UnderlyingGroup:IsGroupRing A}
}\hfill{\scriptsize (attribute)}}\\


 Returns the underlying group of the group ring \texttt{A}. }

 

\subsection{\textcolor{Chapter }{UnderlyingRing (IsGroupRing A)}}
\logpage{[ 2, 1, 5 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UnderlyingRing( A )\index{UnderlyingRing@\texttt{UnderlyingRing}!IsGroupRing A}
\label{UnderlyingRing:IsGroupRing A}
}\hfill{\scriptsize (attribute)}}\\


 Returns the underlying ring of the group ring \texttt{A}. }

 

\subsection{\textcolor{Chapter }{UnderlyingField (IsGroupAlgebra A)}}
\logpage{[ 2, 1, 6 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UnderlyingField( A )\index{UnderlyingField@\texttt{UnderlyingField}!IsGroupAlgebra A}
\label{UnderlyingField:IsGroupAlgebra A}
}\hfill{\scriptsize (attribute)}}\\


 Returns the underlying field of the group algebra \texttt{A}. }

 }

 
\section{\textcolor{Chapter }{Operations with group algebra elements}}\label{elem functions}
\logpage{[ 2, 2, 0 ]}
{
 

\subsection{\textcolor{Chapter }{Support (x)}}
\logpage{[ 2, 2, 1 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Support( x )\index{Support@\texttt{Support}!x}
\label{Support:x}
}\hfill{\scriptsize (method)}}\\


 Returns the support of a group ring element. The support of a non-zero element $ x = \sum \alpha_g g $ of a group ring is the set of elements $g \in G$ for which $\alpha_g$ in not zero. The support of the zero element of a group ring is defined to be
the empty set. }

 

\subsection{\textcolor{Chapter }{CoefficientsBySupport (x)}}
\logpage{[ 2, 2, 2 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CoefficientsBySupport( x )\index{CoefficientsBySupport@\texttt{CoefficientsBySupport}!x}
\label{CoefficientsBySupport:x}
}\hfill{\scriptsize (method)}}\\


 This method returns a list that contains the coefficients corresponding to the
elements of \texttt{Support( x )} in the same order as the elements appear in \texttt{Support( x )}. }

 

\subsection{\textcolor{Chapter }{TraceOfMagmaRingElement (x)}}
\logpage{[ 2, 2, 3 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TraceOfMagmaRingElement( x )\index{TraceOfMagmaRingElement@\texttt{TraceOfMagmaRingElement}!x}
\label{TraceOfMagmaRingElement:x}
}\hfill{\scriptsize (method)}}\\


 This method returns the trace of a group ring element. By definition, the
trace of an element $ x = \sum \alpha_g g $ is $\alpha_1$, that is the coefficient of the identity element of a group $G$. The trace of the zero element is zero. }

 

\subsection{\textcolor{Chapter }{Length (x)}}
\logpage{[ 2, 2, 4 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Length( x )\index{Length@\texttt{Length}!x}
\label{Length:x}
}\hfill{\scriptsize (method)}}\\


 Returns the length of an element of a group ring which is defined as the
number of elements in its support. }

 

\subsection{\textcolor{Chapter }{Augmentation (x)}}
\logpage{[ 2, 2, 5 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Augmentation( x )\index{Augmentation@\texttt{Augmentation}!x}
\label{Augmentation:x}
}\hfill{\scriptsize (method)}}\\


 The augmentation of a group ring element $ x = \sum \alpha_g g $ is the sum of its coefficients: $ \sum \alpha_g $. }

 

\subsection{\textcolor{Chapter }{Involution (x, f)}}
\logpage{[ 2, 2, 6 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Involution( x, f )\index{Involution@\texttt{Involution}!x, f}
\label{Involution:x, f}
}\hfill{\scriptsize (method)}}\\


 Let $FG$ be a group ring and let $f$ be a mapping $G\rightarrow G$, such that $f^2$ is the identity mapping on $G$. Then the involution of $FG$ with respect to $f$ is defined as $\sum\alpha_g g\mapsto\sum\alpha_g f(g)$. This method returns the involution of $x$ with respect to $f$. }

 

\subsection{\textcolor{Chapter }{Involution (x)}}
\logpage{[ 2, 2, 7 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Involution( x )\index{Involution@\texttt{Involution}!x}
\label{Involution:x}
}\hfill{\scriptsize (method)}}\\


 Returns the involution of $x$ with respect to the map $x\mapsto x^{-1}$; see \texttt{Involution} (\ref{Involution}) }

 

\subsection{\textcolor{Chapter }{IsUnit (A, x)}}
\logpage{[ 2, 2, 8 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsUnit( A, x )\index{IsUnit@\texttt{IsUnit}!A, x}
\label{IsUnit:A, x}
}\hfill{\scriptsize (method)}}\\


 Returns \texttt{true} if \texttt{x} is an invertible element of the group ring \texttt{A}; returns \texttt{false} otherwise. }

 

\subsection{\textcolor{Chapter }{IsUnit (x)}}
\logpage{[ 2, 2, 9 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsUnit( x )\index{IsUnit@\texttt{IsUnit}!x}
\label{IsUnit:x}
}\hfill{\scriptsize (method)}}\\


 Returns \texttt{true} if \texttt{x} is an invertible element of a group ring; returns \texttt{false} otherwise. }

 

\subsection{\textcolor{Chapter }{InverseOp (x)}}
\logpage{[ 2, 2, 10 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{InverseOp( x )\index{InverseOp@\texttt{InverseOp}!x}
\label{InverseOp:x}
}\hfill{\scriptsize (method)}}\\


 This method calculates the inverse of a modular group algebra. This function
is invoked if the user types \texttt{x\^-1}. }

 }

 
\section{\textcolor{Chapter }{Important attributes of group algebras}}\label{ideals}
\logpage{[ 2, 3, 0 ]}
{
 

\subsection{\textcolor{Chapter }{AugmentationIdeal (IsFModularGroupAlgebra A)}}
\logpage{[ 2, 3, 1 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AugmentationIdeal( A )\index{AugmentationIdeal@\texttt{AugmentationIdeal}!IsFModularGroupAlgebra A}
\label{AugmentationIdeal:IsFModularGroupAlgebra A}
}\hfill{\scriptsize (method)}}\\


 If $FG$ is a group algebra, then its augmentation ideal is defined as the set of all
elements $FG$ with augmentation $0$; see \texttt{Augmentation} (\ref{Augmentation}). }

 

\subsection{\textcolor{Chapter }{RadicalOfAlgebra (A)}}
\logpage{[ 2, 3, 2 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RadicalOfAlgebra( IsPModularGroupAlgebra, A )\index{RadicalOfAlgebra@\texttt{RadicalOfAlgebra}!A}
\label{RadicalOfAlgebra:A}
}\hfill{\scriptsize (method)}}\\


 The radical of a $p$-modular group algebra coincides with the augmentation ideal. This method
simply checks if the algebra $A$ is a $p$-modular group algebra, and, if yes, it returns the augmentation ideal. }

 

\subsection{\textcolor{Chapter }{WeightedBasis (IsPModularGroupAlgebra A)}}
\logpage{[ 2, 3, 3 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{WeightedBasis( A )\index{WeightedBasis@\texttt{WeightedBasis}!IsPModularGroupAlgebra A}
\label{WeightedBasis:IsPModularGroupAlgebra A}
}\hfill{\scriptsize (method)}}\\


 The argument \texttt{A} must be a modular group algebra. The weighted basis is a basis of the
fundamental ideal such that each power of the fundamental ideal is spanned by
a subset of the basis. Note that this function actually constructs a basis for
the *fundamental ideal* and not for KG. Returns a record whose basis entry is
the basis and the weights entry is a list of corresponding weights of basis
elements with respect to the fundamental ideal filtration. This function uses
the Jennings basis of the underlying group. }

 

\subsection{\textcolor{Chapter }{AugmentationIdealPowerSeries (A)}}
\logpage{[ 2, 3, 4 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AugmentationIdealPowerSeries( IsPModularGroupAlgebra, A )\index{AugmentationIdealPowerSeries@\texttt{AugmentationIdealPowerSeries}!A}
\label{AugmentationIdealPowerSeries:A}
}\hfill{\scriptsize (method)}}\\


 The argument \texttt{A} is a modular group algebra. The method returns a list whose elements are the
terms of the augmentation ideal filtration of \texttt{A}. That is \texttt{AugmentationIdealPowerSeries(A)[k]} is the $i$-th power of the augmentation ideal of A. }

 

\subsection{\textcolor{Chapter }{AugmentationIdealNilpotencyIndex (IsPModularGroupAlgebra A)}}
\logpage{[ 2, 3, 5 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AugmentationIdealNilpotencyIndex( A )\index{AugmentationIdealNilpotencyIndex@\texttt{AugmentationIdealNilpotencyIndex}!IsPModularGroupAlgebra A}
\label{AugmentationIdealNilpotencyIndex:IsPModularGroupAlgebra A}
}\hfill{\scriptsize (method)}}\\


 Returns the smallest number $n$ such that $I^n=0$ where $I$ is the augmentation ideal of $A$. }

 

\subsection{\textcolor{Chapter }{AugmentationIdealOfDerivedSubgroupNilpotencyIndex (IsPModularGroupAlgebra A)}}
\logpage{[ 2, 3, 6 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AugmentationIdealOfDerivedSubgroupNilpotencyIndex( A )\index{AugmentationIdealOfDerivedSubgroupNilpotencyIndex@\texttt{AugmentationIdealOfDerivedSubgroupNilpotencyIndex}!IsPModularGroupAlgebra A}
\label{AugmentationIdealOfDerivedSubgroupNilpotencyIndex:IsPModularGroupAlgebra A}
}\hfill{\scriptsize (method)}}\\


 ??? }

 }

 
\section{\textcolor{Chapter }{Computations with the unit group}}\label{unit group}
\logpage{[ 2, 4, 0 ]}
{
 

\subsection{\textcolor{Chapter }{NormalizedUnitGroup (IsPModularGroupAlgebra A)}}
\logpage{[ 2, 4, 1 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NormalizedUnitGroup( A )\index{NormalizedUnitGroup@\texttt{NormalizedUnitGroup}!IsPModularGroupAlgebra A}
\label{NormalizedUnitGroup:IsPModularGroupAlgebra A}
}\hfill{\scriptsize (method)}}\\


 Determines the normalized unit group of a $p$-modular group algebra $A$. }

 

\subsection{\textcolor{Chapter }{NormalizedUnitCF (IsPModularA)}}
\logpage{[ 2, 4, 2 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NormalizedUnitCF( A, u )\index{NormalizedUnitCF@\texttt{NormalizedUnitCF}!IsPModularA}
\label{NormalizedUnitCF:IsPModularA}
}\hfill{\scriptsize (method)}}\\


 }

 

\subsection{\textcolor{Chapter }{Size (IsNormalizedUnitGroupOfGroupRing A)}}
\logpage{[ 2, 4, 3 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Size( U )\index{Size@\texttt{Size}!IsNormalizedUnitGroupOfGroupRing A}
\label{Size:IsNormalizedUnitGroupOfGroupRing A}
}\hfill{\scriptsize (method)}}\\


 Returns the size of \texttt{U}. }

 

\subsection{\textcolor{Chapter }{PcNormalizedUnitGroup (IsPModularGroupAlgebra A)}}
\logpage{[ 2, 4, 4 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PcNormalizedUnitGroup( A )\index{PcNormalizedUnitGroup@\texttt{PcNormalizedUnitGroup}!IsPModularGroupAlgebra A}
\label{PcNormalizedUnitGroup:IsPModularGroupAlgebra A}
}\hfill{\scriptsize (method)}}\\


 The argument \texttt{A} is a modular group algebra. Computes the normalized unit group of \texttt{A}. The unit group is computed as a polycyclic group given by power-commutator
presentation. The generators of the presentation correspond to the weighted
basis of \texttt{A}. }

 

\subsection{\textcolor{Chapter }{Units (IsPModularGroupAlgebra A)}}
\logpage{[ 2, 4, 5 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Units( A )\index{Units@\texttt{Units}!IsPModularGroupAlgebra A}
\label{Units:IsPModularGroupAlgebra A}
}\hfill{\scriptsize (method)}}\\


 Returns the unit group of \texttt{A}. }

 

\subsection{\textcolor{Chapter }{PcUnits (IsPModularGroupAlgebra A)}}
\logpage{[ 2, 4, 6 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PcUnits( A )\index{PcUnits@\texttt{PcUnits}!IsPModularGroupAlgebra A}
\label{PcUnits:IsPModularGroupAlgebra A}
}\hfill{\scriptsize (method)}}\\


 Returns the unit group of \texttt{A} as a PC group given by a polycyclic presentation. }

 

\subsection{\textcolor{Chapter }{Size (U)}}
\logpage{[ 2, 4, 7 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Size( IsUnitGroupOfGroupRing, U )\index{Size@\texttt{Size}!U}
\label{Size:U}
}\hfill{\scriptsize (method)}}\\


 Returns the size of \texttt{U}. }

 

\subsection{\textcolor{Chapter }{PcUnits (IsPModularGroupAlgebra A)}}
\logpage{[ 2, 4, 8 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PcUnits( A )\index{PcUnits@\texttt{PcUnits}!IsPModularGroupAlgebra A}
\label{PcUnits:IsPModularGroupAlgebra A}
}\hfill{\scriptsize (method)}}\\


 Returns the group of units in \texttt{A} a polycyclic group with a pc-presentation. }

 

\subsection{\textcolor{Chapter }{NaturalBijectionToPcNormalizedUnitGroup (IsPModularGroupAlgebra A)}}
\logpage{[ 2, 4, 9 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NaturalBijectionToPcNormalizedUnitGroup( A )\index{NaturalBijectionToPcNormalizedUnitGroup@\texttt{NaturalBijectionToPcNormalizedUnitGroup}!IsPModularGroupAlgebra A}
\label{NaturalBijectionToPcNormalizedUnitGroup:IsPModularGroupAlgebra A}
}\hfill{\scriptsize (method)}}\\


 The normalised unit group of a $p$-modular group algebra $A$ can be computed using two methods, namely \texttt{NormalizedUnitGroup} and \texttt{PcNormalizedUnitGroup}. These two methods return two different objects, and they can be used for
different types of computations. The elements of \texttt{NormalizedUnitGroup(A)} are represented in their natural group algebra representations, and hence they
can easily be identified in the group algebra. However, \texttt{NormalizedUnitGroup(A)} is often not suitable for fast computation, and one will have to use \texttt{PcNormalizedUnitGroup(A)} if one wants to find some group theoretic properties of the normalized unit
group. This method returns the bijection between \texttt{NormalizedUnitGroup(A)} and \texttt{PcNormalizedUnitGroup(A)}. }

 

\subsection{\textcolor{Chapter }{NaturalBijectionToNormalizedUnitGroup (A)}}
\logpage{[ 2, 4, 10 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NaturalBijectionToNormalizedUnitGroup( A )\index{NaturalBijectionToNormalizedUnitGroup@\texttt{NaturalBijectionToNormalizedUnitGroup}!A}
\label{NaturalBijectionToNormalizedUnitGroup:A}
}\hfill{\scriptsize (method)}}\\


 This function returns the bijection between \texttt{PcNormalizedUnitGroup(A)} and \texttt{NormalizedUnitGroup(A)}; see \texttt{NaturalBijectionToNormalizedUnitGroup} (\ref{NaturalBijectionToNormalizedUnitGroup}) for explanation. }

 

\subsection{\textcolor{Chapter }{GroupBases (IsPModularGroupAlgebra A)}}
\logpage{[ 2, 4, 11 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GroupBases( A )\index{GroupBases@\texttt{GroupBases}!IsPModularGroupAlgebra A}
\label{GroupBases:IsPModularGroupAlgebra A}
}\hfill{\scriptsize (method)}}\\


 ??? }

 }

 
\section{\textcolor{Chapter }{The Lie algebra of a group algebra}}\label{Lie algebra}
\logpage{[ 2, 5, 0 ]}
{
 

\subsection{\textcolor{Chapter }{LieAlgebraByDomain (A)}}
\logpage{[ 2, 5, 1 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LieAlgebraByDomain( A )\index{LieAlgebraByDomain@\texttt{LieAlgebraByDomain}!A}
\label{LieAlgebraByDomain:A}
}\hfill{\scriptsize (method)}}\\


 This method takes an associative algebra as argument, and constructs its
associated Lie algebra in which product is defined as the bracket operation: $[a,b]=ab-ba$. It is recommended that the user never should call this method. The Lie
algebra for an associative algebra should normally be created using \texttt{LieAlgebra( A )}. When \texttt{LieAlgebra} is first invoked it constructs the Lie algebra for $A$ using \texttt{LieAlgebraByDomain}. After that it stores this Lie algebra and simply returns it if \texttt{LieAlgebra} is again called. }

 

\subsection{\textcolor{Chapter }{AugmentationIdealPowerSeries (A)}}
\logpage{[ 2, 5, 2 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AugmentationIdealPowerSeries( A )\index{AugmentationIdealPowerSeries@\texttt{AugmentationIdealPowerSeries}!A}
\label{AugmentationIdealPowerSeries:A}
}\hfill{\scriptsize (method)}}\\


 description }

 

\subsection{\textcolor{Chapter }{CanonicalBasis (A)}}
\logpage{[ 2, 5, 3 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CanonicalBasis( A )\index{CanonicalBasis@\texttt{CanonicalBasis}!A}
\label{CanonicalBasis:A}
}\hfill{\scriptsize (method)}}\\


 description }

 

\subsection{\textcolor{Chapter }{StructureConstantsTable (A)}}
\logpage{[ 2, 5, 4 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{StructureConstantsTable( A )\index{StructureConstantsTable@\texttt{StructureConstantsTable}!A}
\label{StructureConstantsTable:A}
}\hfill{\scriptsize (method)}}\\


 description }

 

\subsection{\textcolor{Chapter }{Embedding (A)}}
\logpage{[ 2, 5, 5 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Embedding( A )\index{Embedding@\texttt{Embedding}!A}
\label{Embedding:A}
}\hfill{\scriptsize (method)}}\\


 description }

 

\subsection{\textcolor{Chapter }{LieDerivedSubalgebra (A)}}
\logpage{[ 2, 5, 6 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LieDerivedSubalgebra( A )\index{LieDerivedSubalgebra@\texttt{LieDerivedSubalgebra}!A}
\label{LieDerivedSubalgebra:A}
}\hfill{\scriptsize (method)}}\\


 description }

 

\subsection{\textcolor{Chapter }{LieCentre (A)}}
\logpage{[ 2, 5, 7 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LieCentre( A )\index{LieCentre@\texttt{LieCentre}!A}
\label{LieCentre:A}
}\hfill{\scriptsize (method)}}\\


 The (Lie) centre of a Lie algebra of a group ring corresponds to the centre of
the underlying group ring, and it can be calculated very fast by considering
the conjugacy classes of the group. Since the corresponding method for the
centre of the group ring does just that, it is being referred to by the method
at hand. Note that he prefix `Lie' is consistently used to distinguish
properties of Lie algebras from the analogous properties of groups (or of
general algebras). Not using this prefix may result in error messages, or even
in wrong results without warning. This is particularly important for the
command LieCentre. }

 

\subsection{\textcolor{Chapter }{IsLieAbelian (A)}}
\logpage{[ 2, 5, 8 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsLieAbelian( A )\index{IsLieAbelian@\texttt{IsLieAbelian}!A}
\label{IsLieAbelian:A}
}\hfill{\scriptsize (method)}}\\


 The Lie algebra $L$ of an associative algebra $A$ is Lie abelian, if and only if $A$ is abelian, so this method refers to \texttt{IsAbelian( A )}. }

 

\subsection{\textcolor{Chapter }{IsLieSolvable (A)}}
\logpage{[ 2, 5, 9 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsLieSolvable( A )\index{IsLieSolvable@\texttt{IsLieSolvable}!A}
\label{IsLieSolvable:A}
}\hfill{\scriptsize (method)}}\\


 In \cite{PPS73} Passi, Passman, and Sehgal have classified all groups $G$ such that the associated Lie algebra $L$ of the group ring is (Lie) solvable. This method uses their classification,
making it considerably faster than the more elementary method which just
calculates Lie commutators. }

 

\subsection{\textcolor{Chapter }{IsLieNilpotent (A)}}
\logpage{[ 2, 5, 10 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsLieNilpotent( A )\index{IsLieNilpotent@\texttt{IsLieNilpotent}!A}
\label{IsLieNilpotent:A}
}\hfill{\scriptsize (method)}}\\


 In \cite{PPS73} Passi-Passman-Sehgal have classified all groups $G$ such that the associated Lie algebra $L$ of the group ring is (Lie) nilpotent. This method uses their classification,
making it considerably faster than the more elementary method which just
calculates Lie commutators. }

 

\subsection{\textcolor{Chapter }{IsLieMetabelian (A)}}
\logpage{[ 2, 5, 11 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsLieMetabelian( A )\index{IsLieMetabelian@\texttt{IsLieMetabelian}!A}
\label{IsLieMetabelian:A}
}\hfill{\scriptsize (method)}}\\


 In \cite{LR86} Levin and Rosenberger have classified all groups $G$ such that the associated Lie algebra $L$ of the group ring is (Lie) metabelian. This method uses their classification,
making it considerably faster than the more elementary method which just
calculates Lie commutators. }

 

\subsection{\textcolor{Chapter }{IsLieCentreByMetabelian (A)}}
\logpage{[ 2, 5, 12 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsLieCentreByMetabelian( A )\index{IsLieCentreByMetabelian@\texttt{IsLieCentreByMetabelian}!A}
\label{IsLieCentreByMetabelian:A}
}\hfill{\scriptsize (method)}}\\


 In \cite{Ross} the third author of this package classified all groups $G$ such that the associated Lie algebra $L$ of the group ring is (Lie) centre-by-metabelian. This method uses the
classification, making it considerably faster than the more elementary method
which just calculates Lie commutators. description }

 

\subsection{\textcolor{Chapter }{LieUpperNilpotencyIndex (A)}}
\logpage{[ 2, 5, 13 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LieUpperNilpotencyIndex( A )\index{LieUpperNilpotencyIndex@\texttt{LieUpperNilpotencyIndex}!A}
\label{LieUpperNilpotencyIndex:A}
}\hfill{\scriptsize (method)}}\\


 description }

 }

 
\section{\textcolor{Chapter }{Other commands}}\label{other}
\logpage{[ 2, 6, 0 ]}
{
 

\subsection{\textcolor{Chapter }{SubgroupsOfIndexTwo (A)}}
\logpage{[ 2, 6, 1 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SubgroupsOfIndexTwo( A )\index{SubgroupsOfIndexTwo@\texttt{SubgroupsOfIndexTwo}!A}
\label{SubgroupsOfIndexTwo:A}
}\hfill{\scriptsize (method)}}\\


 A list is returned here. (The subgroups of index two in the group $G$ are important for the Lie structure of the group algebra $FG$, in case that the underlying field $F$ has characteristic 2.) }

 

\subsection{\textcolor{Chapter }{DihedralDepth (A)}}
\logpage{[ 2, 6, 2 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DihedralDepth( A )\index{DihedralDepth@\texttt{DihedralDepth}!A}
\label{DihedralDepth:A}
}\hfill{\scriptsize (method)}}\\


 }

 

\subsection{\textcolor{Chapter }{JenningsBasis (A)}}
\logpage{[ 2, 6, 3 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{JenningsBasis( A )\index{JenningsBasis@\texttt{JenningsBasis}!A}
\label{JenningsBasis:A}
}\hfill{\scriptsize (method)}}\\


 description }

 

\subsection{\textcolor{Chapter }{LieDimensionSubgroups (A)}}
\logpage{[ 2, 6, 4 ]}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LieDimensionSubgroups( A )\index{LieDimensionSubgroups@\texttt{LieDimensionSubgroups}!A}
\label{LieDimensionSubgroups:A}
}\hfill{\scriptsize (method)}}\\


 description }

 }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}}

\bibliographystyle{alpha}
\bibliography{manual}

\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
