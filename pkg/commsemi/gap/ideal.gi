#############################################################################
##
#W  ideal.gi           COMMSEMI library                        Isabel Araujo 
##
#H  @(#)$Id: ideal.gi,v 1.3 2000/06/01 15:43:59 gap Exp $
##
#Y  Copyright (C)  1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
#Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
##
##  This file contains code for commutative semigroups
##
Revision.ideal_gi:=
    "@(#)$Id: ideal.gi,v 1.3 2000/06/01 15:43:59 gap Exp $";


#############################################################################
##
#M  BasisOfSemigroupIdeal( <id> )
##
InstallMethod(BasisOfSemigroupIdeal, 
"for a commutative fp semigroup and a list of elements", true,
[IsSemigroupIdeal and IsCommutative],0,
function(id)
  local vbasis,basis,s;

  # this only works for commutative semigroups
  if not IsCommutative(Parent(id)) then
    TryNextMethod();
  fi;
  
  s := Parent(id);
  vbasis := VectorBasisOfSemigroupIdealWithFactors(id);
	if IsFpMonoid(s) then
		basis := List([1..Length(vbasis)],i->
            VectorToAssocWord(FreeMonoidOfFpMonoid(s),vbasis[i][1]));
	else
		basis := List([1..Length(vbasis)],i->
            VectorToAssocWord(FreeSemigroupOfFpSemigroup(s),vbasis[i][1]));
	fi;

  return basis;

end);

InstallOtherMethod(BasisOfSemigroupIdeal, 
"for a commutative fp semigroup and a list of elements", true,
[IsSemigroup and IsCommutative,IsList],0,
function(s,x)
  local id;

	# this only works for fp semigroups or fp monoids
	if not(IsFpMonoid(s) or IsFpSemigroup(s)) then
		TryNextMethod();
	fi;

  id := SemigroupIdealByGenerators(s,x);
  return BasisOfSemigroupIdeal(id);

end);

InstallOtherMethod(BasisOfSemigroupIdeal,
"for a commutative fp semigroup and an element", true,
[IsFpSemigroup and IsCommutative,IsElementOfFpSemigroup],0,
function(s,x)
  return BasisOfSemigroupIdeal(s,[x]);
end);

InstallOtherMethod(BasisOfSemigroupIdeal,
"for a commutative fp monoid and an element", true,
[IsFpMonoid and IsCommutative,IsElementOfFpMonoid],0,
function(s,x)
  return BasisOfSemigroupIdeal(s,[x]);
end);

#############################################################################
##
#M  VectorBasisOfSemigroupIdealWithFactors( <S> , <e> )
##
##  for a semigroup <s> and set <X> of elements of <S>
##  it returns a list of triples of words
##  The set consisting of all the words appearing as first components
##  of the triples are words which generate the ideal (of the free
##  semigroup) of all words which represent elements in the ideal
##  of <S> generated by <X>
##  Now if a triple is [w,t,d] than it means that
##  [w]=[t][d] where the notation [w] means the element of
##  the semigroup <S> which w represents
##  
##  This is the algorithm described in Araujo, Kelarev and Solomon
##  changed by Araujo to keep track of the factors
##
InstallMethod(VectorBasisOfSemigroupIdealWithFactors,
"for a semigroup ideal", true,
[IsSemigroupIdeal and IsCommutative],0,
function(id)
  
  local crws,         # rewriting system
        r,            # rules
        u,            # a rule
        V,oldV,       # set containing the basis (set of triples)
        v,            # a triple
        gamma,delta,  # vectors as described above
        y,            # vector
        Y,s,
        Minimize;
   
  ##########################################################
  # given a set of words returns a subset of them
  # with the minimal ones wrt the division order of the
  # corresponding vector
  Minimize:=function(gens)

    local genset,               # set of gens (ie gets rid of repetitions)
          j,                    # loop variable
          nonredundant;         # the result

    genset := ShallowCopy(gens);
    # get rid of gens that have equal first entry
    for j in [1..Length(genset)] do
      if ForAny([1..j-1],i->IsBound(genset[i]) 
      and genset[i][1]=genset[j][1]) then
        Unbind(gens[j]);
      fi;
    od;
    genset:=Set(gens);

    # we start with an empty set and keep adding the gens that
    # are not divisible by anything else
    nonredundant:=[];

    # the following tests if the generator is divisible by
    # anything else
    for j in [1..Length(genset)] do

      if not( ForAny([1..Length(genset)],i->i<>j
          and IsVectorDivLessThanOrEqual(genset[i][1],genset[j][1]))) then
        # and add it to the set
        Add(nonredundant,genset[j]);
      fi;

    od;
    return nonredundant;
  end;

  #################
  # actual function

  s := Parent(id);
  # transform the generators of the ideal into vectors
  Y := List([1..Length(GeneratorsOfMagmaIdeal(id))],i->
              ElementOfFpSemigroupAsVector(GeneratorsOfMagmaIdeal(id)[i]));

  # the set given must not be empty
  if IsEmpty(Y) then
    Error("The set of generators of the ideal must be non empty");
  fi;

  # get the commutative reduced confluent rws of s and its set of vector rules
  crws := CommutativeReducedConfluentSemigroupRws(s);
  r := VectorRulesOfCommutativeSemigroupRws(crws);

  oldV := [];
  V := [];
  for y in Y do
    Add(V,[ShallowCopy(y),y,List([1..Length(y)],i->0)]);
  od;

  while oldV <> V do
    oldV := ShallowCopy(V);

    # we obtain new generators for the ideal as follows:
    # given v in V and a relation u in r
    # we make v[1]+delta-u[1]+u[2] and also v[1]+gamma-u[2]+u[1]
    # delta = vector which entries are the maximum between the
    # correspondent entries of v[1] and u[1], minus v[1] (that is, 
    # what is missing in v[1] to be able to apply the rule u[1]->u[2])
    # gamma = vector which entries are the maximum between the
    # correspondent entries of v[1] and u[2], minus v[1] (that is, 
    # what is missing in v[1] to be able to apply the rule u[1]->u[2]
    # backwards)
    # Notice that by adding a vector delta (or gamma) to v[1]
    # we obtain a vector representing an element of the considered
    # ideal and, and by then applying a rule (forward or backwards
    # we don't change the represented element)
    # Also notice that if v[1] represents the same element as v[2]+v[3]
    # then the new element represents the same element as v[2]+(v[3]+delta)
    # (or v[2]+(v[3]+gamma))

    for v in V do
      for u in r do
        delta := List([1..Length(v[1])],i->Maximum(v[1][i],u[1][i]))-v[1];
        Add(V, [v[1]+delta-u[1]+u[2], v[2],v[3]+delta]);

        gamma := List([1..Length(v[1])],i->Maximum(v[1][i],u[2][i]))-v[1];
        Add(V, [v[1]+gamma-u[2]+u[1], v[2],v[3]+gamma]);

        V := Minimize(V);
      od;
    od;

  od;

  return V;

end);

InstallOtherMethod(VectorBasisOfSemigroupIdealWithFactors,
"for semigroup and a list of elements of it",
[IsSemigroup and IsCommutative,IsList],0,
function(s,x)
  local id;

  id := SemigroupIdealByGenerators(s,x);
  return VectorBasisOfSemigroupIdealWithFactors(id);

end);

#############################################################################
##
#M  VectorBasisOfSemigroupIdeal( <id> )
##
InstallMethod(VectorBasisOfSemigroupIdeal,
"for and ideal of a commutative semigroup",
[IsSemigroupIdeal and IsCommutative],
function(id)
  local vbasis;

  vbasis := VectorBasisOfSemigroupIdealWithFactors(id);
  return List([1..Length(vbasis)],i->vbasis[i][1]);

end);



#############################################################################
##
#M  \in
##
InstallMethod(\in,
"for an element and an ideal from a commutative semigroup", true,
[IsElementOfFpSemigroup, IsSemigroupIdeal and IsCommutative],0,
function(x,id)
  local basis,v;

  basis := VectorBasisOfSemigroupIdeal(id);
  v := ElementOfFpSemigroupAsVector(x);
  
  return ForAny(basis,b->IsVectorDivLessThanOrEqual(b,v));
end);

InstallMethod(\in,
"for an element and an ideal from a commutative fp monoid", true,
[IsElementOfFpMonoid, IsSemigroupIdeal and IsCommutative],0,
function(x,id)
  local basis,v;

  basis := VectorBasisOfSemigroupIdeal(id);
  v := ElementOfFpMonoidAsVector(x);

  return ForAny(basis,b->IsVectorDivLessThanOrEqual(b,v));
end);




#############################################################################
##
#M   
##

