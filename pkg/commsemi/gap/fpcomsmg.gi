#############################################################################
##
#W  fpcomsmg.gi           COMMSEMI library    Isabel Araujo and Andrew Solomon
##
#H  @(#)$Id: fpcomsmg.gi,v 1.6 2001/09/12 20:26:05 gap Exp $
##
#Y  Copyright (C)  1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
#Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
##
##  This file contains code for commutative semigroups
##

Revision.fpcomsmg_gi :=
    "@(#)$Id: fpcomsmg.gi,v 1.6 2001/09/12 20:26:05 gap Exp $";

# TODO
# have to think about the distintion between fp monoids and fp semigroup

###############################################################
##
##  From the theory we know that the commutative fp smg S is 
##  finite iff any crws has, for all generators x,
##  a relation which lhs is x^n, for some n
##  
##  The exponents of this relations give us a bound on the
##  size of the commutative semigroup, since if x^n is a lhs
##  then every word with an occurence of x^k, k>=n, is
##  necessarily equal to a smaller one
##  We build a set T of vectors: all vectors with i-th entry
##  less than the minimum exponent to which generator i
##  appears in relations with lhs of the type x^n
##  The size of T is the refered bound on the size of S
##
##  But other relations from r may give rise to vectors
##  of T representing the same word.
##  ie, S may have strictly less elements than T
##
##  In fact, we have to remove the size of the union of the 
##  ideals generated by lhs of those other relations, because 
##  they correpond to words which are not reduced.
##  
##  If the union of such ideals of vectors ir I then
##  |S|=|T|-|I|
##  Then we just have to calculate the size of T
##  and the size of I. The latter is done by a combinatorial
##  argument (inclusion/exclusion)
##
##  In this way we calculate the size of the semigroup S,
##  given a crws for it, without enumerating S
##

#############################################################################
##
#M  EpimorphismAbelianization(<S>)
##
##  returns an epimorphism from an fp semigroup to its abelianization.
##
InstallMethod(EpimorphismAbelianization,
"for an fp semigroup", true,
[IsFpSemigroup],0,
function(s)

  local f,    # free semigroup
        i,j,  # loop variables 
        r,    # relations 
        x,    # generators of semigroup
        epifun, # the function which computes the epimorphism
        cs;   # the abelianized semigroup

  #add relations to make it commutative
  #relations added are: x*y=y*x for x,y generators of
  #the free underlying semigroup
  f:=FreeSemigroupOfFpSemigroup(s);
  x:=GeneratorsOfSemigroup(f);
  r:=ShallowCopy(RelationsOfFpSemigroup(s));
  
  for i in [1..Length(x)] do
    for j in [1..i-1] do
      Add(r,[x[j]*x[i],x[i]*x[j]]);
    od;
  od;

  cs:=f/r;
  SetIsCommutative(cs,true);

  epifun :=  g->
  VectorToElementOfCommutativeFpSemigroup(cs, ElementOfFpSemigroupAsVector(g));

  return MagmaHomomorphismByFunctionNC(s, cs, epifun);

end);

#############################################################################
##
#M  EpimorphismAbelianization(<S>)
##
##  returns an epimorphism from an fp monoid to its abelianization.
##
InstallMethod(EpimorphismAbelianization,
"for an fp monoid", true,
[IsFpMonoid],0,
function(m)

  local f,    # free monoid 
        i,j,  # loop variables 
        r,    # relations 
        x,    # generators of mnoid 
        epifun, # the function which computes the epimorphism
        cm;   # the abelianized monoid 

  #add relations to make it commutative
  #relations added are: x*y=y*x for x,y generators of
  #the free underlying monoid 
  f:=FreeMonoidOfFpMonoid(m);
  x:=GeneratorsOfMonoid(f);
  r:=ShallowCopy(RelationsOfFpMonoid(m));
  
  for i in [1..Length(x)] do
    for j in [1..i-1] do
      Add(r,[x[j]*x[i],x[i]*x[j]]);
    od;
  od;

  cm:=f/r;
  SetIsCommutative(cm,true);

  epifun :=  g->
  VectorToElementOfCommutativeFpMonoid(cm, ElementOfFpMonoidAsVector(g));

  return MagmaHomomorphismByFunctionNC(m, cm, epifun);

end);

#############################################################################
##
#M  Abelianization(<S>)
##
InstallMethod(Abelianization,
"<S>", true,
[IsSemigroup],0,
function(s)

  #if gap already knows that s is a commutative semigroup,
  #it returns s itself 
  if HasIsCommutative(s) and IsCommutative(s) then
    return s;
  fi;

  return Range(EpimorphismAbelianization(s));
end);


#############################################################################
##
#F  AssocWordToVector (<w>)
##  
##  given a word in the Free Semigroup, transforms it into a vector,
##  where entry i corresponds to the number
##  of times that generator i appears in the word
##
InstallGlobalFunction(AssocWordToVector,
function(w)

  local i,      # loop variable
        k,      # generator of syllable
        m,      # number of generators
        n,      # number of syllables
        vector; # resulting vector


	if IsBound(CollectionsFamily(FamilyObj(w))!.wholeMonoid) then
		m := Length(GeneratorsOfMonoid(CollectionsFamily(
              FamilyObj(w))!.wholeMonoid));
  elif IsBound(CollectionsFamily(FamilyObj(w))!.wholeSemigroup) then
		m := Length(GeneratorsOfSemigroup(CollectionsFamily(
              FamilyObj(w))!.wholeSemigroup));
	else 
		TryNextMethod();
	fi;

  n:=NumberSyllables(w);
  vector:=[];

  #we start by having zeros in all entries
  for i in [1..m] do Add(vector,0);od;

  #run through the syllables of the word
  #and add the exponent to the entry of the vector
  #correponding to the syllable generator
  for i in [1..n] do
    k:=GeneratorSyllable(w,i);
    vector[k]:=vector[k]+ExponentSyllable(w,i);
  od;
  
  return vector;  

end);
  
#############################################################################
##
#F  ElementOfFpSemigroupAsVector (<e>)
##  
##  
InstallGlobalFunction(ElementOfFpSemigroupAsVector,
e -> AssocWordToVector(UnderlyingElement(e)));

#############################################################################
##
#F  ElementOfFpMonoidAsVector (<e>)
## 
InstallGlobalFunction(ElementOfFpMonoidAsVector,
e -> AssocWordToVector(UnderlyingElement(e)));

#############################################################################
##
#F  VectorToElementOfCommutativeFpSemigroup(<S>,<v>)
##
InstallGlobalFunction(VectorToElementOfCommutativeFpSemigroup,
function(s,v)

  local allentrieszero,  
	f,              # the semigroup 
        i,              # loop variable
        fam,            # family of the free gens of the semigroup
        vl,             # the external representation associated to v
        x;              # generators of semigroup

  x:=FreeGeneratorsOfFpSemigroup(s);
  
  if Length(x)<>Length(v) then
    Error("Wrong vector length");
  fi;

  allentrieszero := true;
  for i in [1..Length(v)] do
    if v[i]<>0 then
      allentrieszero := false;
    fi;
  od;
  if allentrieszero then
		# zero vectors are not aloud
		Error("Zero vector not aloud (semigroup does not have identity)");
	fi;

  # we now build the external representation of the free object
  # underlying the element of the fp semigroup
  vl := List([1..2*Length(v)],function(i)
	   if IsOddInt(i) then return (i+1)/2; else return v[i/2]; fi;
	   end);
  fam := FamilyObj(x[1]);
  f:=FamilyObj(GeneratorsOfSemigroup(s)[1]);

  return ElementOfFpSemigroup(f,(ObjByExtRep(fam,vl)));

end);

#############################################################################
##
#F  VectorToElementOfCommutativeFpMonoid(<S>,<v>)
##
InstallGlobalFunction(VectorToElementOfCommutativeFpMonoid,
function(s,v)

  local allentrieszero,	# whether all entries of the vector v are zero
				f,              # the free monoid 
        i,              # loop variable
        fam,            # type of generators of monoid 
        vl,
        x;              # generators of free monoid 


  x:=FreeGeneratorsOfFpMonoid(s);
  
  if Length(x)<>Length(v) then
    Error("Wrong vector length");
  fi;

	allentrieszero := true;
	for i in [1..Length(v)] do
		if v[i]<>0 then
			allentrieszero := false;	
		fi;
	od;
	if allentrieszero then
		return One(s);
	fi;

  # we now build the external representation of the free object
  # underlying the element of the fp semigroup
  vl := List([1..2*Length(v)],function(i)
             if IsOddInt(i) then return (i+1)/2; else return v[i/2]; fi;
             end);

  fam:=FamilyObj(x[1]);
  f:=FamilyObj(GeneratorsOfMonoid(s)[1]);

  return ElementOfFpMonoid(f,(ObjByExtRep(fam,vl)));

end);

#############################################################################
##
#F  VectorOfSupOfEntriesOfElementsOfCommutativeFpSemigroupOrFpMonoid(<s>)
##  
##  Returns a vector which entries are sup of entries of reduced words,
##  ie, sups of entries of elements of the semigroup.
##
InstallGlobalFunction(
VectorOfSupOfEntriesOfElementsOfCommutativeFpSemigroupOrFpMonoid,
function(s)

  local crws,         # commutative reduced confluent rws for s
        r,            # set of vector rules of crws 
        vector,       # the vector of sup
        n,            # number of generators of the semigroup or monoid
        list;         # subslist of the list of rules 

  # we start by getting the commutative confluent rws for the semigroup
  crws := CommutativeReducedConfluentSemigroupRws(s);
  # and get the rules
  r := VectorRulesOfCommutativeSemigroupRws(crws);
  
  vector := [];
  n := Length(r[1][1]);

  # now we choose the rules whose lhs is a power of a generator 
  list := Filtered([1..Length(r)],
      k -> ForAny([1..n],i->ForAll([1..n],j->i=j or r[k][1][j]=0)));  
  # the vector we are looking for is the sum of the corresponding
  # vectors of lhs of the rules to which list refers
	if IsEmpty(list) then
		return fail; 
  else
		vector := Sum(List([1..Length(list)], i-> r[list[i]][1]));
	fi;

  # if the vector has any non-zero entries then  it
  # means that all powers of a certain generator are different
  # and the semigroup is infinite
  # Hence we return fail
  if ForAny([1..n],i->vector[i]=0) then
    return fail;
  fi;

  return vector;
  
end);
      

#############################################################################
##
#M  IsFinite( <S> ) . . . . . . . . . . . . . for a fp commutative semigroup
##
InstallMethod( IsFinite,
    "method for a fp commutative semigroup",
    true,
    [ IsSemigroup and IsCommutative ], 0,
    function(S)
		# this just works for fp semigroups or monoids
		if not (IsFpSemigroup(S) or IsFpMonoid(S)) then
			TryNextMethod();
		fi;
    return 
		 VectorOfSupOfEntriesOfElementsOfCommutativeFpSemigroupOrFpMonoid(S)<>fail;
end);


############################################################################
##
#F  SizeOfFpCommutativeSemigroupOrMonoid(<S>)
##  
##  for a fp commutative semigroup S 
##
##  the global function to calculate the size of an abelian fp semigroup
##  when we have the proper category this function should be a function
##  of a commutative semigroup
##
##  This function takes a fp commutative semigroup 
##
InstallGlobalFunction(SizeOfFpCommutativeSemigroupOrMonoid,
function(s)

  local auxsize,              # size of union of ideals            
        auxsum,               # sum of sizes of intersection of ideals
        generators_of_ideals, # function of the rules, returning gens of ideals
        i,j,U,                # loop variables
        idealgenerators,      # set of ideal generators 
        idgens,               # subset of ideal generators
        i_subsets_of_n,       # list of subsets of {1..n} with i elements 
        crws,                 # rewriting system 
        r,                    # set of vector rules
        rhovector,            # vector of sup of entries
        size_of_intersection_of_ideals, 
        t;                    # upper bound for size of semigroup
        

  #################################################################
  # given a set of vector rules this function returns
  # the vectors which are generators of ideals of
  # non-reduced words (with more than one non-zero compoenent)
  # (ie, vectors correponding to left hand sides of relations of
  # Rules(rws), which are neither trivial nor involve only one gen
  generators_of_ideals:=function(r)

    local listgen,        # list of generators of ideals of non reduced words
          u,              # a vector relation
          n;              # number of generators of the semigroup

    n := Length(r[1][1]);
    listgen:=[];
    for u in r do
      if u[1]<>u[2] then
        if not Number([1..n],i->u[1][i]<>0) in [0..1] then 
          Add(listgen,u[1]);
        fi;
      fi;
    od;

    return Set(listgen);

  end;

  #################################################################
  # given the vector of sup of entries and a set of generators of
  # ideals it calculates the size of the intersection of those ideals
  # If a vector is in the intersection then all its entries
  # have to be greater then or equal to the correponding
  # entries of all the ideal generators. The intersection will be 
  # exactly the set of all vectors with entry i satisfying: 
  # max of entries i of generators of ideals <= i < rhovector(i)
  size_of_intersection_of_ideals:=function(rhovector,idealgens)

    local auxcount,           # auxiliary variable
          auxmax,             # auxiliary variable
          i,k,                # loop variables
          vectorofmax;        

    # we first compute the vector which entries are
    # the maximum of correponding entries of all
    # generators of the considered ideals
    vectorofmax := List([1..Length(rhovector)], 
                i->Maximum(List([1..Length(idealgens)],k->idealgens[k][i])));

    # then count how many elements are in the intersection
    # (elements with entry i satisfied the above stated)
    auxcount:=1;
    for i in [1..Length(rhovector)] do
      auxcount:=auxcount*(rhovector[i]-vectorofmax[i]);
    od;

    return auxcount;

  end;


  #first check if the semigroup is finite or infinite
  if not(IsFinite(s)) then
    return infinity;
  fi;
  
  # get a commutative reduced confluent rws and its set of vector rules
  crws := CommutativeReducedConfluentSemigroupRws(s);
  r := VectorRulesOfCommutativeSemigroupRws(crws);

  # here we know that the semigroup is finite
  # we compute the vector of sup of entries, call it 'rhovector'
  # (ie, any word in the semigroup can be represented by
  # an element with i-th entry is less than i'th entry of
  # the 'rhovector')
  rhovector:=
		  VectorOfSupOfEntriesOfElementsOfCommutativeFpSemigroupOrFpMonoid(s);

  # from the rhovector we consider the set T which is  a set of vectors: 
  # all vectors with i-th entry less than the i entry of the rhovector. 
  # The size of T is a upper bound to the size of S 
  # We compute the size, t, of T:
  t:=1;
  for i in rhovector do
    t:=t*i;
  od;
  # now we have all elements, plus the empty word which is not allowed
  t:=t-1;
  
  # We know calculate the size of the union of all ideals of non-reduced 
  # words (these are principal ideals, generated by the vectors 
  # corresponding to the lhs of relations of the rewriting system for s.
  # We do this by inclusion/exclusion principle

  auxsize:=0;
  idealgenerators:=generators_of_ideals(r);
    
  # the following cycle is the inclusion/exclusion principle
  # (we have as many ideals as ideal generators)
  for i in [1..Length(idealgenerators)] do

    #add sum of sizes of all intersections of i ideals
    auxsum:=0;
    i_subsets_of_n:=
      Combinations(Set([1..Length(idealgenerators)]),i);
    for U in i_subsets_of_n do
      idgens:=[];
      for j in U do
        Add(idgens,idealgenerators[j]);
      od;
      auxsum:=auxsum+size_of_intersection_of_ideals(rhovector,idgens);
    od;
    auxsize:=auxsize+(-1)^(i+1)*auxsum;
  od;
  # auxsize is now the size of the union of the considered ideals.  

  # the size of S is just t-auxsize
	# maybe plus 1 if we are in the monoid case
	if IsFpSemigroup(s) then	
		return t-auxsize;
  elif IsFpMonoid(s) then
		return t-auxsize+1;
	fi;
  
end);

#############################################################################
##
#M  Size( <S> ) . . . . . . . . . . . . . for a fp commutative semigroup
##
InstallMethod( Size,
    "method for a fp commutative semigroup",
    true,
    [ IsSemigroup and IsCommutative ], 0,
    function(s)
      local sizeofs;
			# this method only works for fp semigroups or monoids
			if not(IsFpSemigroup(s) or IsFpMonoid(s)) then
				TryNextMethod();
			fi; 
      sizeofs:=SizeOfFpCommutativeSemigroupOrMonoid(s);
      return sizeofs;
    end);

#############################################################################
##
#M  \=( <x1>, <x2> )
##
##  for two elements of a commutative finitely presented semigroup
##  The reason why this method has a higher rank is that we want
##  to be sure that if the semigroups is commutative we use
##  this method. If the semigroup is not commutative we use
##  TryNextMethod to get the right one.
##
InstallMethod( \=,
"for two elements of a commutative finitely presented semigroup",    
IsIdenticalObj,[ IsElementOfFpSemigroup, IsElementOfFpSemigroup ],
0,
function( x1, x2 )
  local S, CRWS;

  # This line could be improved - find out how it's done
  # for groups
  S := CollectionsFamily(FamilyObj(x1))!.wholeSemigroup;
  if not HasIsCommutative(S) then
    TryNextMethod();
  fi;
  CRWS := CommutativeReducedConfluentSemigroupRws(S);
  return ReducedForm(CRWS, UnderlyingElement(x1)) =
    ReducedForm(CRWS, UnderlyingElement(x2));
end );

#############################################################################
##  
#M  \=( <x1>, <x2> )
##  
##  for two elements of a commutative finitely presented semigroup
##  The reason why this method has a higher rank is that we want
##  to be sure that if the semigroups is commutative we use
##  this method. If the semigroup is not commutative we use
##  TryNextMethod to get the right one.
##
InstallMethod( \=,
"for two elements of a commutative finitely presented semigroup",
IsIdenticalObj,[ IsElementOfFpMonoid , IsElementOfFpMonoid], 0,
function( x1, x2 )
  local S, CRWS;

  # This line could be improved - find out how it's done
  # for groups
  S := CollectionsFamily(FamilyObj(x1))!.wholeMonoid;
  if not HasIsCommutative(S) then
    TryNextMethod();
  fi;
  CRWS := CommutativeReducedConfluentSemigroupRws(S);
  return ReducedForm(CRWS, UnderlyingElement(x1)) =
    ReducedForm(CRWS, UnderlyingElement(x2));
end );


#############################################################################
##
#E  fpcomsmg.gi  . . . . . . . . . . . . . . . . . . . . . . . . . . ends here
