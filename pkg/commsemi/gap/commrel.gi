#############################################################################
##
#W  commrel.gi           COMMSEMI library    Isabel Araujo and Andrew Solomon
##
#H  @(#)$Id: commrel.gi,v 1.3 2000/06/01 15:43:59 gap Exp $
##
#Y  Copyright (C)  1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
#Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
##
##  This file contains code for commutative semigroups
##
Revision.commrel_gi:=
    "@(#)$Id: commrel.gi,v 1.3 2000/06/01 15:43:59 gap Exp $";

#############################################################################
##
#M  IsGreensLessThanOrEqual( <C1>, <C2> )
##
##  for any greens classes (recall that L=R=J=H=D in a commutative semigroup
##
##  Let <e1> be a word representing the representative of <C1>.
##  Let <e2> be a word representing the representative of <C2>.
##  <C1> is less then or equal to  <C2> iff <e1> is in the ideal
##  generated by <e2> (ideal in the free semigroup), ie, iff <e1> is
##  in the ideal generated by the set
##  <J> = BasisOfSemigroupIdeal( <S>, <e2>)
##  So, <C1> is less then or equal to  <C2> iff there is an element z in J
##  such that <z> divides <e1> (in the vector division sense)
##
##  The reason why the rank of this method is increased is to be sure
##  that method selection always chooses this one, for otherwise
##  in the case of R,L and J classes of commutative semigroups, the normal
##  methods would be choosen.
##
InstallMethod( IsGreensLessThanOrEqual,
  "for greens classes of a finitely presented  commutative semigroup", IsIdenticalObj,
  [IsGreensClass, IsGreensClass], 5,
function( c1, c2 )
  local s,            # the semigroup to which c1 and c2 belong
        crws,         # rewriting system
        idbasis,      # basis of the ideal of S generated by a rep of c2
        v1,           # vector representing a representative of c1
        z,            # an element of idbasis
        vz;           # a vector representing the element z

  # get the parent semigroup
  s := Parent( c1 );
  # this only works for finitely presented semigrousp or monoid
  if not (IsFpSemigroup(s) or IsFpMonoid(s))  then
    TryNextMethod();
  fi;

  # this method only works for commutative semigroups
  if HasIsCommutative( s ) then
    if not( IsCommutative( s )) then
      TryNextMethod();
    fi;
  else
    TryNextMethod();
  fi;

  crws := CommutativeReducedConfluentSemigroupRws(s);

  # the ReducedSetOfGeneratorsOfPrincipalIdealOfSemigroup of e2
  idbasis := BasisOfSemigroupIdeal( s, Representative(c2));
  # and get a vector representing a representative of c1
  v1 := AssocWordToVector(UnderlyingElement(Representative(c1)));

  # c1 is less then or equal to c2 iff
  # there is an element in idbasis which divides c1
  return ForAny(idbasis, z-> IsVectorDivLessThanOrEqual(
          AssocWordToVector( z ),v1));

end);

#############################################################################
##
#M  EpimorphismToLargestSemilatticeHomomorphicImage(s) 
##
InstallMethod(EpimorphismToLargestSemilatticeHomomorphicImage,
"for an fp commutative semigroup", true, 
[IsFpSemigroup and IsCommutative],
function(s)
  local f,    # free semigroup
        j,    # loop variables
        r,    # relations
        x,    # generators of semigroup
        epi,  # the function which computes the epimorphism
        ss;   # the semilattice homomorphic image 

  #add relations to make it a semilattice 
  #relations added are: x^2=x for x a generator of
  #the free underlying semigroup
	f:=FreeSemigroupOfFpSemigroup(s);
	x:=GeneratorsOfSemigroup(f);
	r:=ShallowCopy(RelationsOfFpSemigroup(s));

  for j in [1..Length(x)] do
    Add(r,[x[j]^2,x[j]]);
  od;

  ss := f/r;
  # the obtained semigroup is certainly commutative
  SetIsCommutative(ss,true);

  epi :=  g->
  VectorToElementOfCommutativeFpSemigroup(ss, ElementOfFpSemigroupAsVector(g));

  return MagmaHomomorphismByFunctionNC(s, ss, epi);

end);

InstallMethod(EpimorphismToLargestSemilatticeHomomorphicImage,
"for an fp commutative monoid", true,
[IsFpMonoid and IsCommutative],
function(s)
  local f,    # free monoid 
        j,    # loop variables
        r,    # relations
        x,    # generators of monoid
        epi,  # the function which computes the epimorphism
        ss;   # the semilattice homomorphic image

  #add relations to make it a semilattice
  #relations added are: x^2=x for x a generator of
  #the free underlying monoid 
	f := FreeMonoidOfFpMonoid(s);
	x := GeneratorsOfMonoid(f);
	r := ShallowCopy(RelationsOfFpMonoid(s));
  
  for j in [1..Length(x)] do
    Add(r,[x[j]^2,x[j]]);
  od;
  
  ss := f/r;
  # the obtained monoid is certainly commutative
  SetIsCommutative(ss,true);
  
  epi :=  g->
  VectorToElementOfCommutativeFpMonoid(ss, ElementOfFpMonoidAsVector(g));
  
  return MagmaHomomorphismByFunctionNC(s, ss, epi);
end);

#############################################################################
##
#M  LargestSemilatticeHomomorphicImage(<S>)
##
InstallMethod(LargestSemilatticeHomomorphicImage,
"for a commutative semigroup", true,
[IsSemigroup and IsCommutative],0,
function(s)
  return Range(EpimorphismToLargestSemilatticeHomomorphicImage(s));
end);


#############################################################################
##
#M  ArchimedeanRelation(<S>)
##
InstallMethod(ArchimedeanRelation,
"for a commutative fp semigroup or monoid", true,
[IsSemigroup and IsCommutative and IsFinite],0,
function(s)
  local epi,          # epimorphism to largest homomp. image of s 
        ss,           # largest semilattice homomp. image of s
        x,            # an archimedean component
        partition;    # the archimedean components
  
	# this only works for fp monoids or fp semigroups
	if not (IsFpMonoid(s) or IsFpSemigroup(s)) then
		TryNextMethod();
	fi;

  partition := [];

  # get the epimorphism to the largest semilattice homomorphic image
  epi := EpimorphismToLargestSemilatticeHomomorphicImage(s);
  ss := Range(epi);
  # the archimedean compoments are the preimages of the elements of
  # the range of epi
  for x in Elements(ss) do
    Append(partition,[PreImagesElm(epi,x)]);
  od;

  return EquivalenceRelationByPartitionNC(s,partition);
   
end);

#############################################################################
##
#M  StabilizerOfGreensClass(c)
##
##  for a greens class 
##  
InstallMethod(StabilizerOfGreensClass,
"for a greens class of a commutative semigroup", true,
[IsGreensClass], 0, 
function( class )
local s,        # the parent semigroup
      gens, 
      rep, 
      stab, 
      a;        # a generator of the semigroup

  s := Parent(class);
  # this method only works for finite commutative semigroups
  if not (IsCommutative(s) and IsFinite(s)) then 
    TryNextMethod();
  fi;

	if IsFpMonoid(s) then
		gens := GeneratorsOfMonoid(s);
	else
		gens:= GeneratorsOfSemigroup(s);
	fi;
  rep := Representative(class);
  stab:=[];

  for a in gens do
    if a*rep in class then
      Add(stab, a);
    fi;
  od;

  if IsFpMonoid(s) then
    return Submonoid(s,stab);
  else
    return Subsemigroup(s,stab);
  fi;

end);




#E
