This text first briefly describes the result of the discussion of
Alice, Cheryl, Akos, Maska, and me on Okt 20 17:07:38 WST 2004 about
a possible framework for implementing general group recognition 
algorithms in GAP4.
It then goes on to fix some of the details involving an implementation
in GAP.
Later things were changed according to discussions by Akos and me.
            Max.

 Overview:
===========

Recognition is a recursive procedure, doing basically the following
to recognise a group G, given by generators:

 RECOGNISE:
------------

(1) depending on the representation of G (permgroup, matgroup, ...)
      (and possibly other already known info):
    try various methods to find a homomorphism phi : G -> G/N
    for some normal subgroup N

(2) we may find out that G is simple in stage (1), this will work by
    some method to recognise G, find a presentation and a way to write
    arbitrary elements of G as a product of its generators
    ==> stop recursion, return "recognition info"

From now on we assume that the homo. phi : G -> G/N is given and we
can map elements of G through it. Assume further that we have given
G/N generated by the images of the generators of G in some representation.

(3) Recursively recognise G/N, get as a result a method to write arbitrary
    elements of G/N as a product of its generators.

(4) By creating random elements of G, mapping them through phi, writing
    the result in G/N as product in the generators of G/N and then doing
    the same product in G itself we can create random elements of N,
    uniformly distributed in N.

(5) Calculate "enough" random elements of N, such that we are "confident",
    that they generate N.

(6) Recursively recognise N (using the random generators), get as a result
    a method to write arbitrary elements of N as a product of its generators.

(7) We now can write arbitrary elements of G as a product of its generators
    by first mapping them to G/N, writing them there as product of the
    generators, doing the same product in G thereby getting an element of
    N, which we can again write as a product of the generators of N, which
    were products in the generators of G.
    Give this information back.

Note during the "usage" of the information for G further up in the
recursion we might realize that our knowledge about N was not correct
(because we find something which has to be in N but actually is not in
"our N"). In that case, we have to throw away the information about N
and redo it. This will not affect things which might already be calculated
further up in the tree.

This concludes the "recognition phase". We end up with a highly recursive
data structure describing a composition series of G together with the
possibility to write elements of G as a product of its generators.

After that the "verification phase" starts. This is again recursive.
To verify a "tree" as above, we do the following at some group G:

 VERIFY:
---------

(a) Verify G/N recursively, thereby building up a presentation for G/N
    with some relations R1, ..., Rk (words in the generators), and proving
    that our knowledge about G/N is correct.

(b) Calculate the words R1, ..., Rk in G, these are then elements of N.

(c) Write these words as product of our generators for N, if this fails
    we realize that N was not correct, so redo the recognition phase
    for N with the additional generator.

(d) Verify N recursively, thereby building up a presentation for N with some
    relations S1, ..., Sl (words in the generators).
   
(e) With the now available data build up a presentation for G by using
    the relations S1, ..., Sl, the relations R1, ..., Rk together with
    the words in the generators of N and with words for n_i ^ g_j where
    {n_i} are the generators of N and {g_j} those for G.

(f) Return that presentation.


 What is already there in GAP4?
================================

 * groups in various forms
 * homomorphisms between them,
   --> setup could possibly be improved
 * pseudo random choice
 * an implementation of straight line programs as GAP objects
 * the general method selection


 Further needed:
=================

 * a way to keep track of operations "behind" homomorphism, such that
   one can easily "pull back" elements.   --> basically done with "memory"
 * a generic function implementing "RECOGNISE"
 * a generic function implementing "VERIFY"
 * lots of methods to try to find phi:G->G/N, including the case
   N=1 with the possibility to return a presentation for G in this case.
 * a nice setup to encapsulate the "recognition" data which includes
   especially the "possibility to write elements as a product of the
   generators" in a way, which is generic and efficient in the applications.
 * fixing the gory details.


 Possible problems (and solutions):
====================================
 * we do not want to startup PseudoRandom anew in G/N and we do not want
   to calculate products in G while being in G/N
   --> possibility to hand down the state of the pseudorandom machine
       from G to G/N
   

 Input and output of RECOGNISE:
================================

In: 
  G generated by some generators in some representation
  optionally: state of the pseudorandom machine (when going G->G/N)

Out:
  phi (together with G/N)
  data to write elements of G/N as a product of images of the 
    generators of G under phi
  generators of N
  recognition info for N
  --> altogether data to write elements of G as a product of its generators


 Input and output of VERIFY:
=============================

In:
  a "recognition tree" created by RECOGNISE (containing all the groups)

Out:
  a presentation for G and the knowledge of the existence of a proof, 
  that the "recognition tree" is OK.


 Implementation details:
=========================

RECOGNISE is a GAP function, called "RecogniseBB":

  RecogniseBB( G )
    where G is a GAP group object. If we want to hand in the state of the
    pseudo random machine, we just initialize it accordingly within G.
    The generators of G do not have memory.
    The return value is an object of type "IsRecognitionInfo", which is
    essentially a record, wrapped in the object mechanism of GAP4. This
    record represents the "recognition" tree, it will have a recursive
    structure, details see below.
  
    Algorithm:
      RecogniseBB first creates a copy of the group but with generators
      having memory. Then an empty recognition info record ri is created.
      Then "FindHomomorphism" (see below) is called with ri and the original
      group object (without memory).
      Having recognised the factor group G/N we create elements of N and
      then recognise it, by again creating an empty recognition record
      riker for the kernel. In the end we put everything together to be
      able to write elements in G in terms of the generators.

VERIFY is a GAP function, called "VerifyBB":
  VerifyBB( ri )
    where ri is an object in the category "IsRecognitionInfo", details
    see below. This function can call "RecogniseBB" for subtrees of
    the recognition tree coded in ri, if it notices, that something is
    wrong. The return value is a list of straight line programs (or
    only one returning multiple values) for the relations expressed in
    the generators of G. If the function returns, the verification is
    successful. Do we need a return value "fail" for "unlucky cases"?


The various methods to find phi are GAP-methods for the "operation":

  FindHomomorphism( ri, G )
    It is responsible to find a homomorphism phi from G to some group and
    fill in the corresponding recognition info ri. Then it gives at least
    some information about generators of the kernel N of phi.
    FindHomomorphism methods might
      - give up with "TryNextMethod()"
        (nothing changed, but method no good in the current situation)
      - give up with calling "FindHomomorphism" with the same arguments
        (this starts the method selection anew, thereby using possible new
         information about the group object)
      - succeed and return a recognition record, which holds at least the
        following components:
           G, Homo, GmodN, IsRecognisedAsSimple, IsLeaf, DoNot
        (see below for definitions.)
        


We would install such methods like this:

InstallMethod( FindHomomorphism, "cheat: find a Cyclic2",
   [ IsRecognitionInfo, IsGroup and IsPermGroup ], 1,
   function(ri,H)
     local gens,i;
     if "Cyclic2" in failedTests(ri) then
         TryNextMethod();
     elif Size(H) = 2 then
         # First find the first nontrivial generator:
         gens := GeneratorsOfGroup(H);
         i := 1;
         while IsOne(gens[i]) do
             i := i + 1;
         od;
         ri!.firstnontrivialgen := i;
         SetSLPforElement(ri,SLPforElementCyclic2);
         SetFilterObj(ri,IsLeaf);
         Setstamp(ri,"Cyclic2");
         return true;
     else
         AddSet(failedTests(ri),"Cyclic2");
         TryNextMethod();
     fi;
   end);


The attribute `SLPforElement' must be a GAP-function like:

  SLPforElementXYZ( ri, g )
    which gets a completed recognition record ri and a group element g
    and returns a slp s such that 
      g = ResultOfStraightLineProgram(s,GeneratorsOfGroup(ri!.G))

There is a generic method `SLPforElementGeneric' for this just using
recursively the information for G/N and N. For the leaves of the tree,
we will have other methods installed, depending on the type of group
found.


 Entries of the recognition information:
=========================================

Essentially such an object in the filter IsRecognitionInfo is a record
(or "component object" in GAP4). It has the following filters,
attributes and components:
(note that an attribute can be known or not known, whereas the object
can either be in the filter or not)

Filters:
  IsLeaf               : Indicates, whether we are on a leaf in the tree
  DoNotRecurse         : Indicates, that we should not recurse further down,
                         even if it is not a leaf
  IsReady              : Indicates, whether the node is already set up 
                         completely

Generic attributes: (always known in the end)
  group                : the group object at this position of the tree
                         generators with memory
  
  IsRecognisedAsSimple : flag, whether we are in the simple case
  RIpresentation       : a list of slps for relations, only there in
                         the simple case or after the verify phase

Generic attributes for the non-leaf case (and maybe in some leaf-cases):
  homom                : homomorphism G -> G/N
  RIfactor             : recognition info for G/N
  RIkernel             : recognition info for N = kernel
                         `fail' if kernel is recognised to be trivial
  RIparent             : a copy of the recognition info above
  gensQslp             : an slp to write generators in the quotient
                         in terms of the images of our generators under
                         the homomorphism
  gensQpre             : preimages of the generators of the quotient
  gensN                : a list collecting generators of N
  gensNslp             : an slp to write generators of N in terms of
                         generators of G
  statusofgensN        : a string indicating the status of the gensN
                         attribute after the FindHomomorphism call returned
  stamp                : a stamp indicating, which FindHomomorphism method
                         succeeded, typically a string
  SLPforElement        : this attribute holds a function, which can write
                         elements of G in terms of the generators of G
                         a prototype is `SLPforElementGeneric', which is the
                         generic function for standard nodes
  failedTests          : a list of strings to indicate, which FindHomomorphism
                         methods were tested and did not succeed.
                         Every failed method should leave a stamp here, and
                         shoud begin by checking, whether itself did already
                         fail, such that one can avoid doing things twice.

Additional data:
  Depending on type of homomorphism found.


 Conventions for FindHomomorphism methods:
===========================================

 - One can use arbitrary filters for the installation of methods.
   Probably a priority will have to be specified to allow for the right
   order of methods used.

 - Every successful method should leave a `stamp' in the stamp attribute

 - Every unsuccessful method shoud leave a `stamp' in the failedTests
   attribute

 - No method should perform expensive tests before checking in failedTests,
   whether it has already failed

 - FindHomomorphism is called with the original group object from above.
   In particular the generators will usually have no memory.

 - FindHomomorphism finds only the attributes "group", "gensN" and
   "failedTests" bound, the latter two to empty lists.

 - If FindHomomorphism does not set the value for `SLPforElement', then
   `SLPforElementGeneric' is used automatically.

 - No recursion is done if FindHomomorphism sets `IsLeaf' or `DoNotRecurse'.

 - The node is considered ready, iff `IsLeaf' was set by the FindHomomorphism
   method.

 - In case of a non-leaf, the following agreement holds for the attribute
   values of gensQpre and gesQslp:

   If FindHomomorphism does not set any of the two, then it is assumed, that
   the generators of G/N are just the images of the generators of G.
   If FindHomomorphism sets one of the two, the other is calculated 
   automatically.
   For performance reasons, FindHomomorphism should set both, if they are
   already known anyway.

 - The `Image' of the homomorphism must be G/N.

 - The attribute `statusofgensN' has to be set by FindHomomorphism, the
   following values being allowed:
     "somegensNknown"   : gensN might contain some generators of N, but there
                          is no evidence, that the list is complete
     "normalgensNknown" : gensN contains elements, whose normal closure is
                          equal to N
     "gensNknown"       : gensN contains a list of generators of N

 - If the homomorphism is a monomorphism, this can be indicated by an 
   empty gensN together with `statusofgensN' being equal to "gensNknown".


