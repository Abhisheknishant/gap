<?xml version="1.0" encoding="ISO-8859-1"?>
                                                                                
<!-- $Id: manual.xml,v 1.5 2003/08/19 13:28:54 gap Exp $   -->
                                                                                
<!DOCTYPE Book SYSTEM "gapdoc.dtd"
 [ <!ENTITY see '<Alt Only="LaTeX">$\to$</Alt><Alt Not="LaTeX">--&tgt;</Alt>'>
   <!ENTITY Tk '<Package>Tk</Package>'>
   <!ENTITY Tcl '<Package>Tcl</Package>'>
 ]>                                                                                
<Book Name="Tk">
                                                                                
<TitlePage>
  <Title>The &Tk; package</Title>
  <Subtitle>An interface between &GAP; and &Tk;</Subtitle>
  <Version>Version 0.5</Version>
  <Author>Max Neunhöffer
          <Email>Max.Neunhoeffer@Math.RWTH-Aachen.De</Email>
  </Author>
  <Author>Michael Ummels
          <Email>michael@ummels.de</Email>
  </Author>
  <Date>June 2003</Date>
  <Address>
  Lehrstuhl D für Mathematik<Br/> Templergraben
  64<Br/> 52062 Aachen<Br/> Germany
  </Address>
  <Abstract>
  This is the manual to the &Tk; package, which provides an interface
  between &GAP; and &Tk;/&Tcl; to allow the usage of graphics from within 
  &GAP;. &Tcl; is a script language and &Tk; is a toolkit for programming
  graphical user interfaces in a platform independent way. This package
  makes it possible to start up a &Tcl;/&Tk; process from within a &GAP;
  session and communicate with it to access the graphical facilities
  of the &Tk; toolkit from the &GAP; language. This includes all sorts
  of graphics, widgets for user interfaces, event callbacks and status
  inquiries that are supported in &Tk;.
  </Abstract>
  <Copyright>&copyright; 2003 by Max Neunhöffer and Michael Ummels.
  </Copyright>
</TitlePage>
 
<TableOfContents/>
 
<Body>

<!-- ================================================================= -->

<Chapter Label="Intro"><Heading>Introduction</Heading>

<Section><Heading>Basic idea</Heading>
Before this package came into existence there was already a graphical
extension for &GAP;, which was also called a &GAP; package, namely &XGAP;.
The concept of &XGAP; is that a C program called xgap which uses the
Athena widget library to allow some limited use of graphics, starts up
a &GAP; process in the background and talks to that via its standard input 
and output. The controling terminal for &GAP; has to be emulated by xgap
and the communication protocol between &GAP; and xgap is embedded into
the usual input/output stream. <P/>

Although &XGAP; is called a &GAP; package it really does not behave like
one. It is for example not possible to load &XGAP; from an existing &GAP;
session. In addition the graphical possibilities are severely limited
due to the fact that every single type of graphical object has to be 
implemented individually in the C part xgap. The same is true with
respect to extendibility. The Athena widget library is not the most
modern one available. <P/>

The &Tk; package is a try to overcome most of these (if not all) 
deficiencies by providing a link to &Tcl;/&Tk;. &Tcl; is a script
language that was explicitly designed to be extended with the &Tk; 
toolkit for graphics and graphical user interfaces. There is already
an application (called <Q>wish</Q> for <Q>window-shell</Q>) that
contains a complete &Tcl; interpreter and can be driven by commands in
text form. &Tk; offers a big variety of graphical tools for
visualizations and user interfaces.<P/>

The basic idea of the &Tk; package is to start up a wish process in
the background and talk to it via a new communications channel which
is separate from the standard input/output channel of &GAP;. The
&GAP; session with its command line interface in a terminal can
continue to exist as usual and everything regarding graphics is dealt
with over the other channel. <P/>

There was only one fundamental problem to be solved: Of course the
user wants and expects that &GAP;/&Tk; can react to graphical events
when &GAP; prompts the user for a new command to execute. This means
however, that the &GAP; process has to control the input from two
channels simultaneously. The necessary extensions of the &GAP; kernel
for input/output multiplexing have been made already in version 4.3. <P/>

The idea to this setup is mainly due to the <Package>Tkinter</Package>
link package between the <Package>Python</Package> language and &Tk;. <P/>

The &Tk; package also contains an application of the graphical
interface. There are programs to displays tables interactively, where
a <Q>table</Q> can be any rectangular scheme with columns and rows,
where each cell contains some textual information. There is support
for descriptions at the edges and scrolling for the case that the
table is bigger than the available window. The user can select subsets
of cells and trigger actions for them with the mouse or the keyboard.<P/>

These generic routines are used to display character tables in a
convenient way.
</Section>


<Section><Heading>How to read this manual</Heading>

If you have to install this package yourself jump to chapter 
<Ref Chap="install"/> to learn how to do it. <P/>

If you are only interested in the interactive display of tables or
even in that of character tables, then concentrate on chapters
<Ref Chap="tables"/> or <Ref Chap="chartables"/>. <P/>

Otherwise note that this manual provides no introduction to the usage of
&Tcl;/&Tk; itself. As the &Tk; package itself, it only provides a link
between &GAP; and &Tcl;/&Tk;, such that a user familiar with &Tk; can
easily use it from within &GAP;. <P/>

If you know your &Tcl;/&Tk; by heart you probably want to start
reading in section <Ref Sect="trans"/> and directly learn what you
have to do in &GAP; to achieve the desired effect on the &Tcl;/&Tk;
side. Then go on with section <Ref Sect="objects"/> to learn what
&GAP; objects correspond to &Tk;'s widgets and graphical objects.
Use section <Ref Sect="reference"/> as a reference for the
interface. <P/>

If you never used &Tcl;/&Tk; before it is recommended that you
start looking at some examples in section <Ref Sect="someex"/> to get
an idea of the approach. Then use some good documentation of &Tcl;/&Tk;
(see below) and sections <Ref Sect="trans"/> to <Ref Sect="reference"/>
simultaneously to get going. <P/>

In the case that you want to be inspired with respect to the question
<Q>What can be done with &Tk;?</Q>, it might be interesting to proceed
to chapter <Ref Chap="examples"/> to find a lot of examples for the
usage of this package. <P/>

<E>Suggested reading for &Tcl;/&Tk;:</E> <P/>

<URL>http://www.tcl.tk/doc/</URL> for overview over available documentation.<P/>

<URL>http://www.itd.clrc.ac.uk/Publications/Cookbook/</URL> for a start.<P/>

<URL>http://www.tcl.tk/man/tcl8.4/</URL> for reference.<P/>

And the classic by the creator of &Tcl;/&Tk;:<P/>

<Q><E>Tcl and the Tk Toolkit</E></Q>, John Ousterhout, Addison-Wesley, 
ISBN 0-201-63337-X. 
German translation: <Q><E>Tcl und Tk</E></Q>, ISBN: 3-89319-793-1. 
Japanese translation, ISBN: 4-89052-819-9.<P/>

<E>Comment:</E>
<Q>Although it only covers Tcl 7.3 and Tk 3.6, it has excellent sections on
the philosophy of using Tcl. It also covers C programming for Tcl.</Q>

</Section>


<Section><Heading>Overview over the package</Heading>

The source code of the &Tk; package is in the <F>gap</F> subdirectory
of the directory <F>pkg/tk</F>. All the code for the interface is in the
two files <F>tk.gd</F> and <F>tk.gi</F>. The two files <F>table.gd</F>
and <F>table.gi</F> contain object and method definitions for objects
representing generic tables, whereas the two files <F>tktable.gd</F>
and <F>tktable.gi</F> contain object and method definitions for the
objects representing graphical objects for the tables. The code for
character tables is in the two files <F>chartabl.gd</F> and 
<F>chartabl.gi</F>. <P/>

All the documentation is in the <F>doc</F> subdirectory of <F>pkg/tk</F>.
The source code for the manual is in <F>manual.xml</F> and lots of other
files are generated via the <Package>GAPDoc</Package> package. <P/>

Finally, the <F>examples</F> directory contains some examples (especially
all the examples mentioned in this manual). These examples can be read
in conveniently with the following command (after the package &Tk; is
loaded via <C>LoadPackage("tk");</C>): <P/>

<Log>
ReadPkg("tk","examples/xyz.g");
</Log>

where <F>xyz.g</F> is to be replaced by the name of one of the files in

</Section>

</Chapter>

<!-- ================================================================= -->

<Chapter><Heading>The interface</Heading>

<Index Key="Interface">Interface</Index>

<Section Label="someex">
<Heading>Some examples</Heading>

The following examples are thought to give the reader a brief idea of
what the &Tk; package is all about and how things work from a user's
point of view.

<Subsection><Heading>Hello world!</Heading>

Probably the first example program for any programming language is the
hello world program. We demonstrate a slightly enhanced version with
user feedback:
<Log><![CDATA[
gap> LoadPackage("tk");;
gap> t := TkInit();;
gap> b := TkWidget("button",rec(text := "Hello world!"));
<TkWidget type="button" name=".o1">
gap> TkPack(b);
<TkWidget type="button" name=".o1">
gap> f := function() Print("Hallo Welt!\n"); end;;
gap> Tk(b,"configure",rec(command := f));
0]]></Log>
Note that we included the <C>gap&gt;</C> prompt and the output from &GAP; in 
this example to show exactly, what appears on your terminal. You only
have to type the commands after <C>gap&gt;</C>.<P/>

After the <C>TkInit</C> command a small window pops up, this is the so-called
top level window. The next command creates a button with the text
<Q>Hello world!</Q> as a sub-object of the top level window. The <C>TkPack</C>
command packs it into the parent window, which makes it visible. The last
command installs a callback function <C>f</C> for this button.<P/>

Try to click with the left mouse button on the <Q>Hello world!</Q> button.
Note that <Q>something</Q> happens while &GAP; is reading your next command.

You find this example in the file <F>examples/hello.g</F> and can execute
it with the following command: <C>ReadPkg("tk","examples/hello.g");</C>
</Subsection>

<Subsection><Heading>A scrolled canvas</Heading>

In this example we only include the commands that you have to type. You
can find this example in the file <F>examples/scrolledcanvas.g</F> and can
execute it with the following command: 
<C>ReadPkg("tk","examples/scrolledcanvas.g");</C><P/>

<Log><![CDATA[
LoadPackage("tk");
t := TkWidget("toplevel");
f := TkWidget("frame",t);
c := TkWidget("canvas",f,rec(scrollregion := "0 0 2000 2000",
                             background := "white"));
TkItem("oval",c,100,100,200,200,rec(fill := "red"));
h := TkWidget("scrollbar",f,"-orient horizontal");
v := TkWidget("scrollbar",f,"-orient vertical");
TkPack(f,"-fill both -expand 1");
TkGrid(c,"-row 0 -column 0 -sticky news");
TkGrid(h,"-sticky ew -row 1 -column 0");
TkGrid(v,"-sticky ns -row 0 -column 1");
TkLink(c,h,"h");
TkLink(c,v,"v");
Tk("grid rowconfigure",f,"0 -weight 1");
Tk("grid columnconfigure",f,"0 -weight 1");
Tk(c,"configure -scrollregion {0 0 400 400}");]]>
</Log>

We do not want to explain the details of this example as this is essentially
a &Tcl;/&Tk; program. Just for an overview: The <C>TkWidget</C> commands
create widgets and return &GAP; objects corresponding to them. A <Q>canvas</Q>
is a widget that is a rectangular window that can contain graphical objects
like lines, circles, images, curves, text and so on. The 
<C>TkItem</C> commands creates such graphical objects within a canvas
widget and returns a &GAP; object corresponding to them. As in the first
example the <C>TkPack</C> command places a widget within its parent widget.
The <C>TkGrid</C> command does an analogous job using a different algorithm,
namely arranging the widgets in a grid. The <C>TkLink</C> command links
a scrollbar with another widget the scrolling of which is controlled by
the scrollbar.

For a start just note what happens and the following two facts:
<List>
<Item>&GAP; commands are translated to &Tcl;/&Tk; commands which lead to
graphical output.</Item>
<Item>&GAP; objects correspond to graphical widgets and objects to allow
further access during their livetime.</Item>
</List>

</Subsection>

<Subsection><Heading>User input example</Heading>

In the following example (which can be found in the file 
<F>examples/dialog.g</F> and be executed with the command
<C>ReadPkg("tk","examples/dialog.g");</C>) we again only show the
commands that have to be typed:

<Log><![CDATA[
LoadPackage("tk");
l := TkWidget("label",rec(text := "Please enter a number:"));
TkPack(l,rec(side := "left"));
e := TkWidget("entry",rec(width := 10));
TkPack(e,rec(side := "left"));
Tk(e,"insert 0 123456");
f := function() Print("The current value is:",TkValue("[",e,"get]"),"\n"); end;
o := TkWidget("button",rec(text := "OK",command := f));
TkPack(o,rec(side := "left"));]]>
</Log>

Here a widget of type <C>entry</C> is created that allows the user to
edit a text in an input field. This text can be queried via the
<C>TkValue</C> command.
</Subsection>

Now that you have seen the first few examples, we recommend to learn
in the next section, how &Tcl;/&Tk; commands in general look like and
in the section after that, how the &Tk; package translates &GAP; commands
to &Tcl;/&Tk; commands.

</Section>

<Section Label="format">
<Heading>Format of &Tcl;/&Tk; commands</Heading>

The program input to the &Tcl; interpreter consists of strings which are
cut into words and then undergo certain substitutions. The first word in a 
statement must be a command name. Most commands accept a huge variety of
optional arguments. Those optional arguments are specified in a shell-like
manner via words beginning with a dash and are followed by the value of
the argument in the next word. The following two &Tcl;/&Tk; command for example
create a button and pack them in the top level window:

<Log><![CDATA[
button .but -text "Hello world!"
pack .but -side left]]>
</Log>

Here the first command is <C>button</C>, which takes one non-optional
argument <C>.but</C>, which is the name under which the button will
be stored, and gets here an optional argument with name <Q>text</Q>,
the value of which is <Q>Hello world!</Q>. The second command is
<C>pack</C>, which also takes one non-optional argument and has here
one optional argument <Q>side</Q>.<P/>

Often a widget like the above button <C>.but</C> can play the role of
a command as in

<Log><![CDATA[
.but configure -text "Hallo Welt!"]]>
</Log>

where the <Q>configure</Q> method of this object is called, again with
one optional argument.<P/>


</Section>

<Section Label="trans">
<Heading>Translation of &Tcl;/&Tk; commands to &GAP;</Heading>
</Section>

<Section Label="objects">
<Heading>&GAP; objects corresponding to widgets</Heading>
</Section>

<Section Label="reference">
<Heading>Reference of the interface</Heading>
</Section>

<Section><Heading>Technical background information</Heading>
</Section>

</Chapter>

<!-- ================================================================= -->

<Chapter Label="tables">
<Heading>Interactive display of tables</Heading>

</Chapter>

<!-- ================================================================= -->

<Chapter Label="chartables">
<Heading>Interactive display of character tables</Heading>

</Chapter>

<!-- ================================================================= -->

<Chapter Label="install"><Heading>Package installation</Heading>

<Section><Heading>Prerequisites</Heading>

Note that as of now the &Tk; package only runs on
<Package>UNIX</Package>-like operating systems due to the fact that
the necessary inter-process-communication in &GAP; is only implemented
there.<P/>

Of course &Tcl;/&Tk; must be installed on your system. You can test
this by trying to call the <F>wish</F> command in your shell. If the 
command is not found, ask your system administrator to install
&Tcl;/&Tk;. If <F>wish</F> is found, a small quadratic window opens
and you get a percentage sign as prompt. You can leave <F>wish</F>
again by typing Control-D or <F>exit</F>.<P/>
</Section>

<Section><Heading>Installing in the standard location</Heading>

The &Tk; package does not involve any compilation of binaries
whatsoever. Therefore the installation is relatively simple:

<List>
<Item>Download the distribution archive <F>gaptk.tar.gz</F> for
example from the package home page 
<Homepage>http://www.math.rwth-aachen.de/~Max.Neunhoeffer/tk/</Homepage>.
</Item>
<Item>Unpack it in the <F>pkg</F> directory of your &GAP;
installation by:<P/>
<Verb>
gzip -dc gaptk.tar.gz | tar xvf -
</Verb></Item>
<Item>That's it.</Item>
</List>

</Section>

<Section><Heading>Installing in a different location</Heading>

If you want (or have) to install the package in another place than the
<F>pkg</F> directory of your &GAP; installation, create a
directory <F>pkg</F> in another directory, say <F>mygap</F> and
unpack the package in that <F>pkg</F> directory. Then start &GAP;
with an additional command line option like<!--<P/>-->
<Verb>
gap -l ";PATHTOmygap"
</Verb>
where <F>PATHTOmygap</F> is replaced by an absolute path to your
directory <F>mygap</F>. You can start this absolute path with a
<F>~/</F> which will be replaced by the absolute path to your home
directory.<P/>

If you want that links in the HTML version of this manual going into
the main &GAP; manuals behave correctly, you have to rebuild the
documentation by doing<P/>
<Verb>
gap makedoc.g
</Verb>
in the <F>mygap/pkg/tk</F> directory.
</Section>
</Chapter>

<!-- ================================================================= -->

<Chapter Label="examples"><Heading>Examples</Heading>

</Chapter>

</Body>

<TheIndex/>

</Book>
